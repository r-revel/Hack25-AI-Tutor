{
  "title": "Передача логов с виртуальной машины с помощью Fluent Bit и Lua-скрипта",
  "chapters": [
    {
      "name": "Передача логов с виртуальной машины с помощью Fluent Bit и Lua-скрипта",
      "content": "Практические руководства Evolution    \n\n # Передача логов с виртуальной машины с помощью Fluent Bit и Lua-скрипта   Эта статья полезна?          \nFluent Bit — кроссплатформенный инструмент с открытым исходным кодом.\nОн собирает, обрабатывает и фильтрует лог-сообщения из разных источников, а затем сохраняет их в хранилище.\nПосле этого лог-сообщения поступают в маршрутизатор, который определяет, куда они будут отправлены.\nДля работы с разными источниками и приемниками используются специализированные плагины.\n\n## Перед началом работы\n1. Создайте и настройте лог-группу.\n2. Создайте сервисный аккаунт.\nВ блоке Доступы и роли выберите роли:\n- в блоке Проект — «Пользователь сервисов»;\n- в блоке Сервисы — «logaas.writer».\n3. Для сервисного аккаунта создайте API-ключ.\nВ параметрах API-ключа укажите сервис «logging_as_a_service».\nСрок действия API-ключа ограничен — когда он подойдет к концу, мы отправим вам уведомление.\nПосле этого необходимо обновить API-ключ.\n4. Создайте виртуальную машину Ubuntu 22.04.\n5. Подключитесь к созданной виртуальной машине по SSH.\n\n## Шаг 1. Установка Fluent Bit\nПримечание Возможно использование Fluent Bit версии 2.2 и выше.\nРекомендуемая версия — 3.2.\nУстановите Fluent Bit одним из способов:\nИз дистрибутиваAвтоматизированная установка Установка вручную Установите приложение Fluent Bit из сборки дистрибутива для вашей операционной системы.\n\nЧтобы проверить, что fluent-bit установлен корректно, нужно запустить его и убедиться, что он установлен как сервис.\nДля этого:\n1. Запустите fluent-bit как сервис:\n```\nsudo systemctl start fluent-bit\n```\n2. Проверьте статус сервиса fluent-bit — он должен быть активным:\n```\nsystemctl status fluent-bit\n```\n\nЕсли fluent-bit настроен верно, будет выведен статус в виде:\n```\n● fluent-bit.service - Fluent Bit     Loaded: loaded (/lib/systemd/system/fluent-bit.service; disabled; vendor preset: enabled)     Active: active (running) since Tue 2025-03-11 15:48:23 UTC; 3s ago       Docs: https://docs.fluentbit.io/manual/   Main PID: 34596 (fluent-bit)      Tasks: 8 (limit: 2323)     Memory: 9.4M        CPU: 70ms     CGroup: /system.slice/fluent-bit.service             └─34596 /opt/fluent-bit/bin/fluent-bit -c //etc/fluent-bit/fluent-bit.conf\n```\n3. После проверки сервиса fluent-bit остановите его, чтобы далее настроить на совместную работу с logaas:\n```\nsudo systemctl stop fluent-bit\n```\n\n## Шаг 2. Настройка Fluent Bit\n1. Создайте файл logaas_format.lua для форматирования логов в формат сервиса «Клиентское логирование»:\n```\nsudo touch /etc/fluent-bit/logaas_format.lua\n```\n2. Откройте созданный файл с помощью редактора nano:\n```\nsudo nano /etc/fluent-bit/logaas_format.lua\n```\n3. В файл добавьте:\n```\n--    Fluent Bit lua client script--    Version: 1.0.1--    Copyright 2025 Cloud.ru\n--    Licensed under the Apache License, Version 2.0 (the \"License\");--    you may not use this file except in compliance with the License.--    You may obtain a copy of the License at\n--        http://www.apache.org/licenses/LICENSE-2.0\n--    Unless required by applicable law or agreed to in writing, software--    distributed under the License is distributed on an \"AS IS\" BASIS,--    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.--    See the License for the specific language governing permissions and--    limitations under the License.\n\nlocal whitelist = {    \"timestamp\",    \"level\",    \"project_id\",    \"log_group_id\",    \"default_labels\",    \"labels\",    \"message\",    \"json_message\",    \"trace_id\",    \"service_name\",    \"instance_id\"}\nlocal whitelist_hash = {}for _, key in ipairs(whitelist) do    whitelist_hash[key] = trueend\nlocal json = (function()local escape = function(str)    return str:gsub('[\\\\\"/]', function(c)    return '\\\\' .. c    end)end\nlocal function encode_value(val)    local t = type(val)    if t == 'string' then    return '\"' .. escape(val) .. '\"'    elseif t == 'number' or t == 'boolean' then    return tostring(val)    elseif t == 'table' then    local result = {}    for k, v in pairs(val) do        local key = type(k) == 'number' and '[' .. k .. ']' or '\"' .. k .. '\"'        table.insert(result, key .. ':' .. encode_value(v))    end    return '{' .. table.concat(result, ',') .. '}'    else    return 'null'    endend\nreturn {    encode = function(tbl) return encode_value(tbl) end}end)()\n\nfunction extra_fields(record)    local message_ = {}    local keys_to_remove = {}    local json_message = {}    local message_data = {}\n    for key, value in pairs(record) do        if not whitelist_hash[key] then            message_data[key] = value            table.insert(keys_to_remove, key)        end    end\n\n    if next(message_data) ~= nil then        json_message = json.encode(message_data)        return json_message    else        return nil    endend\n\nfunction ensure_string(var)    if type(var) == \"string\" then        return var, true    end\n    if type(var) == \"number\" or type(var) == \"boolean\"  then        return tostring(var), true    end\n    return nil, falseend\n\nfunction format_log(tag, timestamp, record)    -- 1. Project ID & Log Group ID    local default_project_id = record.default_project_id    local default_group_id = record.default_group_id\n    local project_id = record.project_id    if not project_id or project_id == \"\" then       project_id = default_project_id    end\n    local group_id = record.group_id    if not group_id or group_id == \"\" then        group_id = default_group_id    end\n    record.default_project_id = nil    record.default_group_id = nil\n    -- 2. Timestamp    local system_timezone = os.date(\"%z\")    local timezone_formatted = string.sub(system_timezone, 1, 3) .. \":\" .. string.sub(system_timezone, 4, 5)    local sec = timestamp.sec    local nsec = timestamp.nsec    local iso_timestamp = os.date(\"%Y-%m-%dT%H:%M:%S\", sec)    local milliseconds = string.format(\"%03d\", math.floor(nsec / 1000000))    local formatted_ts = iso_timestamp .. \".\" .. milliseconds .. timezone_formatted\n    -- 3. Message    local message = record.message    if type(message) == \"table\" then        message = json.encode(message)    end\n    -- 4. Label merging    local default_labels = {}    local keys_to_remove = {}    local merged_labels = {}\n    for key, value in pairs(record) do        if key:find(\"^default_labels.\") then            local subkey = key:sub(16)            default_labels[subkey] = value            table.insert(keys_to_remove, key)        end    end\n    for _, key in ipairs(keys_to_remove) do        record[key] = nil    end\n    for k, v in pairs(default_labels) do        merged_labels[k] = v    end\n    if record.labels then        for k, v in pairs(record.labels) do            val, ok = ensure_string(v)            if ok then                merged_labels[k] = val            else                print(\"skip unsupported type value: \"..k..\" => \"..v)            end        end    end\n\n    -- 5. Build log    local log_entry = {        timestamp = formatted_ts,        level = record.level or \"INFO\",        project_id = project_id,        log_group_id = group_id,        labels = merged_labels,        message = message,        json_message = extra_fields(record)    }\n    if record.trace_id and record.trace_id ~= \"\" then        log_entry.trace_id = record.trace_id    end\n    if record.service_name and record.service_name ~= \"\" then        log_entry.service_name = record.service_name    end\n    if record.instance_id and record.instance_id ~= \"\" then        log_entry.instance_id = record.instance_id    end\n\n    -- 6. Complete    return 1, timestamp, log_entryend\n```\n4. Откройте файл /etc/fluent-bit/fluent-bit.conf:\n```\nsudo nano /etc/fluent-bit/fluent-bit.conf\n```\n5. Добавьте в него данные в виде:\n```\n[SERVICE]    Daemon Off    Flush 1    Log_Level info    Parsers_File parsers.conf    storage.sync  full\n[INPUT]    Name tail    Path <path-to-log/logfile.log>    Parser docker\n[FILTER]    Name                parser    Match               *    Key_Name            log    Parser              json    Reserve_Data        true\n# target section[FILTER]    name          modify    match         *    Set default_project_id REPLACE_TO_PROJECT_ID    Set default_group_id REPLACE_TO_LOG_GROUP_ID\n#default labels section[FILTER]    name          modify    match         *    Set default_labels.<label_name_1> value_A    Set default_labels.<label_name_2> value_B\n[FILTER]    Name                lua    Match               *    Script              logaas_format.lua    Call                format_log    time_as_table       true\n[OUTPUT]    Name                http    Match               *    Host                logging.api.cloud.ru    Port                443    tls                 on    URI                 /api/v1/logs-ingest    json_date_key       false    Header              Authorization Api-Key REPLACE_TO_SA_API_KEY\n```\n\nСекция [INPUT] указывает на источник логов, а [OUTPUT] — на сервис, в который отправятся логи.\nВ режиме tail сбор логов в fluent-bit работает по принципу отслеживания новых записей в логах.\nПри перезапуске сервиса данные, обработанные ранее, не отправляются в систему повторно.\nИзмените файл, подставив в него свои данные:\n\n- <path-to-log/logfile.log> — путь к файлу-источнику логов: fluent-bit будет сканировать этот файл и отслеживать в нем новые строки.\n- REPLACE_TO_PROJECT_ID и REPLACE_TO_LOG_GROUP_ID — ID проекта и ID лог-группы, в которую будут отправлены логи.\nREPLACE_TO_LOG_GROUP_ID — необязательная строка.\nЕсли ее не добавить, логи отправятся в группу проекта по умолчанию (default-группа).\n- REPLACE_TO_SA_API_KEY — API-ключ сервисного аккаунта.\nПроверьте, что у вас есть доступ к проекту, а для вашего сервисного аккаунта выбраны роли «Пользователь сервисов» и «logaas.writer».\n\nСекция default labels section — опциональная.\nВ ней вы можете указать метки, которые будут добавлены ко всем логам.\nЭто удобно для последующей фильтрации логов с помощью языка фильтрующих выражений.\nМетки указываются в виде default_labels.<label_name>, где <label_name> — имя метки, которая добавится к логам.\nВ следующем шаге инструкции настраивается тестовая отправка данных с помощью генератора логов, который записывает логи в лог-файл.\nДля тестирования с помощью генератора вместо <path-to-log/logfile.log> укажите путь к лог-файлу: /usr/local/bin/log_producer/error_log.log.\nПример изменений в файле /etc/fluent-bit/fluent-bit.conf:\n```\n[SERVICE]    Daemon Off    Flush 1    Log_Level info    Parsers_File parsers.conf    storage.sync  full\n[INPUT]    Name tail    Path /usr/local/bin/log_producer/error_log.log    Parser docker\n[FILTER]    Name                parser    Match               *    Key_Name            log    Parser              json    Reserve_Data        true\n# target section[FILTER]    name          modify    match         *    Set default_project_id 00000000-1111-2222-3333-444444444444    Set default_group_id aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\n#default labels section[FILTER]    name          modify    match         *    Set default_labels.some_field_A value_A    Set default_labels.some_field_B value_B\n[FILTER]    Name                lua    Match               *    Script              logaas_format.lua    Call                format_log    time_as_table       true\n[OUTPUT]    Name                http    Match               *    Host                logging.api.cloud.ru    Port                443    tls                 on    URI                 /api/v1/logs-ingest    json_date_key       false    Header              Authorization Api-Key ZDVkNmVlY2EtxxxxxxxxxxxxxxxxhYTJhNGJl.xxxxxxxxxxxxx\n```\n\n## Шаг 3. Проверка отправки логов\nНа этом этапе вы сможете настроить тестовую отправку логов с помощью bash-скрипта — генератора логов.\nОн будет записывать логи в лог-файл.\nЧтобы создать генератор:\n1. Создайте директорию, в которой будет находиться скрипт:\n```\nsudo mkdir /usr/local/bin/log_producer/\n```\n2. Создайте пустой файл log_producer.sh:\n```\nsudo touch /usr/local/bin/log_producer/log_producer.sh\n```\n3. Откройте созданный файл с помощью редактора nano:\n```\nsudo nano /usr/local/bin/log_producer/log_producer.sh\n```\n\nВ файл добавьте:\n```\n#!/bin/bash\nLOG_FILE=${1:-./error_log.log}\ngenerate_log() {    # Generate @timestamp in UTC with 8 fractional seconds    nanoseconds=$(date +\"%N\")    trimmed_ns=${nanoseconds:0:8}    timestamp=$(date -u \"+%Y-%m-%dT%H:%M:%S.${trimmed_ns}Z\")\n    # Random log level selection    levels=(\"TRACE\" \"DEBUG\" \"INFO\" \"NOTICE\" \"WARN\" \"ERROR\" \"CRITICAL\" \"ALERT\" \"EMERGENCY\" \"FATAL\")    level=${levels[$RANDOM % ${#levels[@]}]}\n    # Thread selection    threads=(\"rest-query-pool-1\" \"rest-query-pool-2\" \"worker-thread-3\" \"io-thread-4\")    thread=${threads[$RANDOM % ${#threads[@]}]}\n    # Logger name (fixed)    logger=\"ru.rtlabs.einfahrt.query.server.http.request.rquery.RQueryCaExecutorImpl\"    request_id=$(uuidgen)    message=\"Результат исполнения запроса $request_id получен полностью\"    context=\"default\"    created_time=$(TZ=\"Europe/Moscow\" date \"+%Y-%m-%dT%H:%M:%S.%3N%:z\")\n    # Build MDC JSON    mdc_json=\"\\\"mdc\\\":{\"    mdc_json+=\"\\\"requestId\\\":\\\"$request_id\\\",\"    mdc_json+=\"\\\"created\\\":\\\"$created_time\\\"\"    mdc_json+=\"}\"\n    # Construct single-line JSON    printf '{\"@timestamp\":\"%s\",\"level\":\"%s\",\"thread\":\"%s\",\"logger\":\"%s\",\"message\":\"%s\",\"context\":\"%s\",%s}\\n' \\        \"$timestamp\" \\        \"$level\" \\        \"$thread\" \\        \"$logger\" \\        \"$message\" \\        \"$context\" \\        \"$mdc_json\"}\n# Handle Ctrl+Ctrap 'echo -e \"\\nLogging stopped. Output: $LOG_FILE\"; exit' SIGINT\necho \"Logging to $LOG_FILE - Press CTRL+C to stop\"while true; do    generate_log >> \"$LOG_FILE\"    sleep 1done\n```\n\nПоследние строки кода запускают генератор логов в бесконечном цикле — чтобы остановить генератор, нажмите CTRL + C.\nВы можете изменить это поведение генератора — например, чтобы задать генерацию логов в течение 1 минуты, замените строки:\n```\nwhile true; do    generate_log >> \"$LOG_FILE\"    sleep 1done\n```\n\nна строки:\n```\ncount=0while [ $count -lt 60 ]; do    generate_log >> \"$LOG_FILE\"    ((count++))    sleep 1done\n```\n4. Назначьте файл log_producer.sh исполняемым:\n```\nsudo chmod +x /usr/local/bin/log_producer/log_producer.sh\n```\n5. Запустите генератор логов:\n```\nsudo /usr/local/bin/log_producer/log_producer.sh\n```\n\nГенератор можно запустить в фоновом режиме, добавив к команде знак & — так вы сможете продолжать работать в этой же консоли, не открывая новую для последующих процессов.\n```\nsudo /usr/local/bin/log_producer/log_producer.sh &\n```\nПосле запуска генератор начнет создавать лог-файл /usr/local/bin/log_producer/error_log.log.\nЧтобы остановить работу log_producer.sh, нажмите CTRL + C.\n\n## Шаг 4. Запуск Fluent Bit для сбора логов\nПеред первым запуском fluent-bit в режиме сервиса нужно проверить, нет ли ошибок доступа и корректно ли заполнены файлы настроек.\nДля этого проверьте работу fluent-bit в следующем порядке:\n1. Запустите fluent-bit в консольном режиме.\n2. Запустите fluent-bit в режиме сервиса.\nВ дальнейшем вы сможете использовать любой из этих способов.\n\n### Запуск в консольном режиме\nЗапустите fluent-bit в консоли:\n```\nsudo /opt/fluent-bit/bin/fluent-bit -c /etc/fluent-bit/fluent-bit.conf\n```\n\nЧтобы завершить работу fluent-bit, нажмите CTRL + C.\n\n### Запуск в режиме сервиса\nЗапустите fluent-bit для сбора логов как сервис:\n```\nsudo systemctl start fluent-bit\n```\n\nЕсли сервис был запущен ранее, его можно перезапустить, чтобы применились изменения конфигурации:\n```\nsudo systemctl restart fluent-bit\n```\n\n## Шаг 5. Просмотр логов\nЧерез несколько секунд после отправки логи появятся в сервисе Клиентского логирования.\nВы можете посмотреть логи в лог-группах.\nЛоги можно отфильтровать с помощью языка фильтрующих выражений и выгрузить как файл.\nВ режиме tail сбор логов в fluent-bit работает по принципу отслеживания новых записей в логах.\nПри перезапуске сервиса данные, обработанные ранее, не отправляются в систему повторно.\nЧтобы данные непрерывно поступали в сервис, выберите подходящий сценарий:\n\n- запустите генератор логов в бесконечном цикле, чтобы поддерживать постоянное поступление данных;\n- выполняйте генерацию логов пакетами — запускайте скрипт многократно с необходимым интервалом.\n\nЭто позволяет исключить дублирование записей и поддерживать актуальность передаваемых данных.\n\n## После окончания работы\nЕсли виртуальная машина и ее логи стали неактуальными, вы можете удалить их:\n- Удалить лог-группу\n- Удалить проект\n- Удалить виртуальную машину\n\n  [© 2025 Cloud.ru](https://cloud.ru)",
      "debug": {
        "start_page": 1,
        "end_page": 1
      }
    }
  ]
}