{
  "title": "Передача аудит-логов с виртуальной машины с помощью Fluent Bit",
  "chapters": [
    {
      "name": "Передача аудит-логов с виртуальной машины с помощью Fluent Bit",
      "content": "Практические руководства Evolution    \n\n # Передача аудит-логов с виртуальной машины с помощью Fluent Bit   Эта статья полезна?          \nПримечание Отправка аудит-логов в сервис находится на стадии Preview.\nЧтобы получить возможность отправлять аудит-логи, обратитесь в техническую поддержку.\nFluent Bit — кроссплатформенный инструмент с открытым исходным кодом.\nОн собирает, обрабатывает и фильтрует лог-сообщения из разных источников, а затем сохраняет их в хранилище.\nПосле этого лог-сообщения поступают в маршрутизатор, который определяет, куда они будут отправлены.\nДля работы с разными источниками и приемниками используются специализированные плагины.\n\n## Перед началом работы\n1. Создайте необходимые типы аудит-событий.\n2. Создайте сервисный аккаунт.\nВ блоке Доступы и роли выберите роли:\n- в блоке Проект — «Пользователь сервисов»;\n- в блоке Сервисы — «audit.writer».\n3. Для сервисного аккаунта создайте API-ключ.\nВ параметрах API-ключа укажите сервис «audit».\nСрок действия API-ключа ограничен — когда он подойдет к концу, мы отправим вам уведомление.\nПосле этого необходимо обновить API-ключ.\n4. Создайте виртуальную машину Ubuntu 22.04.\n5. Подключитесь к созданной виртуальной машине по SSH.\n\n## Шаг 1. Установка Fluent Bit\nУстановите Fluent Bit одним из способов:\nИз дистрибутиваAвтоматизированная установка Установка вручную Установите приложение Fluent Bit из сборки дистрибутива для вашей операционной системы.\n\nЧтобы проверить, что fluent-bit установлен корректно, нужно запустить его и убедиться, что он установлен как сервис.\nДля этого:\n1. Запустите fluent-bit как сервис:\n```\nsudo systemctl start fluent-bit\n```\n2. Проверьте статус сервиса fluent-bit — он должен быть активным:\n```\nsystemctl status fluent-bit\n```\n\nЕсли fluent-bit настроен верно, будет выведен статус в виде:\n```\n● fluent-bit.service - Fluent Bit     Loaded: loaded (/lib/systemd/system/fluent-bit.service; disabled; vendor preset: enabled)     Active: active (running) since Tue 2025-03-11 15:48:23 UTC; 3s ago       Docs: https://docs.fluentbit.io/manual/   Main PID: 34596 (fluent-bit)      Tasks: 8 (limit: 2323)     Memory: 9.4M        CPU: 70ms     CGroup: /system.slice/fluent-bit.service             └─34596 /opt/fluent-bit/bin/fluent-bit -c //etc/fluent-bit/fluent-bit.conf\n```\n3. После проверки сервиса fluent-bit остановите его, чтобы далее настроить на совместную работу с плагином audit:\n```\nsudo systemctl stop fluent-bit\n```\n\n## Шаг 2. Настройка Fluent Bit\n1. Откройте файл /etc/fluent-bit/fluent-bit.conf:\n```\nsudo nano /etc/fluent-bit/fluent-bit.conf\n```\n2. Добавьте в файл данные в виде:\n```\n[SERVICE]    Daemon Off    Flush 1    Log_Level info    Plugins_File plugins.conf    Parsers_File parsers.conf\n[INPUT]    Name tail    Path <path-to-log/logfile.log>    Parser docker    Tag             fb_tag\n[FILTER]    Name        lua    Match       fb_tag    Script      to_audit.lua    call        convert_to_audit\n[OUTPUT]    Name                     http    Match                    fb_tag    Host                     audit.api.cloud.ru    URI                      /bulk/<REPLACE_TO_PROJECT_ID>/send    Port                     443    Format                   json    json_date_key            false    Header                   Authorization Api-Key <REPLACE_TO_AUDIT_API_KEY>    tls on\n```\n\nСекция [INPUT] указывает на источник логов, а [OUTPUT] — на сервис, в который отправятся логи.\nВ режиме tail сбор логов в fluent-bit работает по принципу отслеживания новых записей в логах.\nПри перезапуске сервиса данные, обработанные ранее, не отправляются в систему повторно.\nПодставьте в файл свои данные:\n\n- <path-to-log/logfile.log> — путь к файлу-источнику логов: fluent-bit будет сканировать этот файл и отслеживать в нем новые строки.\n- <REPLACE_TO_PROJECT_ID> — ID проекта, в который будут отправлены аудит-логи.\n- REPLACE_TO_AUDIT_API_KEY — API-ключ сервисного аккаунта с ролью «audit.writer».\nПроверьте, что для вашего сервисного аккаунта выбраны роли «Пользователь сервисов» и «audit.writer».\n\nВ следующем шаге инструкции настраивается тестовая отправка данных с помощью генератора логов, который записывает аудит-логи в лог-файл.\nДля тестирования с помощью генератора вместо <path-to-log/logfile.log> укажите путь к лог-файлу: /usr/local/bin/log_producer/error_log.log.\nПример изменений в файле /etc/fluent-bit/fluent-bit.conf:\n```\n[SERVICE]    Daemon Off    Flush 1    Log_Level info    Plugins_File plugins.conf    Parsers_File parsers.conf\n[INPUT]    Name tail    Path /usr/local/bin/log_producer/error_log.log    Parser docker    Tag             fb_tag\n[FILTER]    Name        lua    Match       fb_tag    Script      to_audit.lua    call        convert_to_audit\n[OUTPUT]    Name                     http    Match                    fb_tag    Host                     audit.api.cloud.ru    URI                      /bulk/00000000-1111-2222-3333-444444444444/send    Port                     443    Format                   json    json_date_key            false    Header                   Authorization Api-Key M2QxNjxxxxxxxxxxxxxxxxxxxxxxxxxxx.1e3c25xxxxxxxxxxxx    tls on\n```\n3. Создайте скрипт-трансформер, который будет переводить исходный формат логов в формат, поддерживаемый сервисом «Аудит-логирование»:\n```\nsudo touch /etc/fluent-bit/to_audit.lua\n```\n4. Откройте файл скрипта с помощью редактора nano:\n```\nsudo nano /etc/fluent-bit/to_audit.lua\n```\n5. Измените скрипт to_audit.lua в соответствии с форматом исходного лог-файла:\n```\nfunction table_to_string(tbl)    local result = \"{\"    for k, v in pairs(tbl) do        -- Check the key type (ignore any numerical keys - assume its an array)        if type(k) == \"string\" then            result = result..\"[\\\"\"..k..\"\\\"]\"..\"=\"        end\n        -- Check the value type        if type(v) == \"table\" then            result = result..table_to_string(v)        elseif type(v) == \"boolean\" then            result = result..tostring(v)        else            result = result..\"\\\"\"..v..\"\\\"\"        end        result = result..\",\"    end    -- Remove leading commas from the result    if result ~= \"{\" then        result = result:sub(1, result:len()-1)    end    return result..\"}\"end\nfunction convert_to_audit(tag, timestamp, record)    new_record = {}    new_record[\"datetime\"] = os.time()*1000    new_record[\"service_name\"] = \"Customer\"    new_record[\"service_version\"] = \"n/a\"    new_record[\"name\"] = \"SyslogEvent\"    new_record[\"session_id\"] = \"\"    new_record[\"user_login\"] = record[\"user_login\"]    new_record[\"user_name\"] = record[\"user_name\"]    new_record[\"user_node\"] = \"n/a\"    new_record[\"tags\"]={\"GT2\",\"GT3\"}    new_record[\"params\"] = {       {           name = \"details\",           value = table_to_string(record)       }    }    return 1, timestamp, new_recordend\n```\n\nГде:\n\n- datetime — время, в которое произошло событие, в формате Unix.\n- service_name — имя сервиса-источника события.\nВ примере в инструкции мы используем предопределенный тип сервиса-источника — [\"service_name\"] = \"Customer\".\nИспользуйте его для тестирования.\nВ дальнейшем вы можете создать свой тип события и указать здесь его источник.\n- service_version — версия сервиса.\n- name — тип события.\nВ примере в инструкции мы используем тип [\"name\"] = \"SyslogEvent\".\nИспользуйте его для тестирования.\nВ дальнейшем вы можете создать свой тип события и указать здесь его название.\n- session_id — ID запроса.\n- user_login — логин пользователя.\n- user_name — имя пользователя.\n- user_node — адрес субъекта события.\n- tags — опциональное поле, массив строк с набором тегов.\n- params — детали события, массив в формате key-value pair.\nСервис-источник сам определяет состав параметров внутри объекта.\n\n## Шаг 3. Проверка отправки аудит-логов\nНа этом этапе вы сможете настроить тестовую отправку аудит-логов с помощью bash-скрипта — генератора логов.\nОн будет записывать аудит-логи в лог-файл.\nЧтобы создать генератор:\n1. Создайте директорию, в которой будет находиться скрипт:\n```\nsudo mkdir /usr/local/bin/log_producer/\n```\n2. Создайте пустой файл log_producer.sh:\n```\nsudo touch /usr/local/bin/log_producer/log_producer.sh\n```\n3. Откройте созданный файл с помощью редактора nano:\n```\nsudo nano /usr/local/bin/log_producer/log_producer.sh\n```\n\nВ файл добавьте:\n```\n#!/bin/bash\nLOG_FILE=${1:-./error_log.log}\ngenerate_log() {    # Generate timestamp with timezone    timestamp=$(date \"+%Y-%m-%dT%H:%M:%S.%3N%:z\")\n    # Random log level selection    levels=(\"TRACE\" \"DEBUG\" \"INFO\" \"NOTICE\" \"WARN\" \"ERROR\" \"CRITICAL\" \"ALERT\" \"EMERGENCY\" \"FATAL\")    level=${levels[$RANDOM % ${#levels[@]}]}\n    # Create labels JSON object    labels_json=\"\\\"labels\\\":{\"    labels_json+=\"\\\"app\\\":\\\"logger\\\",\"    labels_json+=\"\\\"host\\\":\\\"$(hostname)\\\",\"    labels_json+=\"\\\"pid\\\":$$,\"    labels_json+=\"\\\"random\\\":$((RANDOM % 1000))\"    labels_json+=\"}\"\n    # Generate random message    messages=(        \"Processing request\"        \"Task completed\"        \"Operation failed\"        \"Initializing system\"        \"Checking permissions\"        \"Resource allocated\"        \"Connection timeout\"        \"Data received\"        \"Invalid input\"        \"Queue processed\"    )    message=\"${messages[$RANDOM % ${#messages[@]}]} [ID: $((RANDOM % 10000))]\"\n    # Construct single-line JSON    printf '{\"timestamp\":\"%s\",\"level\":\"%s\",\"message\":\"%s\", \"version\":\"V2_1\",\"user_name\":\"Ivan Ivanov\", \"user_login\":\"ivivanov\"}\\n' \\        \"$timestamp\" \\        \"$level\" \\        \"$message\"}\n# Handle Ctrl+Ctrap 'echo -e \"\\nLogging stopped. Output: $LOG_FILE\"; exit' SIGINT\necho \"Logging to $LOG_FILE - Press CTRL+C to stop\"while true; do    generate_log >> \"$LOG_FILE\"    sleep 1done\n```\n\nПоследние строки кода запускают генератор логов в бесконечном цикле — чтобы остановить генератор, нажмите CTRL + C.\nВы можете изменить это поведение генератора — например, чтобы задать генерацию логов в течение 1 минуты, замените строки:\n```\nwhile true; do    generate_log >> \"$LOG_FILE\"    sleep 1done\n```\n\nна строки:\n```\ncount=0while [ $count -lt 60 ]; do    generate_log >> \"$LOG_FILE\"    ((count++))    sleep 1done\n```\n4. Назначьте файл log_producer.sh исполняемым:\n```\nsudo chmod +x /usr/local/bin/log_producer/log_producer.sh\n```\n5. Запустите генератор логов:\n```\nsudo /usr/local/bin/log_producer/log_producer.sh /usr/local/bin/log_producer/error_log.log\n```\n\nГенератор можно запустить в фоновом режиме, добавив к команде знак & — так вы сможете продолжать работать в этой же консоли, не открывая новую для последующих процессов:\n```\nsudo /usr/local/bin/log_producer/log_producer.sh /usr/local/bin/log_producer/error_log.log &\n```\nПосле запуска генератор начнет создавать лог-файл /usr/local/bin/log_producer/error_log.log.\nЧтобы остановить работу log_producer.sh, нажмите CTRL + C.\n\n## Шаг 4. Запуск Fluent Bit для сбора аудит-логов\nПеред первым запуском fluent-bit в режиме сервиса нужно проверить, нет ли ошибок доступа и корректно ли заполнены файлы настроек.\nДля этого проверьте работу fluent-bit в следующем порядке:\n1. Запустите fluent-bit в консольном режиме.\n2. Запустите fluent-bit в режиме сервиса.\nВ дальнейшем вы сможете использовать любой из этих способов.\n\n### Запуск в консольном режиме\nЗапустите fluent-bit в консоли:\n```\nsudo /opt/fluent-bit/bin/fluent-bit -c /etc/fluent-bit/fluent-bit.conf\n```\n\nСообщения такого типа показывают, что данные отправляются успешно:\n```\n[2025/03/20 09:40:33] [ info] [output:http:http.0] worker #1 started[2025/03/20 09:40:37] [ info] [output:http:http.0] audit.api.cloud.ru:443, HTTP status=200{}\n[2025/03/20 09:40:38] [ info] [output:http:http.0] audit.api.cloud.ru:443, HTTP status=200{}\n[2025/03/20 09:40:39] [ info] [output:http:http.0] audit.api.cloud.ru:443, HTTP status=200{}\n```\n\nЧтобы завершить работу fluent-bit, нажмите CTRL + C.\n\n### Запуск в режиме сервиса\nЗапустите fluent-bit для сбора логов как сервис:\n```\nsudo systemctl start fluent-bit\n```\n\nЕсли сервис был запущен ранее, его можно перезапустить, чтобы применились изменения конфигурации:\n```\nsudo systemctl restart fluent-bit\n```\n\n## Шаг 5. Просмотр аудит-логов\nЧерез несколько секунд после отправки аудит-логи появятся в сервисе «Аудит-логирование».\nВы можете посмотреть аудит-логи в таблице.\nАудит-логи можно фильтровать и выгрузить как файл.\nВ режиме tail сбор логов в fluent-bit работает по принципу отслеживания новых записей в логах.\nПри перезапуске сервиса данные, обработанные ранее, не отправляются в систему повторно.\nЧтобы данные непрерывно поступали в сервис, выберите подходящий сценарий:\n\n- запустите генератор логов в бесконечном цикле, чтобы поддерживать постоянное поступление данных;\n- выполняйте генерацию логов пакетами — запускайте скрипт многократно с необходимым интервалом.\n\nЭто позволяет исключить дублирование записей и поддерживать актуальность передаваемых данных.\n\n## После окончания работы\nЕсли проект и виртуальная машина стали неактуальными, вы можете удалить их:\n- Удалить проект\n- Удалить виртуальную машину\n\n  [© 2025 Cloud.ru](https://cloud.ru)",
      "debug": {
        "start_page": 1,
        "end_page": 1
      }
    }
  ]
}