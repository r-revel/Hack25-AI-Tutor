{
  "title": "Devpractice Team. Линейная алгебра на Python [2019] Абдрахманов М.И.",
  "chapters": [
    {
      "name": "Глава 1. Матрицы 10",
      "chapters": [
        {
          "name": "1.1 Общие понятия 10",
          "content": "1.1 Общие понятия Матрицей называют объект, записываемый в виде прямоугольной таблицы, элементами которой являются числа (могут быть как действительные, так и комплексные). Пример матрицы : . В общем виде матрица записывается так: . Представленная выше матрица состоит из -строк и -столбцов. Каждый ее элемент имеет соответствующее позиционное обозначение, определяемое номером строки и столбца на пересечении которых он расположен: - находится в -ой строке и -м столбце. Важным элементом матрицы является главная диагональ , ее составляют элементы, у которых совпадают номера строк и столбцов.",
          "debug": {
            "start_page": 11,
            "end_page": 11
          }
        },
        {
          "name": "1.2 Виды матриц и способы их создания в Python 10",
          "content": "--- Страница 11 --- (продолжение)\n1.1 Общие понятия Матрицей называют объект, записываемый в виде прямоугольной таблицы, элементами которой являются числа (могут быть как действительные, так и комплексные). Пример матрицы : . В общем виде матрица записывается так: . Представленная выше матрица состоит из -строк и -столбцов. Каждый ее элемент имеет соответствующее позиционное обозначение, определяемое номером строки и столбца на пересечении которых он расположен: - находится в -ой строке и -м столбце. Важным элементом матрицы является главная диагональ , ее составляют элементы, у которых совпадают номера строк и столбцов. 1.2 Виды матриц и способы их создания в Python Так как матрица - это прямоугольная таблица чисел, то задание матрицы в Python будет предполагать построение соответствующего двумерного массива. Для создания такого массива из стандартных средств Python наиболее подходящим является тип данных список (англ. list). Но списки не самый удобный инструмент для выполнения операций с матрицами, для этих целей мы будем использовать тип array из библиотеки Numpy. Для того, чтобы использовать библиотеку Numpy ее нужно предварительно установить, после этого - импортировать в свой проект. По установке Numpy можно подробно прочитать в разделе “Установка библиотек Numpy и Scipy” из введения. 10\n1.2 Виды матриц и способы их создания в Python Так как матрица - это прямоугольная таблица чисел, то задание матрицы в Python будет предполагать построение соответствующего двумерного массива. Для создания такого массива из стандартных средств Python наиболее подходящим является тип данных список (англ. list). Но списки не самый удобный инструмент для выполнения операций с матрицами, для этих целей мы будем использовать тип array из библиотеки Numpy. Для того, чтобы использовать библиотеку Numpy ее нужно предварительно установить, после этого - импортировать в свой проект. По установке Numpy можно подробно прочитать в разделе “Установка библиотек Numpy и Scipy” из введения. 10\n--- Страница 12 ---\nДля того импорта данного модуля, добавьте в самое начало вашей программы следующую строку: >>> import numpy as np Если после импорта не было сообщений об ошибке, то значит все прошло удачно и можно начинать работу. Numpy содержит большое количество функций для работы с матрицами, которые мы будем активно использовать. Обязательно убедитесь в том, что библиотека установлена и импортируется в проект без ошибок. Рассмотрим, различные виды матриц и способы их задания в Python. 1.2.1 Вектор Вектором называется матрица, у которой есть только один столбец или одна строка. Более подробно свойства векторов, их геометрическая интерпретация и операции над ними будут рассмотрены в “Главе 3. Основы векторной алгебры ”. 1.2.1.1 Вектор-строка Вектор-строка имеет следующую математическую запись: . Такой вектор в Python можно задать следующим образом: >>> v_hor_np = np.array([1, 2]) >>> print(v_hor_np) [1 2] Если необходимо создать нулевой или единичный вектор (вектор, у которого все элементы либо нули, либо единицы), то можно использовать специальные функции из библиотеки Numpy. Создадим нулевую вектор-строку, состоящую из пяти элементов: >>> v_hor_zeros_v1 = np.zeros((5,)) >>> print(v_hor_zeros_v1) [0. 0. 0. 0. 0.] В случае, если требуется построить вектор-строку так, чтобы он сам являлся элементом массива, это может понадобиться если вектор, в последующем, нужно 11\n--- Страница 13 ---\nбудет транспонировать (см. раздел “",
          "debug": {
            "start_page": 11,
            "end_page": 13
          }
        },
        {
          "name": "1.2 Виды матриц и способы их создания в Python 10",
          "content": "--- Страница 11 --- (продолжение)\n1.1 Общие понятия Матрицей называют объект, записываемый в виде прямоугольной таблицы, элементами которой являются числа (могут быть как действительные, так и комплексные). Пример матрицы : . В общем виде матрица записывается так: . Представленная выше матрица состоит из -строк и -столбцов. Каждый ее элемент имеет соответствующее позиционное обозначение, определяемое номером строки и столбца на пересечении которых он расположен: - находится в -ой строке и -м столбце. Важным элементом матрицы является главная диагональ , ее составляют элементы, у которых совпадают номера строк и столбцов. 1.2 Виды матриц и способы их создания в Python Так как матрица - это прямоугольная таблица чисел, то задание матрицы в Python будет предполагать построение соответствующего двумерного массива. Для создания такого массива из стандартных средств Python наиболее подходящим является тип данных список (англ. list). Но списки не самый удобный инструмент для выполнения операций с матрицами, для этих целей мы будем использовать тип array из библиотеки Numpy. Для того, чтобы использовать библиотеку Numpy ее нужно предварительно установить, после этого - импортировать в свой проект. По установке Numpy можно подробно прочитать в разделе “Установка библиотек Numpy и Scipy” из введения. 10\n1.2 Виды матриц и способы их создания в Python Так как матрица - это прямоугольная таблица чисел, то задание матрицы в Python будет предполагать построение соответствующего двумерного массива. Для создания такого массива из стандартных средств Python наиболее подходящим является тип данных список (англ. list). Но списки не самый удобный инструмент для выполнения операций с матрицами, для этих целей мы будем использовать тип array из библиотеки Numpy. Для того, чтобы использовать библиотеку Numpy ее нужно предварительно установить, после этого - импортировать в свой проект. По установке Numpy можно подробно прочитать в разделе “Установка библиотек Numpy и Scipy” из введения. 10\n--- Страница 12 ---\nДля того импорта данного модуля, добавьте в самое начало вашей программы следующую строку: >>> import numpy as np Если после импорта не было сообщений об ошибке, то значит все прошло удачно и можно начинать работу. Numpy содержит большое количество функций для работы с матрицами, которые мы будем активно использовать. Обязательно убедитесь в том, что библиотека установлена и импортируется в проект без ошибок. Рассмотрим, различные виды матриц и способы их задания в Python. 1.2.1 Вектор Вектором называется матрица, у которой есть только один столбец или одна строка. Более подробно свойства векторов, их геометрическая интерпретация и операции над ними будут рассмотрены в “Главе 3. Основы векторной алгебры ”. 1.2.1.1 Вектор-строка Вектор-строка имеет следующую математическую запись: . Такой вектор в Python можно задать следующим образом: >>> v_hor_np = np.array([1, 2]) >>> print(v_hor_np) [1 2] Если необходимо создать нулевой или единичный вектор (вектор, у которого все элементы либо нули, либо единицы), то можно использовать специальные функции из библиотеки Numpy. Создадим нулевую вектор-строку, состоящую из пяти элементов: >>> v_hor_zeros_v1 = np.zeros((5,)) >>> print(v_hor_zeros_v1) [0. 0. 0. 0. 0.] В случае, если требуется построить вектор-строку так, чтобы он сам являлся элементом массива, это может понадобиться если вектор, в последующем, нужно 11\n--- Страница 13 ---\nбудет транспонировать (см. раздел “",
          "debug": {
            "start_page": 11,
            "end_page": 13
          }
        },
        {
          "name": "1.3 Транспонирование матрицы 17",
          "content": "--- Страница 13 --- (продолжение)\n1.3 Транспонирование матрицы ”), то данная задача решается так: >>> v_hor_zeros_v2 = np.zeros((1, 5)) >>> print(v_hor_zeros_v2 ) [[0. 0. 0. 0. 0.]] Аналогично построим единичную вектор-строку: >>> v_hor_one_v1 = np.ones((5,)) >>> print(v_hor_one_v1) [1. 1. 1. 1. 1.] >>> v_hor_one_v2 = np.ones((1, 5)) >>> print(v_hor_one_v2) [[1. 1. 1. 1. 1.]] 1.2.1.2 Вектор-столбец Вектор-столбец имеет следующую математическую запись: . В общем виде вектор столбец можно задать следующим образом: >>> v_vert_np = np.array([[1], [2]]) >>> print(v_vert_np) [[1] [2]] Рассмотрим способы создания нулевых и единичных векторов-столбцов. Построим нулевой вектор-столбец : >>> v_vert_zeros = np.zeros((5, 1)) >>> print(v_vert_zeros) [[0.] [0.] [0.] [0.] [0.]] 12\n1.3 Транспонирование матрицы ”), то данная задача решается так: >>> v_hor_zeros_v2 = np.zeros((1, 5)) >>> print(v_hor_zeros_v2 ) [[0. 0. 0. 0. 0.]] Аналогично построим единичную вектор-строку: >>> v_hor_one_v1 = np.ones((5,)) >>> print(v_hor_one_v1) [1. 1. 1. 1. 1.] >>> v_hor_one_v2 = np.ones((1, 5)) >>> print(v_hor_one_v2) [[1. 1. 1. 1. 1.]] 1.2.1.2 Вектор-столбец Вектор-столбец имеет следующую математическую запись: . В общем виде вектор столбец можно задать следующим образом: >>> v_vert_np = np.array([[1], [2]]) >>> print(v_vert_np) [[1] [2]] Рассмотрим способы создания нулевых и единичных векторов-столбцов. Построим нулевой вектор-столбец : >>> v_vert_zeros = np.zeros((5, 1)) >>> print(v_vert_zeros) [[0.] [0.] [0.] [0.] [0.]] 12\n--- Страница 14 ---\nЕдиничный вектор-столбец можно создать с помощью функции ones(): >>> v_vert_ones = np.ones((5, 1)) >>> print(v_vert_ones) [[1.] [1.] [1.] [1.] [1.]] 1.2.2 Квадратная матрица Довольно часто, на практике, приходится работать с квадратными матрицами . Квадратной называется матрица, у которой количество столбцов и строк совпадает. В общем виде они выглядят так: . В примерах будем работать со следующей матрицей : . В Numpy можно создать квадратную матрицу с помощью метода array(): >>> m_sqr_arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> print(m_sqr_arr) [[1 2 3] [4 5 6] [7 8 9]] Как вы уже наверное заметили, аргументом функции np.array() является список Python, его можно построить отдельно и передать в функцию: >>> m_sqr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> m_sqr_arr = np.array(m_sqr) >>> print(m_sqr_arr) [[1 2 3] [4 5 6] [7 8 9]] 13\n--- Страница 15 ---\nВ Numpy есть еще одни способ создания матриц - это построение объекта типа matrix с помощью одноименного метода. Задать матрицу можно в виде списка: >>> m_sqr_mx = np.matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> print(m_sqr_mx) [[1 2 3] [4 5 6] [7 8 9]] Также доступен стиль Matlab, когда между элементами ставятся пробелы, а строки разделяются точкой с запятой, при этом такое описание должно быть передано в виде строки: >>> m_sqr_mx = np.matrix( '1 2 3; 4 5 6; 7 8 9' ) >>> print(m_sqr_mx) [[1 2 3] [4 5 6] [7 8 9]] 1.2.3 Диагональная матрица Особым видом квадратной матрицы является диагональная - это такая матрица, у которой все элементы, кроме тех, что расположены на главной диагонали равны нулю: . Диагональную матрицу можно построить вручную, задав только значения элементам на главной диагонали: >>> m_diag = [[1, 0, 0], [0, 5, 0], [0, 0, 9]] >>> m_diag_np = np.matrix(m_diag) >>> print(m_diag_np) [[1 0 0] [0 5 0] [0 0 9]] Библиотека Numpy предоставляет инструменты, которые могут упростить построение такой матрицы. 14\n--- Страница 16 ---\nПервый вариант подойдет в том случае, если у вас уже есть матрица, а вы из нее хотите сделать диагональную. Создадим матрицу размера 3x3: >>> m_sqr_mx = np.matrix( '1 2 3; 4 5 6; 7 8 9' ) Извлечем ее главную диагональ: >>> diag = np.diag(m_sqr_mx) >>> print(diag) [1 5 9] Построим диагональную матрицу на базе полученной диагонали: >>> m_diag_np = np.diag(np.diag(m_sqr_mx)) >>> print(m_diag_np) [[1 0 0] [0 5 0] [0 0 9]] Второй вариант подразумевает построение единичной матрицы, ей будет посвящен следующий параграф. 1.2.4 Единичная матрица Единичной матрицей называют квадратную матрицу, у которой элементы главной диагонали равны единицы, а все остальные нулю: . Создадим единичную матрицу на базе списка, который передадим в качестве аргумента функции matrix(): >>> m_e = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] >>> m_e_np = np.matrix(m_e) >>> print(m_e_np) [[1 0 0] [0 1 0] [0 0 1]] 15\n--- Страница 17 ---\nТакой способ не очень удобен, к счастью для нас, для построения такого типа матриц в библиотеке Numpy есть специальная функция — eye(): >>> m_eye = np.eye(3) >>> print(m_eye) [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] В качестве аргумента функции передается размерность матрицы, в нашем примере - это матрица 3x3. Тот же результат можно получить с помощью функции identity(): >>> m_idnt = np.identity(3) >>> print(m_idnt) [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] 1.2.5 Нулевая матрица У нулевой матрицы все элементы равны нулю: . Пример того, как создать такую матрицу с использованием списков, мы приводить не будем, он делается по аналогии с предыдущим разделом. Что касается Numpy, то в составе этой библиотеки есть функция zeros(), которая создает нужную нам матрицу: >>> m_zeros = np.zeros((3, 3)) >>> print(m_zeros) [[0. 0. 0.] [0. 0. 0.] [0. 0. 0.]] В качестве параметра функции zeros() передается размерность требуемой матрицы в виде кортежа из двух элементов, первый из которых - число строк, второй - столбцов. Если функции zeros() передать в качестве аргумента число, то будет построена нулевая вектор-строка, это мы делали в параграфе, посвященному векторам. 16\n--- Страница 18 ---\n1.2.6 Задание матрицы в общем виде Если у вас уже есть данные о содержимом матрицы, то создать ее можно, используя списки Python или функцию matrix() из библиотеки Numpy: >>> m_mx = np.matrix( '1 2 3; 4 5 6') >>> print(m_mx) [[1 2 3] [4 5 6]] Если же вы хотите создать матрицу заданного размера с произвольным содержимым, чтобы потом ее заполнить, проще всего для того использовать функцию zeros(), которая создаст матрицу заданного размера, заполненную нулями: >>> m_var = np.zeros((2, 5)) >>> print(m_var) [[0. 0. 0. 0. 0.] [0. 0. 0. 0. 0.]] 1.3 Транспонирование матрицы Транспонирование матрицы - это процесс замены строк матрицы на ее столбцы, а столбцов, соответственно, на строки. Полученная в результате матрица называется транспонированной. Символ операции транспонирования - буква . ➣ Численный пример Для исходной матрицы: . Транспонированная будет выглядеть так: . ➤ Пример на Python Решим задачу транспонирования матрицы на Python. Создадим матрицу : >>> A = np.matrix( '1 2 3; 4 5 6') >>> print(A) [[1 2 3] [4 5 6]] 17\n--- Страница 19 ---\nТранспонируем матрицу с помощью метода transpose(): >>> A_t = A.transpose() >>> print(A_t) [[1 4] [2 5] [3 6]] Существует сокращенный вариант получения транспонированной матрицы, он удобен для практического использования: >>> print(A.T) [[1 4] [2 5] [3 6]] Рассмотрим свойства транспонированных матриц. Операции сложения и умножения матриц, а также вычисление определителя будут рассмотрены в последующих параграфах, при первом прочтении можете пропустить этот раздел. Свойство 1. Дважды транспонированная матрица равна исходной матрице: . ➣ Численный пример . ➤ Пример на Python >>> A = np.matrix( '1 2 3; 4 5 6') >>> print(A) [[1 2 3] [4 5 6]] >>> R = (A.T).T >>> print(R) [[1 2 3] [4 5 6]] 18\n--- Страница 20 ---\nСвойство 2. Транспонированная сумма матриц равна сумме транспонированных матриц: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2 3; 4 5 6') >>> B = np.matrix( '7 8 9; 0 7 5') >>> L = (A + B).T >>> R = A.T + B.T >>> print(L) [[ 8 4] [10 12] [12 11]] >>> print(R) [[ 8 4] [10 12] [12 11]] Свойство 3. Транспонированное произведение матриц равно произведению транспонированных матриц, расставленных в обратном порядке: . ➣ Численный пример , . 19\n--- Страница 21 ---\n➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> B = np.matrix( '5 6; 7 8') >>> L = (A.dot(B)).T >>> R = (B.T).dot(A.T) >>> print(L) [[19 43] [22 50]] >>> print(R) [[19 43] [22 50]] В данном примере, для умножения матриц, использовалась функция dot() из библиотеки Numpy. Свойство 4. Транспонированное произведение матрицы на число равно произведению этого числа на транспонированную матрицу: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2 3; 4 5 6') >>> k = 3 >>> L = (k * A).T >>> R = k * (A.T) >>> print(L) [[ 3 12] [ 6 15] [ 9 18]] >>> print(R) [[ 3 12] [ 6 15] [ 9 18]] 20\n--- Страница 22 ---\nСвойство 5. Определители исходной и транспонированной матрицы совпадают: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> A_det = np.linalg.det(A) >>> A_T_det = np.linalg.det(A.T) >>> print(format(A_det, '.9g')) -2 >>> print(format(A_T_det, '.9g')) -2 Ввиду особенностей Python при работе с числами с плавающей точкой, в данном примере при вычислении определителя рассматриваются только первые девять значащих цифр после запятой (за это отвечает параметр '.9g').",
          "debug": {
            "start_page": 13,
            "end_page": 22
          }
        },
        {
          "name": "1.4 Действия над матрицами 21",
          "content": "--- Страница 22 --- (продолжение)\n1.4 Действия над матрицами 1.4.1 Умножение на число При умножении матрицы на число, все элементы матрицы умножаются на это число: , , . 21\n1.4 Действия над матрицами 1.4.1 Умножение на число При умножении матрицы на число, все элементы матрицы умножаются на это число: , , . 21\n--- Страница 23 ---\n➣ Численный пример , , . ➤ Пример на Python >>> A = np.matrix( '1 2 3; 4 5 6') >>> C = 3 * A >>> print(C) [[ 3 6 9] [12 15 18]] Рассмотрим свойства операции умножения матрицы на число. Свойство 1. Произведение единицы и любой заданной матрицы равно заданной матрице: . ➣ Численный пример . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> L = 1 * A >>> R = A >>> print(L) [[1 2] [3 4]] >>> print(R) [[1 2] [3 4]] 22\n--- Страница 24 ---\nСвойство 2. Произведение нуля и любой матрицы равно нулевой матрице, размерность которой равна исходной матрицы: . ➣ Численный пример . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> Z = np.matrix( '0 0; 0 0') >>> L = 0 * A >>> R = Z >>> print(L) [[0 0] [0 0]] >>> print(R) [[0 0] [0 0]] Свойство 3. Произведение матрицы на сумму чисел равно сумме произведений матрицы на каждое из этих чисел: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> p = 2 >>> q = 3 >>> L = (p + q) * A >>> R = p * A + q * A >>> print(L) [[ 5 10] [15 20]] 23\n--- Страница 25 ---\n>>> print(R) [[ 5 10] [15 20]] Свойство 4. Произведение матрицы на произведение двух чисел равно произведению второго числа и заданной матрицы, умноженному на первое число: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> p = 2 >>> q = 3 >>> L = (p * q) * A >>> R = p * (q * A) >>> print(L) [[ 6 12] [18 24]] >>> print(R) [[ 6 12] [18 24]] Свойство 5. Произведение суммы матриц на число равно сумме произведений этих матриц на заданное число: . ➣ Численный пример , . 24\n--- Страница 26 ---\n➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> B = np.matrix( '5 6; 7 8') >>> k = 3 >>> L = k * (A + B) >>> R = k * A + k * B >>> print(L) [[18 24] [30 36]] >>> print(R) [[18 24] [30 36]] 1.4.2 Сложение Складывать можно только матрицы одинаковой размерности — то есть матрицы, у которых совпадает количество столбцов и строк. ➣ Численный пример , , . ➤ Пример на Python >>> A = np.matrix( '1 6 3; 8 2 7') >>> B = np.matrix( '8 1 5; 6 9 12') >>> C = A + B >>> print(C) [[ 9 7 8] [14 11 19]] Рассмотрим свойства сложения матриц. Свойство 1. Коммутативность сложения. От перестановки матриц их сумма не изменяется: . 25\n--- Страница 27 ---\n➣ Численный пример . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> B = np.matrix( '5 6; 7 8') >>> L = A + B >>> R = B + A >>> print(L) [[ 6 8] [10 12]] >>> print(R) [[ 6 8] [10 12]] Свойство 2. Ассоциативность сложения. Результат сложения трех и более матриц не зависит от порядка, в котором эта операция будет выполняться: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> B = np.matrix( '5 6; 7 8') >>> C = np.matrix( '1 7; 9 3') >>> L = A + (B + C) >>> R = (A + B) + C >>> print(L) [[ 7 15] [19 15]] >>> print(R) [[ 7 15] [19 15]] 26\n--- Страница 28 ---\nСвойство 3. Для любой матрицы существует противоположная ей , такая, что их сумма является нулевой матрицей : . ➣ Численный пример . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> Z = np.matrix( '0 0; 0 0') >>> L = A + (-1)*A >>> print(L) [[0 0] [0 0]] >>> print(Z) [[0 0] [0 0]] 1.4.3 Умножение матриц Умножение матриц это уже более сложная операция, по сравнению с рассмотренными выше. Умножать можно только матрицы, отвечающие следующему требованию: количество столбцов первой матрицы должно быть равно числу строк второй матрицы . Для простоты запоминания этого правила можно использовать диаграмму умножения, представленную на рисунке 1. Рисунок 1.1 — Диаграмма матричного умножения 27\n--- Страница 29 ---\nРассмотрим умножение матриц на примере. ➣ Численный пример , , . Каждый элемент новой матрицы является суммой произведений элементов -ой строки первой матрицы и -го столбца второй матрицы. Математически это записывается так: , , , . ➤ Пример на Python Решим задачу умножения матриц на языке Python. Для этого будем использовать функцию dot() из библиотеки Numpy: >>> A = np.matrix( '1 2 3; 4 5 6') >>> B = np.matrix( '7 8; 9 1; 2 3') >>> C = A.dot(B) >>> print(C) [[31 19] [85 55]] 28\n--- Страница 30 ---\nНиже представлены свойства произведения матриц. Примеры свойств будут показаны для квадратной матрицы. Свойство 1. Ассоциативность умножения. Результат умножения матриц не зависит от порядка, в котором будет выполняться эта операция: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> B = np.matrix( '5 6; 7 8') >>> C = np.matrix( '2 4; 7 8') >>> L = A.dot(B.dot(C)) >>> R = (A.dot(B)).dot(C) >>> print(L) [[192 252] [436 572]] >>> print(R) [[192 252] [436 572]] Свойство 2. Дистрибутивность умножения. Произведение матрицы на сумму матриц равно сумме произведений матриц: . ➣ Численный пример , . 29\n--- Страница 31 ---\n➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> B = np.matrix( '5 6; 7 8') >>> C = np.matrix( '2 4; 7 8') >>> L = A.dot(B + C) >>> R = A.dot(B) + A.dot(C) >>> print(L) [[35 42] [77 94]] >>> print(R) [[35 42] [77 94]] Свойство 3. Умножение матриц в общем виде не коммутативно. Это означает, что для матриц не выполняется правило независимости произведения от перестановки множителей: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> B = np.matrix( '5 6; 7 8') >>> L = A.dot(B) >>> R = B.dot(A) >>> print(L) [[19 22] [43 50]] >>> print(R) [[23 34] [31 46]] 30\n--- Страница 32 ---\nСвойство 4. Произведение заданной матрицы на единичную равно исходной матрице: . ➣ Численный пример , . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> E = np.matrix( '1 0; 0 1') >>> L = E.dot(A) >>> R = A.dot(E) >>> print(L) [[1 2] [3 4]] >>> print(R) [[1 2] [3 4]] >>> print(A) [[1 2] [3 4]] Свойство 5. Произведение заданной матрицы на нулевую матрицу равно нулевой матрице: . ➣ Численный пример . ➤ Пример на Python >>> A = np.matrix( '1 2; 3 4') >>> Z = np.matrix( '0 0; 0 0') >>> L = Z.dot(A) >>> R = A.dot(Z) >>> print(L) [[0 0] [0 0]] 31\n--- Страница 33 ---\n>>> print(R) [[0 0] [0 0]] >>> print(Z) [[0 0] [0 0]]",
          "debug": {
            "start_page": 22,
            "end_page": 33
          }
        },
        {
          "name": "1.5 Определитель матрицы 32",
          "content": "--- Страница 33 --- (продолжение)\n1.5 Определитель матрицы Определитель матрицы размера (-го порядка) является одной из ее численных характеристик. Определитель матрицы обозначается как или , его также называют детерминантом . Рассмотрим квадратную матрицу 2x2 в общем виде: . Определитель такой матрицы вычисляется следующим образом: . ➣ Численный пример , . Перед тем, как привести методику расчета определителя в общем виде, введем понятие минора элемента определителя. Минор элемента определителя - это определитель, полученный из данного, путем вычеркивания всех элементов строки и столбца, на пересечении которых стоит данный элемент. Для матрицы 3x3 следующего вида: . Минор будет выглядеть так: . 32\n1.5 Определитель матрицы Определитель матрицы размера (-го порядка) является одной из ее численных характеристик. Определитель матрицы обозначается как или , его также называют детерминантом . Рассмотрим квадратную матрицу 2x2 в общем виде: . Определитель такой матрицы вычисляется следующим образом: . ➣ Численный пример , . Перед тем, как привести методику расчета определителя в общем виде, введем понятие минора элемента определителя. Минор элемента определителя - это определитель, полученный из данного, путем вычеркивания всех элементов строки и столбца, на пересечении которых стоит данный элемент. Для матрицы 3x3 следующего вида: . Минор будет выглядеть так: . 32\n--- Страница 34 ---\nВведем еще одно понятие - алгебраическое дополнение элемента определителя - это минор этого элемента, взятый со знаком плюс или минус: . В общем виде вычислить определитель матрицы можно через разложение определителя по элементам строки или столбца. Суть в том, что определитель равен сумме произведений элементов любой строки или столбца на их алгебраические дополнения. Для матрицы 3x3 это правило будет выполняться следующим образом: . Это правило распространяется на матрицы любой размерности. ➣ Численный пример . 33\n--- Страница 35 ---\n➤ Пример на Python На Python определитель посчитать очень просто. Создадим матрицу размера 3x3 из приведенного выше численного примера: >>> A = np.matrix( '-4 -1 2; 10 4 -1; 8 3 1' ) >>> print(A) [[-4 -1 2] [10 4 -1] [ 8 3 1]] Для вычисления определителя этой матрицы воспользуемся функцией det() из пакета linalg. >>> np.linalg.det(A) -14.000000000000009 Мы уже говорили про особенность работы Python с числами с плавающей точкой, поэтому можете полученное значение округлить до -14. Рассмотрим свойства определителя матрицы. Свойство 1. Определитель матрицы остается неизменным при ее транспонировании: . ➤ Пример на Python Для округления чисел будем использовать функцию round(). >>> A = np.matrix( '-4 -1 2; 10 4 -1; 8 3 1' ) >>> print(A) [[-4 -1 2] [10 4 -1] [ 8 3 1]] >>> print(A.T) [[-4 10 8] [-1 4 3] [ 2 -1 1]] >>> det_A = round(np.linalg.det(A), 3) >>> det_A_t = round(np.linalg.det(A.T), 3) >>> print(det_A) -14.0 >>> print(det_A_t) -14.0 34\n--- Страница 36 ---\nСвойство 2. Если у матрицы есть строка или столбец, состоящие из нулей, то определитель такой матрицы равен нулю: . ➤ Пример на Python >>> A = np.matrix( '-4 -1 2; 0 0 0; 8 3 1' ) >>> print(A) [[-4 -1 2] [ 0 0 0] [ 8 3 1]] >>> np.linalg.det(A) 0.0 Свойство 3. При перестановке строк матрицы знак ее определителя меняется на противоположный: , . ➤ Пример на Python >>> A = np.matrix( '-4 -1 2; 10 4 -1; 8 3 1' ) >>> print(A) [[-4 -1 2] [10 4 -1] [ 8 3 1]] >>> B = np.matrix( '10 4 -1; -4 -1 2; 8 3 1' ) >>> print(B) [[10 4 -1] [-4 -1 2] [ 8 3 1]] >>> round(np.linalg.det(A), 3) -14.0 >>> round(np.linalg.det(B), 3) 14.0 35\n--- Страница 37 ---\nСвойство 4. Если у матрицы есть две одинаковые строки, то ее определитель равен нулю: . ➤ Пример на Python >>> A = np.matrix( '-4 -1 2; -4 -1 2; 8 3 1' ) >>> print(A) [[-4 -1 2] [-4 -1 2] [ 8 3 1]] >>> np.linalg.det(A) 0.0 Свойство 5. Если все элементы строки или столбца матрицы умножить на какое-то число, то и определитель будет умножен на это число: . ➤ Пример на Python >>> A = np.matrix( '-4 -1 2; 10 4 -1; 8 3 1' ) >>> print(A) [[-4 -1 2] [10 4 -1] [ 8 3 1]] >>> k = 2 >>> B = A.copy() >>> B[2, :] = k * B[2, :] >>> print(B) [[-4 -1 2] [10 4 -1] [16 6 2]] >>> det_A = round(np.linalg.det(A), 3) >>> det_B = round(np.linalg.det(B), 3) >>> det_A * k -28.0 >>> det_B -28.0 36\n--- Страница 38 ---\nСвойство 6. Если все элементы строки или столбца можно представить как сумму двух слагаемых, то определитель такой матрицы равен сумме определителей двух соответствующих матриц: . ➤ Пример на Python >>> A = np.matrix( '-4 -1 2; -4 -1 2; 8 3 1' ) >>> B = np.matrix( '-4 -1 2; 8 3 2; 8 3 1' ) >>> C = A.copy() >>> C[1, :] += B[1, :] >>> print(C) [[-4 -1 2] [ 4 2 4] [ 8 3 1]] >>> print(A) [[-4 -1 2] [-4 -1 2] [ 8 3 1]] >>> print(B) [[-4 -1 2] [ 8 3 2] [ 8 3 1]] >>> round(np.linalg.det(C), 3) 4.0 >>> round(np.linalg.det(A), 3) + round(np.linalg.det(B), 3) 4.0 Свойство 7. Если к элементам одной строки прибавить элементы другой строки умноженные на одно и тоже число, то определитель матрицы не изменится: . 37\n--- Страница 39 ---\n➤ Пример на Python >>> A = np.matrix( '-4 -1 2; 10 4 -1; 8 3 1' ) >>> k = 2 >>> B = A.copy() >>> B[1, :] = B[1, :] + k * B[0, :] >>> print(A) [[-4 -1 2] [10 4 -1] [ 8 3 1]] >>> print(B) [[-4 -1 2] [ 2 2 3] [ 8 3 1]] >>> round(np.linalg.det(A), 3) -14.0 >>> round(np.linalg.det(B), 3) -14.0 Свойство 8. Если строка или столбец матрицы является линейной комбинацией других строк (столбцов), то определитель такой матрицы равен нулю: . ➤ Пример на Python >>> A = np.matrix( '-4 -1 2; 10 4 -1; 8 3 1' ) >>> print(A) [[-4 -1 2] [10 4 -1] [ 8 3 1]] >>> k = 2 >>> A[1, :] = A[0, :] + k * A[2, :] >>> round(np.linalg.det(A), 3) 0.0 Свойство 9. Если матрица содержит пропорциональные строки, то ее определитель равен нулю: . 38\n--- Страница 40 ---\n➤ Пример на Python >>> A = np.matrix( '-4 -1 2; 10 4 -1; 8 3 1' ) >>> print(A) [[-4 -1 2] [10 4 -1] [ 8 3 1]] >>> k = 2 >>> A[1, :] = k * A[0, :] >>> print(A) [[-4 -1 2] [-8 -2 4] [ 8 3 1]] >>> round(np.linalg.det(A), 3) 0.0",
          "debug": {
            "start_page": 33,
            "end_page": 40
          }
        },
        {
          "name": "1.6 Обратная матрица 39",
          "content": "--- Страница 40 --- (продолжение)\n1.6 Обратная матрица Обратной матрицей матрицы называют матрицу, удовлетворяющую следующему равенству: , где - это единичная матрица. Для того, чтобы у квадратной матрицы была обратная матрица необходимо и достаточно чтобы определитель был не равен нулю. Введем понятие союзной матрицы . Союзная матрица строится на базе исходной путем замены всех элементов матрицы на их алгебраические дополнения. Исходная матрица: . Союзная ей матрица : . 39\n1.6 Обратная матрица Обратной матрицей матрицы называют матрицу, удовлетворяющую следующему равенству: , где - это единичная матрица. Для того, чтобы у квадратной матрицы была обратная матрица необходимо и достаточно чтобы определитель был не равен нулю. Введем понятие союзной матрицы . Союзная матрица строится на базе исходной путем замены всех элементов матрицы на их алгебраические дополнения. Исходная матрица: . Союзная ей матрица : . 39\n--- Страница 41 ---\nТранспонируя матрицу , мы получим так называемую присоединенную матрицу : . Теперь, зная как вычислять определитель и присоединенную матрицу, мы можем определить матрицу , обратную матрице : . ➣ Численный пример Пример вычисления обратной матрицы. Пусть дана исходная матрица , следующего вида: . Для начала найдем определитель матрицы : . Как видно из приведенных вычислений, определитель матрицы не равен нулю, значит у матрицы есть обратная. Построим присоединенную матрицу, для этого вычислим алгебраические дополнения для каждого элемента матрицы : , , , . Союзная матрица будет иметь следующий вид: . 40\n--- Страница 42 ---\nПрисоединенная матрица получается из союзной путем транспонирования: . Находим обратную матрицу: ➤ Пример на Python Решим задачу определения обратной матрицы на Python. Для получения обратной матрицы будем использовать функцию inv(): >>> A = np.matrix( '1 -3; 2 5') >>> A_inv = np.linalg.inv(A) >>> print(A_inv) [[ 0.45454545 0.27272727] [-0.18181818 0.09090909]] Рассмотрим свойства обратной матрицы. Свойство 1. Обратная матрица обратной матрицы есть исходная матрица: . ➤ Пример на Python >>> A = np.matrix( '1. -3.; 2. 5.') >>> A_inv = np.linalg.inv(A) >>> A_inv_inv = np.linalg.inv(A_inv) >>> print(A) [[1. -3.] [2. 5.]] >>> print(A_inv_inv) [[1. -3.] [2. 5.]] 41\n--- Страница 43 ---\nСвойство 2. Обратная матрица транспонированной матрицы равна транспонированной матрице от обратной матрицы: . ➤ Пример на Python >>> A = np.matrix( '1. -3.; 2. 5.') >>> L = np.linalg.inv(A.T) >>> R = (np.linalg.inv(A)).T >>> print(L) [[ 0.45454545 -0.18181818] [ 0.27272727 0.09090909]] >>> print(R) [[ 0.45454545 -0.18181818] [ 0.27272727 0.09090909]] Свойство 3. Обратная матрица произведения матриц равна произведению обратных матриц: . ➤ Пример на Python >>> A = np.matrix( '1. -3.; 2. 5.') >>> B = np.matrix( '7. 6.; 1. 8.') >>> L = np.linalg.inv(A.dot(B)) >>> R = np.linalg.inv(B).dot(np.linalg.inv(A)) >>> print(L) [[ 0.09454545 0.03272727] [-0.03454545 0.00727273]] >>> print(R) [[ 0.09454545 0.03272727] [-0.03454545 0.00727273]]",
          "debug": {
            "start_page": 40,
            "end_page": 43
          }
        },
        {
          "name": "1.7 Ранг матрицы 42",
          "content": "--- Страница 43 --- (продолжение)\n1.7 Ранг матрицы Ранг матрицы является еще одной важной численной характеристикой. Рангом называют максимальное число линейно независимых строк (столбцов) матрицы. Линейная независимость означает, что строки (столбцы) не могут быть линейно выражены через другие строки (столбцы). Ранг матрицы можно найти через ее миноры, он равен наибольшему порядку минора, который не равен нулю. Существование ранга у матрицы не зависит от того квадратная она или нет. 42\n1.7 Ранг матрицы Ранг матрицы является еще одной важной численной характеристикой. Рангом называют максимальное число линейно независимых строк (столбцов) матрицы. Линейная независимость означает, что строки (столбцы) не могут быть линейно выражены через другие строки (столбцы). Ранг матрицы можно найти через ее миноры, он равен наибольшему порядку минора, который не равен нулю. Существование ранга у матрицы не зависит от того квадратная она или нет. 42\n--- Страница 44 ---\nВычислим ранг матрицы с помощью Python. Создадим единичную матрицу: >>> m_eye = np.eye(4) >>> print(m_eye) [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.]] Ранг такой матрицы равен количеству ее столбцов (или строк), в нашем случае ранг будет равен четырем, для его вычисления на Python воспользуемся функцией matrix_rank(): >>> rank = np.linalg.matrix_rank(m_eye) >>> print(rank) 4 Если мы приравняем элемент в нижнем правом углу к нулю, то ранг станет равен трем: >>> m_eye[3][3] = 0 >>> print(m_eye) [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 0.]] >>> rank = np.linalg.matrix_rank(m_eye) >>> print(rank) 3 43",
          "debug": {
            "start_page": 43,
            "end_page": 44
          }
        }
      ]
    },
    {
      "name": "Глава 2. Решение систем линейных уравнений 44",
      "chapters": [
        {
          "name": "2.1 Решение неоднородной системы в матричной форме 44",
          "content": "--- Страница 45 --- (продолжение)\nГлава 2. Решение систем линейных уравнений Системой линейных уравнений называют совокупность уравнений следующего вида: . Решить такую систему - это значит найти чисел, при подстановке которых уравнение превращается в тождество. Если все , то такая система называется однородной. Если хотя бы одно не равно нулю, то система называется неоднородной. Если система имеет хотя бы одно решение, то она называется совместной, если решений нет, то несовместной. 2.1 Решение неоднородной системы в матричной форме Запишем неоднородную систему линейных уравнений в матричной форме, для этого выделим главную матрицу системы , которая состоит из коэффициентов перед неизвестными в левой части, матрицу столбец из элементов правой части и матрицу столбец из неизвестных . Главная матрица системы: . Матрица столбец из элементов правых частей: . 44\n2.1 Решение неоднородной системы в матричной форме Запишем неоднородную систему линейных уравнений в матричной форме, для этого выделим главную матрицу системы , которая состоит из коэффициентов перед неизвестными в левой части, матрицу столбец из элементов правой части и матрицу столбец из неизвестных . Главная матрица системы: . Матрица столбец из элементов правых частей: . 44\n--- Страница 46 ---\nМатрица столбец из неизвестных: . Используя правило умножения матриц, можно составить систему линейных уравнений в матричной форме: . Решить систему в матричной форме - это значит по известным матрицам и найти матрицу . Матрицу можно найти через умножение матрицы обратной матрице и матрицы : . Если к элементам главной матрицы системы добавить матрицу столбец из элементов правой части, то получим расширенную матрицу системы: . Если ранг расширенной матрицы равен рангу главной матрицы системы, то такая система уравнений будет совместной, в противном случае - несовместной. Совместная система имеет одно решение, если ее ранг равен числу неизвестных, если ранг меньше числа неизвестных, то число решений бесконечное множество. ➣ Численный пример Решим матричным методом следующую систему: . 45\n--- Страница 47 ---\nДля этого построим матрицы системы: . Найдем определитель матрицы : . Построим присоединенную матрицу для матрицы : . Обратная матрица имеет следующий вид: Найдем матрицу : . 46\n--- Страница 48 ---\nДля проверки полученного решения подставим его в исходные уравнения: . Как видно, найденное решение превратило уравнения в тождества, значит решение верное. Решим систему, используя предложенный метод на Python. ➤ Пример на Python >>> A = np.matrix( '3 -1 2; 1 4 -1; 2 3 1' ) >>> B = np.matrix( '-4; 10; 8') >>> print(A) [[3 -1 2] [1 4 -1] [2 3 1]] >>> print(B) [[-4] [10] [ 8]] >>> A_inv = np.linalg.inv(A) >>> print(A_inv) [[0.5 0.5 -0.5] [-0.21428571 -0.07142857 0.35714286] [-0.35714286 -0.78571429 0.92857143]] >>> X = A_inv.dot(B) >>> print(X) [[-1.] [ 3.] [ 1.]]",
          "debug": {
            "start_page": 45,
            "end_page": 48
          }
        },
        {
          "name": "2.2 Метод Крамера 47",
          "content": "--- Страница 48 --- (продолжение)\n2.2 Метод Крамера Метод Крамера можно использовать для решения неоднородных систем линейных уравнений, при этом определитель главной матрицы системы должен быть отличен от нуля . Полученное данным методом решение будет единственным. Построим матрицы , которые получаются из главной матрицы системы путем замены столбца с индексом на матрицу-столбец правых частей. 47\n2.2 Метод Крамера Метод Крамера можно использовать для решения неоднородных систем линейных уравнений, при этом определитель главной матрицы системы должен быть отличен от нуля . Полученное данным методом решение будет единственным. Построим матрицы , которые получаются из главной матрицы системы путем замены столбца с индексом на матрицу-столбец правых частей. 47\n--- Страница 49 ---\nИсходные данные. Главная матрица системы: . Матрица столбец из элементов правых частей: . Матрицы будут выглядеть так: . Неизвестные вычисляются с помощью формул Крамера: , , , где - это определитель главной матрицы системы; - определитель матрицы , полученный из главной путем замены -го столбца на матрицу . 48\n--- Страница 50 ---\nРешим систему линейных уравнений из раздела про матричный метод, но в данном случае, методом Крамера. ➣ Численный пример Дана система уравнений: . Матрицы системы имею вид: . Найдем определитель матрицы А: . Формулы Крамера для поиска неизвестных , и будут выглядеть так: , , . Найдем определители матриц , , : , , . 49\n--- Страница 51 ---\nНайдем численные значения неизвестных: , , . Полученное решение совпадает с тем, что было найдено в предыдущем разделе. ➤ Пример на Python Решим систему методом Крамера на Python: >>> A = np.matrix( '3 -1 2; 1 4 -1; 2 3 1' ) >>> print(A) [[ 3 -1 2] [ 1 4 -1] [ 2 3 1]] >>> B = np.matrix( '-4; 10; 8') >>> print(B) [[-4] [10] [ 8]] >>> A_det = np.linalg.det(A) >>> print(A_det) 14.0 >>> X_m = np.matrix(A) >>> X_m[:, 0] = B >>> print(X_m) [[-4 -1 2] [10 4 -1] [ 8 3 1]] >>> Y_m = np.matrix(A) >>> Y_m[:, 1] = B >>> print(Y_m) [[ 3 -4 2] [ 1 10 -1] [ 2 8 1]] 50\n--- Страница 52 ---\n>>> Z_m = np.matrix(A) >>> Z_m[:, 2] = B >>> print(Z_m) [[ 3 -1 -4] [ 1 4 10] [ 2 3 8]] >>> x = np.linalg.det(X_m) / A_det >>> y = np.linalg.det(Y_m) / A_det >>> z = np.linalg.det(Z_m) / A_det >>> print(x) -1.0 >>> print(y) 3.0 >>> print(z) 1.0",
          "debug": {
            "start_page": 48,
            "end_page": 52
          }
        },
        {
          "name": "2.3 Метод Гаусса 51",
          "content": "--- Страница 52 --- (продолжение)\n2.3 Метод Гаусса Метод Гаусса отличается от рассмотренных нами выше, он более удобен при ручном решении систем линейных уравнений. Суть его заключается в том, что мы приводим систему уравнений к ступенчатому виду, в идеале, у нас из системы вида1: , должна получиться следующая система: . Из нее, последовательно выражая неизвестные, получим их численные значения. ➣ Численный пример Рассмотрим работу метода Гаусса на уже знакомой нам системе уравнений: . 1Количество неизвестных необязательно должно совпадать с числом уравнений в системе 51\n2.3 Метод Гаусса Метод Гаусса отличается от рассмотренных нами выше, он более удобен при ручном решении систем линейных уравнений. Суть его заключается в том, что мы приводим систему уравнений к ступенчатому виду, в идеале, у нас из системы вида1: , должна получиться следующая система: . Из нее, последовательно выражая неизвестные, получим их численные значения. ➣ Численный пример Рассмотрим работу метода Гаусса на уже знакомой нам системе уравнений: . 1Количество неизвестных необязательно должно совпадать с числом уравнений в системе 51\n--- Страница 53 ---\nДля начала поменяем строки 1 и 3 местами: . Разделим первую строку на 2 и вычтем из нее вторую строку, после этого умножим первую строку на 3/2 и вычтем из нее третью строку, полученные уравнения подставляем во вторую и третью строку соответственно: Умножим вторую строку на (-11/5) и вычтем из нее третью строку: Из полученной системы мы может определить значение неизвестной : . Подставляя во второе уравнение, получим значение : . Теперь мы можем вычислить : . Полученные значение совпадают с решением из предыдущих разделов. 52",
          "debug": {
            "start_page": 52,
            "end_page": 53
          }
        },
        {
          "name": "2.4 Решение системы линейных уравнений на Python 53",
          "content": "--- Страница 54 --- (продолжение)\n2.4 Решение системы линейных уравнений на Python Отдельно рассмотрим инструмент, который предоставляет Numpy для решения систем линейных уравнений. Создадим матрицы, так, как это было сделано в разделе 2.1 “Решение неоднородной системы в матричной форме” : >>> A = np.matrix( '3 -1 2; 1 4 -1; 2 3 1' ) >>> B = np.matrix( '-4; 10; 8') >>> print(A) [[ 3 -1 2] [ 1 4 -1] [ 2 3 1]] >>> print(B) [[-4] [10] [ 8]] Для решения системы воспользуемся методом solve() из пакета linalg: >>> X = np.linalg.solve(A, B) >>> print(X) [[-1.] [ 3.] [ 1.]] 53\n2.4 Решение системы линейных уравнений на Python Отдельно рассмотрим инструмент, который предоставляет Numpy для решения систем линейных уравнений. Создадим матрицы, так, как это было сделано в разделе 2.1 “Решение неоднородной системы в матричной форме” : >>> A = np.matrix( '3 -1 2; 1 4 -1; 2 3 1' ) >>> B = np.matrix( '-4; 10; 8') >>> print(A) [[ 3 -1 2] [ 1 4 -1] [ 2 3 1]] >>> print(B) [[-4] [10] [ 8]] Для решения системы воспользуемся методом solve() из пакета linalg: >>> X = np.linalg.solve(A, B) >>> print(X) [[-1.] [ 3.] [ 1.]] 53",
          "debug": {
            "start_page": 54,
            "end_page": 54
          }
        }
      ]
    },
    {
      "name": "Глава 3. Основы векторной алгебры 54",
      "chapters": [
        {
          "name": "3.1 Векторные и скалярные величины 54",
          "content": "--- Страница 55 --- (продолжение)\nГлава 3. Основы векторной алгебры 3.1 Векторные и скалярные величины В рамках геометрической интерпретации под вектором понимается направленный отрезок прямой, характеризуемый длиной и направлением (см. рисунок 3.1). Если вектор рассматривать как алгебраический объект, то он может быть представлен в виде строки или столбца чисел, то есть в виде матрицы размера (1, n) либо (n, 1)2. Связь между геометрическим и алгебраическим представлением более подробно раскрыта в разделе 3.3 “Координаты вектора” . Рисунок 3.1 - Графическое представление вектора Геометрическая интерпретация позволяет проще воспринимать понятие вектора, она также удобна при решении задач из курса физики. Далее мы будем обращаться к геометрическому представлению с целью визуализации и более глубокого интуитивного понимания рассматриваемого вопроса. В физике и технических дисциплинах (механика, электротехника и т.п.) р азличают скалярные и векторные величины. Скалярной называется величина, которая характеризуется только числовым значением. Векторной называется величина, которая характеризуется числовым значением и направлением. Вектор будем обозначать одной маленькой латинской буквой полужирного начертания, вот так: , либо двумя большими латинскими буквами, первая обозначает точку начала, вторая - конц вектора: . Длина вектора (эту величину еще называют м одуль вектора) изображается так: . 2Для обозначения размерности вектора удобно использовать запись (1, n) вместо 1xn 54\n3.1 Векторные и скалярные величины В рамках геометрической интерпретации под вектором понимается направленный отрезок прямой, характеризуемый длиной и направлением (см. рисунок 3.1). Если вектор рассматривать как алгебраический объект, то он может быть представлен в виде строки или столбца чисел, то есть в виде матрицы размера (1, n) либо (n, 1)2. Связь между геометрическим и алгебраическим представлением более подробно раскрыта в разделе 3.3 “Координаты вектора” . Рисунок 3.1 - Графическое представление вектора Геометрическая интерпретация позволяет проще воспринимать понятие вектора, она также удобна при решении задач из курса физики. Далее мы будем обращаться к геометрическому представлению с целью визуализации и более глубокого интуитивного понимания рассматриваемого вопроса. В физике и технических дисциплинах (механика, электротехника и т.п.) р азличают скалярные и векторные величины. Скалярной называется величина, которая характеризуется только числовым значением. Векторной называется величина, которая характеризуется числовым значением и направлением. Вектор будем обозначать одной маленькой латинской буквой полужирного начертания, вот так: , либо двумя большими латинскими буквами, первая обозначает точку начала, вторая - конц вектора: . Длина вектора (эту величину еще называют м одуль вектора) изображается так: . 2Для обозначения размерности вектора удобно использовать запись (1, n) вместо 1xn 54",
          "debug": {
            "start_page": 55,
            "end_page": 55
          }
        },
        {
          "name": "3.2 Проекция вектора на ось 55",
          "content": "3.2 Проекция вектора на ось Проекция вектора на ось равна произведению модуля вектора на косинус угла между вектором и осью. Рассмотрим вектор и ось . Проекцией вектора на ось будет произведение и косинуса угла между вектором и осью (см. рисунок 3.2) . Рисунок 3.2 - Проекция вектора на ось В виде формулы это можно записать так:",
          "debug": {
            "start_page": 56,
            "end_page": 56
          }
        },
        {
          "name": "3.3 Координаты вектора 55",
          "content": "--- Страница 56 --- (продолжение)\n3.2 Проекция вектора на ось Проекция вектора на ось равна произведению модуля вектора на косинус угла между вектором и осью. Рассмотрим вектор и ось . Проекцией вектора на ось будет произведение и косинуса угла между вектором и осью (см. рисунок 3.2) . Рисунок 3.2 - Проекция вектора на ось В виде формулы это можно записать так: 3.3 Координаты вектора Координатами вектора называют его проекции на оси координат: , , , . Если известны координаты начальной и конечной точки, то координаты вектора определяются следующим образом: , , . 55\n3.3 Координаты вектора Координатами вектора называют его проекции на оси координат: , , , . Если известны координаты начальной и конечной точки, то координаты вектора определяются следующим образом: , , . 55\n--- Страница 57 ---\nРисунок 3.3 Проекция вектора на оси координат ➣ Численный пример Рассмотрим вектор , у которого начальная точка имеет координаты , конечная - . Тогда вектор , выраженный через координаты проекций на оси координат будет выглядеть так: , , . ➤ Пример на Python Теперь решим эту задачу на языке Python. Как уже было сказано выше, вектор может быть задан через координаты его начала и конца, в Python для этого будем использовать Numpy массивы. Зададим эти точки в виде переменных: >>> A = np.array([1, 2, 3]) >>> print(A) [1 2 3] >>> B = np.array([3, 5, 2]) >>> print(B) [3 5 2] >>> AB = B - A >>> print(AB) [ 2 3 -1] 56\n--- Страница 58 ---\n3.4 Модуль вектора и его направление в пространстве Модулем вектора называется величина, равная квадратному корню из суммы квадратов его координат: , . Направление вектора определяется косинусами углов между вектором и осями координат: α - угол между вектором и осью . β - угол между вектором и осью . γ - угол между вектором и осью . Направляющие векторы рассчитываются по следующим формулам: , , . ➣ Численный пример Для демонстрации будем использовать вектор из раздела про координаты вектора: . Найдем его модуль: . Теперь мы можем вычислить направляющие косинусы: , , . 57\n--- Страница 59 ---\n➤ Пример на Python Для вычисления модуля вектора будем использовать функцию norm() из библиотеки numpy.linalg: >>> AB=np.array([6, 7, 2]) >>> module_AB=np.linalg.norm(AB) >>> print(module_AB) 9.433981132056603 Напишем функции для вычисления косинусов: >>> cos_x = lambda a: a[0] / np.linalg.norm(a) >>> cos_y = lambda a: a[1] / np.linalg.norm(a) >>> cos_z = lambda a: a[2] / np.linalg.norm(a) >>> cos_x(AB) 0.6359987280038161 >>> cos_y(AB) 0.741998516004452 >>> cos_z(AB) 0.211999576001272 Для того, чтобы получить значения косинусов в виде списка составим следующую функцию: >>> vect_cos = lambda a: [a[i] / np.linalg.norm(a) for i in range(len(a))] >>> vect_cos(AB) [0.6359987280038161, 0.741998516004452, 0.211999576001272]",
          "debug": {
            "start_page": 56,
            "end_page": 59
          }
        },
        {
          "name": "3.4 Операции над векторами 58",
          "content": "--- Страница 59 --- (продолжение)\n3.4 Операции над векторами 3.4.1 Сложение векторов Геометрическое представление векторов прекрасно подходит для иллюстрации правила параллелограмма для сложения векторов (см. рисунок 3.4). Рисунок 3.4 - Сложение векторов. Правило параллелограмма 58\n3.4 Операции над векторами 3.4.1 Сложение векторов Геометрическое представление векторов прекрасно подходит для иллюстрации правила параллелограмма для сложения векторов (см. рисунок 3.4). Рисунок 3.4 - Сложение векторов. Правило параллелограмма 58\n--- Страница 60 ---\nСуть в том, что от конца первого вектора откладыва ется второй, а от конца второго - первый, в полученном на этих векторах параллелограмме проводится диагональ, которая и будет является результирующим вектором. Это правило можно упростить: достаточно отложить от конца первого вектора второй и соединить начало первого и конец второго, такой подход называется правилом треугольника (иллюстрация приведена на рисунке 3.5). Рисунок 3.5 - Сложение векторов. Правило треугольника Если рассматривать вектора в алгебраической форме - через численные значения их проекций, то при суммировании векторов, мы получаем вектор, проекции которого равны сумме проекций слагаемых векторов. Для двумерного вектора это будет выглядеть так: если у нас есть два вектора: , . Вектор суммы данных векторов будет таким: . ➣ Численный пример Рассмотрим сложение векторов на примере. Пусть нам даны следующие вектора: , . Вычислим вектор суммы: . 59\n--- Страница 61 ---\nНа рисунке 3.6 представлено суммирование векторов по правилу треугольника. Рисунок 3.6 - Пример использования правила треугольника для сложения векторов ➤ Пример на Python На Python задача суммирования векторов сводится к получению суммы соответствующих массивов: >>> a = np.array([2, 1]) >>> b = np.array([1, 3]) >>> c = a + b >>> print(c) [3 4] 3.4.2 Вычитание векторов Для вычитания векторов также существует свое правило треугольника . Графический вид этого правила представлен на рисунке 3.7. Рисунок 3.7 - Вычитание векторов. Правило треугольника При вычитании, результирующий вектор выходит из конца второго вектора в конец первого вектора. Для двумерного случая с векторами: , . 60\n--- Страница 62 ---\nВектор разности определяется так: . ➣ Численный пример В качестве исходных возьмем вектора из примера про сложение: , . Найдем разность вектора и : . Иллюстрация примера приведена на рисунке 3.8. Рисунок 3.8 - Вычитание векторов. Пример ➤ Пример на Python >>> a = np.array([2, 1]) >>> b = np.array([1, 3]) >>> c = b - a >>> print(c) [-1 2] 3.4.3 Умножение вектора на число При умножении вектора на число , все компоненты вектора умножаются на это число. Графически умножение вектора на число показано на рисунке 3.9. Рисунок 3.9 - Умножение вектора на число 61\n--- Страница 63 ---\nЗапишем алгебраическую формулу для данной операции : , . ➣ Численный пример Умножим вектор с координатами (2, 1) на число 2. , . Рисунок 3.10 - Пример умножения вектора на число ➤ Пример на Python >>> a = np.array([2, 1]) >>> k = 2 >>> c = k * a >>> print(c) [4 2] 3.4.4 Скалярное произведение двух векторов Скалярным произведением двух векторов и называется число, равное произведению модулей этих векторов на косинус угла между ними: . Скалярное произведение можно выразить через координаты векторов: , , . 62\n--- Страница 64 ---\nЕсли транспонировать один из векторов, то скалярное произведение можно выразить через операцию умножения матриц: . ➣ Численный пример Даны два вектора и : , . Найдем их скалярное произведение: . ➤ Пример на Python Найдем скалярное произведение векторов: >>> a = np.array([2, 7, 3]) >>> b = np.array([5, 9, 3]) >>> ab_scal = a.dot(b. T) >>> ab_scal 82 3.4.5 Векторное произведение двух векторов Векторным произведение двух векторов и называется третий вектор , который удовлетворяет следующим условиям: 1.Вектор перпендикулярен векторам и . 2.Модуль вектора определяется по формуле: . 3.Вектора , и образуют правую тройку векторов3. Векторное произведение также можно выразить через координаты перемножаемых векторов: , , 3https://bit.ly/2uMXVxr 63\n--- Страница 65 ---\n. Векторное произведение равно определителю матрицы , составленной из единичных орт-векторов и проекций векторов и на данные орт-векторы. ➣ Численный пример Для численного примера возьмем уже знакомые нам вектора и : , . Найдем их модули: , . Зная значение скалярного произведения из предыдущего параграфа, определим косинус угла между этими векторами: . Синус угла можно вычислить следующим образом: . Рассчитаем модуль векторного произведения: . Получим векторное произведение, выраженное через координаты векторов. . 64\n--- Страница 66 ---\n➤ Пример на Python Решим задачу векторного умножения на Python, для начала определимся с модулем. Будем работать с векторами из раздела про скалярное произведение: >>> a = np.array([2, 7, 3]) >>> b = np.array([5, 9, 3]) Найдем косинус угла между векторами. Это можно сделать двумя способами: - предварительно реализовав соответствующую формулу: >>> vect_cos = lambda a, b: a.T.dot(b) / (np.linalg.norm(a) * np.linalg.norm(b)) - воспользоваться уже готовой формулой из scipy, которая вычисляет косинусное расстояние: >>> vect_cos(a, b) 0.9711114784134267 Используя полученную функцию, найдем синус угла между векторами: >>> vect_sin = lambda a, b: (1 - vect_cos(a, b)**2)**0.5 >>> vect_sin(a, b) 0.23862626949623264 Теперь у нас есть все данные, чтобы построить формулу для модуля векторного произведения: >>> prod_vect = lambda a, b: np.linalg.norm(a)*np.linalg.norm(b)*vect_sin(a, b) >>> prod_vect(a, b) 20.149441679609886 3.4.6 Смешанное произведение трех векторов Смешанное произведение трех векторов (его еще называют векторно-скалярн ым) определяется так: два вектора умножаются векторно, после этого, полученное произведение необходимо умножить на третий вектор скалярно. Рассмотрим три вектора , и : , , . 65\n--- Страница 67 ---\nСмешанное произведение будет выглядеть так: . ➤ Пример на Python Для нахождения смешанного произведения с использованием Python воспользуемся знаниями из раздела про определители матриц: >>> a = [2, 7, 3] >>> b = [5, 9, 3] >>> c = [7, 4, 5] >>> vmp = np.matrix([a, b, c]) >>> np.linalg.det(vmp) -90.999999999999972 66",
          "debug": {
            "start_page": 59,
            "end_page": 67
          }
        }
      ]
    },
    {
      "name": "Глава 4. Линейные векторные пространства 67",
      "chapters": [
        {
          "name": "4.1 Общие сведения 67",
          "content": "--- Страница 68 --- (продолжение)\nГлава 4. Линейные векторные пространства 4.1 Общие сведения Введем понятие линейного пространства . Рассмотрим такое множество , на котором определена операция сложения элементов из этого множества и умножение элемента множества на некоторое число. Здесь и далее под числом будем понимать число из множества действительных чисел . При этом элемент, полученный в результате указанного выше сложения или умножения на число, также принадлежит множеству . Если множество обладает ниже перечисленными свойствами (их называют аксиомами линейного пространства ), то такое множество называется линейным пространством . Если элементами такого линейного пространства являются векторы, то такое пространство называется линейным векторным пространством . В рамках данной главы под вектором будем понимать строку или столбце чисел. Свойство 1. Сложение элементов линейного пространства коммутативно. От перестановки слагаемых сумма не изменяется: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1,2]]).T >>> b = np.array([[3,4]]).T >>> L = a + b >>> R = b + a >>> print(L) [[4] [6]] >>> print(R) [[4] [6]] 67\n4.1 Общие сведения Введем понятие линейного пространства . Рассмотрим такое множество , на котором определена операция сложения элементов из этого множества и умножение элемента множества на некоторое число. Здесь и далее под числом будем понимать число из множества действительных чисел . При этом элемент, полученный в результате указанного выше сложения или умножения на число, также принадлежит множеству . Если множество обладает ниже перечисленными свойствами (их называют аксиомами линейного пространства ), то такое множество называется линейным пространством . Если элементами такого линейного пространства являются векторы, то такое пространство называется линейным векторным пространством . В рамках данной главы под вектором будем понимать строку или столбце чисел. Свойство 1. Сложение элементов линейного пространства коммутативно. От перестановки слагаемых сумма не изменяется: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1,2]]).T >>> b = np.array([[3,4]]).T >>> L = a + b >>> R = b + a >>> print(L) [[4] [6]] >>> print(R) [[4] [6]] 67\n--- Страница 69 ---\nСвойство 2. Сложение элементов линейного пространства ассоциативно. Результат суммирования ряда элементов не зависит от порядка суммирования: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1,2]]).T >>> b = np.array([[3,4]]).T >>> c = np.array([[5,6]]).T >>> L = a +(b + c) >>> R = a + b)+ c >>> print(L) [[ 9] [12]] >>> print(R) [[ 9] [12]] Свойство 3. Множество содержит нулевой элемент, для которого справедливо следующее: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1,2]]).T >>> z = np.array([[0,0]]).T >>> L = a + z >>> R = a >>> print(L) [[1] [2]] >>> print(R) [[1] [2]] 68\n--- Страница 70 ---\nСвойство 4. В множестве для любого элемента существует обратный ему элемент: если - это элемент множества , то - является обратным элементом для , и он также содержится в множестве . При этом выполняется равенство: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1,2]]).T >>> m_a = np.array([[-1,-2]]).T >>> z = np.array([[0,0]]).T >>> L = a + m_a >>> R = z >>> print(L) [[0] [0]] >>> print(R) [[0] [0]] Свойство 5. Произведение суммы элементов из множества на число равно сумме произведений этого числа на данные элементы: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1, 2]]).T >>> b = np.array([[3, 4]]).T >>> k = 2 >>> L = k * (a + b) >>> R = k * a + k * b >>> print(L) [[ 8] [12]] 69\n--- Страница 71 ---\n>>> print(R) [[ 8] [12]] Свойство 6. Произведение суммы чисел на элемент множества равно сумме произведений элемента на заданные числа: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1, 2]]).T >>> p = 2 >>> q = 3 >>> L = (p + q) * a >>> R = p * a + q * a >>> print(L) [[ 5] [10]] >>> print(R) [[ 5] [10]] Свойство 7. Произведение чисел, умноженное на элемент из множества , равно произведению одного из чисел и элемента, умноженно го на другое число: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1, 2]]).T >>> p = 2 >>> q = 3 >>> L = (p * q) * a 70\n--- Страница 72 ---\n>>> R = p *(q * a) >>> print(L) [[ 6] [12]] >>> print(R) [[ 6] [12]] Свойство 8. Множество содержит единичный элемент, для которого справедливо следующее равенство: . ➣ Численный пример . ➤ Пример на Python >>> a = np.array([[1, 2]]).T >>> k = 1 >>> L = k * a >>> R = a >>> print(L) [[1] [2]] >>> print(R) [[1] [2]]",
          "debug": {
            "start_page": 68,
            "end_page": 72
          }
        },
        {
          "name": "4.2 Линейная зависимость векторов 71",
          "content": "--- Страница 72 --- (продолжение)\n4.2 Линейная зависимость векторов Рассмотрим очень важную тему, которая имеет огромное практическое значение - линейная зависимость векторов . Пусть у нас есть система векторов , как вы помните, каждый вектор представляет собой строку или столбец чисел . Составим следующее равенство: . 71\n4.2 Линейная зависимость векторов Рассмотрим очень важную тему, которая имеет огромное практическое значение - линейная зависимость векторов . Пусть у нас есть система векторов , как вы помните, каждый вектор представляет собой строку или столбец чисел . Составим следующее равенство: . 71\n--- Страница 73 ---\nЕсли такое равенство выполняется при , , …, не все из которых равны нулю, то такая система векторов называется линейно зависимой . Вектор , который может быть представлен как сумма произведений векторов на числа, называется линейной комбинацией векторов : . Для того, чтобы определить является ли заданная система векторов линейно зависимой, необходимо разложить вектора на компоненты и составить соответствующую систему уравнений, если она имеет ненулевое решение, то такая система векторов линейно зависима. ➣ Численный пример Пусть дана следующая система векторов: , , . Необходимо определить является ли она линейно зависимой. Составим систему уравнений: . Полученная система является однородной. Для того, чтобы она имела единственное (нулевое) решение, необходимо, чтобы ее ранг совпадал с числом неизвестных. Ранг главной матрицы системы равен двум, а число неизвестных - три, следовательно система уравнений имеет как минимум одно ненулевое решение, это означает, что система векторов зависима. В случае, когда число уравнений равно числу неизвестных, для определения числа решений можно ориентироваться на определитель главной матрицы системы. Если он равен нулю, то система имеет бесконечное множество решений, если отличен от 72\n--- Страница 74 ---\nнуля, то она имеет одно (нулевое) решение. Определитель главной матрицы нашей системы равен нулю, что еще раз подтверждает вывод о том, что заданная система векторов линейно зависима. ➤ Пример на Python Приведем необходимые вычисления на Python: >>> A = np.matrix('1 -1 2; 1 3 2; -2 1 -4') >>> np.linalg.det(A) 0.0 >>> np.linalg.matrix_rank(A) 2",
          "debug": {
            "start_page": 72,
            "end_page": 74
          }
        },
        {
          "name": "4.3 Базис системы векторов 73",
          "content": "--- Страница 74 --- (продолжение)\n4.3 Базис системы векторов У системы векторов можно выделить максимальную линейно независимую подсистему, которая характеризуется тем, что если в нее добавить еще один вектор (из данной системы), то она станет линейно зависимой. Из приведенного в разделе 4.2 примере, максимальная линейно независимая система векторов выглядит так: , либо так: . При этом, добавление к любой из данных подсистем вектора из заданной системы приведет к тому, что полученная система будет линейно зависимой. Для заданной конечной линейной системы векторов базисом называется любая ее максимальная линейно независимая подсистема, а число векторов в базисе называется рангом системы векторов. Если вы, по заданным векторам, построите матрицу, то ее ранг будет равен рангу базиса исходной системы векторов. Базис конечной линейной системы - это такой набор векторов, через который может быть выражен любой вектор системы. Другими словами, любой вектор из линейной системы является линейной комбинацией векторов базиса. 73\n4.3 Базис системы векторов У системы векторов можно выделить максимальную линейно независимую подсистему, которая характеризуется тем, что если в нее добавить еще один вектор (из данной системы), то она станет линейно зависимой. Из приведенного в разделе 4.2 примере, максимальная линейно независимая система векторов выглядит так: , либо так: . При этом, добавление к любой из данных подсистем вектора из заданной системы приведет к тому, что полученная система будет линейно зависимой. Для заданной конечной линейной системы векторов базисом называется любая ее максимальная линейно независимая подсистема, а число векторов в базисе называется рангом системы векторов. Если вы, по заданным векторам, построите матрицу, то ее ранг будет равен рангу базиса исходной системы векторов. Базис конечной линейной системы - это такой набор векторов, через который может быть выражен любой вектор системы. Другими словами, любой вектор из линейной системы является линейной комбинацией векторов базиса. 73\n--- Страница 75 ---\nДля линейного пространства векторов, так же как и для системы, существует понятие базиса. Базис линейного пространства - это упорядоченная независимая система векторов, через которую может быть выражен любой вектор этого пространства. Количество векторов в базисе называется размерностью пространства. Число различных базисов линейного пространства бесконечно. Когда мы говорим, что пространство трехмерно - это значит, что его базис состоит из трех векторов, и любая точка (вектор) пространства может быть определена через вектора базиса. Чаще всего, на практике, приходится встречаться с естественным базисом . Выглядит он так: , , …, . Через естественный базис очень просто выразить любой вектор данного линейного пространства. В этом случае, координаты вектора будут коэффициентами соответствующей линейной комбинации. Рассмотрим вектор: . Построим его линейную комбинацию, выраженную через естественный базис: . Необходимо отметить, что такое представление единственно. Как было отмечено ранее, количество базисов линейного пространства бесконечно, это значит, что помимо естественного базиса существуют еще и другие. Все базисы линейного пространства связаны между собой. Мы можем переходить от одного базиса к другому при необходимости. Разберем этот вопрос более подробно. 74\n--- Страница 76 ---\nВыделим в нашем линейном пространстве два базиса: , . Так как каждый вектор пространства может быть выражен через вектора базиса, то выразим каждый вектор через вектора , получим следующую систему: . Тот же результат мы получим если выполним матричное умножение: , где и - это заданные выше вектора, а - это матрица перехода, которая имеет следующий вид: . ➣ Численный пример В параграфе “3.5.5 Векторное произведение двух векторов ”, был рассмотрен следующий численный пример: . Векторы , , , в данном случае являются естественным базисом трехмерного пространства, они имеют координаты: , , . Эти вектора также называют орт-векторами. 75",
          "debug": {
            "start_page": 74,
            "end_page": 76
          }
        },
        {
          "name": "4.4 Линейные операторы 76",
          "content": "--- Страница 77 --- (продолжение)\n4.4 Линейные операторы Для более интуитивного понимания данной темы, операторы, или как их еще называют отображения, можно воспринимать как функции особого вида. Оператор ставит в соответстви е вектору из линейного пространства некоторый вектор из линейного пространства . На языке математики это можно записать так: . Оператор называется линейным, если для него выполняются следующие равенства: , , где и - это векторы из линейного пространства ; , - векторы из линейного пространства ; - число из множества действительных чисел . Из раздела про базис системы векторов, вы наверное помните, что можно переходить от одного базиса к другому, умножая первый на специальную матрицу перехода. Для того чтобы задать линейный оператор , который переводит вектор из линейного пространства с базисом в линейное пространство с базисом достаточно задать образы , которые переводят базис в базис . Вектор , если его представить в виде линейной комбинации векторов базиса, будет выглядеть так: . Тогда отображение вектора в векторное пространство будет представлено следующим образом: . 76\n4.4 Линейные операторы Для более интуитивного понимания данной темы, операторы, или как их еще называют отображения, можно воспринимать как функции особого вида. Оператор ставит в соответстви е вектору из линейного пространства некоторый вектор из линейного пространства . На языке математики это можно записать так: . Оператор называется линейным, если для него выполняются следующие равенства: , , где и - это векторы из линейного пространства ; , - векторы из линейного пространства ; - число из множества действительных чисел . Из раздела про базис системы векторов, вы наверное помните, что можно переходить от одного базиса к другому, умножая первый на специальную матрицу перехода. Для того чтобы задать линейный оператор , который переводит вектор из линейного пространства с базисом в линейное пространство с базисом достаточно задать образы , которые переводят базис в базис . Вектор , если его представить в виде линейной комбинации векторов базиса, будет выглядеть так: . Тогда отображение вектора в векторное пространство будет представлено следующим образом: . 76\n--- Страница 78 ---\nОтображение векторов базиса линейного пространства в вектора базиса линейного пространства мы уже знаем как строить: , . Матрица называется матрицей линейного оператора . В отличии от матрицы перехода, которая является квадратной, матрица линейного оператора определяется размерностью пространств, которые связывает данный оператор. В дальнейшем для нас будут представлять интерес линейные операторы, которые отображают линейное пространство само на себя - случай, когда . Матрицы таких операторов квадратные. ➣ Численный пример Рассмотрим на примере как действует линейный оператор в линейном векторном пространстве. Пусть нам дано двумерное векторное пространство и линейный оператор , действующий в нем. Матрица линейного оператора имеет вид: . Найдем координаты вектора, в который будет переведен с помощью оператора вектор , . . 77\n--- Страница 79 ---\n➤ Пример на Python На Python эта задача решается довольно просто. Для того, чтобы решение было более красивым создадим специальную функцию, которая будет реализовывать данное отображение: >>> f = lambda x: np.dot(np.array([[1, 2], [0, 1]]), x. T) >>> x = np.array([1, 2]) >>> x_ = f(x) >>> print(x_) [5 2] Таким образом получаем, что для того, чтобы выполнить определенные преобразования с вектором необходимо умножить его матрицу линейного оператора. Состав матрицы определяет вид преобразования: отражение, изменение масштаба, поворот и т.п. Рассмотрим на примерах различные виды преобразований. 4.4.1 Отражение вектора в себя Начнем с самого простого линейного оператора, который переводит вектор в себя. Рисунок 4.1 - Отражение вектора в себя ➣ Численный пример Здесь и далее будем работать с вектором: . Матрица линейного оператора, отражающая вектор в самого себя, имеет следующий вид: . 78\n--- Страница 80 ---\nВычислим результат применения заданного линейного оператора: . ➤ Пример на Python Создадим вектор и матрицу линейного оператора: >>> x = np.array([2, 1]) >>> A = np.array([[1, 0], [0, 1]]) >>> print(A) [[1 0] [0 1]] Создадим функцию , которая будет реализовывать линейное отражение. Эту функцию будем использовать в следующих примерах: >>> f = lambda A, x: np.dot(A, x. T) Выполним линейное преобразование: >>> f(A, x) array([2, 1]) Как вы можете видеть, результирующий вектор не изменился. 4.4.2 Масштабирование Матрица, выполняющая масштабирование вектора, имеет следующий вид: . В таком виде масштаб вектора будет изменен на заданный коэффициент по каждой из осей координат. 79\n--- Страница 81 ---\n, Рисунок 4.2 - Масштабирование вектора Если необходимо изменить масштаб только в выбранных направлениях, то задайте коэффициенты на нужных позициях главной диагонали, остальным присвойте значение 1. Например, для пространства с базисом для масштабирования по направлению вектора можно использовать следующую матрицу: . ➣ Численный пример Построим оператор увеличивающий координаты вектора в два раза, его матрица будет иметь вид: . Применим данный оператор к вектору: , . Рассмотрим другой пример, по оси абсцисс вектор уменьшим в два раза, а по оси ординат увеличим в три раза: . Тогда результат применения данного вектора к уже известному нам вектору будет выглядеть так: . 80\n--- Страница 82 ---\n➤ Пример на Python Выполним вычисления из приведенного выше численного примера: >>> x = np.array([2, 1]) >>> A_m1 = np.array([[2, 0], [0, 2]]) >>> f(A_m1, x) array([4, 2]) >>> A_m2 = np.array([[0.5, 0], [0, 3]]) >>> f(A_m2, x) array([1., 3.]) 4.4.3 Отражение Отражение относительно той или иной оси является востребованной операцией в прикладных задачах. Рассмотрим горизонтальное (относительно оси ординат) и вертикальное (относительно оси абсцисс) отражени е. 4.4.3.1 Горизонтальное отражение Оператор, выполняющий горизонтальное отражение, имеет следующую матрицу: . При умножении на такую матрицу вектор зеркально отражается относительно оси ординат (см. рисунок 4.3). , Рисунок 4.3 - Горизонтальное отражение вектора Рассмотрим численный и программный примеры, демонстрирующие работу данного оператора. 81\n--- Страница 83 ---\n➣ Численный пример Будем использовать введенную выше матрицу : . В качестве вектора возьмем уже знакомый нам: . Применим оператор с матрицей к вектору : . ➤ Пример на Python Решим эту задачу на Python: >>> z = np.array([2, 1]) >>> A_hor = np.array([[-1, 0], [0, 1]]) >>> f(A_hor, z) array([-2, 1]) 4.4.3.2 Вертикальное отражение Матрица оператора, выполняющего вертикальное отражение, выглядит следующим образом: . Графически данную операцию можно продемонстрировать так, как показано на рисунке 4.4. , Рисунок 4.4 - Горизонтальное отражение вектора 82\n--- Страница 84 ---\nПерейдем к примерам вертикального отражения. ➣ Численный пример Воспользуемся заданной матрицей : . Применим оператор с матрицей к вектору из предыдущего примера: . ➤ Пример на Python Напишем соответствующую программу на Python: >>> z = np.array([2, 1]) >>> A_vert = np.array([[1, 0], [0, -1]]) >>> f(A_vert, z) array([2, -1]) 4.4.4 Поворот Матрицы операторов, выполняющих поворот на заданный угол, имеют более интересное наполнение. Рассмотрим два линейных оператора: первый будет осуществлять поворот по часовой стрелке, второй - против. 4.4.4.1 По часовой стрелке Для поворота по часовой стрелке на угол используется оператор с матрицей следующего вида: . , Рисунок 4.5 - Поворот вектора по часовой стрелке 83\n--- Страница 85 ---\n➣ Численный пример Построим матрицу для оператора, поворачивающего вектор на 45 градусов: . В качестве аргумента буде м использовать вектор: . Применим оператор с матрицей к вектору : . ➤ Пример на Python Программа на Python с оператором вращения выглядит так: >>> import math >>> z = np.array([2, 1]) >>> A_rot_cl = np.array([[math.cos(math.pi/4), math.sin(math.pi/4)],[(- 1)*math.sin(math.pi/4), math.cos(math.pi/4)]]) >>> f(A_rot_cl, z) array([ 2.12132034, -0.70710678]) 4.4.4.2 Против часовой стрелке Для поворота против часовой стрелки на угол немного модифицируем матрицу из предыдущего параграфа. Рисунок 4.6 - Поворот вектора против часовой стрелки 84\n--- Страница 86 ---\n➣ Численный пример Построим матрицу для оператора, поворачивающего вектор на 60 градусов против часовой стрелки: . В качестве аргумента будет использовать вектор: . Применим оператор с матрицей к вектору : . ➤ Пример на Python Программа на Python с оператором вращения выглядит так: >>> import math >>> z = np.array([2, 1]) >>> A_rot_not_cl = np.array([[math.cos(math.pi/3), (-1)*math.sin(math.pi/3)], [math.sin(math.pi/3), math.cos(math.pi/3)]]) >>> f(A_rot_not_cl, z) array([0.1339746 , 2.23205081]) 4.4.5 Перемещение по осям Для решения задачи параллельного переноса векторов в трехмерном пространстве, нам понадобится матрица 3х3, следующего вида: . Если мы применим оператор с такой матрицей к вектору: . 85\n--- Страница 87 ---\nПолучим следующий результат: . , Рисунок 4.7 - Перенос вектора ➣ Численный пример Матрица, перемещающая вектор на единицу по оси абсцисс и на двойку по оси ординат, будет иметь следующий вид: . Построим вектор, который будет выступать аргументом нашего оператора: . Применим оператор с матрицей к вектору : . ➤ Пример на Python Программа на Python с оператором вращения выглядит так: >>> z = np.array([2,1,1]).T >>> A_mov = np.array([[1, 0, 1], [0, 1, 2], [0, 0, 1]]) >>> f(A_mov, z) array([3, 3, 1]) 86\n--- Страница 88 ---\n4.4.6 Эквивалентные преобразования применительно к СЛАУ В разделе 2.3 мы разбирали метод Гаусса для решения систем линейных алгебраических уравнений. Наша цель состояла приведении исходной системы уравнений к треугольному виду. Суть этой работы заключалась в том, что с исходной системой мы последовательно производили ряд преобразований, при этом система до и после этих преобразований имела одно и тоже решение. Такие преобразования называются эквивалентными . Различают три вида эквивалентных преобразований: 1.Перестановка двух уравнений в системе. 2.Умножение одного из уравнений системы на число, не равное нулю. 3.Прибавление одного уравнения к другому, умноженному на число. Применение эквивалентных преобразований удобно производить в матричном виде. Для начала проделаем это вручную. ➣ Численный пример Вернемся к численному примеру из раздела 2.3: необходимо решить систему линейных уравнений: . Построим расширенную матрицу системы: . Последовательно проделаем с этой системой ряд преобразований, в том же порядке, как это было сделано в разделе 2.3: . 87\n--- Страница 89 ---\nКаждое из эквивалентных преобразований можно представить как результат применения линейного оператора к заданной матрице. Рассмотрим матрицы, умножение на которые соответствует определенным эквивалентным преобразованиям. 1. Перестановка двух уравнений в системе. Данному преобразованию соответствует перестановка строк в расширенной матрице системы. Для того, чтобы произвести перестановку строк достаточно заданную матрицу размера (m, n) умножить на единичную матрицу размера (n, n), в которой будут переставлены соответствующие строки. 2. Умножение одного из уравнений системы на число, не равное нулю. Для выполнения такого преобразования необходимо расширенную матрицу системы умножить слева на матрицу, которая используется для масштабирования вектора по заданному направлению: . 3. Прибавление одного уравнения к другому, умноженному на число. Такое эквивалентное преобразование производится путем умножения соответствующей расширенной матрицы системы на матрицу следующего вида: . 88\n--- Страница 90 ---\n➣ Численный пример Построим и применим соответствующие матрицы для преобразования расширенной матрицы системы из предыдущего примера : . Матрица, выполняющ ая первое эквивалентное преобразование, меняет 1-ю и 3-ю строки, она имеет следующий вид: . Второе эквивалентное преобразование заключается в том, что мы вначале делим первую строку на 2 и вычитаем из нее вторую строку, после этого умножаем первую строку на 3/2 и вычитаем из нее третью строку. Этот набор операций можно произвести с помощью матрицы: . В рамках третьего преобразования мы умножаем вторую строку на (-11/5) и вычитаем из нее третью строку. Построим соответствующую матрицу: . Процесс построения треугольной матрицы будет выглядеть так: , . 89\n--- Страница 91 ---\n➤ Пример на Python Решим задачу на Python. Для начала создадим исходную расширенную матрицу системы: >>> A = np.array([[3, -1, 2, -4], [1, 4, -1, 10], [2, 3, 1, 8]]) >>> print(A) [[ 3 -1 2 -4] [ 1 4 -1 10] [ 2 3 1 8]] Теперь построим матрицы для выполнения эквивалентных преобразований: >>> R1 = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]]) >>> print(R1) [[0 0 1] [0 1 0] [1 0 0]] >>> R2 = np.array([[1, 0, 0], [0.5, -1, 0], [1.5, 0, -1]]) >>> print(R2) [[ 1. 0. 0. ] [ 0.5 -1. 0. ] [ 1.5 0. -1. ]] >>> R3 = np.array([[1, 0, 0], [0, 1, 0], [0, -2.2, -1]]) >>> print(R3) [[ 1. 0. 0. ] [ 0. 1. 0. ] [ 0. -2.2 -1. ]] Выполним необходимые матричные умножения: >>> R3.dot(R2.dot(R1.dot(A))) array([[ 2., 3., 1., 8.], [ 0., -2.5, 1.5, -6.], [ 0., 0., -2.8, -2.8]]) Как вы можете видеть результат совпадает с тем, что было получено при вычислении вручную. Если данный вопрос перевести на язык линейных операторов, то можно сделать следующее интересное наблюдение: задав умножение на соответствующую матрицу как линейное отображение, готовый результат мы можем получить через композицию 90\n--- Страница 92 ---\nлинейных операторов — то есть последовательное их применение к результату полученному на предыдущем этапе. Рассмотрим это на примере. Создадим три линейных оператора: >>> def f1(x): R1 = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]]) return R1.dot(x) >>> def f2(x): R2 = np.array([[1, 0, 0], [0.5, -1, 0], [1.5, 0, -1]]) return R2.dot(x) >>> def f3(x): R3 = np.array([[1, 0, 0], [0, 1, 0], [0, -2.2, -1]]) return R3.dot(x) Теперь применим их последовательно к заданной матрице: >>> f3(f2(f1(A))) array([[ 2. , 3. , 1. , 8. ], [ 0. , -2.5, 1.5, -6. ], [ 0. , 0. , -2.8, -2.8]])",
          "debug": {
            "start_page": 77,
            "end_page": 92
          }
        },
        {
          "name": "4.5 Собственные векторы линейного оператора 91",
          "content": "--- Страница 92 --- (продолжение)\n4.5 Собственные векторы линейного оператора 4.5.1 Характеристический полином матрицы Если из матрицы вычесть единичную матрицу , умноженную на некоторую переменную , то получим матрицу, которая называется характеристической матрицей матрицы : , . 91\n4.5 Собственные векторы линейного оператора 4.5.1 Характеристический полином матрицы Если из матрицы вычесть единичную матрицу , умноженную на некоторую переменную , то получим матрицу, которая называется характеристической матрицей матрицы : , . 91\n--- Страница 93 ---\nОпределитель такой матрицы будет полиномом -ой степени от и может рассматриваться как функция: . ➣ Численный пример Построим характеристическое уравнение для следующей матрицы: , . Решим полученное уравнение: , , , . ➤ Пример на Python Воспользуемся возможностями Python и библиотеки Numpy для вычисления корней характеристического уравнения матрицы: >>> A = np.matrix(\"1 4 1; 0 2 2 ; 0 0 3\") >>> A matrix([[1, 4, 1], [0, 2, 2], [0, 0, 3]]) >>> w, v = np.linalg.eig(A) >>> w array([1., 2., 3.]) 92\n--- Страница 94 ---\n4.5.2 Собственные векторы и собственные значения линейного оператора В самом начале раздела 4.4 мы ввели понятие линейного оператора. Если линейный оператор переводит некоторый вектор в вектор , то такой вектор называется собственным вектором оператора : . При этом называется собственным значением линейного оператора . Полученный вектор является коллинеарным, то есть он равен исходному вектору, умноженному на какое-то число. Собственными значениями линейного оператора могут быть только корни характеристического уравнения матрицы этого линейного оператора. При этом из корней следует выбирать только те, которые принадлежат полю над которым построено линейное пространство. То есть, если у нас элементы вектора - это действительные числа, то из всех собственных значений нужно выбрать те, которые являются действительными числами, а если есть комплексные, что возможно при решении уравнения, то их следует отбросить. Попробуем самостоятельно построить собственный вектор для заданного оператора. ➣ Численный пример Для простоты возьмем линейный оператор, работающий с векторами над полем действительных чисел, с матрицей : . Построим характеристическое уравнение матрицы: . 93\n--- Страница 95 ---\nНайдем корни характеристического уравнения: , , , . Из корней характеристического уравнения выбираем те, которые являются действительными числами ( так как элементы вектора, над которым работает линейный оператор, являются действительными числами). В нашем случае - это все полученные корни. Построим собственные вектора данного линейного оператора: , , , . Для первого корня характеристического уравнения собственный вектор будет иметь следующий вид: . Найдем собственный вектор для второго корня характеристического уравнения: , , , . 94\n--- Страница 96 ---\nСобственный вектор для имеет вид: . Собственные векторы и собственные значения линейного оператора имеют большое практическое значение, особенно в такой области как машинное обучение и анализ данных. Линейный оператор, воздействуя на собственный вектор, как мы только что узнали, изменяет лишь длину этого вектора, направление остается прежним. Другими словами, направление собственного вектора указывает на направление, в котором происходит максимальное изменение вектора, чаще всего это сжатие или растяжение. Представьте себе таблицу с данными, в которой столбцы - это различные признаки, изначально вы не знаете насколько эти признаки информативны, то есть насколько они хорошо описывают представленные данные. Найденные собственные вектора для нашей таблицы-матрицы выявляют те признаки, которые имеют для нас наибольшую ценность, это позволит сжать матрицу, сохранив максимум полезной информации. 95",
          "debug": {
            "start_page": 92,
            "end_page": 96
          }
        }
      ]
    },
    {
      "name": "Глава 5. Разложения матриц 96",
      "chapters": [
        {
          "name": "5.1 LU-разложение матрицы 96",
          "content": "--- Страница 97 --- (продолжение)\nГлава 5. Разложения матриц 5.1 LU-разложение матрицы -разложение используется для представления матрицы в виде произведения двух матриц: - нижней треугольной матрицы и - верхней треугольной матрицы: . У матрицы все элементы главной диагонали равны единице. Матрицу можно представить в виде -разложения, если все главные диагональные миноры не вырождены (отличны от нуля). Разложение такого типа используется для: •решения систем линейных уравнений; •вычисления обратной матрицы; •вычисления определителя. Рассмотрим численный пример -разложения. ➣ Численный пример Построим -разложение следующей матрицы: . Используя элементарные преобразования приведем ее к верхнему треугольному виду. Более подробно об этом можете прочитать в разделе “ 4.4.7 Эквивалентные преобразования применительно к СЛАУ ”: . 96\n5.1 LU-разложение матрицы -разложение используется для представления матрицы в виде произведения двух матриц: - нижней треугольной матрицы и - верхней треугольной матрицы: . У матрицы все элементы главной диагонали равны единице. Матрицу можно представить в виде -разложения, если все главные диагональные миноры не вырождены (отличны от нуля). Разложение такого типа используется для: •решения систем линейных уравнений; •вычисления обратной матрицы; •вычисления определителя. Рассмотрим численный пример -разложения. ➣ Численный пример Построим -разложение следующей матрицы: . Используя элементарные преобразования приведем ее к верхнему треугольному виду. Более подробно об этом можете прочитать в разделе “ 4.4.7 Эквивалентные преобразования применительно к СЛАУ ”: . 96\n--- Страница 98 ---\nЕсли произведение матриц, осуществляющих выполнение эквивалентных преобразований, мы выделим в отдельную матрицу и найдем от нее обратную, то это и будет искомая матрица : , , , . Проверим вычисления: . ➤ Пример на Python Проведем вычисления, аналогичные тем, что были проделаны в численном примере, на языке Python: >>> A = np.array([[4, 1, 3], [8, 1, 8], [-12, -4, -6]]) >>> A array([[ 4, 1, 3], [ 8, 1, 8], [-12, -4, -6]]) >>> R1=np.array([[1, 0, 0],[2, -1, 0],[3, 0, 1]]) >>> R2=np.array([[1, 0, 0],[0, 1, 0],[0, 1, 1]]) >>> U = R2.dot(R1.dot(A)) >>> U array([[ 4, 1, 3], [ 0, 1, -2], [ 0, 0, 1]]) 97\n--- Страница 99 ---\n>>> T = R2.dot(R1) >>> T array([[ 1, 0, 0], [ 2, -1, 0], [ 5, -1, 1]]) >>> L = np.linalg.inv(T) >>> L array([[ 1., 0., 0.], [ 2., -1., -0.], [-3., -1., 1.]]) >>> L.dot(U) array([[ 4., 1., 3.], [ 8., 1., 8.], [-12., -4., -6.]]) -разложение можно выполнить, используя специальную функцию из библиотеки scipy, эту библиотеку необходимо предварительно установить и импортировать. За данный тип разложения отвечает scipy.linalg.lu. В результате будут получены матрицы , и . Смысл матриц и остается тот же, матрица - это простая перестановочная матрица. Рассмотрим как это работает: >>> import scipy.linalg as la >>> P, L, U = la.lu(A) >>> P array([[0., 0., 1.], [0., 1., 0.], [1., 0., 0.]]) >>> L array([[1., 0., 0.], [-0.66666667, 1., 0.], [-0.33333333, 0.2, 1.]]) >>> U array([[-12., -4., -6.], [ 0., -1.66666667, 4.], [ 0., 0., .2]]) 98\n--- Страница 100 ---\n>>> A array([[ 4, 1, 3], [ 8, 1, 8], [-12, -4, -6]]) >>> P.dot(L.dot(U)) array([[ 4., 1., 3.], [ 8., 1., 8.], [-12., -4., -6.]])",
          "debug": {
            "start_page": 97,
            "end_page": 100
          }
        },
        {
          "name": "5.2 QR-разложение матрицы 99",
          "content": "--- Страница 100 --- (продолжение)\n5.2 QR-разложение матрицы По определению разложение матрицы является представление м матрицы в виде произведения ортогональной матрицы и верхней треугольной матрицы . С понятием верней треугольной матрицы мы уже встречались ранее. Ортогональная матрица - новое для нас понятие, разберем его более подробно. Ортогональная матрица - это такая матрица, у которой ее транспонированная матрица равна обратной матрице, сумма квадратов всех элементов строки или столбца равна единице, а попарное произведение элементов двух строк или столбцов равно нулю. Существует несколько способов получения разложения матрицы. Рассмотрим один из них, суть которого заключается в ортогонализации и нормировании столбцов исходной матрицы. ➣ Численный пример Выполним разложение для следующей матрицы: . Проведем процедуру ортогонализации над столбцами матрицы для того, чтобы они стали перпендикулярны друг другу. Выпишем столбцы матрицы: , , . 99\n5.2 QR-разложение матрицы По определению разложение матрицы является представление м матрицы в виде произведения ортогональной матрицы и верхней треугольной матрицы . С понятием верней треугольной матрицы мы уже встречались ранее. Ортогональная матрица - новое для нас понятие, разберем его более подробно. Ортогональная матрица - это такая матрица, у которой ее транспонированная матрица равна обратной матрице, сумма квадратов всех элементов строки или столбца равна единице, а попарное произведение элементов двух строк или столбцов равно нулю. Существует несколько способов получения разложения матрицы. Рассмотрим один из них, суть которого заключается в ортогонализации и нормировании столбцов исходной матрицы. ➣ Численный пример Выполним разложение для следующей матрицы: . Проведем процедуру ортогонализации над столбцами матрицы для того, чтобы они стали перпендикулярны друг другу. Выпишем столбцы матрицы: , , . 99\n--- Страница 101 ---\nПосле процесса ортогонализации получим следующие вектора: , , . Теперь проведем нормировку векторов , и : , , . Матрица будет иметь следующий вид: . В тоже время: , , . Подставим численные значения в приведенные выше формулы: , 100\n--- Страница 102 ---\n, . Получим матрицу следующего вида: . Так как , то . Это значит, что , где : . ➤ Пример на Python Рассмотрим быстрый способ получения -разложения матрицы, для этого воспользуемся функцией np.linalg.qr() из библиотеки Numpy. В качестве аргумента в эту функцию передается исходная матрица, результатом ее работы являются две матрицы и : >>> A = np.matrix(\"2 1 3; 0 1 4; 1 3 4\") >>> A matrix([[2, 1, 3], [0, 1, 4], [1, 3, 4]]) >>> q, r = np.linalg.qr(A) 101\n--- Страница 103 ---\n>>> q matrix([[-0.89442719, 0.40824829, -0.18257419], [ -0., -0.40824829, -0.91287093], [ -0.4472136, -0.81649658, 0.36514837]]) >>> r matrix([[-2.23606798, -2.23606798, -4.47213595], [ 0., -2.44948974, -3.67423461], [ 0., 0., -2.73861279]]) Как вы можете видеть из примера: матрицы и совпадают с теми, что мы получили, в ходе вычисления “вручную” если их умножить на . Так как произведение двух отрицательных чисел - есть число положительное, то результат можно считать аналогичным. Если перемножить матрицы и , то должны получить матрицу , проверим это: >>> q.dot(r) matrix([[2., 1., 3.], [0., 1., 4.], [1., 3., 4.]])",
          "debug": {
            "start_page": 100,
            "end_page": 103
          }
        },
        {
          "name": "5.3 Сингулярное разложение матрицы 102",
          "content": "--- Страница 103 --- (продолжение)\n5.3 Сингулярное разложение матрицы Суть сингулярного разложения матрицы заключается в том, ее можно представить в виде произведения трех матриц : , где матрица - ортогональная, - диагональная, - ортогональная. Из “Главы 4. Линейные операторы ” вы должны помнить, что матрица определяет некоторое линейное преобразование над вектором. Сингулярное разложение матрицы показывает, как такую линейную операцию можно превратить в последовательное вращение вектора, масштабирование (растяжение или сжатие) и снова вращение. Для сингулярного разложения матрицы мы не будем приводить подробный численный пример, а сразу покажем как эта задача решается на Python. 102\n5.3 Сингулярное разложение матрицы Суть сингулярного разложения матрицы заключается в том, ее можно представить в виде произведения трех матриц : , где матрица - ортогональная, - диагональная, - ортогональная. Из “Главы 4. Линейные операторы ” вы должны помнить, что матрица определяет некоторое линейное преобразование над вектором. Сингулярное разложение матрицы показывает, как такую линейную операцию можно превратить в последовательное вращение вектора, масштабирование (растяжение или сжатие) и снова вращение. Для сингулярного разложения матрицы мы не будем приводить подробный численный пример, а сразу покажем как эта задача решается на Python. 102\n--- Страница 104 ---\n➤ Пример на Python >>> A = np.matrix(\"1 0 1; 0 1 0; 1 0 1\") >>> A matrix([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) >>> u, s, v = np.linalg.svd(A) >>> u matrix([[-0.70710678, 0., -0.70710678], [ 0., 1. , 0.], [-0.70710678, 0., 0.70710678]]) >>> s array([2., 1., 0.]) >>> v matrix([[-0.70710678, 0., -0.70710678], [ 0., 1., 0.], [ 0.70710678, 0., -0.70710678]]) 103",
          "debug": {
            "start_page": 103,
            "end_page": 104
          }
        }
      ]
    },
    {
      "name": "Глава 6. Комплексные числа 104",
      "chapters": [
        {
          "name": "6.1 Что такое комплексное число? 104",
          "content": "--- Страница 105 --- (продолжение)\nГлава 6. Комплексные числа 6.1 Что такое комплексное число? Перед тем как перейти к рассмотрению комплексных чисел, вспомним, какие множества чисел используются в математике. Приведенный ниже список не претендует на полноту, он нужен только для того, чтобы плавно перейти к понятию комплексного числа. В начальной школе начинают проходить, так называемые, натуральные числа , они обозначаются буквой и используются для счета предметов. Считается, что наименьшим натуральным числом является 1, следующее 2 и т.д.: . Если мы будем складывать и умножать натуральные числа, то в результате получим также натуральные числа. Но вот для вычитание это не всегда выполнимо, например: , результат - натуральное число. А в следующем примере: полученное значение уже не является натуральным числом. Для того, чтобы можно было использовать операцию «вычитание» множество натуральных чисел необходимо расширить до множества целых чисел, оно обозначается , в него входят натуральные числа, обратные им отрицательные числа и ноль: . Сложение, вычитание и умножение целых чисел дает целое число. Но для операции “деление” это не так. Рассмотрим пример: , получаем целое число. Но если мы делимое и делитель поменяем местами: , результат уже не будет являться целым числом. 104\n6.1 Что такое комплексное число? Перед тем как перейти к рассмотрению комплексных чисел, вспомним, какие множества чисел используются в математике. Приведенный ниже список не претендует на полноту, он нужен только для того, чтобы плавно перейти к понятию комплексного числа. В начальной школе начинают проходить, так называемые, натуральные числа , они обозначаются буквой и используются для счета предметов. Считается, что наименьшим натуральным числом является 1, следующее 2 и т.д.: . Если мы будем складывать и умножать натуральные числа, то в результате получим также натуральные числа. Но вот для вычитание это не всегда выполнимо, например: , результат - натуральное число. А в следующем примере: полученное значение уже не является натуральным числом. Для того, чтобы можно было использовать операцию «вычитание» множество натуральных чисел необходимо расширить до множества целых чисел, оно обозначается , в него входят натуральные числа, обратные им отрицательные числа и ноль: . Сложение, вычитание и умножение целых чисел дает целое число. Но для операции “деление” это не так. Рассмотрим пример: , получаем целое число. Но если мы делимое и делитель поменяем местами: , результат уже не будет являться целым числом. 104\n--- Страница 106 ---\nВыполним расширение множества чисел, на этот раз, наше новое множество будет содержать в себе все множество целых чисел и все дроби, которые можно представить в виде отношения числителя и знаменателя, последний из которых не равен нулю. Такое множество называется множество рациональных чисел и обозначается : , если . Помимо простых арифметических действий (сложение, вычитание, умножение и деление) при работе с числами, часто приходится применять операции: возведение в степень и извлечение корня. Опять таки, если взять подходящее рациональное число и извлечь из него квадратный корень: , получим рациональное число. По аналогии с изложенным выше, вы уже можете догадаться, что существуют такие рациональные числа, квадратный корень из которых не является рациональным числом, в качестве примера можно привести число 2: Такие числа называются иррациональными. Множества рациональных и иррациональных чисел составляют множество действительных чисел, оно обозначается как . Но операция извлечения квадратного корня достаточно коварна, существуют такие действительные числа, квадратный корень из которых не может быть представлен другим действительным числом. Например квадратный корень из (-1) не является действительным числом. До знакомства с комплексными числами, как правило, даже говорят, что такого корня не существует. Множество комплексным чисел представляет собой множество пар значений , где - называют действительной частью, а - мнимой частью комплексного числа. 105",
          "debug": {
            "start_page": 105,
            "end_page": 106
          }
        },
        {
          "name": "6.2 Задание комплексных чисел 106",
          "content": "--- Страница 107 --- (продолжение)\n6.2 Задание комплексных чисел 6.2.1 Алгебраическая форма задания комплексного числа В алгебраической форме комплексное число записывается так : , где - действительная часть; - мнимая часть. называют мнимой единицей, квадрат которой равен единице . Теперь вы знаете, чему равен квадратный корень из (-1), он равен : . Нулевым элементом в множестве комплексных чисел является следующее : . 6.2.2 Геометрическая интерпретация комплексного числа Геометрически комплексное число можно рассматривать как точку на двумерной плоскости, на которой и являются координатами. На комплексной плоскости определяют действительную ось, она обозначается , и мнимую ось - обозначается . Рисунок 6.1 — Комплексное число на комплексной плоскости Комплексные числа могут быть представлены в виде векторов, на той же комплексной плоскости, выходящих из точки с координатами до точки . 106\n6.2 Задание комплексных чисел 6.2.1 Алгебраическая форма задания комплексного числа В алгебраической форме комплексное число записывается так : , где - действительная часть; - мнимая часть. называют мнимой единицей, квадрат которой равен единице . Теперь вы знаете, чему равен квадратный корень из (-1), он равен : . Нулевым элементом в множестве комплексных чисел является следующее : . 6.2.2 Геометрическая интерпретация комплексного числа Геометрически комплексное число можно рассматривать как точку на двумерной плоскости, на которой и являются координатами. На комплексной плоскости определяют действительную ось, она обозначается , и мнимую ось - обозначается . Рисунок 6.1 — Комплексное число на комплексной плоскости Комплексные числа могут быть представлены в виде векторов, на той же комплексной плоскости, выходящих из точки с координатами до точки . 106\n--- Страница 108 ---\nРисунок 6.2 — Комплексное число, заданное вектором на комплексной плоскости 6.2.3 Модуль и аргумент комплексного числа Помимо действительной и мнимой части комплексное число может быть определено с помощью модуля и аргумента. Модуль комплексного числа - это длинна вектора, а аргумент - угол между вектором и действительной осью. Рисунок 6.3 — Модуль и аргумент комплексного числа Если комплексное число задано так: , тогда модуль рассчитывается по формуле: , аргумент определяется следующим образом: . 6.2.4 Тригонометрическая форма задания комплексного числа Располагая понятиями модуля и аргумента комплексного числа, можно перейти к рассмотрению тригонометрической формы задания комплексного числа. 107\n--- Страница 109 ---\nЕсли модуль обозначить через , а аргумент через , тогда действительная и мнимая части комплексного числа могут быть вычислены так: , . Само комплексное число примет следующую форму: . 6.2.5 Показательная форма комплексного числа Для того, чтобы представить комплексное число в показательной форме необходимо воспользоваться формулой Эйлера: . Глядя на тригонометрическую форму записи комплексного числа, можно вывести его показательную форму: .",
          "debug": {
            "start_page": 107,
            "end_page": 109
          }
        },
        {
          "name": "6.3 Задание комплексного числа в Python 108",
          "content": "--- Страница 109 --- (продолжение)\n6.3 Задание комплексного числа в Python Комплексные числа могут быть заданы парой , что сразу наталкивает на мысль использования кортежей Python для работы с ними: >>> z = (1, 2) >>> print(z) (1, 2) Но в этом случае придется самостоятельно написать функции для выполнения арифметических операций с комплексными числами. Мы этого делать не будем, вместо этого воспользуемся типом complex: >>> z = complex(1, 2) >>> print(z) (1+2j) >>> z1 = complex('1+3j') >>> print(z1) (1+3j) 108\n6.3 Задание комплексного числа в Python Комплексные числа могут быть заданы парой , что сразу наталкивает на мысль использования кортежей Python для работы с ними: >>> z = (1, 2) >>> print(z) (1, 2) Но в этом случае придется самостоятельно написать функции для выполнения арифметических операций с комплексными числами. Мы этого делать не будем, вместо этого воспользуемся типом complex: >>> z = complex(1, 2) >>> print(z) (1+2j) >>> z1 = complex('1+3j') >>> print(z1) (1+3j) 108\n--- Страница 110 ---\nКак вы можете видеть, при распечатке такого числа оно представляется в знакомой нам алгебраической форме. Действительная и мнимая части числа могут быть получены с помощью специальных атрибутов : >>> z.real 1.0 >>> z.imag 2.0 В типе complex нет методов для вычисления модуля и аргумента, для этого можно воспользоваться функциями из модуля cmath. Импортируем этот модуль : >>> import cmath Модуль и аргумент созданного выше числа определяется так : >>> r = cmath.polar(z)[0] >>> print(r) 2.23606797749979 >>> f = cmath.phase(z) >>> print(f) 1.1071487177940904",
          "debug": {
            "start_page": 109,
            "end_page": 110
          }
        },
        {
          "name": "6.4 Комплексно сопряженное число 109",
          "content": "--- Страница 110 --- (продолжение)\n6.4 Комплексно сопряженное число Числом, сопряженным с комплексным называют . Графически это можно представить так : Рисунок 6.4 — Комплексно сопряженное число ➣ Численный пример Для числа комплексно сопряженным будет . 109\n6.4 Комплексно сопряженное число Числом, сопряженным с комплексным называют . Графически это можно представить так : Рисунок 6.4 — Комплексно сопряженное число ➣ Численный пример Для числа комплексно сопряженным будет . 109\n--- Страница 111 ---\n➤ Пример на Python Создадим комплексное число : >>> z = complex(1, 2) >>> print(z) (1+2j) Получим для него комплексно-сопряженное : >>> c_z = z.conjugate() >>> print(c_z) (1-2j)",
          "debug": {
            "start_page": 110,
            "end_page": 111
          }
        },
        {
          "name": "6.5 Операции над комплексными числами 110",
          "content": "--- Страница 111 --- (продолжение)\n6.5 Операции над комплексными числами 6.5.1 Сложение комплексных чисел При сложении комплексных чисел действительные и мнимые части складываются по отдельности: , , . ➣ Численный пример , , . ➤ Пример на Python >>> z = complex('1+2j') >>> x = complex('3+4j') >>> z + x (4+6j) 110\n6.5 Операции над комплексными числами 6.5.1 Сложение комплексных чисел При сложении комплексных чисел действительные и мнимые части складываются по отдельности: , , . ➣ Численный пример , , . ➤ Пример на Python >>> z = complex('1+2j') >>> x = complex('3+4j') >>> z + x (4+6j) 110\n--- Страница 112 ---\n6.5.2 Вычитание комплексных чисел При получении разности комплексных чисел вычитание действительных и мнимых частей производится по отдельности : , , . ➣ Численный пример , , . ➤ Пример на Python >>> z = complex('5+3j') >>> x = complex('2+4j') >>> z - x (3-1j) 6.5.3 Умножение комплексных чисел Рассмотрим умножение комплексных чисел. Оно выполняется по алгебраическим правилам умножения сумм в скобках: , , . ➣ Численный пример , , . 111\n--- Страница 113 ---\n➤ Пример на Python >>> z = complex('5+3j') >>> x = complex('2+4j') >>> z * x (-2+26j) 6.5.4 Деление комплексных чисел Для вычисления частного от деления двух комплексных чисел используется вот такая формула: . ➣ Численный пример , , . ➤ Пример на Python >>> z = complex('5+3j') >>> x = complex('2+4j') >>> z / x (1.1-0.7j)",
          "debug": {
            "start_page": 111,
            "end_page": 113
          }
        },
        {
          "name": "6.6 Возведение в степень комплексного числа 112",
          "content": "--- Страница 113 --- (продолжение)\n6.6 Возведение в степень комплексного числа При возведении в степень комплексного числа удобно работать с тригонометрической формой записи числа, это позволит использовать формулу Муавра: . ➣ Численный пример , , , . 112\n6.6 Возведение в степень комплексного числа При возведении в степень комплексного числа удобно работать с тригонометрической формой записи числа, это позволит использовать формулу Муавра: . ➣ Численный пример , , , . 112\n--- Страница 114 ---\n➤ Пример на Python >>> z = complex('1+2j') >>> z**2 (-3+4j)",
          "debug": {
            "start_page": 113,
            "end_page": 114
          }
        },
        {
          "name": "6.7 Извлечение корня из комплексного числа 113",
          "content": "--- Страница 114 --- (продолжение)\n6.7 Извлечение корня из комплексного числа При извлечении корня из комплексного числа, также удобно представлять его в тригонометрической форме. Корень -ой степени из комплексного числа будет равен -му количеству корней, вычисляемых по формуле: . ➣ Численный пример , , , , . ➤ Пример на Python >>> import cmath >>> z = complex('3+4j') >>> r = abs(z) >>> ph = cmath.phase(z) >>> x1 = complex((r**0.5)*math.cos(ph/2), (r**0.5)*math.sin(ph/2)) >>> x1 (2+1j) >>> x2 = complex((r**0.5)*math.cos((ph+2*cmath.pi)/2), (r**0.5)*math.sin((ph+2*cmath.pi)/2)) >>> x2 (-2.0000000000000004-0.9999999999999999j) 113\n6.7 Извлечение корня из комплексного числа При извлечении корня из комплексного числа, также удобно представлять его в тригонометрической форме. Корень -ой степени из комплексного числа будет равен -му количеству корней, вычисляемых по формуле: . ➣ Численный пример , , , , . ➤ Пример на Python >>> import cmath >>> z = complex('3+4j') >>> r = abs(z) >>> ph = cmath.phase(z) >>> x1 = complex((r**0.5)*math.cos(ph/2), (r**0.5)*math.sin(ph/2)) >>> x1 (2+1j) >>> x2 = complex((r**0.5)*math.cos((ph+2*cmath.pi)/2), (r**0.5)*math.sin((ph+2*cmath.pi)/2)) >>> x2 (-2.0000000000000004-0.9999999999999999j) 113\n--- Страница 115 ---\nСписок литературы Алгебра / Линейная алгебра 1. Шевцов Г.С. Линейная алгебра: теория и прикладные аспекты: учеб. пособие. - 2-е изд., испр. и доп. - М.: Магистр: ИНФРА-М, 2011. - 528 с. 2. Ильин В.А., Позняк Э.Г. Линейная алгебра: Учеб.: Для вызов. - 6-е изд., стер. - М.: ФИЗМАТЛИТ, 2014.-280 с. 3. Винберг Э.Б. Курс Алгебры. 2-еизд., испр. и доп. — М.: Изд-во «Факториал Пресс», 2001. — 544 с. 4. Кострикин А.И. Введение в алгебру. Часть I. Основы алгебры: Учебник. - М.: Физико-математическая литература, 2000. - 272 с. 5. Кострикин А.И. Введение в алгебру. Часть II. Линейная алгебра. Учебник. - М.: Физико-математическая литература, 2000. — 368 с. 6. Курош А.Г. Курс высшей алгебры. 9-е изд. — М.: Главная редакция физико- математической литературы, 1968. — 431 с. Python 1. Лутц М. Изучаем Python, 4-е издание. – Пер. с англ. – СПб.: Символ-Плюс, 2011. – 1280 с., 2. Лучано Рамальо. Python. К вершинам мастерства / Пер. с англ. Слинкин А.А. - М.: ДМК Пресс, 2016. - 768 с. 4. Бизли Д. Python. Подробный справочник. - Пер. с англ. - Спб.: Символ-Плюс, 2010. - 864 с. 5. Alex Martelli. Python in a Nutshell, Second Edition . - O’Reilly Media, Inc . 6. David Beazley, Brian K. Jones. Python Cookbook, Third Edition. - O’Reilly Media, Inc . 114",
          "debug": {
            "start_page": 114,
            "end_page": 115
          }
        }
      ]
    }
  ]
}