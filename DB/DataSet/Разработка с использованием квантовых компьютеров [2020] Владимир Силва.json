{
  "title": "Разработка с использованием квантовых компьютеров [2020] Владимир Силва",
  "chapters": [
    {
      "name": "Глава 1. Странный и прекрасный мир квантовой механики 22",
      "content": "--- Страница 24 --- (продолжение)\nГлава 1 . Странный и прекрасный мир квантовой механики Макс Планк и ультрафиолетовая катастрофа, с которой все началось Планк предположил, что тепло и свет состоят из неделимых частей, ко - торые он назвал квантами света. Эта идея возникла в результате попыток объяснить эксперименты с излучением абсолютно черного тела, когда тело, полностью поглощающее любое излучение (тепло), имеет внутри полость с отверстием, позволяющим части излучения выйти наружу (рис. 1.1). С возрастанием температуры внутри полости частота излучения достигает видимых человеческому глазу диапазонов, соответствующих разным цветам. В то время, например, производители фарфора хорошо знали, что все тела при определенных температурах окрашиваются в кон- кретные цвета (табл. 1.1). Рис. 1.1. Результаты эксперимента по излучению абсолютно черного тела\nГлава 1 . Странный и прекрасный мир квантовой механики Макс Планк и ультрафиолетовая катастрофа, с которой все началось Планк предположил, что тепло и свет состоят из неделимых частей, ко - торые он назвал квантами света. Эта идея возникла в результате попыток объяснить эксперименты с излучением абсолютно черного тела, когда тело, полностью поглощающее любое излучение (тепло), имеет внутри полость с отверстием, позволяющим части излучения выйти наружу (рис. 1.1). С возрастанием температуры внутри полости частота излучения достигает видимых человеческому глазу диапазонов, соответствующих разным цветам. В то время, например, производители фарфора хорошо знали, что все тела при определенных температурах окрашиваются в кон- кретные цвета (табл. 1.1). Рис. 1.1. Результаты эксперимента по излучению абсолютно черного тела\n--- Страница 25 ---\nМакс Планк и ультрафиолетовая катастрофа, с которой все началось 25 Таблица 1.1. Окраска света при различных температурах Температура, °C Цвет 500 Темно-красный 800 Вишнево-красный 900 Оранжевый 1000 Желтый 1200 Белый На рис. 1.1 проиллюстрирован эксперимент по излучению абсолютно черного тела совместно с результатами, соответствующими классической теории спектральных линий, полученными во время экспериментов 1890-х годов. Эксперименты физика предсказали бесконечную интен - сивность ультрафиолетового спектра. Это явление, которое стало извест - ным как ультрафиолетовая катастрофа, было порождением сомнительных теоретических споров и экспериментальных результатов. Если это правда, то получается, что опасно сидеть даже рядом с камином! Планк стремился найти решение проблемы ультрафиолетовой катастрофы. Ученый воспользовался вторым законом термодинамики, связанным с понятием энтропии, чтобы вывести формулу для экспериментальных результатов, полученных при излучении абсолютно черного тела: S = –k log W, где S — энтропия Больцмана; k — постоянная Больцмана; W — вероятность того, что для элемента, будь то твердое тело, жидкость или газ, будет до - стигнуто определенное расположение атомов. Используя статистический метод Больцмана для расчета энтропии, Планк искал формулу, соответствующую результатам эксперимента с абсолютно черным телом. Разделив полную энергию E на порции пропорционально частоте f, он получил уравнение: E = hf, где E — порция энергии; h — постоянная Планка; f — частота. Тем не менее он столкнулся с проблемой: статистический метод Больцмана\n--- Страница 26 ---\n26 Глава 1 . Странный и прекрасный мир квантовой механики требовал, чтобы порции со временем уменьшались до нуля. Это свело бы на нет уравнение и тем самым лишило бы его смысла. После долгих экспериментов Планк вынужден был предположить, что количество энергии должно быть конечным. И на Планка снисходит невероятное озарение: если это справедливо, то означает, что генератор не может по - глощать или излучать энергию в непрерывном диапазоне. Поглощение и излучение энергии должны происходить небольшими неделимыми порциями E = hf — так называемыми квантами света. Отсюда и термин «квантовая механика». Квантовый переход Бора Нильс Бор применил предложенную Планком новаторскую идею квантов света к атому — наименьшей единице материи. Он дал смелое описание взаимосвязи атома и света: электрон, вращающийся вокруг ядра, будет излучать или поглощать свет, вызывая квантовый переход. Следователь - но, квантовый переход был переходом между двумя состояниями, однако Бор не смог полностью описать это. Другие ученые приняли идею скептически и называли теорию бессмыс - лицей, дешевым оправданием незнания или считали слишком смелой, слишком фантастической, чтобы быть правдой. Результатом стал раскол в физическом сообществе на тех, кто сплотился вокруг Бора, который ве - рил в квантовую природу материи, и тех, кто поддерживал классическую точку зрения. В этом противостоянии Эйнштейн вскоре присоединился к борьбе на классической стороне. Битва титанов: коты Шредингера и принцип неопределенности К середине 1920-х годов новая теория о квантовой природе материи ока - залась в шатком положении, стоя перед реальной перспективой скорого упадка. Для того чтобы укрепить ее фундамент, потребовалось два новых революционных открытия.\n--- Страница 27 ---\nБитва титанов: коты Шредингера и принцип неопределенности 27 Первое произошло в 1926 году, когда немецкий физик Вернер Гейзенберг попытался узаконить взгляды Бора, создав математическое описание атома для того, что сейчас известно как матричная механика. Эта идея считалась слишком сложной для восприятия даже опытным физикам. Тем не менее самым большим вкладом Гейзенберга в эту область является знаменитый принцип неопределенности, который мы рассмотрим далее. Второе открытие пришло от австрийского физика Эрвина Шредингера, который описал атом не как частицу, а как волну. Эта идея основывалась на аргументах французского физика-теоретика Луи де Бройля, который предположил, что частицы могут проявлять волновые свойства и что двойственность может быть необходима для понимания природы света (рис. 1.2). Рис. 1.2. Двойственная природа фотона. Он ведет себя как частица и как волна Де Бройль воспользовался знаменитым уравнением Эйнштейна для энергии E = mc2 и квантами света Планка E = hf, чтобы найти взаимосвязь между длиной волны λ и импульсом P фотона: E = mc2 = (mc)c. С учетом того, что mc — импульс P фотона, а c (скорость) = f (частота) · λ (длина волны), уравнение принимает вид: E = P(f λ). Но подождите, формула Планка утверждает, что энергия E = hf. Таким образом, используя базовую алгебру, де Бройль пришел к заключению: h f = P(f λ); h = Pλ; λ = h / P.\n--- Страница 28 ---\n28 Глава 1 . Странный и прекрасный мир квантовой механики Де Бройль показал, что длина волны фотона уменьшается с увеличением импульса (рис. 1.3). По аналогии он предположил, что это соотношение верно не только для фотонов, но и для всех частиц. С учетом того, что в то же время импульс электрона P = (масса) · (скорость) можно легко определить экспериментально, это означало, что длину волны можно рас - считать из уравнения де Бройля! В то время идея казалась нелепой, так как классические физики знали, что электрон является частицей — это открытие было сделано Дж. Дж. Томсоном задолго до того, в 1897 году. Рис. 1.3. Соотношение де Бройля между длиной волны и импульсом фотона Шредингер использовал идеи де Бройля, чтобы найти подход, который был бы более приемлемым для существующего положения, ознаменовав возвращение в непрерывный, визуализируемый мир классической физи - ки. Он был прав насчет волновой функции, но совершенно не прав насчет существующего положения вещей. Введение в универсальную волновую функцию Шредингер стремился найти такую функцию, чтобы ее можно было при - менить к любой физической системе, для которой известна математиче - ская форма энергии. Одним из основных уравнений квантовой механики является уравнение Шредингера, определяющее изменение с остояний\n--- Страница 29 ---\nБитва титанов: коты Шредингера и принцип неопределенности 29 квантовых систем с течением времени. Его часто называют волновым уравнением Шредингера, а его решение — волновой функцией, зависящей от времени. Она обозначается греческой буквой ψ (произносится «пси», рис. 1.4). Волновая функция Шредингера была немедленно принята как математический инструмент исключительной силы для решения задач, связанных с атомной структурой материи, и считается одним из величай - ших достижений XX века. Рис. 1.4. Знаменитая волновая функция Шредингера стремилась описать любую физическую систему с известной энергией Бор и Гейзенберг объединили усилия со Шредингером, чтобы использо - вать невероятную мощь его волновой функции, но сначала им нужно было разрешить свои разногласия. Три гиганта встретились для их обсуждения в 1926 году в недавно созданном институте в Копенгагене. Шредингер отверг концепцию Бора и Гейзенберга о дискретных квантовых переходах в структуре атома. Он хотел использовать свое новое открытие как путь назад к непрерывным физическим процессам, не нарушаемым внезапными переходами. На самом деле он предлагал классическую тео - рию материи, основанную исключительно на волнах, вплоть до сомнения в существовании частиц. Шредингер предположил, что частицы на самом деле являются суперпозицией волн. Ошибочность этого утверждения\n--- Страница 30 ---\n30 Глава 1 . Странный и прекрасный мир квантовой механики позже была обоснована Хендриком Лоренцем, который доказал, что их (частицы) все равно невозможно победить. Позже Шредингер будет со - мневаться в важности волновых колебаний как источника всей физиче - ской реальности. Бор, Гейзенберг и Шредингер спорили яростно, до изнеможения. Бор требовал абсолютной ясности во всех аргументах, пытаясь заставить Шредингера признать, что его интерпретация была неполной. Шредин - гер придерживался классической точки зрения, иногда оплакивая свою работу по теории атома и квантовым переходам (то, что он, вероятно, не имел в виду). Шредингер ненавидел интерпретацию строения атома, предложенную Бором. Нужен был последний элемент, чтобы эти двое смогли прийти к соглашению о цельной квантовой теории. Вероятностная интерпретация ψ: волновая функция была призвана разгромить квантовую механику, а не стать ее основой Великий рок-гитарист Джимми Хендрикс услышал мелодию Hey Joe, вы - пустил кавер и сделал ее своей, создав таким образом, пожалуй, один из величайших каверов. Точно так же поступили и отцы квантовой механики. Они осознали огромную силу волновой функции и присвоили ее. В этой истории есть небольшой любопытный нюанс: Шредингер терпеть не мог дискретную интерпретацию энергии и тепла, данную Планком. Он хотел использовать свою гладкую и непрерывную волновую функцию, чтобы победить кванты света Планка. В это трудно поверить, но в 1930-е годы от - крытие Планка было настолько революционным, что большинство физиков считали его сумасшедшим. Тем не менее так же, как Хендрикс — ту мелодию, основатели квантовой механики сделали своей волновую функцию. Прорыв был осуществлен немецким физиком Максом Борном, который разработал идею волновой функции как вероятности того, что электрон в данном состоянии рассеется в некотором направлении. Борн заявил, что вероятность P существования состояния задается квадратом модуля амплитуды волновой функции, то есть P = |ψ|2. Этот подход был новатор -\n--- Страница 31 ---\nБитва титанов: коты Шредингера и принцип неопределенности 31 ским в то время, ведь Борн не требовал более точных ответов: все, что мы получаем в атомной теории, — это вероятности. Эта принципиально новая идея привела Нильса Бора к интерпретации атома в совершенно новом ключе (рис. 1.5). Рис. 1.5. Модель Бора в сравнении с вероятностным толкованием волновой функции, данным Максом Борном Кот Шредингера пытается сорвать вероятностную вечеринку Борна По мере того как идея Борна о вероятностной природе ψ набирала оборо - ты, Шредингер предположил, что его волновая функция использовалась некорректно, и это привело к знаменитому мысленному эксперименту, который позже будет известен как «Кот Шредингера», о котором вы, вероятно, слышали. В эксперименте Шредингер стремился опровергнуть вероятностную интерпретацию ψ Борна. Это выглядит так: живого кота помещают в ящик с радиоактивным источником, который является пусковым устройством для молотка, разбивающего колбу с ядом, кото - рый, в свою очередь, убивает кота. Если предположить, что вероятность радиоактивного распада составляет 50 % в час, то через час механизм может сработать и тогда кот погибнет. Шредингер утверждал: согласно интерпретации Борна квантовая теория предсказывает, что через час кот в ящике не будет ни мертвым, ни живым, а будет комбинацией двух состоя - ний — суперпозицией обеих волновых функций. Шредингер считал, что это нелепо и приводит к парадоксу. Однако сегодня этот так называемый\n--- Страница 32 ---\n32 Глава 1 . Странный и прекрасный мир квантовой механики парадокс используется для обучения квантовым вероятностям и супер - позиции состояний. Удивительное свойство суперпозиции таково: как только ящик открыва - ется, волновые функции в состоянии суперпозиции коллапсируют в одно состояние, делая кота или мертвым, или живым, — таким образом, акт на - блюдения разрешает тупиковую ситуацию. Еще одно невероятное озарение посетит Гейзенберга, размышляющего о конкретной степени неопределен - ности местоположения частицы в структуре атома, отстаиваемой Бором. Принцип неопределенности Гейзенберг рассуждал о том, почему местонахождение частицы в атоме Бора невозможно определить. После долгих размышлений в момент озарения он понял: для того чтобы узнать, где находится частица, нужно взглянуть на нее, а для этого — буквально пролить на нее свет. Но когда вы делаете это, положение частицы изменяется, таким образом, акт на - блюдения частицы влияет на ее положение. Гейзенберг назвал эту идею принципом неопределенности . Для изучения проблемы Гейзенберг разработал гипотетический экс - перимент с использованием микроскопа, испускающего гамма-лучи с большим импульсом и низкой частотой навстречу наблюдаемому электрону. Определенная в сотрудничестве с Бором цель состояла в том, чтобы описать количественное соотношение путем оценки неопределен - ности при одновременном измерении импульса и координаты. Было установлено, что неопределенность координаты близка к длине волны излучения, ΔX ~ λ. Точно так же неопределенность импульса электрона близка к импульсу фотона, используемого для освещения частицы, ΔP ~ h / λ. Отметим сле - дующее: из уравнения де Бройля известно, что импульс фотона P = h / λ. Гейзенберг показал, что при перемножении обеих неопределенностей произведение всегда будет больше или равно h: ΔX · ΔP ≥ λ · h / λ; ΔX · ΔP ≥ h.\n--- Страница 33 ---\nБитва титанов: коты Шредингера и принцип неопределенности 33 Это принцип неопределенности Гейзенберга, который гласит: «Неопре - деленность одновременного измерения импульса и сопряженной ему координаты всегда больше некоторой постоянной величины и близка к постоянной Планка h». Существует простой эксперимент, который физики обычно используют, чтобы показать принцип неопределенности в действии. Он называется экс- периментом с одной щелью и выглядит следующим образом: лазерный луч проходит через широкую вертикальную щель и падает на проекционный экран. На нем мы видим именно то, что и ожидали, — точку. Теперь, если уменьшать ширину щели, границы точки также начнут сжиматься. Однако при ширине щели около 0,254 мм (1/100 дюйма) принцип неопределен - ности начинает действовать и, по словам Гейзенберга, направление луча становится неопределенным. Таким образом, теперь мы наблюдаем, как свет распространяется все шире и шире! Звучит безумно: как пучок света может стать шире, если сделать щель у 'же? Это совершенно непонятно на интуитивном уровне, но так все и работает. Рис. 1.6. Эксперимент с одной щелью продемонстрировал принцип неопределенности в действии Принцип неопределенности имеет огромное значение, потому что он устраняет разрыв между теориями Шредингера и Бора, закладывая фундамент современной квантовой теории. То есть электрон — это ча - стица, как предположил Бор, но мы не знаем точно, где он находится, как гласит принцип неопределенности (Гейзенберг). Наконец, вероятность его местонахождения определяется волновой функцией (Шредингер/\n--- Страница 34 ---\n34 Глава 1 . Странный и прекрасный мир квантовой механики Борн). Таким образом, для электрона характерна двойственность — он и частица, и волна. На основе всего этого возникает цельное представление о квантовой механике, которое позже будет известно как копенгагенская интерпретация. Интерференция и двухщелевой эксперимент Интерференция — еще одно невероятное свойство квантовой механики, которое заставляет задуматься о том, что происходит в мире за кулисами нашей реальности. Великий физик Ричард Фейнман однажды сказал об интерференции: основы квантовой механики можно понять из исследо - вания интерференции и двухщелевого эксперимента. Хорошо известно, что в начале XIX века шли дискуссии о природе света. Некоторые, как Ньютон, утверждали, что он состоит из частиц, другие предполагали, что он ведет себя как волна. В 1801 году Томас Юнг по - ставил опыт с двумя щелями, пытаясь свести эти теории воедино. В этом эксперименте луч света направлен на экран с двумя вертикальными щелями. После того как свет проходит через щели, полученный рисунок фиксируется на экране. Когда одна щель закрыта, видна одна линия света, соответствующая открытой щели. Здравый смысл и интуиция говорят нам, что, когда обе щели открыты, результирующий рисунок продемонстрирует две линии света, параллельные щелям. Невероятно, но это не так. На практике свет, проходящий сквозь щели и отображаемый на фотопластинке, разделяется на несколько линий различной степени яркости (рис. 1.7). Этот странный результат озадачил физиков, которые предположили, что между волнами и частицами, проходящими через щели, происходит ин - терференция. Если поток фотонов достаточно слаб, чтобы гарантировать, что на пластину попадают отдельные фотоны, то можно ожидать, что будут видны две световые линии (один фотон, проходящий через первую или вторую щель и оказывающийся в одной из двух возможных световых линий). Однако это не так. Свет каким-то образом делает невозможное:\n--- Страница 35 ---\nЭйнштейн — Бору: «Бог не играет в кости» 35 каждый фотон не только проходит через обе щели, но и одновременно проходит каждую возможную траекторию на пути к цели. Рис. 1.7. Двухщелевой эксперимент, проведенный Томасом Юнгом То, что такие события, как интерференция, которая кажется невозможной, могут происходить в атомном масштабе, сбивало с толку величайшие умы того времени. А вскоре новая теория столкнется с самой большой проблемой титана физики Альберта Эйнштейна. Эйнштейн — Бору: «Бог не играет в кости» Занимаетесь вы наукой или нет, вы, вероятно, слышали знаменитую фразу Эйнштейна «Бог не играет в кости». Эйнштейн написал это Нильсу Бору, когда обсуждал с ним природу квантовой механики. Бор считал, что по - нятия пространства — времени неприменимы на микроуровне. Однако Эйнштейн твердо верил в ткань пространства — времени и думал, что эту идею можно распространить на атомный масштаб. В сущности, это было корнем разногласий между ними. Эйнштейн предположил, что свойства элементарной частицы можно измерить, не нарушая ее равновесия. Но эта идея противоречил а ин- терпретации Бора — Гейзенберга. Два гиганта встретились на собрании\n--- Страница 36 ---\n36 Глава 1 . Странный и прекрасный мир квантовой механики величайших физиков того времени в Брюсселе в 1927 году, где Эйнштейн пытался раз и навсегда доказать, что неопределенность не управляет реальностью. Эйнштейн призвал Бора провести серию мысленных экспериментов, чтобы опровергнуть принцип неопределенности. В первом раунде Эйнштейн разработал коробку, которая, по его мнению, сможет заре - гистрировать точный момент, когда частица света испускается из не - большого отверстия в боковой части коробки, и в то же время измерить ее вес (рис. 1.8). Рис. 1.8. Экспериментальная коробка Эйнштейна, призванная опровергнуть принцип неопределенности В мысленном эксперименте, представленном на рис. 1.8, в коробке есть источник света с часами, предназначенными для измерения точного вре - мени испускания фотона. В то же время коробка с грузом на дне и соот- ветствующим измерительным устройством висит на пружине. Идея была\n--- Страница 37 ---\nБор — Эйнштейну: «Не говори Богу, что ему делать» 37 проста: взвесить коробку до и после испускания фотона и одновременно зарегистрировать точное время с помощью часов. Уровни энергии можно легко рассчитать, используя уравнение Эйнштейна E = mc2. В этот момент решалась судьба принципа неопределенности. Если эксперимент коррек - тен, принцип неопределенности будет опровергнут и квантовая теория потерпит поражение. Бор немедленно принялся за работу, пытаясь убедить Эйнштейна в том, что если его устройство сработает, то это будет означать конец физики. Бор в конце концов победил, заявив, что Эйнштейн не принял во вни - мание собственную теорию: часы подвержены влиянию гравитации, что приводит к неопределенности во время измерения. Он доказал верность расчета соотношения неопределенности для энергии и времени ΔEΔt ≥ h, используя уравнение Эйнштейна и формулу для красного смещения. С этим результатом первый раунд остался за Бором, однако это было еще не все. Эйнштейн верил в полную картину физической реальности, и на его пути стоял принцип неопределенности. Он вернется с еще большим вызовом. Бор — Эйнштейну: «Не говори Богу, что ему делать» «Бог не играет в кости» — это непоколебимый принцип Эйнштейна. Твердая вера в то, что реальность существует независимо от кого бы то ни было. Когда Эйнштейн написал Бору, что Бог не играет в кости, тот ответил: «Не говори Богу, что ему делать». Это подготовило почву для нового раунда противоборства между ними в попытке выяснить, что удер - живает ядро от распада. К середине 1930-х годов, когда происходили эти события, общая теория относительности и квантовая теория уже были широко признаны как самые убедительные идеи, объясняющие устрой - ство мира. Второй раунд посвящен наиболее парадоксальному аспекту квантовой теории — тому, что микрочастицы остаются связанными друг с другом даже на больших расстояниях.\n--- Страница 38 ---\n38 Глава 1 . Странный и прекрасный мир квантовой механики Запутанность и ЭПР-парадокс: мистическое дальнодействие Поначалу считалось, что свет ведет себя как волна, но Эйнштейн доказал, что свет также демонстрирует поведение таких частиц, как фотоны. То же самое относится и к атомам. Они вели себя и как частицы, и как волны, в зависимости от используемого измерительного прибора. Кроме того, оба условия были необходимы для получения полной картины — Бор назвал это взаимодополняемостью. Так как же понимать материю с учетом этих двух противоречий? Бор считал, что атом как таковой существует вне нашего восприятия. Это было больше, чем Эйнштейн мог принять с его верой в идею пространства — времени в основе всей физической реальности и желанием распространить данную концепцию на микроуровень. Бор же думал, что пространство и время бес - смысленны, а реальность непознаваема и все, что у нас есть, — это явления. Примерно в это же время Эйнштейн бросает второй и последний вы - зов Бору. В статье, написанной в соавторстве с коллегами Подольским и Розеном, Эйнштейн задает вопрос: дает ли квантовая механика полное описание физической реальности? Он предлагает мысленный экспери - мент, в котором две частицы, испускаемые одним источником, имеют общие свойства и становятся разделенными. Тогда должна существовать возможность измерить первую частицу и получить информацию о вто- рой, не нарушая ее равновесия. Цель эксперимента состояла в том, чтобы продемонстрировать абсурдность представления Бора о частицах, кото - рые ведут себя по-разному из-за измерительного устройства. Согласно принципам квантовой механики измерение первой частицы будет влиять на другую во времени и пространстве. Теперь представьте, что частицы должны быть разделены очень боль - шими расстояниями, например находятся на разных концах Вселенной. Это создаст парадокс, нарушающий фундаментальный научный принцип причины и следствия. Существовало мнение, что все соб ытия имеют при - чину и следствие и информация не может передаваться быстрее скорости света, являющейся конечным пределом скорости во Вселенной. Эйнштейн\n--- Страница 39 ---\nНеравенство Белла: проверка запутанности 39 назвал это принципом локальности. Данный парадокс будет известен как парадокс Эйнштейна — Подольского — Розена, или ЭПР. Как только Бор узнал о статье, он немедленно прекратил все работы. Задача должна была быть решена. Бор поначалу неохотно, но все же дал ответ, за - явив, что обе частицы должны рассматриваться как единая система. Другими словами, эти частицы запутываются, а пространство и время в такой системе не имеют смысла. Поэтому картина микромира была непостижимой. Эйнштейн назвал эффект запутанных частиц, отстоящих друг от друга на большие расстояния, мистическим дальнодействием1. Разногласия между исследователями никак не разрешались. Но в 1965 году физик Джон Белл совершил открытие, которое всех примирило. Неравенство Белла: проверка запутанности Белл предложил ряд неравенств, чтобы обеспечить экспериментальное до - казательство существования локальных скрытых переменных. Формально теорема Белла о неравенстве гласит: никакая физическая теория локальных скрытых переменных никогда не сможет воспроизвести все предсказания квантовой механики . Существует простой способ понять эту очень важную теорему, используя простые средние. Рассмотрим поляризацию фотонов (колебания света в определенной плоскости) под углами A = 0°, B = 120° и C = 240° (рис. 1.9). Согласно теореме Белла если реальность не зависит от наблюдения, то фотон имеет определенные одновременные значения для этих трех настроек поляризации и они должны соответствовать восьми случаям, показанным в табл. 1.2. 1 В немецком тексте Эйнштейна оно названо spukhafte Fernwirkung, в английском переводе Макса Борна — spooky action at a distance. Иногда используется обо - значение «жуткое дальнодействие» или «призрачное дальнодействие». Мы будем придерживаться варианта «мистическое дальнодействие». — Примеч. науч. ред.\n--- Страница 40 ---\n40 Глава 1 . Странный и прекрасный мир квантовой механики Рис. 1.9. Поляризация света под тремя углами Таблица 1.2. Перестановки для поляризации фотонов под тремя углами Номер A (0°) B (120°) C (240°) [AB] [BC] [AC] Сумма Среднее 1 А+ В+ С+ 1 (++) 1 (++) 1 (++) 3 1 2 А+ В+ С− 1 (++) 0 0 1 1/3 3 А+ В− С+ 0 0 1 (++) 1 1/3 4 А+ В− С− 0 1 (––) 0 1 1/3 5 А− В+ С+ 0 1 (++) 0 1 1/3 6 А− В+ С− 0 0 1 (––) 1 1/3 7 А− В− С+ 1 (––) 0 0 1 1/3 8 А− В− С− 1 (––) 1 (––) 1 (––) 3 1 Тепер ь задайте простой вопрос: если мы измерим поляризацию под лю - бым углом, какова вероятность того, что поляризация у любого соседа будет такой же, как у первого ? Также рассчитайте суммарное и среднее значения поляризации. В табл. 1.2 поляризация соседей представлена столбцами AB, BC и AC. Знаки «+» и «–» в столбцах A, B и C указывают на положительную или отрицательную поляризацию под заданными\n--- Страница 41 ---\nЭПР-парадокс разгромлен: Бор смеется последним 41 углами. Обратите внимание на то, что существует восемь возможных перестановок, обозначенных номерами строк. Таким образом, если мы находим одинаковую поляризацию (одинаковый знак) для двух соседей, то записываем 1, а также знак в столбцах AB, BC или AC. Это необходимо для расчета суммарного и среднего значений для соответствующей строки в таблице перестановок. Теперь, если, как утверждает Эйнштейн, существует поляризация, неза - висимая от измерения (локальности), тогда вероятность этой поляриза - ции должна быть ≥ 1/3. С другой стороны, если Бор прав, а реальность определяется актом наблюдения, то вероятность поляризации будет < 1/3. Это лежит в основе неравенства Белла. Белл не принимает чью-либо сто - рону: это не говорит о корректности одного или другого, но дает средства для поиска истины экспериментальным путем. В 1982 году французский физик Ален Аспе провел эксперимент, который раз и навсегда доказал, что Бор был прав с самого начала. ЭПР-парадокс разгромлен: Бор смеется последним В эксперименте Аспе лазером облучается кальциевый источник, в результа - те чего создается пара фотонов, одновременно движущихся в противопо - ложных направлениях. Фотоны проходят через поляризационный фильтр, который пропускает только фотон, поляризованный в одной плоскости. При прохождении фотона результат записывается измерительными устройствами, расположенными с обеих сторон. Измерительные приборы подключены к счетчику, который регистрирует результаты множества взаимодействий (рис. 1.10). Когда оба поляризационных фильтра были откалиброваны в одном на - правлении, Аспе обнаружил корреляцию между парами фотонов. Они либо пройдут, либо будут заблокированы одновременно. Эта корреляция согласуется с мнением Эйнштейна о том, что фотон обладает свойством поляризации, предопределенным в момент излучения источником, а не в момент измерения, как предсказывала квантовая механика.\n--- Страница 42 ---\n42 Глава 1 . Странный и прекрасный мир квантовой механики Рис. 1.10. Эксперимент Алена Аспе по проверке неравенства Белла, первый этап В то же время если настройки поляризации фильтров различаются, то следует ожидать, что определенный минимальный процент фотонов либо пройдет, либо будет заблокирован. Здесь в игру вступает неравенство Белла, как показано в табл. 1.2. Если процент проходящих или блокируемых фотонов больше ожида- емого минимума или равен ему, неравенство Белла сохраняется и поля- ризация фотонов определяется в момент излучения (победа достается Эйнштейну, а квантовая механика терпит поражение). Если процент меньше ожидаемого минимума, неравенство Белла нару - шается и квантовая физика верна. Поляризация определяется в момент измерения (побеждает Бор, и квантовая механика спасена). Аспе выполнил измерения для множества пар фотонов при разных на - стройках поляризации. Результаты были поразительными: измерения нарушали неравенство Белла, таким образом, невозможно было заранее определить поляризацию в момент излучения. Квантовая механика корректна! Оказалось, фотоны выбирали общую поляризацию в момент измерения. Может ли существовать какой-то неизвестный сигнал между фотонами, говорящий им, что нужно выбрать общее значение в момент измерения?\n--- Страница 43 ---\nЭПР-парадокс разгромлен: Бор смеется последним 43 Теория относительности Эйнштейна гласит, что ни один сигнал не может распространяться быстрее скорости света — конечного предела скорости во Вселенной. Он назвал этот мнимый одновременный сигнал мистиче - ским дальнодействием. Ален Аспе хотел проверить это утверждение на втором этапе своего эксперимента. Физик использовал два оптических переключателя, которые развет - вляются на два отдельных поляризационных фильтра, присоединенных к измерительному устройству каждый (рис. 1.11). Как и прежде, все из - мерительные приборы подключены к счетчику для сбора результатов. Оптический переключатель предназначен для передачи фотона в одном из двух направлений с чрезвычайно высокой частотой — 2 нс. Расстояние между концами экспериментальной установки было рав - но 12 м. Для скорости света (3 · 108 м/с) переход от одного конца к дру- гому составляет 40 нс. Рис. 1.11. Эксперимент Алена Аспе для проверки мистического дальнодействия Теперь, если никакой сигнал не может распространяться быстрее скорости света, как гласит теория относительности, одному фотону потребуется свыше 40 нс, чтобы сообщить другому, какое значение поляризации\n--- Страница 44 ---\n44 Глава 1 . Странный и прекрасный мир квантовой механики выбрать. Поскольку оптический переключатель изменяется с большей скоростью (2 нс), корреляция между фотонами не должна сохраняться. То есть фотоны не должны быть в состоянии выбрать одинаковую поля - ризацию в момент измерения (никаких мистических дальнодействий). В то же время, если корреляция сохраняется, все становится очень стран - ным, так как какой-то сигнал передается на оба фотона быстрее скорости света. Невероятно, но корреляция находилась в полном согласии с квантовой ме - ханикой, раз и навсегда доказав, что значение поляризации было выбрано одновременно обоими фотонами в момент измерения быстрее скорости света. Это означало, что расстояние между фотонами могло быть беско - нечно большим, например от одного конца Вселенной до другого, и, что звучит еще более пугающе, такую корреляцию можно рассматривать как движение во времени: из настоящего в прошлое и наоборот! Реальность дурачит нас: все взаимосвязано? Эксперимент Аспе доказывает, что существуют квантовые запутывания. И если мы хотим объяснить их, а не просто принять, то должны признать: корреляции1 происходят быстрее скорости света. Раз некоторым это трудно осмыслить, все становится еще более странным. В телевизионном интервью для BBC физик Джон Белл сказал: «Мы никак не можем это использовать, например, мы не можем отправлять сообщения или ин - формацию быстрее скорости света. И этот факт предсказывает квантовая механика. Кажется, что природа подшучивает над нами: за кулисами про - исходят необычные вещи, которые мы не можем использовать». 1 Автор иногда пишет, что фотоны «обмениваются» или «взаимодействуют» быстрее скорости света. Но это не совсем так: между ними не происходит никакого взаимо - действия и нет нарушения теории относительности. Квантовая механика фунда - ментально нелокальна — волновая функция может быть любых размеров, и на нее не действуют обычные правила распространения взаимодействий или информации. По сути, просто нельзя говорить о двух разных фотонах в запутанной паре, которые «взаимодействуют», — это некий новый объект, который описывается «размазанной» в пространстве волновой функцией. — Примеч. науч. ред.\n--- Страница 45 ---\nРеальность дурачит нас: все взаимосвязано? 45 В конце концов, Бор и Эйнштейн так и не разрешили свои разногласия. Они оба ушли в мир иной, но их наследие продолжает существовать. Пролистывая страницы их увлекательных биографий, нельзя не задаться вопросом: как бы чувствовал себя Бор, глядя на результаты эксперимента Алена Аспе, доказывающие, что он был прав с самого начала? Был бы он счастлив от своего триумфа над Эйнштейном? Было ли все это противо - стоянием двух эгоцентричных гениев, пытающихся доказать, кто лучше? Как вы думаете? Я предпочитаю верить, что это была борьба на благо науки. В общем, победителем в столкновении двух титанов стало все человечество.\n--- Страница 46 ---\n2Квантовые вычисления: искривление ткани самой реальности Полупроводники прошли долгий путь со времен вакуумной трубки. Труд - но поверить, что сегодня размер транзистора составляет около 14 нм, то есть близок к размеру молекулы. В этой главе вы узнаете о происхождении квантовых вычислений, начиная с транзистора. Складывается впечатле - ние, что технология производства полупроводниковых приборов и тран- зисторов противоречит законам физики. Далее углубленно рассмотрим базовый компонент квантового компьютера — кубит, включая странные эффекты суперпозиции, запутывания и управления кубитом с помощью логических элементов. Разработка кубитов — важная тема, и в этой главе описываются ведущие прототипы от крупных ИТ-компаний с учетом плюсов и минусов каждого из них. Вы также узнаете о том, как квантовые компьютеры выдерживают конкуренцию с традиционными компьютерами. В настоящее время у квантовых дела идут не слишком гладко, но в ближайшие несколько лет ситуация изменится. Тем не менее у них есть некоторые недостатки: они нестабильны и склонны к ошибкам. Нам предстоит выяснить поче - му. В этой главе также обсуждаются весьма занимательные поиски так называемого квантового превосходства (quantum supremacy). Между ИТ-гигантами идет жесткая борьба, победителя в которой не видно.\n--- Страница 47 ---\nТранзистор вступает в противоречие с законами физики 47 Еще одной темой обсуждений стал спорный алгоритм квантового от - жига, а также его отличие от стандартного подхода на основе квантовых вентилей, используемого на протяжении всей этой книги. Закончим главу рассмотрением истории появления универсальных кван - товых компьютеров, включая достижения всех основных поставщиков: в ближайшей перспективе квантовые компьютеры появятся во многих центрах обработки данных. В долгосрочной перспективе будущее видится блестящим, поскольку значительные ресурсы вкладываются в такие об - ласти, как аэрокосмическая промышленность, медицина, искусственный интеллект и т. д. Гонка становится глобальной. Итак, начнем. Транзистор вступает в противоречие с законами физики Вы когда-нибудь заглядывали в свой домашний компьютер просто из любопытства, чтобы увидеть, из чего он состоит? По сути, это материн - ская плата со всевозможными электронными устройствами, а в центре находится большой черный квадрат — процессор. В зависимости от того, какой у вас ПК, может быть несколько процессоров, графических процессоров (GPU), аудио- и сетевых карт и всевозможных модульных компонентов. Все они состоят из миллионов транзисторов, которые являются основным строительным элементом многих электронных устройств. Транзистор — это, по сути, крошечный переключатель с по- ложениями «включено/выключено», позволяющий электронам либо проходить, либо нет. Это свойство используется для кодирования 0 или 1 — основы двоичной системы счисления, применяемой во всей электронике. Транзисторы объединяются для создания логических элементов (табл. 2.1). Они выполняют основные арифметические действия: сложение, вычи - тание, умножение и деление. Эти простые операции обеспечивают всю мощь, которая нам необходима для запуска высокоэффективных научных симуляций, игр, шифрования данных, просмотра веб-страниц, отправки электронных писем друзьям и т. д.\n--- Страница 48 ---\n48",
      "debug": {
        "start_page": 24,
        "end_page": 48
      }
    },
    {
      "name": "Глава 2. Квантовые вычисления: искривление ткани самой реальности 46",
      "content": "--- Страница 48 --- (продолжение)\nГлава 2 . Квантовые вычисления: искривление ткани самой реальности Таблица 2.1. Основные логические элементы Тип Символ Описание Таблица истинности НЕ Инвертирует ввод (логическое отрицание)А~A 01 10 И Логическое произведение (конъюнкция)АВА И В 000 010 100 111 ИЛИ Логическое дополнение (дизъюнкция)АВА ИЛИ В 000 011 101 111 И-НЕ Инвертирует логическое произведение (отрицание конъюнкции)АВА И-НЕ В 001 011 101 110 ИЛИ-НЕ Инвертирует логическое дополнение (отрицание дизъюнкции)АВА ИЛИ-НЕ В 001 010 100 110 ИЛИ-ИЛИ Исключающее ИЛИ: выход ИЛИ-ИЛИ для двух входных элементов равен 1, только когда оба входных значения различны, и 0, если они одинаковыАВА ИЛИ-ИЛИ В 000 011 101 110 Появление транзисторов стало причиной огромного технологического про - гресса в нашем обществе. Они повсюду: в компьютерах, устройствах связи, медицинском оборудовании, аэрокосмической технике и т. д. О каком бы\nГлава 2 . Квантовые вычисления: искривление ткани самой реальности Таблица 2.1. Основные логические элементы Тип Символ Описание Таблица истинности НЕ Инвертирует ввод (логическое отрицание)А~A 01 10 И Логическое произведение (конъюнкция)АВА И В 000 010 100 111 ИЛИ Логическое дополнение (дизъюнкция)АВА ИЛИ В 000 011 101 111 И-НЕ Инвертирует логическое произведение (отрицание конъюнкции)АВА И-НЕ В 001 011 101 110 ИЛИ-НЕ Инвертирует логическое дополнение (отрицание дизъюнкции)АВА ИЛИ-НЕ В 001 010 100 110 ИЛИ-ИЛИ Исключающее ИЛИ: выход ИЛИ-ИЛИ для двух входных элементов равен 1, только когда оба входных значения различны, и 0, если они одинаковыАВА ИЛИ-ИЛИ В 000 011 101 110 Появление транзисторов стало причиной огромного технологического про - гресса в нашем обществе. Они повсюду: в компьютерах, устройствах связи, медицинском оборудовании, аэрокосмической технике и т. д. О каком бы\n--- Страница 49 ---\nПятинанометровый транзистор: большая проблема 49 устройстве вы ни подумали, вполне возможно, что она сделана на основе транзисторов. Но технология их развития вот-вот столкнется с непреодо - лимым препятствием — законами физики, в частности квантовой механики. Пятинанометровый транзистор: большая проблема С 1960-х годов вычислительная мощность традиционных компьютеров возрастала экспоненциально, в то время как сами они становились все меньше и меньше. Сегодня компьютеры состоят из миллионов транзи - сторов, но, как только транзистор начинает приближаться по размеру к атому, вступает в действие странный мир квантовой механики и прежние правила теряют силу. Рассмотрим рис. 2.1 и 2.2, на которых показаны размеры полупроводников, выпускаемых в период с 1970-х по 2020-е годы. С приблизительно 10 мкм в 1970-х годах размеры постоянно уменьшаются и составляют примерно 1 мкм к концу 1980-х годов (табл. 2.2, 2.3). Более того, с 1990-х годов на - блюдается огромный спад кривой в нанометровом масштабе (1 нм = 10–9 м) (см. рис. 2.2). Мы говорим о транзисторах, приближающихся по величине к молекулам. К 2019 году размер транзистора составляет около 5 нм. При таком масштабе странные свойства квантовой механики могут начать сеять хаос в классическом компьютере. Рис. 2.1. Размеры полупроводников с 1970-х по 1980-е годы\n--- Страница 50 ---\n50 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Таблица 2.2. Данные о размерах полупроводников для рис. 2.1 Год Размер, мкм 1971 10,0 1974 6,0 1977 3,0 1982 1,5 1985 1,0 Рис. 2.2. Размеры полупроводников с 1990-х годов Таблица 2.3. Данные о размерах полупроводников для рис. 2.2 Год Размер, нм 1995 600 2001 130 2010 32 2014 14 2019 7 2021 5 На рис. 2.3 показан размер транзистора в 2020 году (около 5 нм) в срав- нении с молекулой воды (0,275 нм). К сожалению, транзисторы не могут уменьшаться вечно. Существует порог, который называется квантовым масштабом. Если размер полупроводника будет меньше значения этого порога, классические компьютеры окажутся бесполезными.\n--- Страница 51 ---\nКвантовый масштаб и конец эпохи транзисторов 51 Рис. 2.3. Размер транзистора в сравнении с размером молекулы воды Квантовый масштаб и конец эпохи транзисторов Возможно, конец эпохи транзисторов — это преувеличение. Тем не ме- нее квантовый масштаб и его влияние таковыми не являются. В физике квантовый масштаб — это расстояние, на котором квантово-механические эффекты проявляются в изолированной системе. Эта странная граница существует при 100 нм и менее или при очень низкой температуре. Фор - мально квантовый масштаб — это расстояние, на котором квантуется действие или момент импульса. Квантовые эффекты проявляются в микроскопических масштабах, при - водя к проблемам в современной микроэлектронике. Наиболее типичные эффекты — туннелирование электронов и интерференция, как показано в двухщелевом эксперименте. Туннелирование электронов Электронное туннелирование, также известное как квантовое туннелиро - вание, представляет собой явление, когда частица проходит через барьер, который невозможно преодолеть в классическом масштабе. Это создает проблемы для транзистора, и вот почему.\n--- Страница 52 ---\n52 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Предположим, у нас есть частица с энергией E, пытающаяся преодолеть барьер высотой V. Согласно классическому закону сохранения энергии частице нужно обладать энергией E > V, чтобы пройти через него, то есть кинетическая энергия частицы должна быть больше, чем потенциальная энергия V (рис. 2.4). Рис. 2.4. Квантовое туннелирование в действии ПРИМЕЧАНИЕ Электронное туннелирование может предвещать конец эпохи транзи - сторов, но там, где один теряет, другой находит. Это важное свойство привело к разработке сканирующего туннельного микроскопа, что зна - чительно повлияло на химические, биологические и материаловедче - ские исследования.\n--- Страница 53 ---\nКвантовый масштаб и конец эпохи транзисторов 53 На рис. 2.4 показаны эффекты классической механики, а также квантового туннелирования. Согласно принципам квантовой механики существует вероятность того, что электрон пройдет через барьер, даже если его ки - нетическая энергия меньше, чем потенциальная энергия барьера ( E < V). Это связано с принципом неопределенности Гейзенберга. Из предыдущей главы вы узнали о двойственном поведении фотонов и других частиц, демонстрирующих свойства как волн, так и частиц. Для волн действует волновая функция Шредингера, для частиц Нильс Бор описал изменения в состоянии атома, когда тот получает или теряет энергию (квантовые переходы). Принцип неопределенности устраняет разрыв, вводя вероят - ность положения и импульса частицы в данный момент времени. Когда частица, такая как электрон или фотон, приближается к барьеру, такому как транзистор, существует вероятность того, что она пройдет прямо через него. Это связано с тем, что ее волновая функция умень - шается от синусоидальной до экспоненциальной формы, и ее решением становится уравнение: ; (2.1) , (2.2) где: ψ — убывающая волновая функция Шредингера; N — константа нормализации;  ; m — масса частицы; V — потенциальная энергия, E — кинетическая энергия; h — постоянная Планка = 6,626 ⋅ 10–34 м2 ⋅ кг/с; a — толщина барьера. Согласно Энгелю1, вероятность P того, что частица пройдет через барьер, может быть рассчитана по формуле (2.2). Кроме того, чтобы 1 Engel T. Quantum Chemistry and Spectroscopy. Upper Saddle River, N. J. Pearson, 2006.\n--- Страница 54 ---\n54 Глава 2 . Квантовые вычисления: искривление ткани самой реальности произошло квантовое туннелирование, должны быть выполнены сле - дующие условия: барьер тонкий и имеет конечную высоту; потенциальная энергия барьера превышает его кинетическую энер - гию ( E < V); частица обладает волновыми свойствами, это говорит о том, что кван - товое туннелирование применимо только к наноразмерным объектам, таким как электроны, фотоны и т. д. Давайте немного развлечемся, рассчитав вероятности квантового тун - нелирования для различных размеров барьеров полупроводников, вы - пускаемых на данный момент. Далее приводятся упражнения, которые помогут вам лучше разобраться в этом процессе. Упражнение 2.1 Воспользовавшись любимым инструментом, например электронной та - блицей Excel, рассчитайте вероятность квантового туннелирования для электрона по формуле (2.2), учитывая следующие значения: кинетическая энергия электрона E = 4,5 эВ; квадратный барьер с потенциальной энергией V = 5 эВ (помните: для того чтобы произошло квантовое туннелирование, должно соблюдаться условие E < V); постоянная Планка h = 6,626 ⋅ 10–34 м2·кг/с; масса электрона m = 9,1 ⋅ 10—31 кг. Размер барьера, обеспечиваемого техпроцессом производства полупровод- ников, приведен в табл. 2.2 и 2.3 (менее 100 нм для 20 00 года и позже). ПРИМЕЧАНИЕ Электрон-вольт (эВ) — основная единица энергии в квантовой механи - ке; 1 эВ = 1,6 ⋅ 10–19 Дж. Это значение потребуется для преобразования единиц при расчете вероятности.\n--- Страница 55 ---\nКвантовый масштаб и конец эпохи транзисторов 55 Решение 2.1 Я использовал электронную таблицу Excel, чтобы легко вычислить значения из таблицы. Итак, выберите ячейку в Excel и введите фор - мулу (2.2). Помните, что часть ( V – E) нужно уменьшить, умножив на 1,6 ⋅ 10–19 Дж/эВ. Таким образом, формула (2.2) в Excel принимает вид: В приведенной формуле ячейка D5 содержит размер барьера, а осталь - ное — константы π = 3,14, h = 6,626 ⋅ 10–34, m = 9,1 ⋅ 10–31 и 1 эВ = 1,6 ⋅ 10–19 Дж. Добавив формулу, создайте новую таблицу с годом выпуска и разме - ром барьера в нанометрах (см. табл. 2.2 и 2.3). Наконец, скопируйте логику формулы для данных из ячеек для всех лет и размеров барьеров (табл. 2.4). Таблица 2.4. Вероятности туннелирования электронов для технологии производства полупроводников Год Размер барьера, м Вероятность 1989 8E–07 0 2001 1,3E–07 0 2006 6,5E–08 6,5829E–205 2010 3,2E–08 3,0188E–101 2014 1,4E–08 1,053E–44 2017 1,00E–08 3,86767E–32 2019 7,00E–09 1,02616E–22 2021 5,00E–09 1,96664E–16 После 5E–10 0,026876484 Какие выводы можно сделать на основании этих данных? Вероятность оказалась низкой даже для техпроцесса при размере барье - ра 5 нм, ожидаемого в 2021 году (2E–16). Помните, что для получения процентов данное значение нужно умножить на 100.EXP(((−4*D5*3.14)/(6.626E−34)) * SQRT(2 * (9.1E−31) * (5 − 4.5) * (1.6E−19))).\n--- Страница 56 ---\n56 Глава 2 . Квантовые вычисления: искривление ткани самой реальности При размере барьера около 500 пм начинаются некоторые странности. Вероятность составляет 0,0269, следовательно, существует 2,69%-ная вероятность того, что электрон пройдет через барьер. Это значит, напри - мер, что если вы отправляете закодированное сообщение, то 2,69 % бит будет потеряно! Ничего хорошего. ПРИМЕЧАНИЕ Пикометр (пм) — это 1/1000 нм, или 10—12 м. Упражнение 2.2 Напишите на любимом языке программирования крошечную программу для расчета вероятности, как показано в упражнении 2.1. Убедитесь, что результаты совпадают. Распечатайте результаты в виде стандартного вы - вода, как показано далее. Quantum tunnelling probab ilities for current semiconductor processes. 2001 1.30e-07 0.000e+00 2010 3.20e-08 2.684e-101 2014 1.40e-08 1.000e-44 2019 7.00e-09 1.000e-22 2021 5.00e-09 1.931e-16 Beyond 5.00e-10 2.683e-02 Решение 2.2 В листинге 2.1 показана маленькая программа на Java, в которой рассчиты - вается вероятность для разных годов и размеров для существующей техно - логии производства полупроводников, как это сделано в упражнении 2.1. Листинг 2.1. Программа на Java для расчета вероятности квантового туннелирования для технологии производства полу проводников с 2000 года public class Quantum Tunnelling { /** Постоянная Планка */ static final double K_PLANK = 6.626e-34;\n--- Страница 57 ---\nКвантовый масштаб и конец эпохи транзисторов 57 /** Масса электрона (кг) */ static final double K_ELECTRON_MASS = 9.1e-31; /** Электрон-вольт */ static final double K_EV = 1.6e-19; /** * Энгелева вероятность квантового туннелирования * * @param size * Размер барьера в метрах. * @param E * Кинетическая энергия в электрон-вольтах (эВ). * @param V * Потенциальная энергия в эВ. * @return Вероятность квантового туннелирования */ static double EngelProbability(double size, double E, double V) { if (E > V) { throw new IllegalArgumentException (\"Potential energy (V) must be > Kinetic Energy (E)\"); } double delta = V – E; double p1 = ((-4 * size * Math.PI) / K_PLANK); double p2 = Math.sqrt(2 * K_ELECTRON_MASS * delta * K_EV); return Math.exp(p1 * p2); } /** Простой тест для существующей технологии производства полупроводников */ public static void main(String[] args) { try { /** Размеры барьеров для текущей технологии производства полупроводников */ final double[] SIZES = { 130e-9, 32e-9, 14e-9, 7e-9, 5e-9, 500e-12 }; // Даты для вывода на экран final String[] DATES = { \"2001\", \"2010\", \"2014\", \"2019\", \"2021\", \"Beyond\" }; final double E = 4.5; // Кинетическая энергия электрона (эВ) final double V = 5.0; // Потенциальная энергия (эВ) // Отображение… for (int i = 0; i < DATES.length; i++) { double p = EngelProbability(SIZES[i], E, V);\n--- Страница 58 ---\n58 Глава 2 . Квантовые вычисления: искривление ткани самой реальности System.out.println(String.format(\"%s\\t%2.2e\\t%2.3e\", DATES[i], SIZES[i], p)); } } catch (Exception e) { e.printStackTrace(); } } } Листинг 2.1 определяет функцию EngelProbability , которая принимает три аргумента: размер барьера (м), кинетическую энергию частицы Е (эВ) и по- тенциальную энергию V (эВ). В ней вычисляется формула (2.1), а затем воз - вращается вероятность. После этого основная программа просто проходит в цикле по массиву для разных годов выпуска полупроводников String[] DATES = { \"2001\", \"2010\", \"2014\", \"2019\", \"2021\", \"Beyond\"} и соответствую - щих размеров: double[] SIZES = { 130e-9, 32e-9, 14e-9, 7e-9, 5e-9, 500e-12} . Данные отформатированы в виде таблицы для стандартного вывода. Упражнение 2.3 Отобразите данные, полученные в упражнениях 2.1 или 2.2, на графике, чтобы лучше представить ситуацию. И смело предсказывайте год кончины транзистора при существующей технологии производства полупровод- ников! Решение 2.3 Электронные таблицы — замечательный инструмент для обработки статистических значений. На основе приведенных ранее данных можно построить превосходную линейную диаграмму (рис. 2.5). Итак, конец эпохи транзисторов должен наступить году примерно в… Я скептически отношусь к возможности предсказания точного года. Что я узнал о квантовой механике, так это то, что все управляется неопре - деленностью. Если предположить, что 1%-ная вероятность квантового туннелирования неприемлема для существующей технологии произ - водства, то приведенные ранее данные покажут: примерно к 2025 году при размере барьера от 1 нм до 500 пм транзисторы и, следовательно, все компьютеры могут стать непригодными для использования. Хотя\n--- Страница 59 ---\nКвантовый масштаб и конец эпохи транзисторов 59 я предполагаю, что транзисторы превратятся в нечто другое, возможно, во что-то органическое или еще более странное. Тем не менее пришло время на всякий случай начать учиться программировать квантовые компьютеры. Рис. 2.5. Вероятности квантового туннелирования для технологии производства полупроводников Теперь рассмотрим следующий квантовый эффект, вызывающий про - блемы для транзистора: неопределенность положения или импульса, продемонстрированную в базовых экспериментах со щелями. Эксперименты со щелями Эти эксперименты были проведены много десятилетий назад и предна - значались для демонстрации странного мира квантовой механики. Они бы- вают разных видов: с одной щелью, с двумя щелями и др. В эксперименте\n--- Страница 60 ---\n60 Глава 2 . Квантовые вычисления: искривление ткани самой реальности с одной щелью луч лазера проходит через вертикальную прорезь шириной несколько сантиметров и проецируется на поверхность. Ширину щели можно уменьшить. Как и ожидалось, на поверхности мы видим точку. Теперь, если ширина щели уменьшается, спроецированная точка стано - вится у 'же и у'же — это тоже ожидаемый результат. Но подождите, когда ширина щели достигает примерно 0,254 мм (1/100 дюйма), начинается нечто странное. Точка не становится у 'же, а расползается в широкую го - ризонтальную линию. И это чрезвычайно нелогично. ПРИМЕЧАНИЕ Более подробное иллюстрированное описание эксперимента приведено в главе 1. Когда речь идет о транзисторах, эксперименты со щелями важны, потому что они показывают странные эффекты квантовой механики в крошечных масштабах. В общем, ньютоновские и релятивистские законы времени и пространства не имеют смысла при таких масштабах и создадут про - блемы для транзистора. Вероятное будущее транзисторов Возможно, я слишком рано заговорил о конце эпохи транзисторов. На са- мом деле наука уже рассматривает возможные альтернативы и помимо квантовых вычислений. Есть несколько интригующих проектов для решения этой проблемы. Молекулярная электроника — очень перспективная область. Она обе - щает выйти за рамки малых интегральных микросхем, используя молекулярные строительные блоки для изготовления электронных компонентов. Это междисциплинарная область, которая охватывает физику, химию и материаловедение.\n--- Страница 61 ---\nРичард Фейнман и квантовый компьютер 61 Органическая электроника — термин, который звучит одновременно захватывающе и фантастически. Это область материаловедения, рас - сматривающая разработку и применение органических молекул или полимеров, которые демонстрируют желаемые электронные свойства, такие как проводимость. Представьте себе транзисторы из органиче - ских материалов, таких как углерод. Не совсем живые машины, но уже близко. Ричард Фейнман и квантовый компьютер Идею вычислительной системы, основанной на квантовых свойствах, высказал лауреат Нобелевской премии по физике Ричард Фейнман. В 1982 году он предложил квантовый компьютер, способный обратить эф - фекты квантовой механики в свою пользу1. С тех пор интерес к квантовым вычислениям носил в основном теоретический характер, но все должно было измениться. В 1995 году Питер Шор в своей общеизвестной работе «Алгоритмы простой факторизации и дискретного логарифмирования на квантовом компьютере за полиномиальное время»2 описал алгоритм фак - торизации больших чисел для работы на квантовом компьютере. Это по- ложило начало гонке за созданием реального квантового компьютера, для которого математически доказано, что временная сложность ( O, или время выполнения) его алгоритма значительно меньше, чем у нынешнего лидера классических вычислений — метода решета числового поля. Алгоритм Шора сам по себе имеет глубокий смысл. Рассмотрите рис. 2.6, демонстрирующий временные сложности метода решета числового поля и алгоритма Шора в сравнении. Математически было подсчитано, что алгоритм Шора может вычислить 232-значное целое число (RSA-232), одно из самых больших целых чис ел, 1 Quantum computation. David Deutsch. Physics World, 1/6/92. A comprehensive and inspiring guide to quantum computing. 2 Peter W. Shor. Polynomial-Time Algorithms for Prime Factorization and Discrete Loga - rithms on a Quantum Computer // https://arxiv.org/abs/quant-ph/9508027.\n--- Страница 62 ---\n62 Глава 2 . Квантовые вычисления: искривление ткани самой реальности за считаные секунды. Таким образом, действующий квантовый компьютер, который сможет реализовать алгоритм Шора, сделает бесполезным асим - метричное шифрование. Имейте в виду, что асимметричное шифрование задействовано во всех областях современной жизни: например, в банках для шифрования личных данных и счетов клиентов, в Интернете для за - щиты аккаунтов пользователей и т. д. Рис. 2.6. Сравнение временных сложностей метода решета числового поля и алгоритма Шора Но пока еще рано бежать в банк, забирать все свои деньги и прятать их под матра сом. Практическая реализация этого алгоритма отстоит на десятилетия от на - стоящего момента. Более подробно обсудим этот увлекательный алгоритм в главе 3. Теперь вернемся к Фейнману и его квантовому компьютеру. В класси - ческом компьютере основной единицей является бит (0 или 1). В ком - пьютере Фейнмана основной единицей является кубит, или квантовый бит, — единица столь же причудливая, как и основанная на ней теория.\n--- Страница 63 ---\nКубит, странный и потрясающий одновременно 63 Кубит, странный и потрясающий одновременно Как и его классический собрат, кубит может принимать значение либо 0, либо 1. Физически кубиты могут быть представлены как любая двух - уровневая квантовая система наподобие: спина частицы в магнитном поле, где верх означает 0, а низ — 1; поляризации единичного фотона, где горизонтальная поляризация со - ответствует 1, а вертикальная — 0. Квантовый компьютер можно сделать из света. Разве это не странно? В обоих случаях 0 и 1 — единственно возможные состояния. Геометри - чески кубит можно представить с помощью поверхности, носящей назва - ние сферы Блоха — инструмента, названного в честь шведского физика Феликса Блоха (рис. 2.7). Рис. 2.7. Геометрическое представление квантового состояния с помощью сферы Блоха Строго говоря, сфера Блоха — это геометрическое представление в трех- мерном гильбертовом пространстве чистого состояния двухуровневой\n--- Страница 64 ---\n64 Глава 2 . Квантовые вычисления: искривление ткани самой реальности квантовой системы или кубита. Ее северный и южный полюсы пред - ставляют собой стандартные базисные векторы и соответственно, которые, в свою очередь, соответствуют спину электрона, направленному вверх и вниз. Помимо основных векторов, сфера может иметь проме - жуточное значение, называемое суперпозицией и являющееся, по сути, вероятностью для 0 или 1. Хитрость в том, что мы не можем предсказать, какой она будет, за исключением момента наблюдения, когда вероятность коллапсирует в окончательное состояние. Суперпозиция состояний Представьте себе, что можно было бы подбросить монету, которая могла бы упасть не только орлом или решкой, но и обеими сторонами одновременно. Такая монета открывала бы для нас большие возможности. Тем не менее здесь есть подвох: в тот момент, когда вы наблюдаете квантовую монету, ей приходится выбирать свое состояние: орел или решка, и никогда не из- вестно, в каком положении она находилась раньше. Это одна из причин, по которой нужно быть осторожными при измерении кубитов, потому что они изменяются в момент наблюдения. В общем, суперпозиция меняет правила игры. Давайте посмотрим почему. Однобитовый классический компьютер в каждый отдельно взятый момент времени может находиться в одном из двух состояний (или хранить его), 0 или 1. Однокубитный квантовый компьютер может на - ходиться (или хранить) в двух состояниях одновременно. Это 21 = 2. Двухбитовый классический компьютер может хранить только одну из 22 = 4 возможных комбинаций. Двухкубитный квантовый компьютер может хранить 22 = 4 возможных значения одновременно. С учетом того, что байт (8 бит) является базовой единицей, используемой для хранения информации в любой системе, число значений, которые могут быть сохранены одновременно в квантовом компьютере, будет равно 2n, где n — число кубитов. Сравните это с емкостью запоминающего устройства классического компьютера (табл. 2.5), и вы поймете, почему кубиты действительно мощны.\n--- Страница 65 ---\nКубит, странный и потрясающий одновременно 65 Таблица 2.5. Емкость запоминающего устройства (ЗУ) для кубитов Биты/кубиты Классическое ЗУ, байт Квантовое ЗУ, бит Квантовое ЗУ, байт 4 1 16 2 8 1 256 32 32 4 4 294 967 296 536 870 912 68 8 1,84467E+19 2,30584E+18 Таким образом, объем данных, которые могут храниться одновремен - но в квантовом компьютере, поражает настолько, что появился новый термин — квантовое превосходство . Это та точка, в которой квантовый компьютер сможет решить задачи, которые не по силам классическому компьютеру. Это понятие будет подробно обсуждаться в следующем разделе данной главы. А пока рассмотрим другое странное свойство ку - бита — запутанность. Запутанность: наблюдение за кубитом изменяет состояние его партнера Много лет назад Альберт Эйнштейн назвал квантовую запутанность мистическим дальнодействием . Хотите верьте, хотите нет, но запутан - ность была доказана экспериментально французским физиком Аленом Аспе в 1982 году. Он продемонстрировал, как влияние на одну из двух коррелированных частиц передается со скоростью большей, чем ско - рость света! ПРИМЕЧАНИЕ Ирония здесь в том, что люди не могут использовать запутанность, чтобы отсылать сообщения со скоростью больше скорости света, поскольку информация не может так быстро перемещаться. Это про - тиворечие, а также эксперимент Алена Аспе более подробно описаны в главе 1.\n--- Страница 66 ---\n66 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Если набор кубитов запутан, то каждый из них мгновенно отреагирует на изменение другого, независимо от того, как далеко они находятся друг от друга (на противоположных сторонах Галактики, например, что звучит действительно невероятно). Это полезно в том смысле, что если мы из - меряем свойства одного кубита, то можем сделать вывод о свойствах его партнера, не видя последнего. Кроме того, запутанность можно измерить с помощью квантовой томо - графии. Квантовая томография рассчитывает вероятность измерения каждого возможного состояния системы. ПРИМЕЧАНИЕ Многокубитное запутывание представляет собой шаг вперед в реализа - ции крупномасштабных квантовых вычислений. Это область активных исследований. В настоящее время физики в Китае эксперименталь - но продемонстрировали квантовую запутанность с десятью кубитами в сверхпроводящей цепи1. Запутывание — один из аспектов управления кубитом. Еще одна умо - помрачительная особенность — управление им с помощью квантовых вентилей. Управление кубитами с помощью квантовых вентилей Вентили являются базовыми строительными блоками квантового ком - пьютера. Как и их классические аналоги, они оперируют набором входов для создания набора выходов. Но, в отличие от своих собратьев, они рабо - тают одновременно во всех возможных состояниях кубита, что делает их 1 Chao Song et al. 10-Qubit Entanglement and Parallel Logic Operations with a Supercon - ducting Circuit // Physical Review Letters. DOI: 10.1103/PhysRevLett.119.180511.\n--- Страница 67 ---\nКубит, странный и потрясающий одновременно 67 действительно крутыми и странными одновременно. Далее рассмотрим основные вентили квантового компьютера. Измерительный элемент Известно, что акт измерения или наблюдения кубита изменяет его состоя- ние. Этот процесс также рассматривается как измерительный элемент (measurement gate). Измерительный элемент принимает кубит в супер - позиции состояний в качестве входных данных и выдает либо 0, либо 1. Вероятность того, что значением вывода будет 0 или 1, зависит от состоя- ния, в котором изначально находится кубит (рис. 2.8). Рис. 2.8. Измерительный элемент и вероятность его выходного значения Обратите внимание на то, что измерение должно быть последним действи - ем в квантовой цепи, поскольку согласно принципам квантовой механики наблюдение кубита при промежуточных вычислениях коллапсирует его волновую функцию и разрушит параллелизм, достигнутый суперпози - цией состояний. Вентиль SWAP Вентиль SWAP обмена состояниями принимает два кубита и меняет их состояния (рис. 2.9).\n--- Страница 68 ---\n68 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Рис. 2.9. Вентиль SWAP в действии Вентиль Паули X Вентиль Паули Х (рис. 2.10) — это квантовый аналог классического опе - ратора НЕ. Строго говоря, он поворачивает кубит на 180° вокруг оси Х. Обратите внимание на то, что ось Х указывает за пределы экрана, как показано на сфере Блоха на рис. 2.7. Рис. 2.10. Вентиль Паули Х\n--- Страница 69 ---\nКубит, странный и потрясающий одновременно 69 ПРИМЕЧАНИЕ Вентиль Паули назван в честь одного из отцов квантовой физики ав - стрийца по происхождению Вольфганга Эрнста Паули. В 1945 году он получил Нобелевскую премию по физике за разработку принципа ис - ключения, или принципа Паули, в котором, по сути, говорится, что два электрона не могут существовать в одном и том же квантовом состоя- нии1. Работу Паули высоко оценивал Альберт Эйнштейн, кроме того, австриец был близким другом колоссов квантовой механики Нильса Бора и Бернарда Гейзенберга. Вентили Паули Y и Z Вентили, осуществляющие поворот вокруг осей Y и Z, известны как вен - тили Паули Y и Z соответственно. Вентиль Паули Y воздействует на одиночный кубит. Он поворачи - вает его вокруг оси Y сферы Блоха на π радиан (180°) и преобразует в и в . Вентиль Паули Z воздействует на одиночный кубит. Он поворачивает его вокруг оси Z сферы Блоха на π радиан (180°), оставляет базисное состояние неизменным и преобразует в . Вентиль Адамара (H) Вентиль Адамара воздействует на одиночный кубит. Он является комби - нацией двух поворотов: на π радиан вокруг оси Х; на π/2 радиан вокруг оси Y. 1 Nobel Lecture: Exclusion Principle and Quantum Mechanics Pauli’s own account of thedevelopment of the Exclusion Principle // www.nobelprize.org/nobel_prizes/physics/ laureates/1945/pauli-lecture.html.\n--- Страница 70 ---\n70 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Вентиль Адамара является квантовым аналогом матрицы Адамара — квадратной матрицы, элементы которой принимают значения либо +1, либо −1, а строки являются взаимно перпендикулярными: . ПРИМЕЧАНИЕ Преобразование Адамара можно использовать при шифровании данных, а также во многих алгоритмах обработки сигналов и сжатия данных. Управляемые вентили (cX cY cZ) Управляемые вентили действуют на два и более кубита, где один или более из них являются управляющими для какой-либо операции. Например, управляемый вентиль НЕ (CNOT или cX) действует на два кубита и вы- полняет операцию НЕ на втором кубите только тогда, когда первый кубит имеет состояние , и оставляет его неизменным в противном случае. Вентиль Тоффоли (CCNOT) Это управляемый вентиль, который оперирует тремя кубитами. Если первые два кубита находятся в состоянии , он применяет оператор Паули X (или НЕ) к третьему, иначе никаких действий не выполняет. Данный вентиль преобразует в . Квантовые вентили, приведенные в табл. 2.6, являются базовыми строи - тельными блоками квантовых схем по аналогии с классическими логиче - скими операторами из табл. 2.1, принятыми для цифровых схем. Таблица 2.6. Основные квантовые вентили Вентиль Условное обозначение Описание Измерительный Принимает на вход кубит в суперпозиции и выдает либо 0, либо 1\n--- Страница 71 ---\nКубит, странный и потрясающий одновременно 71 Вентиль Условное обозначение Описание X (NOT) Вращает кубит на 180° вокруг оси X. Преобразует в и в Y Производит поворот вокруг оси Y сферы Блоха на π радиан. Представлен матрицей Паули: , где — мнимая единица Z Производит поворот вокруг оси Z сферы Блоха на π радиан. Представлен матрицей Паули: Адамара Представляет собой поворот на π радиан вокруг оси . Иначе говоря, преобразует состояние в и в SWAP (S) Меняет состояния двух кубитов в соответствии с базисом , , , . Представлен матрицей: Управляемый (cX cY cZ)Действует на два и более кубита, где один кубит и более являются управляющими для какой-либо операции. В общем виде описывается матрицей: , где U — одна из матриц Паули, σX, σY или σZ Продолжение \n--- Страница 72 ---\n72 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Вентиль Условное обозначение Описание Тоффоли (CCNOT)Это обратимый вентиль, что означает, что его выход можно восстановить по его входу (состояния перемещаются без увеличения физической энтропии). Имеет трехбитные входы и выходы, если для первых двух бит установлено значение 1, то инвертирует третий бит, в противном случае все биты остаются неизменными. Обратимые вентили важны, потому что они рассеивают меньше тепла. Когда логический элемент поглощает свои входные данные, информация теряется, так как на выходе меньше информации, чем на входе. Такие потери информации — это рассеивание энергии в окружающую среду в виде тепла. В квантовых вычислениях вентиль Тоффоли очень важен, так как квантовая механика требует, чтобы преобразования были обратимыми, и допускает более общие состояния (суперпозиции) вычислений, чем классические компьютеры Таким образом, квантовый вентиль управляет вводом суперпозиций, вращает вероятности и создает другую суперпозицию в качестве своего выхода. Физически кубиты могут создаваться различными способами, и в настоящее время промышленные предприятия начинают действовать в разных направлениях, каждое из которых имеет свои достоинства и не- достатки. Рассмотрим их. Проектирование кубитов Когда дело доходит до проектирования кубитов, только крупные компании могут вступить в гонку по созданию практичного квантового компьюте - ра. Ввиду странности и сложности квантовой механики это задача не из Таблица 2.6 (продолжение)\n--- Страница 73 ---\nКубит, странный и потрясающий одновременно 73 легких. В статье для журнала Science Magazine1 писатель Габриэль Попкин в общих чертах обрисовал, какие действия предпринимают технологиче - ские гиганты. Кажется, что все они хотят сделать ставку на разные типы устройства. Пока явного победителя нет, и гонка продолжается. Далее рассмотрим самые распространенные типы кубитов, по словам Попкина. Сверхпроводящие контуры Когда электрический ток проходит через проводник, часть энергии теряется в виде тепла и света. Это явление называется сопротивлением и зависит от типа материала: некоторые металлы, например медь и золото, хорошо про - водят электричество и, следовательно, имеют низкое сопротивление. Ученые обнаружили, что чем холоднее материал, тем лучшим проводником элек - тричества он становится. Таким образом, чем ниже температура, тем ниже сопротивление. Но независимо от того, насколько холодными будут золото или медь, они всегда будут показывать некоторый уровень сопротивления. Ртуть в этом смысле отличается от других металлов. В 1911 году ученые обнаружили, что при ее охлаждении до 4,2 К (выше абсолютного нуля) сопротивление становится равным нулю. Этот эксперимент привел к от- крытию сверхпроводника — материала, который имеет нулевое электри - ческое сопротивление при очень низких температурах. С тех пор было об - наружено много сверхпроводящих материалов: алюминий, галлий, ниобий и др., которые демонстрируют нулевое сопротивление при критической температуре. Самое замечательное в сверхпроводниках заключается в том, что электрический ток в них протекает без каких-либо потерь, поэтому теоретически в замкнутом контуре он может циркулировать вечно. ПРИМЕЧАНИЕ Этот принцип был доказан экспериментально, когда ученые смогли поддерживать электрический ток, протекающий через сверхпроводящие кольца, в течение многих лет. 1 Ученые близки к созданию квантового компьютера, который сможет превзойти обычный: http://www.sciencemag.org/news/2016/12/scientists-are-close-building- quantumcomputer- can-beat-conventional -one/.\n--- Страница 74 ---\n74 Глава 2 . Квантовые вычисления: искривление ткани самой реальности В кубите, изготовленном из сверхпроводящего контура, ток колебательно меняет направление с прямого на обратное. Микроволновое излучение побуждает ток перейти в суперпозицию состояний (рис. 2.11). Рассмотрим преимущества и недостатки такого устройства. Рис. 2.11. Сверхпроводящий кубит Преимущества: низкий уровень ошибок (около 99,4 % успешных логических операций); быстрый, изготовлен из существующего материала; приличное количество (девять) запутанных кубитов, способных вы - полнять двухкубитные операции. Недостатки: малое время сохранения когерентности состояний — 0,00005 с. Это минимальное количество времени, в течение которого сохраняется суперпозиция состояний; должно находиться при сверхнизких температурах, –271 °C. На таком устройстве работает облачная платформа IBM Q Experience, на базе которой создан код, используемы й в этой книге. Применяется также\n--- Страница 75 ---\nКубит, странный и потрясающий одновременно 75 Google и частным предприятием Quantum Circuits, Inc. (QCI), которое стремится разработать практичный квантовый компьютер на основе сверхпроводников. Ионные ловушки Ионная ловушка — это методика управления квантовыми состояниями в кубите. При этом задействуется комбинация электрических или маг - нитных полей для захвата заряженных частиц (ионов) в системе, изолиро - ванной от внешней среды. Лазеры применяются для создания состояний пар кубитов для одиночных операций или связи между внутренними состояниями и внешними динамическими состояниями для запутывания. Применение ионных ловушек — это стремление воплотить в жизнь меч - ту о крупномасштабных универсальных квантовых вычислениях путем масштабирования с использованием массивов ионных ловушек . Данная методика позволяет также создавать большие запутанные состояния с по- мощью сетей с фотонной связью из запутанных удаленных друг от друга ионных цепочек или комбинации этих двух идей (рис. 2.12). Рис. 2.12. Ионные ловушки и цепочки для крупномасштабных квантовых вычислений\n--- Страница 76 ---\n76 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Рассмотрим преимущества и недостатки ионных ловушек. Преимущества: большое время сохранения когерентности состояний. Эксперты утвер- ждают, что ионные ловушки могут сохранять запутанность более 1000 с, а это весьма существенно в сравнении со сверхпроводящими контура - ми (0,00005 с); более высокий уровень успешного выполнения (99,9 %), чем у сверх - проводников (99,4 %). Ненамного, но все же; наибольшее количество (14) запутанных кубитов, способных выполнять двухкубитные операции, на настоящее время. Недостатки: медленное выполнение операций; требуется большое количество лазеров. Лидером в разработке данной технологии является компания IonQ, рас - положенная в штате Мэриленд, США. Кремниевые квантовые точки Intel, гигант в области создания ЦПУ для ПК, возглавляет этот проект. В кремниевой квантовой точке электроны вертикально ограничены ос - новным состоянием квантовой ямы в арсениде галлия (GaAs), образуя двумерный электронный газ (2DEG). Электронный газ 2DEG может свободно перемещаться в двух измерениях, но сильно ограничен третьим (рис. 2.13). Такое жесткое ограничение приводит к появлению квантован - ных уровней энергии для движения в третьем направлении, что может представлять большой интерес для квантовых структур. ПРИМЕЧАНИЕ На сегодняшний найден способ получения 2DEG на транзисторах, изго - товленных из полупроводников. Они также демонстрируют квантовые эффекты, такие как эффект Холла, в которых двумерная электронная проводимость квантуется при низких температурах и сильных магнит - ных полях.\n--- Страница 77 ---\nКубит, странный и потрясающий одновременно 77 Рис. 2.13. Квантовая точка в арсениде галлия Перечислим преимущества и недостатки кремниевых квантовых точек. Преимущества: стабильны, созданы на основе существующих полупроводниковых материалов; лучшее время сохранения когерентности состояний, чем у сверхпрово - дящих материалов, составляющее 0,03 с. Недостатки: малое количество (два) запутанных кубитов, способных выполнять двухкубитные операции; уровень успешного выполнения ниже, чем у сверхпроводящих контуров и ионных ловушек, но все еще выше 99 %. Топологические кубиты Топологические кубиты призваны устранить ошибки, характерные для квантовых компьютеров. Ошибки происходят из-за вероятностного характера квантовой механики и касаются времени сохранения коге - рентности состояний или продолжительности запутывания кубитов. Топологический кубит использует двумерные квазичастицы, называемые анионами, пути которых огибают друг друга, образуя косы в трехмер ном\n--- Страница 78 ---\n78 Глава 2 . Квантовые вычисления: искривление ткани самой реальности пространстве-времени. Эти косы образуют логические вентили, из кото - рых состоит компьютер (рис. 2.14). Рис. 2.14. Топологический кубит с косами, действующими как логические вентили Преимущества: стабильность; отсутствие ошибок (понятие времени жизни неприменимо). Недостаток в том, что на данный момент это чисто теоретические раз - работки, хотя недавние эксперименты показывают, что такие элементы могут быть созданы в реальных условиях с использованием полупровод- ников, изготовленных из арсенида галлия при температуре, близкой к абсолютному нулю, и подвергнутых воздействию сильных магнитных полей. Microsoft и Bell Labs — в числе компаний, которые поддерживают данный проект. NV-центры в алмазе NV-центры в алмазе — это места в кристаллической решетке алмаза, где должен находиться, но отсутствует атом углерода. NV-центры используют нанометровые атомные дефекты в алмазных материалах, чтобы функцио -\n--- Страница 79 ---\nКубит, странный и потрясающий одновременно 79 нировать как кубиты. С помощью атомно-силовой микроскопии было обнаружено, что на поверхности природных алмазов присутствует не - сколько типов дефектов. Этот дефект, или вакансия, наряду с атомом азота добавляет электрон в решетку алмаза. Затем квантовый спин электрона можно контролировать с помощью лазера (рис. 2.15). Рис. 2.15. Кубит на основе NV-центра в алмазе По словам Дирка Энглунда и его коллег с кафедры электротехники и компьютерных наук Массачусетского технологического института, NV-центры в алмазе решают извечную проблему легкого считывания информации из кубитов. Алмазы являются естественными излучателя - ми света, поэтому частицы света, испускаемые NV-центрами, сохраняют суперпозицию состояний, так что могут перемещать информацию между квантовыми вычислительными устройствами. Лучше всего они работают при комнатной температуре, не требуется охлаждение до –272 °C! По словам Энглунда, одним из подводных камней в случае NV-центров в алмазе является то, что они имеются только на 2 % поверхности алмаза. Поэтому исследователи разрабатывают процессы бомбардировки поверх - ности алмаза пучками электронов с целью создания большего количества NV-центров. Преимущества: продолжительное сохранение когерентности состояний — 10 с; высокий уровень успешного выполнения — 99,2 %;\n--- Страница 80 ---\n80 Глава 2 . Квантовые вычисления: искривление ткани самой реальности приличное количество (девять) запутанных кубитов, способных вы - полнять двухкубитные операции; кубиты функционируют при комнатных температурах. Это просто невероятно. Недостатки: малое количество NV-центров на поверхности материала — около 2 %; сложно произвести запутывание. В целом со времен Ричарда Фейнмана квантовые компьютеры прошли долгий путь развития благодаря ведущим мировым компаниям, стремя - щимся заработать. Прямо сейчас сверхпроводниковые контуры зани - мают лидирующие позиции. Однако благодаря новым исследованиям, например, NV-центров в алмазе, есть шанс реализовать мечту о крупно- масштабных квантовых вычислениях. Квантовые компьютеры в сравнении с традиционным аппаратным обеспечением Квантовые компьютеры превосходят классические машины при решении определенных задач. Рассмотрим табл. 2.7, в которой показаны времен - ные сложности двух конкретных задач для квантового и классического компьютеров. Таблица 2.7. Сравнение временной сложности некоторых задач при их решении на квантовом и классическом компьютерах Задача Квантовый компьютерВременная сложностьКлассический компьютерВременная сложность Поиск Алгоритм Гровера Быстрый поискn / 2 Факторизация больших чиселАлгоритм Шора Метод решета цифрового поля\n--- Страница 81 ---\nКвантовые компьютеры в сравнении с традиционными 81 Поиск по алгоритму Гровера обеспечивает лучшую производительность, чем традиционный. Это может сильно повлиять на центры обработки данных для таких компаний, как Google, MS и Yahoo. Представьте, что ваш веб-поиск основан на квантовых процессорах в облаке. Сейчас мы далеки от этого, но все же. Это одна из причин, по которой крупные IT- компании вкладывают значительные средства в разработку своих кван - товых платформ. Другая задача и, возможно, главная причина, по которой квантовые вы - числения набирают такие обороты, — это факторизация больших целых чисел. Когда Питер Шор придумал алгоритм квантовой факторизации, он нанес серьезный удар по криптографической безопасности, используемой сегодня повсеместно. Алгоритм Шора угрожает современным системам шифрования, быстро раскладывая на множители большие целые числа. Эти числа используются с целью создания криптографических ключей для кодирования всех данных в Интернете: банковских счетов, бизнес-транс - акций, чатов, видео с котиками и т. д. Алгоритм Шора настолько быстр, что фактически может вычислить самые большие целые числа за считаные минуты. Сравните это с нынешним классическим чемпионом — методом решета числового поля, которому могут понадобиться миллиарды лет для разложения таких чисел. Квантовые компьютеры могут быть бесценными инструментами не толь- ко в сферах поиска и шифрования, но и для симуляций, молекулярного моделирования, искусственного интеллекта, нейронных сетей и многого другого. Давайте посмотрим, как это происходит. Сложные симуляции Физики согласны с тем, что симуляции на атомном уровне — та область, в которой квантовые машины превзошли самих себя. В конце концов, это идеальное соответствие: машина, построенная на основе атомов, сможет симулировать квантово-механические системы с гораздо большей точ - ностью, чем классический компьютер. Было подсчитано , что квантовый\n--- Страница 82 ---\n82 Глава 2 . Квантовые вычисления: искривление ткани самой реальности компьютер с несколькими десятками квантовых битов может выполнять симуляцию, на которую классическому компьютеру потребуется неве - роятное количество времени. Например, модель Хаббарда, названную в честь британского физика Джона Хаббарда, которая описывает движение электронов в кристалле, можно симулировать квантовым компьютером1. По мнению Хаббарда, эта задача выходит за рамки возможностей клас - сического компьютера. Молекулярное моделирование и новые материалы В статье, опубликованной в журнале Science Magazine , сообщалось, что химики из Итальянского технологического института в Генуе смодели - ровали молекулу гидрида бериллия2 — соединения, состоящего из двух атомов водорода и одного атома бериллия, — в квантовом компьютере. Ничего особенного по сегодняшним классическим стандартам, однако это трамплин в будущее, полное надежд на открытие новых лекарств. Молекулярное моделирование — это непаханое поле для квантовых машин, поскольку физики и химики регулярно используют компьютеры для симуляции поведения атомов и молекул. Математики утвержда - ют, что большинство симуляций требует огромных вычислительных мощностей. Это особенно верно для молекулярного моделирования, поскольку с увеличением числа частиц взаимодействие между ними становится экспоненциально более сложным. Кроме того, странные законы квантовой механики затрудняют расчет распределения этих электронов в молекуле. Некоторые из экспериментов в данной области описаны в табл. 2.8. 1 Hubbard J. Electron Correlations in Narrow Energy Bands // Proceedings of the Royal Society of London 276 (1365): 238–257. 1963. Bibcode:1963RSPSA.276 238H. doi:10.1098/rspa.1963.0204. JSTOR 2414761. 2 Popkin G. Quantum computer simulates largest molecule yet. Sep. 13, 2017 // http:// www. sciencemag .org/news/2017/09/quantum-computer-simulates-largestmolecule- yet-sparking-hope-future-drug-discoveries.\n--- Страница 83 ---\nТаблица 2.8. Квантовые эксперименты по молекулярному моделированию Год Компания Эксперимент 2016 Google Исследователи из лаборатории квантовых вычислений в Венеции, штат Калифорния, использовали три кубита для расчета расположения электронов с наименьшей энергией в молекуле водорода 2017 IBM IBM разрабатывает интерактивный алгоритм для расчета основных состояний определенных молекул. Ученые применяли до шести сверхпроводниковых кубитов для анализа водорода, гидрида лития и гидрида бериллия, кодируя расположение электронов каждой молекулы в квантовом компьютере и переводя молекулу в ее основное состояние, которое они измеряли и кодировали на обычном компьютере В целом молекулярное моделирование имеет скромное начало, но его будущее выглядит блестящим для химических и фармацевтических компаний. Молекулярное моделирование намерено стать прекрасным приложением для квантовых вычислений. Усовершенствованное глубокое обучение Когда речь идет о глубоком обучении, традиционные задачи делятся на три категории: симуляция, оптимизация и сэмплирование. В предыду - щих разделах мы видели, насколько квантовый компьютер выделяется при симуляции, особенно на молекулярном и атомном уровнях, а что насчет оптимизации? Некоторые задачи оптимизации неразрешимы для традиционного оборудования из-за большого количества взаимодей - ствующих переменных, необходимых для их решения. К таким задачам относятся свертка белков, симуляция полета космического корабля и др. Квантовые компьютеры могут эффективно заниматься оптимизацией, используя технику, называемую стохастическим градиентным спуском. Это метод поиска лучшего решения среди большого набора возможных, сравнимый с поиском самой низкой точки ландшафта, состоящего из холмов и долин.Квантовые компьютеры в сравнении с традиционными 83\n--- Страница 84 ---\n84 Глава 2 . Квантовые вычисления: искривление ткани самой реальности ПРИМЕЧАНИЕ Канадская компания D-Wave уже продает коммерческие квантовые компьютеры, предназначенные для решения задач оптимизации с по- мощью стохастического градиентного спуска и других методов. Среди их клиентов — военно-промышленная компания Lockheed Martin и Google. Задачи квантового сэмплирования попадают в набор вычислительных задач, которые производят выборки из вероятностных распределений. Двумя классами задач сэмплирования, которые демонстрируют мощь квантовых алгоритмов, являются бозонное и мгновенное сэмплирование за квантовое полиномиальное время. Несколько мелкомасштабных реали - заций этих двух методов были выполнены с помощью квантовой оптики. На рис. 2.16 схематически изображена задача бозонного сэмплирования для образца с 32 модами. Пять фотонов (слева) вводятся в линейную сеть с матрицей рассеяния (внизу) , и все выходы наблюдаются в базисе Фока (справа) . Согласно статье А. П. Лунда, М. Дж. Бремнера и Т. С. Ральфа, опубликованной в Nature в разделе «Квантовая информация», эта задача неразрешима для классических компьютеров, даже для систем среднего масштаба, таких как 50 бозонов на 2500 траекториях. Даже для небольших систем (20 бозонов и 400 траекторий) неизвестен выполнимый классиче - ский алгоритм, который может реализовать эту симуляцию1. Рис. 2.16. Схема задачи бозонного сэмплирования 1 Lund A. P., Bremner M. J., Ralph T. C. Quantum sampling problems, BosonSampling and quantum supremacy // www.nature.com/articles/s41534-017-0018-2.\n--- Страница 85 ---\nНе так уж много для задач квантового сэмплирования, экспериментально демонстрирующих превосходство квантовых алгоритмов в данной об - ласти. Глубокое обучение и искусственный интеллект (ИИ) — вот две дисциплины, идущие рука об руку в сложных вычислениях с нейронными сетями, которые являются жемчужиной современных исследований. Квантовые нейронные сети и искусственный интеллект Квантовые нейронные сети (QNN) — пока больше научная фантастика, чем научный факт. Тем не менее теоретическая основа заложена в 1990-х го дах, и широко проводятся исследования по многим направлениям. Использование квантовой обработки информации для улучшения суще - ствующих моделей нейронных сетей1. Все дело в расширении существу - ющих моделей с помощью более быстрых и эффективных алгоритмов. Это область, где квантовые вычисления непревзойденны. Немаловаж - ным мотивом для этого исследования является сложность обучения классических нейронных сетей, особенно для приложений с большими данными. И есть надежда, что такие возможности квантовых вычис - лений, как параллелизм или эффекты интерференции и запутывания, могут сыграть на руку. Потенциальные квантовые эффекты в мозге2. Это направление объ - единяет квантовую физику и нейробиологию, здесь ведутся бурные дебаты, выходящие за рамки науки. Есть пионеры, усердно работающие в теоретической области квантовой биологии, которая набирает обороты благодаря следующим открытиям: •признакам эффективного переноса энергии при фотосинтезе за счет квантовых эффектов; •сообщениям об эффектах Mag-Lag у пациентов, прошедших МРТ, из-за чего предполагают, что тонкие взаимодействия в мозге могут быть квантовыми по своей природе. 1 Schuld M., Sinayskiy I., Petruccione F. The quest for a Quantum Neural Network // Quan - tum Information Processing, 13, 11. 2014. — Р. 2567–2586. 2 Loewenstein W. Physics in mind. A quantum view of the brain. Basic Books, 2013.Квантовые компьютеры в сравнении с традиционными 85\n--- Страница 86 ---\n86 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Квантовая ассоциативная память . Это новый алгоритм, введенный Дэном Вентурой и Тони Мартинесом в 1999 году1. Они предлагают квантовый компьютер на основе схем, имитирующий ассоциативную память. Алгоритм записывает состояния памяти в суперпозиции, а за- тем использует квантовый поиск, аналогичный алгоритму Гровера, для извлечения состояния памяти, наиболее близкого к заданному входу, с конечной целью — имитировать особенности человеческого мозга. Черные дыры. Хотите верьте, хотите нет, существуют идеи моделиро - вания черных дыр как QNN. А также предположения, что черные дыры и мозг могут хранить воспоминания схожим образом2. В целом, если в будущем человечество поработит квантовый компьютер, подобный SkyNet, возможно, он будет сделан из своего рода QNN. Прямо сейчас это может казаться шуткой, но великие ученые, такие как Стивен Хокинг, предупреждали об этом. Нам осталось только прислушаться. В следующем разделе рассмотрим подводные камни, из-за которых сложно построить квантовые компьютеры. Подводные камни квантовых компьютеров: декогеренция и интерференция Декогеренция и интерференция — базовые принципы квантовой меха - ники, вызывающие трудности при крупномасштабных квантовых вы - числениях. Декогеренция В квантовой механике частицы описываются волновой функцией. Фун - даментальное свойство квантовой механики называется когерентностью 1 Ventura D., Martinez T. A quantum associative memory based on Grover’s algorithm // Proceedings of the International Conference on Artificial Neural Networks and Genetics Algorithms, 1999. — Р. 22–27. 2 Dvali G. and colleagues. Black Holes as Brains: Neural Networks with Area Law Entropy // https://arxiv.org/pdf/1801.03918.pdf.\n--- Страница 87 ---\nПодводные камни квантовых компьютеров: декогеренция и интерференция 87 или определенным фазовым соотношением между состояниями. Коге - рентность необходима для функционирования квантовых компьютеров. Но когда квантовая система контактирует со своей средой, со временем когерентность ослабевает, и этот процесс называется квантовой декоге - ренцией . Формально декогеренция — это время, которое требуется для исчезновения суперпозиции состояний, и на него влияет вероятностный характер волновой функции. Эту ситуацию можно рассматривать как утечку информации из системы в окружающую среду. ПРИМЕЧАНИЕ Понятие декогеренции было введено немецким физиком Х. Дитером Цее в 1970 году, чтобы было проще понять коллапс волновой функции1. Декогеренцию можно обнаружить экспериментальным путем: квантовая механика говорит, что частицы могут находиться в нескольких состо - яниях (невозбужденном или возбужденном или в двух разных местах) одновременно. Только акт наблюдения дает случайное значение для конкретного состояния. Если возбуждение измеряется энергетическими уровнями частицы (где низкий энергетический уровень означает отсут - ствие возбуждения, а высокий — его наличие), когда электромагнитная волна посылается к частице с соответствующей частотой, будут проис - ходить колебания энергетических уровней частицы между высокими и низкими. Затем состояние частицы можно измерить и усреднить, создав так называемые осцилляции Раби. Поскольку частица никогда не бывает полностью изолирована из-за столкновений атомов, электромагнитных полей или тепловых резервуаров, например, то суперпозиция прекратится и колебания исчезнут. Таким образом, декогеренция дает информацию о взаимодействии квантового объекта и его среды, и это имеет решающее значение для 1 Schlosshauer M. Decoherence, the measurement problem, and interpretations of quantum mechanics // Reviews of Modern Physics, 76 (4), 2005. — Р. 1267–1305. arXiv:quant- ph/0312059 Freely accessible. Bibcode:2004RvMP…76.1267S. doi:10.1103/RevMod - Phys.76.1267.\n--- Страница 88 ---\n88 Глава 2 . Квантовые вычисления: искривление ткани самой реальности квантовых вычислений. То есть чем выше когерентность (время, в течение которого сохраняется суперпозиция), тем выше будет качество кубита. Некоторые виды кубитов, такие как сверхпроводящие контуры, сохра - няют когерентность состояний совсем недолго и должны находиться при очень низких температурах (–271 °C), чтобы противостоять этому эффекту. Другие, такие как ионные ловушки и NV-центры в алмазе, очень долго сохраняют когерентность состояний и могут находиться при комнатной температуре. Коммерческие предприятия, работающие в области создания квантовых компьютеров, сталкиваются с огромной проблемой, пытаясь бороться за сохранение когерентности состояний кубитов. Более подробное описание этих усилий смотрите в подразделе «Проектирование кубитов» на с. 72. Квантовая коррекция ошибок Квантовая коррекция ошибок (QEC) направлена на достижение от - казоустойчивых квантовых вычислений путем защиты информации от ошибок из-за декогеренции и других помех окружающей среды. Когда квантовый компьютер настраивает некоторые кубиты, он использует квантовые вентили, чтобы запутать их и манипулировать вероятностями, а затем, наконец измерив выходные коллапсирующие суперпозиции, по - лучает конечную последовательность из 0 или 1. Это означает, что серия вычислений в целом выполняется в тот момент, когда все ваши схемы отработали. В конечном счете вы можете измерить только один выход из всего спектра возможных решений. У каждого возможного решения есть вероятность оказаться правильным, поэтому его, возможно, придется перепроверить и попытаться получить повторно. Этот процесс называется квантовой коррекцией ошибок. В классическом мире коррекция ошибок выполняется с избыточно - стью, то есть путем создания копий данных, последующего присвоения вероятностей возможным условиям возникновения ошибки и, наконец, сравнения условия с наибольшей вероятностью с исходным сообщением, чтобы определить, произошла ли ошибка. Чтобы проиллюстрировать этот процесс, рассмотрим следующую таблицу, представляющую один бит информации.\n--- Страница 89 ---\nПодводные камни квантовых компьютеров: декогеренция и интерференция 89 Сообщение Избыточные копии Ошибка (1) Ошибка (1, 2) 0 0 1 1 0 0 1 0 0 0 Вероятность (1 / 3) = 0,33 (1 / 3) · (1 / 3) = 0,11 Допустим, есть однобитовое сообщение (0) и мы создаем три избыточные копии для исправления ошибок. Предполагая, что ошибки, вызванные шумами, независимы и происходят с некоторой вероятностью, более вероятно, что ошибка возникает в одном бите, а переданное сообщение равно трем 0. Возможно также, что появляется двухбитовая ошибка и пере- данное сообщение равно трем 1, но этот результат менее вероятен. Таким образом, мы можем использовать этот метод для исправления сообщения в случае ошибок в классической системе. К сожалению, это невозможно в квантовых масштабах из-за теоремы о запрете клонирования квантовых состояний (no-cloning theorem). ПРИМЕЧАНИЕ Теорема о запрете клонирования квантовых состояний утверждает, что невозможно создать точную копию произвольного неизвестного квантового состояния. Она была сформулирована и доказана физиком Джеймсом Л. Парком в 1970 году1. Теорема о запрете клонирования создает проблемы для квантовых вы - числений, поскольку для исправления ошибок нельзя создавать избы - точные копии кубитов. Тем не менее можно распространить информацию одного кубита на сильно запутанное состояние нескольких физических кубитов. Эта техника была открыта Питером Шором с помощью метода с использованием кода коррекции ошибок путем хранения информации одного кубита на девяти запутанных кубитах. Однако данная схема предотвращает появление лишь некоторых ошибок. Со временем было 1 Wootters W., Zurek W. A Single Quantum Cannot be Cloned // Nature, 299, 1982. — Р. 802–803. Bibcode:1982Natur.299 802W.doi:10.1038/299802a0.\n--- Страница 90 ---\n90 Глава 2 . Квантовые вычисления: искривление ткани самой реальности разработано несколько схем квантовых кодов коррекции ошибок. Наи - более значимыми являются следующие. Трехкубитный код Это основная отправная точка для квантовой коррекции ошибок. Метод кодирует один логический кубит в три физических так, что может испра - вить единичную ошибку инвертирования разрядов в матрице Паули Х (σx). Этот код способен исправлять ошибки без измерения состояния исходного кубита с помощью двух дополнительных кубитов для извлечения так называемой информации о синдроме (информации о возможных ошиб - ках) из блока данных и не нарушая исходное состояние. Однако этот код не может исправлять битовые и фазовые (знаковые) инвертирования разрядов одновременно, возможно только однобитовое инвертирование. Питер Шор использовал данный метод для разработки девятикубитного кода, исправляющего ошибки. Код Шора Этот код коррекции ошибок основан на трехкубитном коде и способен исправлять инверсию битов, инверсию знака или то и другое одновре - менно. Код Шора работает путем кодирования одного логического кубита в девять физических кубитов, задействуя это дополнительное реальное состояние для хранения информации о синдроме возможных ошибок. Обратите внимание, что этот код может исправлять ошибки только в од- ном кубите. Код, как правило, проще и позволяет создавать структуры схем, лучше совместимые с физическими ограничениями компьютерной архитектуры. Другие современные разработки в области квантовой кор - рекции ошибок включают: бозонные коды — пытаются хранить информацию об исправлении ошибок в бозонных модах, используя то преимущество, что осцилля - торы имеют бесконечно большое количество уровней энергии в одной физической системе1; 1 Cochrane P. T., Milburn G. J., Munro W. J. Macroscopically distinct quantumsuperposition states as a bosonic code for amplitude damping // Physical Review A, 59 (4), 1999. — Р. 2631–2634. doi:10.1103/PhysRevA.59.2631.\n--- Страница 91 ---\nПроцессор на 50 кубитах и задача для квантового превосходства 91 топологические коды — были введены физиком Алексеем Китаевым при разработке торического кода для исправления топологических ошибок. Структура этого кода определяется на двумерной решетке с использованием цепочек ошибок, которые определяют нетривиальные топологические пути по поверхности кода1. В общем, декогеренция и коррекция квантовых ошибок не облегчают ра - боту ИТ-компаний, стремящихся реализовать мечту о крупномасштабных отказоустойчивых квантовых вычислениях. Тем не менее прогресс идет быстрыми темпами благодаря новым конструкциям кубитов с длительным сохранением когерентности состояний и улучшенным кодам квантовой коррекции ошибок. На самом деле темп такой быстрый, что эксперты в этой области придумали новый звучный термин для крупномасштабных квантовых вычислений — квантовое превосходство . Процессор на 50 кубитах и задача для квантового превосходства Квантовое превосходство — звучный термин. Он был придуман физиком Джоном Прескиллом, чтобы описать переломный момент, при котором квантовый компьютер сможет решать задачи, неразрешимые для клас - сических компьютеров. Это очень мощное утверждение, так как оно требует доказательства суперполиномиального ускорения по сравнению с лучшими классическими аналогами. ПРИМЕЧАНИЕ Суперполиномиальное ускорение — это улучшение времени выпол - нения алгоритма до выхода за пределы полиномиального времени. Например, алгоритм, который выполняется за время k1nc1 + k2nc2 +…, где k и c — произвольные константы, а n — размер входных данных, назы - вается полиномиальным временем. Алгоритм, время работы которого 2n, где n — размер входного сигнала, называется алгоритмом суперполи - номиального времени. 1 Kitaev A. Y. Quantum Computations: algorithms and error correction. 52:1191, 1997.\n--- Страница 92 ---\n92 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Исследователи усердно трудятся над доказательством квантового пре - восходства с помощью нескольких уже существующих алгоритмов, которые обеспечивают суперполиномиальное ускорение, превосходя классических чемпионов. Далее подробно описывается хроника этой деятельности. 1982 год. Ричард Фейнман, гигант квантовой механики, предлагает квантовый компьютер, который может использовать атомные принципы суперпозиции, интерференции и запутывания. Такая машина изменит правила игры. 1994 год. Математик Питер Шор предлагает пресловутый алгоритм факторизации для квантового компьютера. Алгоритм признается сенсацией, когда становится понятно, что по временной сложности он обошел классического суперчемпиона (метод решета числового поля, NFS) благодаря суперполиномиальным ускорениям. Алгоритм не реа- лизован и не доказан экспериментально, тем не менее джинн вылетел из бутылки, так как волнение нарастает почти так же быстро, как ускорение алгоритма Шора по сравнению с NFS. 2012 год. Физик Джон Прекилл ввел термин «квантовое превосходство» в статье «Квантовые вычисления и граница запутанности», чтобы фор - мально описать момент, когда квантовые компьютеры возьмут верх. Гонка идет среди гигантов информационных технологий. 2016 год. Google, крупнейший поисковик, решает взять на себя задачу доказать квантовое превосходство к концу 2017 года, создав 49-кубит - ный чип, который сможет производить выборки из распределений, недоступные для любых современных классических компьютеров, за разумное время. Усилия не увенчались успехом. 2017 год. Исследователи из лаборатории Т. Дж. Уотсона в IBM симу - лируют 49- и 56-кубитные схемы на обычном суперкомпьютере Blue Gene/Q в Ливерморской национальной лаборатории им. Лоуренса, увеличивая количество кубитов, необходимых для квантового пре - восходства1. 1 Pednault E. and colleagues. Breaking the 49-Qubit Barrier in the Simulation of Quantum Circuits // https://arxiv.org/pdf/1710.05867.pdf.\n--- Страница 93 ---\nПолемика о квантовом отжиге и минимизации энергии 93 2018 год. Растет скептицизм по поводу доказательства квантового превосходства, поскольку подводные камни квантовых вычислений становятся все более очевидными: оценки квантовой коррекции ошибок достигают 3 % от входных данных в каждом цикле. Квантовые компью - теры намного более зашумлены и сильнее подвержены ошибкам по сравнению с классическими аналогами. Отказоустойчивый квантовый компьютер становится Святым Граалем. Несмотря на то что до окончательного доказательства квантового пре - восходства еще далеко, ИТ-специалисты считают, что компании начнут получать отдачу от инвестиций в квантовые технологии в ближайшие несколько лет. Когда или при каком количестве кубитов наступит это так называемое квантовое превосходство, когда даже суперкомпьютеры не смогут держать марку? Хотите верьте, хотите нет, но в Канаде есть компания D-Wave Systems, которая продает 2000-кубитные компьютеры для коммерческого использования. Правда, их работа остается противо - речивой из-за процесса, называемого квантовым отжигом. В следующем разделе показано почему. Полемика о квантовом отжиге и минимизации энергии Квантовый отжиг (QA), иногда называемый адиабатическими кванто - выми вычислениями (AQC), является формой квантовых вычислений с использованием адиабатической теоремы. Не вдаваясь в технические подробности, приведу список концепций, облегчающих понимание этого процесса. Адиабатическая теорема . Предложена Максом Борном и Владимиром Фоком в 1928 году. Она гласит: «Квантово-механическая система, под - верженная постепенному изменению внешних условий, адаптирует свою функциональную форму, но, когда подвергается быстро меня- ющимся условиям, для адаптации функциональной формы недоста - точно времени, поэтому пространственная плотность вероятности остается неизменной».\n--- Страница 94 ---\n94 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Гамильтониан (H) . Важное понятие в квантовой механике, особенно для квантового отжига. В квантовой механике гамильтониан является оператором, соответствующим полной энергии системы в большинстве случаев. Другими словами, это сумма кинетических энергий всех частиц плюс потенциальная энергия частиц, связанных с системой. СОВЕТ Адиабатическую теорему легче понять, рассмотрев простой пример колебания маятника в вертикальной плоскости. Если опора маятника движется резко, режим колебаний изменится. Но если опора перемеща - ется очень медленно, движение маятника относительно нее останется неизменным. В этом суть адиабатического процесса: постепенное из - менение внешних условий позволяет системе адаптироваться так, что она сохраняет первоначальный характер. Схематично квантовый отжиг можно описать следующими шагами. 1. Найдите потенциально сложный гамильтониан, основное состояние которого описывает решение интересующей задачи. 2. Подготовьте систему с простым гамильтонианом и инициализируйте до основного состояния. 3. Используйте адиабатический процесс, чтобы развить простой гамиль - тониан в желаемый сложный гамильтониан. Согласно адиабатической теореме система остается в основном состоянии, таким образом, конеч - ное состояние системы описывает решение задачи. Пионером в этом виде квантовых вычислений является компания D-Wave Systems, которая продала несколько квантовых компьютеров с довольно большим количеством кубитов. Две тысячи кубитов: все не так, как кажется Рассмотрим хронику для серий квантовых систем, проданных D-Wave. 2007 год. D-Wave продемонстрировала свое первое 16-кубитное обо - рудование.\n--- Страница 95 ---\nПолемика о квантовом отжиге и минимизации энергии 95 2011 год. D-Wave One, 128-кубитный компьютер, проданный Lockheed Martin за 10 миллионов долларов. 2013 год. D-Wave Two, 512-кубитный компьютер, проданный Google для лаборатории квантового искусственного интеллекта, пытающейся доказать квантовое превосходство. 2015 год. D-Wave 2X, преодолел 1000-кубитный предел, продан неиз - вестному покупателю. 2017 год. D-Wave 2000Q, их последний, 2000-кубитный компьютер, проданный фирме, занимающейся обеспечением кибербезопасности, под названием Temporal Defense Systems за 15 миллионов долларов. Трудно поверить в то, что 2000-кубитный квантовый компьютер уже продан, когда такие гиганты, как IBM и Google, только начинают созда - вать 16-кубитные системы. Это притом, что IBM — компания, которая специализируется на крупномасштабном оборудовании и располагает самыми большими капиталами среди всех. Однако здесь дело в том, что, несмотря на большое количество кубитов, D-Wave 2000Q не способен решить большинство задач, с которыми может столкнуться система IBM Q. На самом деле компьютер D-Wave может решать только задачи квантового отжига, то есть задачи, решаемые в соответствии с адиабатической теоремой. Квантовый отжиг: подмножество квантовых вычислений Специалисты в данной области назвали квантовый отжиг ограничитель - ным, что вызвало некоторые споры ввиду следующих фактов. Платформы наподобие IBM Q используют логические вентили для управления кубитами , тогда как компьютеры, реализующие кванто - вый отжиг, их не содержат и поэтому не могут полностью управлять состояниями кубитов. Системы D-Wave отличаются тем, что их кубиты стремятся к мини - мальному состоянию энергии. Ими нельзя управлять с помощью кван - товых вентилей, но их поведение можно предсказать по адиабатическо й\n--- Страница 96 ---\n96 Глава 2 . Квантовые вычисления: искривление ткани самой реальности теореме. Это делает их хорошим инструментом для решения задач минимизации энергии. Квантовый отжиг применяется главным образом для задач комбина - торной оптимизации, где пространство поиска дискретно с локальным минимумом (например, для нахождения основного состояния разупо - рядоченного магнетика или спинового стекла1). QA пользуется тем, что все физические системы стремятся к состоянию с минимальной энергией. Проиллюстрируем это на примере чашки горячего кофе: если на некоторое время оставить ее на прилавке, кофе начнет остывать, пока не достигнет температуры, равной температуре окружающей среды. Таким образом, кофе стремится к состоянию с минимальной энергией. ПРИМЕЧАНИЕ Математическая оптимизация — метод из семейства локального поиска. Это итеративный метод, который начинается с произвольного решения задачи, а затем пытается найти лучшее решение, постепенно изменяя один из его элементов. Если это приводит к лучшему решению, в него вносятся дополнительные изменения, повторяющиеся до тех пор, пока не будут найдены более оптимальные решения. Вопрос о том, сможет ли машина D-Wave QA превзойти классические компьютеры, остается без ответа. Есть несколько исследований, каждое из которых идет своим путем: в январе 2016 года ученые из Google исполь - зовали систему D-Wave для проведения серии тестов по туннелированию с конечным радиусом действия с QA-решателем в сравнении с имитацией отжига (SA) и симулированным квантовым методом Монте-Карло (QMC) на одноядерном классическом процессоре2. Результат: QA-решатель пре - взошел SA и QMC в 108 раз. 1 Ray P., Chakrabarti B. K., Chakrabarti A. Sherrington-Kirkpatrick model in a transverse field: Absence of replica symmetry breaking due to quantum fluctuations // Phys. Rev. B 39, 11828. 1989. 2 Denchev V. S. and colleagues. What is the Computational Value of Finite Range Tunnel - ing? // Google Labs, Jan 2016 // https://arxiv.org/pdf/1512.02206.pdf.\n--- Страница 97 ---\nПолемика о квантовом отжиге и минимизации энергии 97 Это впечатляет. Однако другие говорят, что не стоит торопиться: иссле - дователи из Швейцарского федерального технологического института не сделали заявления о существенном ускорении для чипа D-Wave, но не исключили того, что его можно достичь в будущем. На рис. 2.17 показаны основные внутренние процессы процессора QA, такого как в D-Wave. Он состоит из двумерного массива кубитов из сверхпроводящих контуров, которые переносят электрический ток. Ку - биты действуют как магниты, которые могут указывать вверх, вниз или, согласно свойствам квантовой механики, вверх и вниз одновременно. Каждый кубит в массиве может взаимодействовать с другими через свя - зующие элементы, которые можно запрограммировать так, чтобы они могли снизить свою энергию, указывая в том же или противоположном направлении. Идея состоит в том, чтобы закодировать задачу, указав все возможные взаимодействия в микросхеме, и решить ее, найдя минималь - ную энергию или основное состояние кубита. Рис. 2.17. Схема процессора на основе квантового отжига\n--- Страница 98 ---\n98 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Чтобы найти основное состояние, машина запускает массив в запутан - ном состоянии и медленно начинает взаимодействия. Затем система ищет состояние с самой низкой энергией аналогично тому, как шарик катится по неровной поверхности в поисках наиболее глубокой точки. В классической физике колебания тепловой энергии ведут шар к ниж- ней точке, это называется термическим отжигом . Однако в квантовой механике шар может пройти через низкие точки, чтобы еще быстрее найти самые низкие. Это причина, по которой квантовый отжиг счи - тается более быстрым для таких задач, как распознавание образов или машинное обучение. Таким образом, архитектура D-Wave отличается от архитектуры тради - ционных квантовых компьютеров тем, что может решить только задачу минимизации энергии. Это привело к полемике с некоторыми сотрудни - ками из IBM, назвавшими ее тупиковой. Даже ученые из Google, которые проводили эксперимент с QA на D-Wave 2X для примеров бинарной оптимизации K-го порядка, в своих сводках утверждали, что имитация отжига — для «невежественных или отчаянных». Усилил полемику тот факт, что D-Wave не может выполнить алгоритм Шора, потому что это не процесс минимизации энергии. Шору требуется так называемый универсальный квантовый компьютер, который может выполнять любой квантовый алгоритм. Универсальные квантовые вычисления и будущее Универсальный квантовый компьютер, известный также как квантовая машина Тьюринга (QTM), является конечной квантовой машиной. Он был определен как абстрактная машина, способная охватить всю мощь квантовых вычислений. То есть он способен выполнять любой квантовый алгоритм. Несмотря на то что на реализацию этой мечты потребуются десятилетия, началась новая глобальная гонка, в рамках которой крупные игроки ИТ-отрасли и правительства вкладывают значительные средства в исследования и разработку этих машин.\n--- Страница 99 ---\nУниверсальные квантовые вычисления и будущее 99 Google и квантовый искусственный интеллект Google был первым клиентом D-Wave и использовал их машины в се- рии экспериментов по оптимизации, результаты которых показали, что квантовый отжиг может протекать значительно быстрее, чем имитация отжига на одноядерном процессоре. Кроме того, Google объявил, что раз - рабатывает собственную технологию квантовых вычислений, что имеет смысл, учитывая количество ресурсов, находящихся в их распоряжении. Хотя в настоящее время ничего подходящего для демонстрации нет, по - хоже, что идет работа над гибридом, основанным на вентилях подхода IBM и квантовом отжиге D-Wave. Фактически в июне 2017 года Google объявил, что они тестируют кван - товый компьютер с 20 кубитами, надеясь к 2018 году создать компьютер с 49 кубитами. Кажется, они хотят бросить вызов IBM в достижении квантового превосходства. Google ясно дал понять, чего они хотят в об- ласти квантовых вычислений: создать искусственный интеллект (ИИ). В статье Commercialize Early Quantum Technologies для Springer Nature они представляют лабораторию квантового ИИ, организованную для создания отказоустойчивой квантовой машины, способной решить любые задачи. Усилия Google сосредоточены в трех ключевых областях машинного обучения и искусственного интеллекта. Симуляция . Одним из наиболее естественных способов применения является моделирование химических реакций и материалов: более проч - ных полимеров для самолетов, улучшенных каталитических нейтрализа - торов для автомобилей, более эффективных материалов для солнечных батарей, новых фармацевтических препаратов и воздухопроницаемых тканей. Квантовые вычисления обещают сэкономить огромные суммы, перенеся компьютерную мощность, необходимую для создания этих материалов, на новый уровень. Разработка вычислительных материалов представляет собой крупную отрасль со множеством бизнес-моделей, созданных для квантового моделирования: оплата подписки на доступ, консультации, обмен акций на квантовые инновации и др. Оптимизация . Задачи оптимизации трудно решить на обычных ком - пьютерах. Лучшие классические методы используют статистические\n--- Страница 100 ---\n100 Глава 2 . Квантовые вычисления: искривление ткани самой реальности методы, такие как минимизация энергии (термический отжиг). Кван - товые принципы могут обеспечить значительное ускорение путем туннелирования через тепловые барьеры, чтобы найти минимально возможную точку или лучшее решение. В целом квантовая оптими - зация может быть полезна для большинства задач машинного обуче - ния. Логистические компании, диагностика пациентов в учре ждениях здравоохранения и компании, занимающиеся поиском в Сети, могут получить значительные инновации. Сэмплирование . В основном связана с задачами машинного обучения, такими как вывод и распознавание образов. Квантовое сэмплирование может обеспечить превосходную производительность в запросах с распре - делением вероятностей. И не только это. Благодаря значительному парал - лелизму, достигнутому квантовыми компьютерами, можно использовать сэмплирование, чтобы окончательно доказать квантовое превосходство. Google делает большие ставки на квантовую оптимизацию и управление рисками в будущем, но сейчас у IBM есть преимущество: 20-кубит - ная платформа для коммерческих клиентов и 16-битная бесплатная Q Experience для всех облачных платформ. Одно можно сказать наверняка: в ближайшее время у каждого крупного поставщика появятся облачные квантовые платформы. Квантовые машины в центрах обработки Проектирование и конструирование кубитов основано на экстремаль - ных разработках. Поскольку квантовая механика имеет странную природу, кубиты очень чувствительны к шуму окружающей среды, склонны к ошибкам из-за принципа декогеренции, вдобавок, как пра - вило, трудно управлять ими и создавать их в больших масштабах. Та - ким образом, не ожидайте, что вскоре увидите квантовый компьютер в местном магазине. Не рассчитывайте, что в ближайшие десятилетия ваш внук сможет купить квантовый компьютер и поставить его в го- стиной. Если не будет существенного прогресса в технологиях, это вряд ли произойдет вообще. Частично это связано с тем, что кубиты\n--- Страница 101 ---\nУниверсальные квантовые вычисления и будущее 101 должны храниться при ультранизкой температуре (0,015 К, или около –273 °С), чтобы избежать воздействия шума от окружающей среды. Для того чтобы иметь некоторое представление об этой температуре, рассмотрите таблицу, в которой приведены средние температуры для различных областей Вселенной. Объект Температура, К Температура, °С Кубит 0,015 –273 Космический вакуум (температура, создаваемая равномерным фоновым излучением или послесвечениями после Большого взрыва)2,7 –270 Средняя температура Земли 331 58 Температура Луны в дневное/ночное время 373/100 100/–173 ПРИМЕЧАНИЕ Кельвин — основная единица измерения температуры в физике. В клас- сической термодинамике ноль по шкале Кельвина определяется как абсолютный ноль или температура, при которой все тепловые движения прекращаются. В краткосрочной перспективе очень вероятно, что квантовые компьютеры заполонят центры обработки данных. Это означает, что они не придут на смену персональным, а будут выполнять большинство сложных задач, таких как поиск, симуляция, моделирование и др. Кроме того, инсайдеры ожидают, что квантовые компьютеры дополнят традиционные, в резуль - тате чего можно будет развивать такие сферы, такие как шифрование, научная разведка и искусственный интеллект. Итак, через несколько лет можно ожидать, что цифровой помощник в вашем телефоне или дома будет работать на базе квантового компью - тера. Вот еще пища для размышлений: примерно через десять лет мы будем проводить большую часть нашего времени, общаясь с квантовыми компьютерами.\n--- Страница 102 ---\n102 Глава 2 . Квантовые вычисления: искривление ткани самой реальности Гонка становится глобальной Происходит переход на новый уровень, когда в игру вступают правитель - ства, обеспечивающие крупные инвестиции в этой области. Согласно пресс-релизу Digital Single Market, Европейская комиссия планирует начиная с 2018 года вложить 1 миллиард евро в создание Единого циф - рового рынка (со значительным финансированием в течение следующих 20 лет1). Это дополнительные инвестиции к 550 млн евро, потраченным на отдельные инициативы, чтобы вывести Европу в авангард того, что они считают второй квантовой революцией. Кроме того, согласно пресс-релизу Alibaba Cloud, выпущенному в июле 2015 года, Китайская академия наук (CAS) объединяется с Alibaba, крупнейшим игроком в области электронной коммерции в Китае, для соз - дания лаборатории квантовых вычислений CAS . Квантовые вычисления превратились в глобальную гонку, и последствия будут значительными. Будущие приложения Нет предела тому, чего можно достичь благодаря огромному потенциалу квантовых вычислений. Приведу примеры возможных будущих приложе - ний и описание того, как они повлияют на наше общество, в следующих отраслях. Авиационная промышленность . Авиастроительные компании корпят над разработкой и использованием квантовых алгоритмов для модели - рования воздушного потока, позволяющих сэкономить годы по срав - нению со своими классическими аналогами. Это приведет к созданию за короткий промежуток времени более надежного и эффективного самолета с низким уровнем шума и выбросов. Освоение космоса . НАСА играло с системой D-Wave, решая различные задачи, начиная от оптимальных конструкций до оптимального разме - щения коммерческих грузов в космическом корабле. Другие приложе - 1 European Commission will launch 1 billion quantum technologies flagship // Digital Single Market // https://ec.europa.eu/digital-single-market/en/news/european- commission-will-launch-eu1-billion-quantum-technologies-flagship.\n--- Страница 103 ---\nУниверсальные квантовые вычисления и будущее 103 ния включают в себя алгоритмы квантового искусственного интеллекта и квантово-классические гибридные алгоритмы. Медицина . Квантовые вычисления могут обеспечить превосходное молекулярное моделирование, что приведет к молниеносному моде - лированию белка, более быстрому появлению и тестированию новых лекарств. Это сократит жизненный цикл их доставки пациенту. Лекар - ства следующего поколения и средства от рака — в наших руках. Это лишь некоторые из возможных способов применения квантовых вычислений. Обратите внимание, что я не упоминаю существующие достижения, такие как шифрование данных и безопасность: квантовая факторизация и возможность победить асимметричное шифрование, вероятно, являются основными причинами, по которым квантовые вы - числения в последнее время набирают обороты. В следующей главе вы познакомитесь с IBM Q Experience. Это первая платформа квантовых вы - числений в облаке, которая предоставляет реальные квантовые устройства для использования по своему усмотрению.\n--- Страница 104 ---\n3IBM Q Experience: уникальная платформа для квантовых вычислений в облаке В этой главе мы рассмотрим квантовые вычисления в облаке с помощью IBM Q Experience — первой платформы такого типа. Глава начинается с обзора Composer — веб-консоли, используемой для визуального созда - ния схем, запуска экспериментов, исследования аппаратных устройств и многого другого. Далее вы узнаете, как создать свой первый эксперимент и запустить его на симуляторе или реальном квантовом устройстве. IBM Q Experience обладает мощным REST API для управления жизненным циклом эксперимента, и в главе будет показано, как это делать, с подроб - ным описанием конечных точек и параметров запроса. Глава заканчивается примером практической реализации официальной библиотеки Python (названной IBMQuantumExperience) для Node JS. Эта пользовательская библиотека Node JS позволит проверить ваши навыки работы с асинхрон - ным JavaScript и REST API. Приступим! IBM, безусловно, занимает первое место в гонке квантовых вычисле - ний в облаке. Они придумали действительно классную платформу для удаленного запуска экспериментов под названием Q Experience. Мне кажется или в названиях этих инструментов действительно много анало - гий с теорией музыки? Проверим: визуальный редактор, используемый для создания квантовых схем, называется Composer («Композитор»). Не странно ли? Квантовые схемы, построенные с помощью редакто - ра, называются партитурами (как в нотах), не говоря уже о том, что\n--- Страница 105 ---\nПервое знакомство с IBM Q Experience 105 визуально окно редактора о чень похоже на страницу нотной тетради. Я давно играю на классической гитаре и, только взглянув на Composer, сразу вспомнил гитарную партитуру (с вентилями, напоминающими ноты). Все еще думаете, что я сумасшедший? Платформа называется Q Experience, а вы когда-нибудь слышали о Experience Джимми Хен - дрикса? Возможно, Composer — это сборник партитур, в котором вы создадите великолепный шедевр, чтобы все мы смогли им наслаждаться. Квантовые вычисления действительно способны изменить текущее положение дел. Первое знакомство с IBM Q Experience Q Experience — это платформа IBM для квантовых вычислений в облаке, и она действительно крутая. Давайте посмотрим (все материалы публи - куются с разрешения © International Business Machines Corporation). 1. Создайте аккаунт на https://quantumexperience.ng.bluemix.net/qx/experience . Вам понадобится указать адрес электронной почте. Затем дождитесь письма-подтверждения и продолжите регистрацию. 2. Войдите в веб-консоль и перейдите на вкладку Composer вверху (рис. 3.1). Рис. 3.1. Главное окно IBM Q Experience\n--- Страница 106 ---\n106 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Квантовый Composer Composer — это визуальный инструмент для создания квантовых схем, или партитур. Вверху показана гистограмма эксперимента с доступными для использования кубитами (рис. 3.2). Рис. 3.2. Окно эксперимента в Composer В левой части гистограммы видны пять кубитов, доступных из процессора ibmqx4. Все они инициализированы в основное состояние |0 〉. Линия вни- зу — это линия измерения, где будут собраны результаты схемы. Помните, что измерение должно выполняться последним в схеме, так как все опе - рации вентилей выполняются параллельно и с наложением состояний. В правой части — квантовые вентили. Перетащите их к местоположе - нию определенного кубита на гистограмме, чтобы начать строить схему. Квантовые вентили Квантовые вентили, поддерживаемые IBM Q Experience, описаны в табл. 3.1. Таблица 3.1. Квантовые вентили для IBM Q Experience Вентиль Описание Паули Х Вращает кубит на 180° вокруг оси X. Преобразует в и — в . Известен также как инвертирование разрядов или НЕ-вентиль. Представлен м атрицей",
      "debug": {
        "start_page": 48,
        "end_page": 106
      }
    },
    {
      "name": "Глава 3. IBM Q Experience: уникальная платформа для квантовых вычислений в облаке 104",
      "content": "--- Страница 109 ---\nПервое знакомство с IBM Q Experience 109 Рис. 3.3. Редактор экспериментов в режиме QASM ПРИМЕЧАНИЕ QASM — это квантовый язык ассемблера, созданный на базе плат - формы OPENQASM. Используется для экспериментов с неглубокими квантовыми схемами. Несмотря на то что умение писать на ассемблере стало чем-то вроде утраченного искусства, некоторым QASM может показаться более удобным, чем Python SDK или даже визуальный редактор. Теперь рассмотрим различные квантовые процессоры. Доступное квантовое серверное ПО Есть несколько квантовых процессоров, которые можно выбрать для проведения экспериментов. В табл. 3.2 приведен официальный список, ранжированный в соответствии с количеством кубитов (по информации с сайта о серверном ПО для IBM Q Experience).\n--- Страница 110 ---\n110 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Таблица 3.2. Официальный список квантового серверного ПО, доступного для пользователей IBM Q Experience Наименование Подробности Ibmqx2 Условное название: Sparrow. Количество кубитов: 5. Доступен онлайн с 24 января 2017 года Ibmqx4 Условное название: Raven. Количество кубитов: 5. Доступен онлайн с 25 сентября 2017 года Ibmqx3 Условное название: Albatross. Количество кубитов: 16. Доступен онлайн с июня 2017 года Ibmqx5 Условное название: Albatross. Количество кубитов: 16. Доступен онлайн с 28 сентября 2017 года В табл. 3.2 приведен официальный список процессоров, доступных на момент написания книги, но существует куда более интересный способ получить обновленный список доступных машин в реальном времени с помощью превосходного REST API. Более подробное описание этого API дано в разделе «Удаленный доступ через REST API» текущей гла - вы, а пока продемонстрирую, как получить всегда актуальный список серверного ПО, используя конечную точку REST Available Backend List : https://quantumexperience.ng.bluemix.net/api/Backends?access_token=ACCESS- TOKEN . СОВЕТ Чтобы получить токен доступа, смотрите подраздел «Аутентифика - ция» раздела «Удаленный доступ через REST API» на с. 130. Обратите внимание, что токен API не совпадает с токеном доступа. Токены API используются для выполнения квантовых программ через Python SDK. Токены доступа применяются для вызова REST API.\n--- Страница 111 ---\nПервое знакомство с IBM Q Experience 111 Перейдя по URL, приведенному в предыдущем абзаце, вы увидите список квантовых процессоров в формате JSON. Вот как это выглядит на момент написания книги (листинг 3.1). Учтите, что полученный вами результат может отличаться. Листинг 3.1. HTTP-ответ на вызов Backend Information REST API [{ \"name\": \"ibmqx2\", \"version\": \"1\", \"status\": \"on\", \"serialNumber\": \"Real5Qv2\", \"description\": \"5 transmon bowtie\", \"basisGates\": \"u1,u2,u3,cx,id\", \"onlineDate\": \"2017-01-10T12:00:00.000Z\", \"chipName\": \"Sparrow\", \"id\": \"28147a578bdc88ec8087af46ede526e1\", \"topologyId\": \"250e969c6b9e68aa2a045ffbceb3ac33\", \"url\": \"https://ibm.biz/qiskit-ibmqx2\", \"simulator\": false, \"nQubits\": 5, \"couplingMap\": [ [0, 1], [0, 2], [1, 2], [3, 2], [3, 4], [4, 2] ] }, { \"name\": \"ibmqx5\", \"version\": \"1\", \"status\": \"on\", \"serialNumber\": \"ibmqx5\", \"description\": \"16 transmon 2x8 ladder\", \"basisGates\": \"u1,u2,u3,cx,id\", \"onlineDate\": \"2017-09-21T11:00:00.000Z\", \"chipName\": \"Albatross\", \"id\": \"f451527ae7b9c9998e7addf1067c0df4\", \"topologyId\": \"ad8b182a0653f51dfbd5d66c33fd08c7\", \"url\": \"https://ibm.biz/qiskit-ibmqx5\", \"simulator\": false, \"nQubits\": 16, \"couplingMap\": [ [1, 0], …\n--- Страница 112 ---\n112 Глава 3 . IBM Q Experience: платформа для вычислений в облаке [15, 14] ] }, { \"name\": \"Device Real5Qv1\", \"status\": \"off\", \"serialNumber\": \"Real5Qv1\", \"description\": \"Device Real5Qv1\", \"id\": \"cc7f910ff2e6860e0d4918e9ee0ebae0\", \"topologyId\": \"250e969c6b9e68aa2a045ffbceb3ac33\", \"simulator\": false, \"nQubits\": 5, \"couplingMap\": [ [0, 1], [0, 2], [1, 2], [3, 2], [3, 4], [4, 2] ] }, { \"name\": \"ibmqx_hpc_qasm_simulator\", \"status\": \"on\", \"serialNumber\": \"hpc-simulator\", \"basisGates\": \"u1,u2,u3,cx,id\", \"onlineDate\": \"2017-12-09T12:00:00.000Z\", \"id\": \"084e8de73c4d16330550c34cf97de3f2\", \"topologyId\": \"7ca1eda6c4bff274c38d1fe66c449dff\", \"simulator\": true, \"nQubits\": 32, \"couplingMap\": \"all-to-all\" }, { \"name\": \"ibmqx4\", \"version\": \"1\", \"status\": \"on\", \"serialNumber\": \"ibmqx4\", \"description\": \"5 qubits transmon bowtie chip 3\", \"basisGates\": \"u1,u2,u3,cx,id\", \"onlineDate\": \"2017-09-18T11:00:00.000Z\", \"chipName\": \"Raven\", \"id\": \"c16c5ddebbf8922a7e2a0f5a89cac478\", \"topologyId\": \"3b8e671a5a3b56899e6e601e6a3816a1\", \"url\": \"https://ibm.biz/qiskit-ibmqx4\", \"simulator\": false, \"nQubits\": 5, \"couplingMap\": [ [1, 0], [2, 0], [2, 1],\n--- Страница 113 ---\nПервое знакомство с IBM Q Experience 113 [2, 4], [3, 2], [3, 4] ] }, { \"name\": \"ibmqx3\", \"version\": \"1\", \"status\": \"off\", \"serialNumber\": \"ibmqx3\", \"description\": \"16 transmon 2x8 ladder\", \"basisGates\": \"u1,u2,u3,cx,id\", \"onlineDate\": \"2017-06-06T11:00:00.000Z\", \"chipName\": \"Albatross\", \"id\": \"2bcc3cdb587d1bef305ac14447b9b0a6\", \"topologyId\": \"db99eef232f426b45d2d147359580bc6\", \"url\": \"https://ibm.biz/qiskit-ibmqx3\", \"simulator\": false, \"nQubits\": 16, \"couplingMap\": [ … ] }, { \"name\": \"QS1_1\", \"version\": \"1\", \"status\": \"standby\", \"serialNumber\": \"QS1_1\", \"description\": \"20 qubit device v1\", \"basisGates\": \"SU2+CNOT\", \"onlineDate\": \"2017-10-20T11:00:00.000Z\", \"chipName\": \"Qubert\", \"id\": \"cb141f7bb641b8a10487a6fab8483b86\", \"topologyId\": \"25197b9b73c4b52ca713ca4d126417b5\", \"simulator\": false, \"nQubits\": 20, \"couplingMap\": [ … ] }, { \"name\": \"ibmqx_qasm_simulator\", \"status\": \"on\", \"description\": \"online qasm simulator\", \"basisGates\": \"u1,u2,u3,cx,id\", \"id\": \"18da019106bf6b5a55e0ef932763a670\", \"topologyId\": \"250e969c6b9e68aa2a045ffbceb3ac33\", \"simulator\": true, \"nQubits\": 24, \"couplingMap\": \"all-to-all\" }]\n--- Страница 114 ---\n114 Глава 3 . IBM Q Experience: платформа для вычислений в облаке В листинге 3.1 показан текущий список доступных процессоров, кото - рый по большей части совпадает с официальным перечнем с сайта IBM Q Experience. Тем не менее там есть много дополнительной интересной информации о конструктивных схемах машин. Дополнительные процессоры и симуляторы. •Похоже, что для использования доступны два удаленных симуля - тора — ibmqx_qasm_simulator и ibmqx_hpc_qasm_simulator , хотя в офи- циальной документации упоминается только ibmqx_qasm_simulator . Эта информация может пригодиться при тестировании сложных схем: чем больше симуляторов, тем лучше. •Уже давно ходят слухи о 20-кубитном процессоре. Поговаривают даже о запланированном выходе 50-кубитного монстра к концу 2018 года1. Этот список, по-видимому, подтверждает по крайней мере существование 20-кубитной машины. Но пока рано радоваться, она будет доступна только для корпоративных клиентов. Помимо обычной информации, такой как название машины, версия, состояние, количество кубитов и т. д., есть термины, с которыми мы должны ознакомиться. •basisGates — физические кубитные вентили процессора. Это основа, на которой могут быть построены более сложные логические элементы. Большинство процессоров в списке используют u1, u2, u3, cx, id: — вентили u1, u2, u3 называются частичными НЕ-вентилями , они вращают кубит вокруг осей X, Y, Z на θ, φ или λ радиан; — cx называется управляемым НЕ-вентилем (CNOT или CX). Он задействует два кубита и выполняет операцию НЕ на втором кубите, только когда первый кубит находится в состоянии , и оставляет его неизменным в противном случае; — id — это единичный вентиль, который выполняет операцию простоя (idle) на кубите в течение одной единицы времени. 1 IBM уже предоставляет доступ к Q System One с 20 кубитами и в ближайшее время откроет для партнеров доступ к квантовому компьютеру с 50 кубитами. — Примеч. ред.\n--- Страница 115 ---\nОпус 1: вариации на тему состояний Белла и GHZ 115 •couplingMap — карта связей. Определяет взаимодействия между от - дельными кубитами, сохраняя при этом квантовую когерентность (или чистое состояние — представьте, что солдаты, переходя реку по старому мосту, идут не в ногу, чтобы амплитуды их шагов не со- впали и это не привело к разрушению моста). Связывание кубитов в пары используется для упрощения квантовой схемы и позволяет разбить систему на более мелкие единицы. Теперь вернемся к Composer, чтобы создать первую квантовую компо - зицию. Опус 1: вариации на тему состояний Белла и GHZ Здесь мы рассмотрим два умопомрачительных квантовых эксперимента, используемых для демонстрации странности квантовой механики: состояния Белла — показывают, что физика не описывается локальной реальностью. Это то, что Эйнштейн назвал мистическим дальнодей - ствием ; GHZ-состояния — даже еще более странные, чем состояния Белла, GHZ- состояния (названные в честь своих создателей Гринбергера, Хорна и Цейлингера) являются трехкубитным обобщением состояний Белла. Рассмотрим их подробнее. Состояния Белла и мистическое дальнодействие Состояния Белла являются экспериментальной проверкой известных неравенств Белла. В 1964 году ирландский физик Джон Белл предложил способ проверки квантово й запутанности (мистического дальнодействия). Он вывел ряд неравенств, которые стали очень востребованы в физиче - ском сообществе. Они известны как неравенства Белла (сегодня называют теоремой Белла).\n--- Страница 116 ---\n116 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Рассмотрим поляризацию фотона (когда свет колеблется в определенной плоскости) под тремя углами: A = 0°, B = 120° и C = 240°. Здравый смысл подсказывает нам, что фотон имеет определенные значения одновременно для этих трех настроек поляризации и они должны соответствовать восьми случаям, приведенным в табл. 3.3. Таблица 3.3. Перестановки для поляризации фотонов под тремя углами Номер А (0°) В (120°) С (240°) [AB] [BC] [AC] Сумма Среднее 1 А+ В+ С+ 1(++) 1(++) 1(++) 3 1 2 А+ В+ С– 1(++) 0 0 1 1/3 3 А+ В– С+ 0 0 1(++) 1 1/3 4 А+ В– С– 0 1(––) 0 1 1/3 5 А– В+ С+ 0 1(++) 0 1 1/3 6 А– В+ С– 0 0 1(––) 1 1/3 7 А– В– С+ 1(––) 0 0 1 1/3 8 А– В– С– 1(––) 1(––) 1(––) 3 1 Теперь по теореме Белла зададимся вопросом: какова вероятность того, что поляризация у любого соседа будет такой же, как у первого? Мы также рассчитываем сумму и среднее значение поляризаций. Если предположить, что в реальности все именно так, то в соответствии с табл. 3.3 ответ на этот вопрос таков: вероятность должна быть больше или равна 1/3. Это то, что дает неравенство Белла: средство проверить данное утверждение. Но вот что невероятно: хотите верьте, хотите нет, квантовая механика противо - речит неравенству Белла, давая вероятности менее 1/3. Это было экспе - риментально доказано в 1982 году французским физиком Аленом Аспе. ПРИМЕЧАНИЕ Более подробное описание эксперимента Аспе и неравенства Белла приведено в разделе «ЭПР-парадокс разгромлен: Бор смеется послед - ним» главы 1. Итак, теперь переведем поляризацию фотонов из табл. 3.3 в эксперимент, который можно запустить на квантовом компьютере. В 1969 году Джон\n--- Страница 117 ---\nОпус 1: вариации на тему состояний Белла и GHZ 117 Клаузер, Майкл Хорн, Абнер Шимони и Ричард Холт представили до - казательство теоремы Белла — неравенство Клаузера — Хорна — Шимо - ни — Холта, которое формально утверждает1: Проиллюстрировать это нам помогут два персонажа, Алиса и Боб. На сто- роне Алисы имеются настройки детектора A и A', на стороне Боба — B и B', а также четыре комбинации для проверки в отдельных экспериментах. Реальное положение дел свидетельствует о том, что для пары запутанных частиц таблица четности, показывающая все возможные перестановки, выглядит следующим образом. А B 1 А B' 0 A' B 0 A' B' 1 В классическом реализме неравенство Клаузера — Хорна — Шимо - ни — Холта превращается в |S| = 2. Однако математический формализм квантовой механики предсказывает максимальное значение для S, соот - ветствующее , что нарушает это неравенство. Это можно проверить с помощью четырех отдельных квантовых схем (по одной на измерение) по два кубита в каждой. Для упрощения задачи примем, что измерения на детекторе Алисы A = Z и A' = X, а на детекторе Боба B = W и B' = V (табл. 3.4). Чтобы начать эксперимент, следует построить базовое состояние Белла (рис. 3.4), которое соответствует тождеству . Предыдущее выражение, по существу, означает, что кубит, находящийся у Алисы, может иметь значение 0 или 1. Если бы Алиса измерила свой кубит в стандартном базисе, результат был бы совершенно случайным с вероятностью 1/2 для каждого возможного варианта. И если бы Боб измерил свой кубит, результат был бы таким же, как у Алисы. Итак, если бы измерения выполнил Боб, то также получил бы результат, на первый взгляд кажущийся случайным, а если бы Алиса и Боб общались, 1 Скобки задают корреляции между результатами измерения (среднее произведения отдельных исходов экспериментов А и В). — Примеч. науч. ред.\n--- Страница 118 ---\n118 Глава 3 . IBM Q Experience: платформа для вычислений в облаке они бы обнаружили, что, хоть результаты казались случайными, они коррелируют. Рис. 3.4. Базовое состояние Белла На рис. 3.4 два кубита первоначально находятся в основном состоянии . Вентиль H создает суперпозицию первого кубита, соответствующую со - стоянию . Затем вентиль CNOT инвертирует второй кубит, если первый возбужден, создавая состояние . Это исходное запутанное состояние, необходимое для четырех измерений в табл. 3.4 (все материалы публикуются с разрешения © International Business Machines Corporation). Для вращения измерительного базиса вокруг оси ZW используйте серию вентилей S-H-T-H. Для поворота измерительного базиса вокруг оси ZV задействуйте серию вентилей S-H-T-H. Измерения XW и XV выполняются так же, как описано ранее, и измерение X через вентиль Адамара проводится перед стандартным измерением. СОВЕТ Перед выполнением эксперимента в Composer убедитесь, что для его топологии (количество кубитов и целевое устройство) в партитуре установлено значение 2 для симулятора. Некоторые топологии (напри - мер, пять кубитов в реальном квантовом устройстве) не поддерживают запутывание для кубитов 0 и 1, что приводит к ошибкам при проекти - ровании. Обратите внимание, что целевым устройством может быть настоящий квантовый процессор или симулятор. В общем, до тех пор, пока вы используете симулятор, у вас все будет хорошо.\n--- Страница 119 ---\nОпус 1: вариации на тему состояний Белла и GHZ 119Таблица 3.4. Квантовые схемы для состояний Белла Измерение состояния Белла Результаты для 100 запусков c[2] 11 10 00 01Вероятность 0,39 0,06 0,46 0,09 c[2] 11 10 00 01Вероятность 0,49 0,07 0,36 0,08 Продолжение \n--- Страница 120 ---\n120 Глава 3 . IBM Q Experience: платформа для вычислений в облакеИзмерение состояния Белла Результаты для 100 запусков c[2] 11 10 00 01Вероятность 0,42 0,05 0,49 0,04 c[2] 11 10 00 01Вероятность 0,05 0,52 0,03 0,40Таблица 3.4 (продолжение)\n--- Страница 121 ---\nОпус 1: вариации на тему состояний Белла и GHZ 121 Теперь нужно построить таблицу с результатами каждого измерения плюс вероятность корреляции между A и B . Сумма вероятностей для чет - ности запутанных частиц определяется как: . Помните, что конечная цель — определить, что верно: S ≤ 2 или | S| = 2. Таким образом, скомпоновав результаты всех измерений, мы получаем табл. 3.5. Таблица 3.5. Объединение результатов для экспериментов Белла P(00) P(11) P(01) P(10) <AB> AB (ZW) 0,46 0,39 0,09 0,06 0,68 AB' (ZV) 0,36 0,49 0,08 0,07 0,73 A'B (XW) 0,49 0,42 0,04 0,05 0,47 A'B'(XV) 0,03 0,05 0,40 0,52 –0,32 Складываем абсолютные значения из столбца и получаем | S| = 2,2. Этот результат противоречит неравенству Белла (как предсказывает квантовая механика) и очень близок к результатам официальных испы - таний, проведенных 2 мая 2017 года учеными из IBM, которые провели 8192 запуска. Как насчет ваших? Еще более необычно: проверка GHZ-состояний GHZ-состояния названы в честь физиков Гринбергера, Хорна и Цей- лингера, которые придумали обобщенную проверку для N запутанных кубитов. Наиболее простым является GHZ-состояние с тремя кубитами: . ПРИМЕЧАНИЕ Важность GHZ-состояний заключается в том, что они показывают: за - путывание более чем двух частиц приводит к конфликту с концепцией локального реализма не только для статистических (вероятностных), но и для нестатистических (детерминистских) предсказаний.\n--- Страница 122 ---\n122 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Проще говоря, GHZ-состояния демонстрируют более сильное нарушение неравенства Белла. Рассмотрим это на примере простой головоломки. Представьте три независимых блока, каждый из которых содержит две переменные, X и Y. Каждая переменная имеет два возможных значения: 1 и –1. Нужно найти для X и Y набор значений, который является реше - нием следующего набора тождеств. 1. XYY = 1. 2. YXY = 1. 3. YYX = 1. 4. XXX = –1. Для нетерпеливых: решения не существует. Например, замените Y = 1 в тождествах 1, 2 и 3, а затем перемножьте их. Набор примет следующий вид. 1. X11 = 1. 2. 1X1 = 1. 3. 11X = 1. 4. XXX = –1. 5. Перемножили тождества 1, 2 и 3 и получили XXX = 1. Решения не существует, потому что тождество 4 XXX = –1 противоречит тождеству 5 XXX = 1. Пугает то, что GHZ-состояние действительно может дать решение этой задачи, что кажется невозможным в детерминистском представлении классической реальности. Но в мире квантовой механики нет ничего невозможного, есть просто маловероятное. Удивительно, но тесты GHZ могут с уверенностью исключить описание локальной реальности после одного прогона эксперимента, однако сначала мы должны построить базовое GHZ-состояние. Базовое GHZ-состояние для запуска эксперимента (так же как и резуль - таты для вероятности, которые должны составлять около половины) показано в табл. 3.6.\n--- Страница 123 ---\nОпус 1: вариации на тему состояний Белла и GHZ 123 Таблица 3.6. Базовое GHZ-состояние 1. В базовой схеме вентиль Адамара, примененный к кубитам 1 и 2, пере - водит их в суперпозицию . В то же время вентиль X произ - водит операцию отрицания над кубитом 3. Таким образом, мы получаем состояния . 2. Два вентиля CNOT запутывают все кубиты в следующее состояние: . 3. Наконец, три вентиля Адамара преобразуют шаг 2 в следующее состо - яние: . Теперь создайте квантовые схемы для тождеств XYY, YXY, XYY и XXX из предыдущего раздела, как показано в табл. 3.7 (все материалы публику - ются с разрешения © International Business Machines Corporation). Для измерения Х примените вентиль Н к соответствующему кубиту. Для каждого экземпляра Y примените S† (ИЛИ-НЕ к S) и вентиль H к соответствующему кубиту. Наконец, сравните результаты предыдущего эксперимента с официаль - ными данными из IBM Q Experience. Каков ваш итоговый результат? В целом принципы квантовой механики, описанные в этом разделе, были поставлены под сомнение теорией, названной супердетерминизмом, ко - торая дает возможность выйти из сложившейся ситуации.\n--- Страница 124 ---\n124 Глава 3 . IBM Q Experience: платформа для вычислений в облакеТаблица 3.7. Квантовые схемы для GHZ-состояний Измерение Результаты для 100 запусков c[3] 011 101 110 000Вероятность 0,34 0,23 0,23 0,20 c[3] 011 101 110 000Вероятность 0,23 0,28 0,25 0,24\n--- Страница 125 ---\nОпус 1: вариации на тему состояний Белла и GHZ 125Измерение Результаты для 100 запусков c[3] 011 101 110 000Вероятность 0,23 0,26 0,35 0,16 c[3] 010 100 111 001Вероятность 0,25 0,32 0,22 0,21\n--- Страница 126 ---\n126 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Супердетерминизм: уход от мистичности. Был ли Эйнштейн прав все это время? В интервью BBC в 1969 году физик Джон Белл рассказал о своей работе в области квантовой механики. Он сказал, что мы должны принять пред - положение о том, что действия между запутанными частицами передаются со скоростью большей, чем скорость света, но в то же время мы никак не можем это использовать. Информация не может распространяться со скоростью большей, чем скорость света, что также предсказывает кван - товая механика. Как будто природа подшучивает над нами . Он также упомянул, что существует возможность решить эту загадку — принцип под названием «супердетерминизм». Запутывание частиц подразумевает, что измерения, выполненные на одной частице, мгновенно влияют на другую, даже отстоящую от нее на большое расстояние (представьте противоположные стороны Галактики или Вселенной), даже когда они разделены во времени. Эйнштейн был яростным противником этой теории: вспомните его знаменитое послание Нильсу Бору о том, что Бог не бросает кости. Он не мог принять вероят - ностный характер квантовой механики, поэтому в 1935 году вместе с кол- легами Подольским и Розеном придумал печально известный парадокс ЭПР, чтобы оспорить ее основы. Согласно парадоксу ЭПР, измерение в одной из двух запутанных частиц, разделенных огромным расстоянием, не может мгновенно повлиять на другую, поскольку событие должно будет проходить со скоростью боль - шей, чем скорость света (предел максимальной скорости во Вселенной). Это противоречит общей теории относительности, создавая парадокс: ничто не движется быстрее скорости света, что является абсолютным законом относительности. Тем не менее в 1982 году предположения квантовой механики б ыли под - тверждены французским физиком Аленом Аспе. Он провел эксперимент, который показал, что неравенство Белла нарушается запутанными фото - нами. Он также доказал, что измерение на одном из запутанных фотонов распространяется со скоростью большей, чем скорость света, чтобы пере - дать его состояние другому.\n--- Страница 127 ---\nОпус 1: вариации на тему состояний Белла и GHZ 127 С тех пор результаты, полученные Аспе, вновь и вновь подтверждаются (подробности эксперимента приведены в главе 1). Ирония заключается в следующем: есть вероятность, что Эйнштейн был прав с самого начала, а запутанность — всего лишь иллюзия. Это принцип супердетерминизма. ПРИМЕЧАНИЕ Проще говоря, супердетерминизм говорит, что с самого начала суще - ствования Вселенной свободы выбора не было. Все корреляции и за- путанность частиц были заданы в момент Большого взрыва. Таким образом, нет необходимости в сигнале, передающемся со скоростью, превышающей скорость света, чтобы сообщать частице B, каков ре - зультат частицы A. Если это верно, данная уловка докажет, что Эйнштейн был прав, когда предположил парадокс ЭПР, и вся наша тяжелая работа в области кван - тового программирования — всего лишь иллюзия. Но этот принцип зву - чит скорее как догма, ведь согласно ему все результаты предопределены судьбой, тогда как Белл с научной точки зрения утверждал, что суперде - терминизм неправдоподобен. Он рассуждает о том, что свобода выбора фактически ничем не ограничена для поставленной цели из-за изменений, вызванных множеством очень мелких эффектов. Супердетерминизм на - звали непроверяемым, поскольку экспериментаторы никогда не смогут устранить корреляции, которые были созданы в начале существования Вселенной. Однако это не заставило ученых отказаться от попыток до - казать, что Эйнштейн прав, а запутывание частиц — иллюзия. На самом деле существует труднореализуемый оригинальный эксперимент, который призван разрешить все противоречия. Рассмотрим его. На рис. 3.5 проиллюстрирован стандартный эксперимент по проверке неравенства Белла (внизу) и вариант эксперимента с использованием космических фотонов (вверху) , выполненные Эндрю Фридманом и его коллегами из MIT1. 1 Gallicchio J., Friedman A. S., Kaiser D. I. Testing Bell’s Inequality with Cosmic Photons: Closing the Setting-Independence Loophole // http://web.mit.edu/asf/www/Papers/ Gallicchio_Friedman_Kaiser_2014.pdf.\n--- Страница 128 ---\n128 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Рис. 3.5. Эксперимент по проверке нарушения неравенства Белла с космическими фотонами в сравнении со стандартной проверкой ПРИМЕЧАНИЕ Полное описание стандартной проверки неравенства Белла смотрите в разделе «ЭПР-парадокс разгромлен: Бор смеется последним» главы 1. Фридман и его коллеги предложили новый вариант стандартного экс - перимента Белла с использованием космических лучей. Суть его состоит в том, чтобы использовать астрономические наблюдения в реальном времени за далекими звездами нашей Галактики, далекими квазарами или пятнами космического микроволнового фона, чтобы, по существу,\n--- Страница 129 ---\nУдаленный доступ через REST API 129 позволить Вселенной решить, как организовать эксперимент, вместо того чтобы задействовать стандартный генератор квантовых случайных чисел. То есть использовать фотоны из далеких галактик для управления ори - ентацией поляризационных фильтров непосредственно перед прибытием запутанных фотонов. В случае успеха последствия будут грандиозными. Если результаты та - кого эксперимента не нарушат неравенства Белла, это будет означать, что супердетерминизм в конце концов может оказаться верным. Запутывание частиц будет иллюзией, и сигнал между запутанными частицами не может передаваться быстрее, чем свет, как предсказывает теория относительности. Эйнштейн окажется прав: мистических дальнодействий не существует. К счастью для нас, любителей квантовой механики, до сих пор ничего подобного не происходило. Имейте в виду, что Фридман и его коллеги — не единственная команда, участвующая в эксперименте. Есть несколько коллективов, пытающихся разгадать эту загадку. И боль- шинство их результатов согласуется с квантовой механикой. Иначе говоря, они нарушают неравенство Белла. Кажется, что разрыв между позициями Эйнштейна и Бора в борьбе теории относительности с кван- товой механикой давно устранен. Я все еще делаю ставку на квантовую механику. В следующем разделе показано, как получить доступ к IBM Q Experience удаленно с помощью удобного REST API. Удаленный доступ через REST API Q Experience имеет относительно малоизвестный REST API, который скрыто обрабатывает все удаленные коммуникации. Используется теку - щими Python SDK. QISKit (Quantum Information Science Kit) является платформой кванто - вых вычислений с открытым кодом для квантового программирования на Python.\n--- Страница 130 ---\n130 Глава 3 . IBM Q Experience: платформа для вычислений в облаке IBMQExperience — менее известная библиотека в комплекте с QISKit, которая упаковывает REST API в клиент Python. В этом разделе мы заглянем в IBMQExperience и рассмотрим различные конечные точки REST для удаленного доступа. Но сначала требуется аутентификация. Аутентификация Прежде чем выполнить любой вызов REST API, мы должны получить токен доступа. Это будет ключ доступа для любых вызовов в этом разделе. Обратите внимание, что токен доступа не совпадает с токеном API (то - кен API задействуется для выполнения квантовых программ на Python). Существует два способа получения токена доступа. Использование токена API . Чтобы получить токен API, войдите в кон- соль IBM Q Experience и выполните инструкции, приведенные в сле- дующем разделе. Использование имени пользователя и пароля вашей учетной записи . Давайте посмотрим, как это делается с помощью REST. СОВЕТ Чтобы получить токен API, войдите в консоль IBM Q Experience, вы - берите свое имя пользователя, затем My Account (Моя учетная запись) и перейдите на вкладку Advanced (Дополнительно), расположенную в правом верхнем углу. Далее нажмите кнопку Generate (Генерировать), а затем скопируйте токен API (рис. 3.6). Следите за тем, чтобы токен был в безопасности. Аутентификация через токены API: метод HTTP: POST; URL: https://quantumexperience.ng.bluemix.net/api/users/loginWithToken ; полезные данные: {\"apiToken\": \"YOUR_API_TOKEN\"} .\n--- Страница 131 ---\nУдаленный доступ через REST API 131 Рис. 3.6. Получение токена API из консоли Аутентификация с помощью пароля пользователя: метод HTTP: POST; URL: https://quantumexperience.ng.bluemix.net/api/users/login ; полезные данные: {\"email\": \"USER-NAME\", \"password\": \"YOUR-PASSWORD\"} . Ответ для обоих методов: { \"id\": \"ACCESS_TOKEN\", \"ttl\": 1209600, \"created\": \"2018-04-15T20:21:03.204Z\", \"userId\": \"USER-ID\" } Здесь id — это ваш токен доступа, ttl — время жизни (или время окон - чания действия) в миллисекундах, а userId — ваш идентификатор поль - зователя. Сохраните токен доступа и идентификатор пользователя для выполнения заданий этого раздела. Обратите внимание, что по истечении сеанса необходимо создать новый токен доступа. Перечисление доступного серверного ПО Этот вызов возвращает список всего доступного серверного ПО и симу - ляторов в IBM Q Experience в формате JSON: метод HTTP: GET; URL: https://quantumexperience.ng.bluemix.net/api/Backends?access_token=ACESS- TOKEN.\n--- Страница 132 ---\n132 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Параметры запроса Наименование Значение access_token Токен доступа к вашему аккаунту Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Пример ответа Типом содержимого ответа для всех вызовов API является application/ json. Следующий абзац показывает частичный результат вызова этой ко - нечной точки. Обратите внимание, что она будет возвращать как реальные процессоры, так и симуляторы: [{ \"name\": \"ibmqx2\", \"version\": \"1\", \"status\": \"on\", \"serialNumber\": \"Real5Qv2\", \"description\": \"5 transmon bowtie\", \"basisGates\": \"u1,u2,u3,cx,id\", \"onlineDate\": \"2017-01-10T12:00:00.000Z\", \"chipName\": \"Sparrow\", \"id\": \"28147a578bdc88ec8087af46ede526e1\", \"topologyId\": \"250e969c6b9e68aa2a045ffbceb3ac33\", \"url\": \"https://ibm.biz/qiskit-ibmqx2\", \"simulator\": false, \"nQubits\": 5, \"couplingMap\": [ [0, 1], [0, 2], [1, 2], [3, 2], [3, 4], [4, 2] ] }, ] Наиболее важные ключи из предыдущего ответа описаны в табл. 3.8.\n--- Страница 133 ---\nУдаленный доступ через REST API 133 Таблица 3.8. Ключи для ответа на запрос о доступном серверном ПО Ключ Описание Name Идентификатор имени процессора, который будет применяться при выполнении кода Version Строка или положительное целое число, по всей вероятности, используемое для отслеживания изменений в процессоре Description Это, вероятно, описание оборудования, применяемого для сборки чипа. Вы можете увидеть что-то вроде: • развязка из пяти трансмонов; • цепная схема 2 × 8 из 16 трансмонов. Примечание: трансмон — тип помехоустойчивого сверхпроводящего кубита. Разработан Робертом Дж. Шоэлкопфом, Мишелем Деворе, Стивеном М. Гирвином и их коллегами из Йельского университета в 2007 году basisGates Это физические кубитные вентили процессора. Они являются основой, на которой могут быть построены более сложные логические вентили nQubits Количество кубитов, используемых процессором couplingMap Карта связей определяет взаимодействия между отдельными кубитами, сохраняя при этом квантовую когерентность. С ее помощью можно упростить квантовую схему и разбить систему на более мелкие единицы Получение информации о калибровке заданного процессора Результатом этого вызова является список в формате JSON калибровоч - ных параметров для заданного процессора в Q Experience. Эти параметры подробно описаны на информационном сайте серверного ПО IBMQX: метод HTTP: GET; URL: https://quantumexperience.ng.bluemix.net/api/Backends/NAME/calibra- tion?access_token=ACCESS-TOKEN . Параметры запроса Наименование Значение access_token Токен доступа к вашему аккаунту\n--- Страница 134 ---\n134 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py (значение по умолчанию для официального клиента, также, я предполагаю, оно может быть любым) Пример ответа Кубиты очень чувствительны к ошибкам и шуму окружающей среды. Информация о калибровке дает представление о качестве кубитов внутри процессора. В листинге 3.2 показан упрощенный ответ с параметрами калибровки для ibmqx4. Некоторые из наиболее примечательных пара - метров: gateError — частота возникновения ошибок для операции применения вентиля на кубите в данный момент времени; readoutError — частота возникновения ошибок для операции считыва - ния данных кубита в данный момент времени. ПРИМЕЧАНИЕ Оценка качества кубитов включает четыре этапа (операции): подго - товку, запоминание, применение вентиля и считывание. Для отсле - живания качества кубита частота ошибок рассчитывается на этапах применения вентилей и считывания. Это информация, возвращаемая в ответе на данный вызов API. Обратите внимание на то, что после использования кубиты необходимо сбросить (охладить) до базового состояния. Листинг 3.2. Упрощенная форма ответа на запрос о калибровочных параметрах для ibmqx4 { \"lastUpdateDate\": \"2018-04-15T10:47:03.000Z\", \"qubits\": [{ \"gateError\": {\n--- Страница 135 ---\nУдаленный доступ через REST API 135 \"date\": \"2018-04-15T10:47:03Z\", \"value\": 0.0012019552727863259 }, \"name\": \"Q0\", \"readoutError\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 0.049 } }, … ], \"multiQubitGates\": [{ \"qubits\": [1, 0], \"type\": \"CX\", \"gateError\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 0.03024023736391171 }, \"name\": \"CX1_0\" },… ]} Информацию, приведенную в листинге 3.2, можно увидеть на вкладке Devices (Устройства) консоли IBM Q Experience, в главном меню (рис. 3.7). Получите информацию о калибровке через REST и сравните ее с ото- браженной на веб-консоли (все материалы публикуются с разрешения © International Business Machines Corporation). Получение параметров серверного ПО В результате данного вызова будет возвращен список параметров сер - верного ПО для заданного процессора в Q Experience в формате JSON. Некоторые из этих параметров: температура охлаждения кубита в Кельвинах: Например, я получил значение 0,021 K для ibmqx4, что является сверхнизкой температурой и соответствует –459,6 °F или –273,1 °C; время буфера (нс); время вентилей (нс). Другие квантовые спецификации более подробно описаны на информа - ционном сайте для серверного ПО.\n--- Страница 136 ---\n136 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Рис. 3.7. Информация о калибровке, переданная веб-консолью Тип запроса и конечная точка URL: метод HTTP: GET; URL: https://quantumexperience.ng.bluemix.net/api/Backends/NAME/para- meters?access_token=ACCESS-TOKEN . Параметры запроса Наименование Значение access_token Токен доступа к вашему аккаунту Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py\n--- Страница 137 ---\nУдаленный доступ через REST API 137 Пример ответа В листинге 3.3 приведен упрощенный ответ с параметрами ibmqx4 в фор- мате JSON. Листинг 3.3. Упрощенный ответ на запрос о параметрах ibmqx4 { \"lastUpdateDate\": \"2018-04-15T10:47:03.000Z\", \"fridgeParameters\": { \"cooldownDate\": \"2017-09-07\", \"Temperature\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 0.021, \"unit\": \"K\" } }, \"qubits\": [{ \"name\": \"Q0\", \"buffer\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 10, \"unit\": \"ns\" }, \"gateTime\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 50, \"unit\": \"ns\" }, \"T2\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 16.5, \"unit\": \"μs\" }, \"T1\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 45.2, \"unit\": \"μs\" }, \"frequency\": { \"date\": \"2018-04-15T10:47:03Z\", \"value\": 5.24208, \"unit\": \"GHz\" } }, ] }\n--- Страница 138 ---\n138 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Получение статуса очереди процессора Этот вызов возвращает состояние определенной очереди событий кван - тового процессора: метод HTTP: GET; URL: https://quantumexperience.ng.bluemix.net/api/Backends/NAME/queue/status . Параметры запроса Как ни странно, данный вызов API не запрашивает токен доступа. Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Пример ответа Например, чтобы получить очередь событий для ibmqx4, скопируйте следующий URL в адресную строку своего браузера: https://quantumexperi - ence.ng.bluemix.net/api/Backends/ibmqx4/queue/status . Ответ выглядит как {\"state\":true, \"status\":\"active\", \"lengthQueue\":0} , где: state: — состояние процессора. Если он работает, значение true, ина- че — false ; status: — состояние очереди выполнения, значения — активно или занято; lengthQueue: — размер очереди выполнения или количество симуляций, ожидающих выполнения. ПРИМЕЧАНИЕ Когда вы отправляете эксперимент в IBM Q Experience, он попадает в очередь выполнения. Этот вызов API полезен для отслеживания за - груженности процессора в данный момент.\n--- Страница 139 ---\nУдаленный доступ через REST API 139 Перечисление заданий в очереди выполнения Этот вызов возвращает список заданий в очереди выполнения процессора: метод HTTP: GET; URL: https://quantumexperience.ng.bluemix.net/api/Jobs?access_token=ACCESS- TOKEN&filter=FILTER . Параметры запроса Наименование Значение access_token Токен доступа к вашему аккаунту filter Указание размера результата в JSON. Например, {\"limit\":2} возвратит не более двух записей Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Пример ответа В листинге 3.4 показан формат ответа на данный вызов. Судя по всему, эта информация представляет собой хронологию выполненных экспери - ментов, где указаны статус, даты, результаты, код, калибровка и многое другое. Листинг 3.4. Упрощенная форма ответа на вызов API Get Jobs [{ \"qasms\": [{ \"qasm\": \"…\", \"status\": \"DONE\", \"executionId\": \"331f15a5eed1a4f72aa2fb4d96c75380\", \"result\": { \"date\": \"2018-04-05T14:25:37.948Z\", \"data\": {\n--- Страница 140 ---\n140 Глава 3 . IBM Q Experience: платформа для вычислений в облаке \"creg_labels\": \"c[5]\", \"additionalData\": { \"seed\": 348582688 }, \"time\": 0.0166247, \"counts\": { \"11100\": 754, \"01100\": 270 } } } }], \"shots\": 1024, \"backend\": { \"name\": \"ibmqx_qasm_simulator\" }, \"status\": \"COMPLETED\", \"maxCredits\": 3, \"usedCredits\": 0, \"creationDate\": \"2018-04-05T14:25:37.597Z\", \"deleted\": false, \"id\": \"d405c5829274d0ee49b190205796df87\", \"userId\": \"ef072577bd26831c59ddb212467821db\", \"calibration\": {} }, …] ПРИМЕЧАНИЕ В зависимости от размера очереди выполнения вы можете получить пустой результат ([ ]), если в очереди нет заданий, или результат в фор- мате, показанном в листинге 3.4. В любом случае убедитесь, что код ответа HTTP — 200 (OK). Получение информации о балансе аккаунта При создании учетной записи каждому пользователю присваивается определенное количество кредитов на выполнение (по умолчанию 15),\n--- Страница 141 ---\nУдаленный доступ через REST API 141 которые расходуются при проведении экспериментов. Этот вызов предо - ставляет информацию о балансе вашего аккаунта: метод HTTP: GET; URL: https://quantumexperience.ng.bluemix.net/api/users/USER-ID?access_ token=ACCESS-TOKEN . СОВЕТ Идентификатор пользователя можно получить из ответа на запрос аутентификации через токен API или с помощью пароля пользователя. Подробнее см. в подразделе «Аутентификация» данного раздела на с. 130. Параметры запроса Наименование Значение access_token Токен доступа к вашему аккаунту Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Пример ответа В листинге 3.5 показан типичный ответ на данный вызов. Листинг 3.5. Типичный ответ на запрос о балансе аккаунта { \"institution\": \"Private Research\", \"status\": \"Registered\", \"blocked\": \"None\", \"dpl\": {\n--- Страница 142 ---\n142 Глава 3 . IBM Q Experience: платформа для вычислений в облаке \"blocked\": false, \"checked\": false, \"wordsFound\": {}, \"results\": {} }, \"credit\": { \"promotional\": 0, \"remaining\": 150, \"promotionalCodesUsed\": [], \"lastRefill\": \"2018-04-12T14:05:09.136Z\", \"maxUserType\": 150 }, \"additionalData\": { }, \"creationDate\": \"2018-04-01T15:36:16.344Z\", \"username\": \"\", \"email\": \"\", \"emailVerified\": true, \"id\": \"\", \"userTypeId\": \"…\", \"firstName\": \"…\", \"lastName\": \"…\" } Список экспериментов пользователя Ответом на такой вызов является список всех экспериментов для задан - ного идентификатора пользователя: метод HTTP: GET; URL: https://quantumexperience.ng.bluemix.net/api/users/USER-ID/codes/ lastest?access_token=ACCESS-TOKEN&includeExe cutions=true . Параметры запроса Наименование Значение USER-ID Ваш идентификатор пользователя, полученный на этапе аутентификации access_token Токен доступа к вашему аккаунту includeExecutions Если задано значение true, включает выполнение в результат\n--- Страница 143 ---\nУдаленный доступ через REST API 143 Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Пример ответа В листинге 3.6 показан типичный ответ на данный вызов. Листинг 3.6. Ответ на запрос о списке экспериментов { \"total\": 17, \"count\": 17, \"codes\": [{ \"type\": \"Algorithm\", \"active\": true, \"versionId\": 1, \"idCode\": \"…\", \"name\": \"3Q GHZ State YXY-Measurement 1\", \"jsonQASM\": { … }, \"qasm\": \"\", \"codeType\": \"QASM2\", \"creationDate\": \"2018-04-14T19:09:51.382Z\", \"deleted\": false, \"orderDate\": 1523733740504, \"userDeleted\": false, \"displayUrls\": { \"png\": \"URL\" }, \"isPublic\": false, \"id\": \"…\", \"userId\": \"…\" }]} Запуск эксперимента В результате данного вызова эксперимент будет удаленно запущен на IBM Q Experience: метод HTTP: POST; URL: https://quantumexperience.ng.bluemix.net/api/codes/execute?access_ token=ACCESS-TOKEN&shots=SHOTS&deviceRunType=RUN-TYPE .\n--- Страница 144 ---\n144 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Параметры запроса Наименование Значение shots Количество запусков на выполнение. Чем их больше, тем выше точность результатов. Обратите внимание на то, что уровень ваших кредитов будет уменьшаться на 3 за каждые 1024 запуска. В квантовом мире пространство ценится на вес золота access_token Токен доступа к вашему аккаунту deviceRunType Устройство, на котором запускается эксперимент. Это может быть: • для реальных процессоров — реальное наименование устройства, такое как ibmqx2 и ibmqx3; • для моделирующих устройств — моделирующее устройство или sim_trivial_2 seed (необязательный параметр)Необязательное случайное значение, которое требуется только для моделирующих устройств Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Content-Type Приложение/формат json Формат полезных данных Телом ответа является документ в формате JSON, описывающий экспе - римент, как показано в следующем отрывке: { \"name\": \"Experiment NAME\", \"codeType\": \"QASM2\", \"qasm\": \"CODE\" }\n--- Страница 145 ---\nУдаленный доступ через REST API 145 Пример ответа Это, пожалуй, самый важный вызов API. В качестве упражнения возьмем одно из состояний Белла из предыдущего раздела и запустим его как на моделирующем, так и на реальном устройстве с использованием REST API (листинг 3.7). Листинг 3.7. Измерение состояния Белла XW IBMQASM 2.0; include \"qelib1.inc\"; qreg q[2]; creg c[2]; h q[0]; cx q[0],q[1]; h q[0]; s q[1]; h q[1]; t q[1]; h q[1]; measure q[0] -> c[0]; measure q[1] -> c[1]; В листинге 3.7 приведен код на ассемблере из эксперимента с одним из состояний Белла (XW) , выполненного в веб-консоли в предыдущем разделе. Возьмите этот код и создайте полезные данные в формате JSON в виде {\"name\": \"NAME\", \"codeType\": \"QASM2\", \"qasm\": \"ONE-LINE-QASM\"} . Об- ратите внимание, что нужно передать название эксперимента и код на QASM должен быть отформатирован как одна строка, включая символ конца строки. Таким образом, полезные данные принимают оконча - тельный вид: {\"name\": \"REST Bell State XW\", \"codeType\": \"QASM2\", \"qasm\": \"IBMQASM 2.0;\\ ninclude \\\"qelib1.inc\\\";\\nqreg q[2];\\ncreg c[2];\\nh q[0];\\ncx q[0],q[1];\\ nh q[0];\\ns q[1];\\nh q[1];\\nt q[1];\\nh q[1];\\nmeasure q[0] -> c[0];\\ nmeasure q[1] -> c[1];\"} Теперь мы готовы отправить наш эксперимент через REST. Не забудьте, что вы должны сначала аутентифицироваться для получения токена до - ступа.\n--- Страница 146 ---\n146 Глава 3 . IBM Q Experience: платформа для вычислений в облаке СОВЕТ REST-клиенты доступны для большинства, если не для всех браузе - ров. Установите клиент REST в любимый браузер и создайте запрос на аутен тификацию, как описано в подразделе «Аутентификация» на с. 130. Сохраните его и держите наготове, чтобы получить токен доступа. Я буду использовать YARC (Yet Another REST Client) от Chrome для от - правки полезных данных сначала на моделирующее, а затем на реальное устройство (рис. 3.8). Рис. 3.8. REST-клиент в YARC от Chrome с полезными данными для эксперимента с состоянием Белла XW Отправка на моделирующее устройство Для отправки на моделирующее устройство используйте следующие параметры запроса: access_token=ACESS_TOKEN&shots=1&deviceRunType= simulator\n--- Страница 147 ---\nУдаленный доступ через REST API 147 Убедитесь, что код ответа — 200 (OK), и взгляните на вывод ответа. Удосто - верьтесь, что эксперимент был записан в консоли Q Experience (рис. 3.9). Рис. 3.9. Веб-консоль, показывающая эк сперимент с состоянием Белла XW, отправленный через REST Отправка на реальное устройство Для отправки на реальное устройство (в данном случае ibmqx4) измените параметры запроса на: access_token=ACESS_TOKEN &shots=1&deviceRunType= ibmqx4 ПРИМЕЧАНИЕ Реальные квантовые устройства могут быть отключены для техниче - ского обслуживания или по любой другой причине. Если это так, то отправка не удастся и вы получите ответ HTTP 400 (неверный запрос). Перед отправкой на реальное квантовое устройство убедитесь, что оно находится в Сети! Если все пройдет хорошо, задание будет помещено в очередь выполнения и записано в веб-консоли. В листинге 3.8 показан результат отправки на реальное устройство со статусом PENDING_IN_QUEUE .\n--- Страница 148 ---\n148 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Листинг 3.8. Упрощенный HTTP-ответ из эксперимента с состоянием Белла XW, отправленного через REST { \"startDate\": \"2018-04-16T13:05:43.440Z\", \"modificationDate\": 1523883943441, \"typeCredits\": \"plan\", \"status\": { \"id\": \"WORKING_IN_PROGRESS\" }, \"deviceRunType\": \"real\", \"ip\": { \"ip\": \"…\", \"city\": \"Raleigh\", \"country\": \"United States\", \"continent\": \"North America\" }, \"shots\": 1, \"paramsCustomize\": {}, \"deleted\": false, \"userDeleted\": false, \"id\": \"…\", \"codeId\": \"…\", \"userId\": \"…\", \"infoQueue\": { \"status\": \"PENDING_IN_QUEUE\", \"position\": 21, \"estimatedTimeInQueue\": 735 }, \"code\": { \"type\": \"Algorithm\", \"active\": true, \"versionId\": 1, \"idCode\": \"…\", \"name\": \"REST Bell State XW #1\", \"jsonQASM\": { … \"numberGates\": 7, \"hasMeasures\": true, \"numberColumns\": 11, \"include\": \"include \\\"qelib1.inc\\\";\" }, \"qasm\": \"…\", \"codeType\": \"QASM2\", \"creationDate\": \"2018-04-16T13:05:42.547Z\", \"deleted\": false,\n--- Страница 149 ---\nУдаленный доступ через REST API 149 \"orderDate\": 1523883943351, \"userDeleted\": false, \"isPublic\": false, \"id\": \"…\", \"userId\": \"…\" } } На этом этапе вы успешно отправили свой первый эксперимент через REST. Попробуйте увеличить количество запусков вашего эксперимента, чтобы добиться большей точности. Запуск задания Этот вызов очень похож на предыдущий запуск эксперимента, однако у него есть две конечные точки. 1. Для обычных пользователей IBM Q Experience. 2. Для корпоративных клиентов. Требуются идентификаторы хаба, группы и проекта. У корпоративных клиентов есть как премиальный аккаунт, так и доступ к мощным 20-кубитным процессорам и, возможно, 50-кубитному чипу, который, по слухам, выйдет в конце 2018 года: метод HTTP: POST; URL 1 (5, 16 кубитов): https://quantumexperience.ng.bluemix.net/api/ Jobs?access_token=ACCESS-TOKEN ; URL 2 (20+ корпоративных кубитов): https://quantumexperience.ng.bluemix. net/api/Network/HUB/Groups/GROUP/Projects/PROJECT/jobs?access_token=ACCESS- TOKEN . Параметры запроса Наименование Значение access_token Токен доступа к вашему аккаунту\n--- Страница 150 ---\n150 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Content-Type Приложение/формат json Формат полезных данных Формат полезных данных включает все параметры выполнения: название серверного ПО, запуски и код в одном документе формата JSON, как по - казано в следующем отрывке: { \"backend\": { \"name\": \"simulator\" }, \"shots\": 1, \"qasms\": [{ \"qasm\": \"qams\" }, …] } ПРИМЕЧАНИЕ Эксперименты, отправленные через конечную точку Run Job, не за- писываются в раздел «Итоги» Composer, но помещаются в очередь выполнения для обработки. В то же время отправка через конечную точку Run Experiment приведет к записи в Composer. Обратите внимание и на то, что для любого экс - перимента, отправленного на моделирующее устройство, результаты возвращаются немедленно. Эксперименты, отправленные на реальное квантовое устройство, всегда будут входить в очередь выполнения в со- стоянии PENDING. По завершении пользователю будет отправлено уведомление по электронной почте. Давайте быстро отправим работу на реальное устройство ibmqx4. Вставьте в свой клиент REST следу- ющую конечную точку: https://quantumexperience.ng.bluemix.net/api/Jobs?access_ token=access_token .\n--- Страница 151 ---\nУдаленный доступ через REST API 151 Установите метод HTTP POST, токен доступа и заголовки, как описано в предыдущем разделе. Используйте следующие полезные данные: { \"qasms\": [{ \"qasm\": \"\\n\\ninclude \\\"qelib1.inc\\\";\\nqreg q[5];\\ncreg c[5];\\ nu2(-4*pi/3,2*pi) q[0];\\nu2(-3*pi/2,2*pi) q[0];\\nu3(-pi,0,-pi) q[0];\\nu3(-pi,0, -pi/2) q[0];\\nu2(pi,-pi/2) q[0];\\nu3(-pi,0,-pi/2) q[0];\\nmeasure q -> c;\\n\" }], \"shots\": 1024, \"backend\": { \"name\": \"ibmqx4\" }, \"maxCredits\": 3 } Эти полезные данные передают случайный эксперимент реальному устройству ibmqx4. Перед отправкой убедитесь, что оно в Сети (или используйте моделирующее устройство). Удостоверьтесь также, что код QASM, включая символ перевода строки ( \\n), расположен в одной строке. Обратите внимание на то, что двойные кавычки должны быть экранированы. Если отправка не удалась, это, вероятно, означает, что устройство находится в автономном режиме или QASM в ваших полезных данных неверный. Дважды и трижды проверьте, чтобы убедиться, что все правильно. Ответ, который я получил, говорит мне, что мое задание выполняется : { \"qasms\": [ { \"qasm\": \"…\", \"status\": \"WORKING_IN_PROGRESS\", \"executionId\": \"5ba6955fd867ef0046615172\" } ], \"shots\": 1024, \"backend\": { \"id\": \"5ae875670f020500393162b3\", \"name\": \"ibmqx4\" }, \"status\": \"RUNNING\", \"maxCredits\": 3, \"usedCredits\": 3, \"creationDate\": \"2018-09-22T19:17:51.448Z\", \"id\": \"5ba6955fd867ef0046615171\", \"userId\": \"5ae8750 60f0205003931559a\",\n--- Страница 152 ---\n152 Глава 3 . IBM Q Experience: платформа для вычислений в облаке \"infoQueue\": { \"status\": \"PENDING_IN_QUEUE\", \"position\": 11 } } Обратите внимание, что мое задание не будет показано Composer, тем не менее я получу по электронной почте уведомление со ссылкой на результаты. Получение версии API Возвращает версию REST API в Q Experience: метод HTTP: GET; URL: https://quantu mexperience.ng.bluemix.net/api/version?access_token=ACCESS- TOKEN . Параметры запроса Наименование Значение access_token Токен доступа к вашему аккаунту Заголовки HTTP Наименование Значение x-qx-client-application Значения по умолчанию для qiskit-api-py Форм ат ответа Возвращает строку с версией API (на момент написания этой книги — 6.4.8). Заглянем внутрь написанного на Python REST API в IBMQuantumExpe- rience, чтобы посмотреть, что происходит за кулисами. В качестве упраж - нения создадим собственный клиент для Node JS.\n--- Страница 153 ---\nКлиент Node JS для IBMQuantumExperience 153 Клиент Node JS для IBMQuantumExperience В этом разделе описано простое упражнение, призванное сымитировать один из компонентов Python SDK, известный как QISKit (Quantum Information Software Kit). В следующей главе мы более подробно рас - смотрим Python SDK, а здесь укажем, что данный SDK создан на основе двух базовых библиотек. IBMQuantumExperience . Это реализация REST-клиента в Python, в кото- рую я заглянул, чтобы представить REST API из предыдущего раздела. Данная модульная библиотека плохо документирована, что логично, поскольку она может измениться в будущем. QISKit SDK . Это главная точка входа во все ваши квантовые про - граммы. Она обертывает логику вентилей, трансляцию текстов на ассемблере, симуляторы — локальный симулятор Python и быстрый симулятор C++ — и многое другое. Эта библиотека также вызывает IBMQuantumExperience для всех взаимодействий с платформой IBM Q Experience через REST. Python — прекрасный язык, но центры обработки данных сейчас поваль - но увлеклись Node JS. В этом разделе представлена простая реализация REST API для Node JS. Вот несколько причин, почему эта библиотека будет полезной. Node JS — рабочая лошадка для сетевых асинхронных вызовов ввода/ вывода. Она быстрая, и это идеальная платформа для клиентов REST. Python — хороший язык с множеством великолепных числовых, мате - матических, графических библиотек, но у него есть некоторые особен - ности. Например, важность отступов в Python (вы не можете одно - временно использовать табуляцию и пробелы — здесь нет скобок для разграничения блоков). Поначалу это сводило меня с ума, ведь почти во всех компьютерных языках применяются фигурные скобки для разделения логических блоков. В Python такого нет — вы должны ис - пользовать пробелы или табуляцию, причем не одновременно. Мне это не нравится. Я думаю, это неудачная реализация: если вы допустили\n--- Страница 154 ---\n154 Глава 3 . IBM Q Experience: платформа для вычислений в облаке ошибку, то не знаете, где заканчивается логический блок. Вот для чего нужны скобки. Разнообразие всегда приветствуется: преодолев все проблемы с Python, я подумал, что эта библиотека может стать основой для клона QISKit для Node JS. Приступим. Построение модуля Node для IBMQuantumExperience Я пытался сохранить названия как можно более близкими к применяемым в версии Python. Чтобы создать модуль Node JS, сделайте папку с именем IBMQuantumExperience и инициализируйте Node JS, как показано далее: $ mkdir IBMQuantumExperience $ cd IBMQuantumExperience $ npm init ПРИМЕЧАНИЕ Пользователям Linux: я использовал Windows, чтобы написать этот раздел. Более того, я предполагаю, что вы установили Node JS, знакомы с модулями Node и умеете писать код на JavaScript. В общем, вы може - те получить установщики Node для всех платформ по адресу https:// nodejs.org/en/. Также обратите внимание на то, что Linux не нравятся названия пакетов прописными буквами. Избавьте себя от головной боли и воспользуйтесь Windows, чтобы проработать эт от раздел. Node предоставляет менеджер пакетов под названием npm (он в значи - тельной степени совпадает с pip в Python), который можно использовать для инициализации вашего модуля. Третья команда создаст в текущей папке два файла: index.js — это код вашего модуля. Примечание для пользователей Linux: создайте этот файл самостоятельно; Package.json — это дескриптор модуля, содержащий такую информацию, как название, версия, автор, зависимости и многое другое.\n--- Страница 155 ---\nКлиент Node JS для IBMQuantumExperience 155 Там же создайте папку test для юнит-тестов и установите мощный REST- клиент Node request : $ mkdir test $ npm install request Вторая команда устанавливает популярный пакет HTTP-запросов и все его зависимости в текущую папку. Теперь мы готовы реализовать REST API из предыдущего раздела. Откройте index.js в своем любимом редак - торе и начинайте. Экспорт методов API Чтобы предоставить API через Node, используйте библиотеку module. exports , как показано в листинге 3.9. Обратите внимание, что это ча - стичная реализация библиотеки и все фрагменты будут собраны в сле- дующих разделах. Полная реализация доступна в папке Workspace\\Ch03\\ IBMQuantumExperience . При этом вы должны суметь вставить все эти листинги в index.js . Опять же я предполагаю, что вы понимаете, как модули написаны в Node JS. Листинг 3 .9. Предоставление открытых методов API через Node const log = require('./log'); // Простая настраиваемая библиотека журналов (см. раздел отладки) const request = require('request'); //… module.exports = { init: function (cfg) { _config = cfg; var debug = _config.debug ? _config.debug : false; log.init (debug); return loginWithToken (); }, getCalibration : calibration, getBackends : backends, getParameters : parameters, runExperiment : experiment // Оставлено в качестве упражнения getJobs : jobs, // Оставлено в качестве упражнения getMyCredits : credits }\n--- Страница 156 ---\n156 Глава 3 . IBM Q Experience: платформа для вычислений в облаке В листинге 3.9 происходит импорт внешней библиотеки с помощью клю - чевого слова require . Во второй строке импортируется клиентская библиотека HTTP-запросов для взаимодействия с Q Experience. В пятой строке декларируются предоставляемые данным модулем публичные методы: •init — осуществляет аутентификацию на платформе Q Experience, как описано в разделе «Удаленный доступ через REST API» на с. 129; •getCalibration — возвращает параметры калибровки платформы для заданного устройства; •getBackends — возвращает список доступных для использования квантовых (и моделирующих) устройств; •getParameters — возвращает параметры устройств в соответствии с описанием в разделе Devices (Устройства) веб-консоли Composer; •runExperiment — запускает эксперимент удаленно на моделирующем или реальном квантовом устройстве; •getJobs — возвращает список текущих заданий в очереди выполне - ния эксперимента; •getMyCredits — возвращает пользовательский баланс кредитов на выполнение и другую полезную информацию. Аутентификация с использованием токена Перед аутентификацией библиотека инициализируется так же, как в Python, с конфигурационным объектом JSON, содержащим URL-адрес платформы, API-токен и многое другое. Например, так мы бы протести - ровали вызов REST API для получения информации о серверном ПО (взято из test.js ): // Запросите файл `index.js` из той же папки const qx = require('index.js'); // Вставьте ваш токен API здесь var config = { APItoken: 'YOUR_API_TOKEN'\n--- Страница 157 ---\nКлиент Node JS для IBMQuantumExperience 157 , debug : true , 'url' : 'https://quantumexperience.ng.bluemix.net/api' , 'hub' : 'MY_HUB' , 'group' : 'MY_GROUP' , 'project' : 'MY_PROJECT' } // Получите информацию о серверном ПО async function testBackends() { await qx.init(config); var result = await qx.getBackends(); console.log(\"---- BACKENDS ----\\n\" + JSON.stringify(result) + \"\\n-----\" ); } Помните, что хаб, группа и проект являются параметрами только для корпоративных клиентов. Таким образом, они не используются в этой реализации, однако поддержку для них легко добавить. После инициа - лизации просто отправьте запрос POST для входа в систему с помощью токена, как описано в REST API (листинг 3.10). Данный код, как и все листинги в этих разделах, находится в файле index.js . Листинг 3.10. Аутентификация с помощью токена через REST function loginWithToken () { let options = { url: _config.url + '/users/loginWithToken', form: {'apiToken': _config.APItoken} }; return new Promise(function(resolve, reject) { // Выполнить асинхронно задание // {\"id\":\"Access tok\",\"ttl\":1209600,\"created\":\"2018-04- // 17T23:30:21.089Z\",\"userId\":\"userid\"} request.post(options, function(err, res, body) { if (err) { reject(err); } else { var json = JSON.parse(body); _accessToken = json.id; _userId = json.userId; log.debug(\"Got User:\" + _userId + \" Tok:\" + _accessToken); resolve(JSON.parse(body)); } }); }) }\n--- Страница 158 ---\n158 Глава 3 . IBM Q Experience: платформа для вычислений в облаке В листинге 3.10: системный вызов request.post задействуется для отправки запроса HTTP POST в конечную точку https://quantumexperience.ng.bluemix.net/ api/users/loginWithToken с использованием полезных данных в формате JSON {'apiToken':'YOUR_TOKEN'} . В соответствии с описанием REST API в ответ на данный вызов будет возвращен документ в формате JSON: {\"id\":\"TOKEN\",\"ttl\":1209600, \"created\":\"DATE\", \"userId\":\"USERID\"} . Этот документ анализируется, а токен доступа ( id) и идентификатор пользователя ( userId ) сохраняются для последующего применения; обратите внимание: поскольку все сетевые операции ввода/вывода в Node асинхронные, все методы возвращают объект Promise . По сути, это асинхронная задача, инкапсулирующая необходимость ожидания выполнения задачи до считывания результатов. Таким образом, если вызов HTTP-запроса завершится успешно, будет выполнен обратный вызов resolve из Promise с данными HTTP-ответа, в противном случае — обратный вызов reject из Promise . ПРИМЕЧАНИЕ Объекты Promise являются убедительной альтернативой обратным вы - зовам для асинхронного кода. Тем не менее они могут иногда вводить в заблуждение. В общем, объекты Promise становятся стандартом де-факто для асинхронного программирования на JavaScript. Если вы находите, что код обработки Promise сложен, существует более простой способ. Он будет показан в следующем разделе, где мы реализуем метод для извлечения списка серверного ПО. Перечисление серверного ПО В листинге 3.11 показан запрос Node для получения серверного ПО из Q Experience. Посылается HTTP-запрос GET на https://quantumexperience.ng.bluemix.net/ api/Backends?access_token=TOKEN .\n--- Страница 159 ---\nКлиент Node JS для IBMQuantumExperience 159 Возвращается объект Promise , который можно вызвать из любой асинхронной функции с помощью нового функционала async/await в JavaScript. Листинг 3.11. Получение списка серверного ПО через Node const _defaultHdrs = { 'x-qx-client-application': _userAgent }; function backends () { let options = { url: _config.url + '/Backends?access_token=' + _accessToken, headers: _defaultHdrs }; return new Promise(function(resolve, reject) { // Выполнить асинхронно задание request.get(options, function(err, res, body) { if (err) { reject(err); } else { resolve(JSON.parse(body)); } }); }) } Чтобы протестировать предыдущий метод, можно воспользоваться функционалом async/await из Node.js ≥ 7.6, как показано в следующем фрагменте: async function testBackends() { await qx.init(config); var result = await qx.getBackends(); console.log(\"---- BACKENDS ----\\n\" + JSON.stringify(result) + \"\\n-----\" ); } ПРИМЕЧАНИЕ Асинхронная функция может содержать выражение await: тогда ее выполнение приостанавливается, программа ожидает сообщения об успешном выполнении от переданного объекта Promise, а затем возоб - новляет выполнение функции и возвращает значение результата.\n--- Страница 160 ---\n160 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Перечисление параметров калибровки В листинге 3.12 показано, как получить параметры калибровки и обору - дования для конкретного серверного ПО в IBM Q Experience. Получить калибровочные данные, отправив запрос GET на https:// quantumexperience.ng.bluemix.net/api/Backends/NAME/calibra tion?access_ token=TOKEN , где NAME — это серверное ПО, о котором вы хотите сделать запрос, TOKEN — токен доступа, полученный на шаге аутентификации. Получить параметры серверного ПО, отправив аналогичный за - прос GET на https://quantumexperience.ng.bluemix.net/api/Backends/NAME/ parameters?access_token=TOKEN . Формат ответа на оба запроса описан в разделе «Удаленный доступ через REST API» данной главы. Листинг 3.12. Получение данных о калибровке и параметрах устройства function calibration (name) { let options = { url: _config.url + '/Backends/' + name +'/calibration?access_token=' + _accessToken, headers: _defaultHdrs }; return new Promise(function(resolve, reject) { request.get(options, function(err, res, body) { if (err) { reject(err); } else { resolve(JSON.parse(body)); } }); }) } function parameters (name) { let options = { url: _config.url + '/Backends/' + name +'/parameters?access_token=' + _accessToken, headers: _defaultHdrs }; return new Promise(function(resolve, reject) {\n--- Страница 161 ---\nКлиент Node JS для IBMQuantumExperience 161 request.get(options, function(err, res, body) { if (err) { reject(err); } else { resolve(JSON.parse(body)); } }); }) } Для тестирования кода создайте асинхронную функцию и используйте ключевое слово await , чтобы получить ответ от асинхронной задачи, как показано в следующем фрагменте: async function testCalibration() { await qx.init(config); var result1 = await qx.getCalibration('ibmqx4'); var result2 = await qx.getParameters('ibmqx4'); console.log(JSON.stringify(result1) ); console.log(JSON.stringify(result1) ); } В качестве последнего шага рассмотрим выполнение эксперимента. Старт эксперимента Это наиболее важный вызов API, и после его выполнения эксперимент должен быть записан в раздел результатов вашей веб-консоли IBM Q Experience (листинг 3.13). Чтобы отправить эксперимент программным путем, выполните HTTP- запрос POST в конечную точку /codes/execute с полезными данными в формате JSON: {'name': name, \"codeType\": \"QASM2\", \"qasm\": \"YOUR_QASM_CODE\"} Помните, что код на ассемблере должен быть отформатирован как одна строка с символами конца строки ( \\n) для разделения инструк - ций. Например, в следующем коде объявляются пять кубитов и пять классических регистров: \"\\n\\ ninclude \\\"qelib1.inc\\\";\\nqreg q[5];\\ ncreg c[5];\\n\" .\n--- Страница 162 ---\n162 Глава 3 . IBM Q Experience: платформа для вычислений в облаке Параметр name определяет название эксперимента, которое будет за - писано в веб-консоли. Параметр shots — это количество запусков, выполняемых квантовым процессором. Параметр device может быть названием моделирующего (для удаленно - го моделирующего устройства) или реального квантового устройства, таким как ibmqx4. СОВЕТ Если вы запустите эксперимент на реальном устройстве, он будет помещен в очередь выполнения для дальнейшей обработки. По за - вершении вы получите письмо. А если запустите эксперимент на уда - ленном моделирующем устройстве, результаты будут возвращаться синхронно. Листинг 3.13. Запуск эксперимента const _userAgent = 'qiskit-api-py'; // Глобальная переменная function experiment (name, qasm, shots, device) { let options = { url: _config.url + '/codes/execute?access_token=' + _accessToken + '&shots=' + shots + '&deviceRunType=' + device, headers: {'Content-Type': 'application/json', 'x-qx-client-application': _userAgent} , form: {'name': name, \"codeType\": \"QASM2\", \"qasm\": qasm} }; return new Promise(function(resolve, reject) { request.post(options, function(err, res, body) { if (err) { reject(err); } else { resolve(JSON.parse(body)); } }); }) }\n--- Страница 163 ---\nКлиент Node JS для IBMQuantumExperience 163 Вставьте код из листинга 3.13 в файл index.js , используйте следующий фрагмент кода для запуска эксперимента на реальном квантовом устрой - стве ibmqx4, затем убедитесь, что эксперимент записан в веб-консоли, и дождитесь уведомления по электронной почте: async function testExperiment () { await qx.init(config); var name = \"REST Experiment from Node JS #1\" var qasm = \"\\n\\ninclude \\\"qelib1.inc\\\";\\nqreg q[5];\\ncreg c[5];\\ nu2(-4*pi/3,2*pi) q[0];\\nu2(-3*pi/2,2*pi) q[0];\\nu3(-pi,0,-pi) q[0];\\nu3(-pi,0,-pi/2) q[0];\\nu2(pi,-pi/2) q[0];\\nu3(-pi,0,-pi/2) q[0];\\nmeasure q -> c;\\n\"; var shots = 1; var device = \"ibmqx4\"; var result = await qx.runExperiment(name, qasm, shots, device); console.log(\"---- EXPERIMENT \" + name + \" ----\\n\" + JSON.stringify(result) + \"\\n-----\" ) } ПРИМЕЧАНИЕ Код для модуля Node для IBMQuantumExperience находится в раз- деле Workspace\\Ch03\\IBMQuantumExperience исходного кода кни - ги. Тестовый скрипт проекта размещен в файле test/tests.js. Отре - дактируйте этот файл, добавьте свой токен API и выполните его из IBMQuantumExperience с помощью команды node test/tests.js. Отладка и тестирование Для простой отладки я создал подмодуль log.js (на том же уровне, что и index.js ) и использовал основной объект консоли для отображения информации, как показано в следующем фрагменте: var _debug = false; function LOGD( tag, txt ) { if ( _debug ) { console.log('[DBG-QX] ' + tag + ' ' + (txt ? txt : \")); } }\n--- Страница 164 ---\n164 Глава 3 . IBM Q Experience: платформа для вычислений в облаке function LOGE( tag, txt ) { console.error('[ERR-QX] ' + tag + ' ' + (txt ? txt : \")); } function init (debug) { _debug = debug; } exports.init = init; exports.debug = LOGD; exports.error = LOGE; Основной модуль ( index.js ) использует этот подмодуль для отображения отладочных сообщений в консоли. Наконец, чтобы протестировать пакет, отредактируйте test/tests.js и вставьте фрагменты теста, описанные в этих разделах, как показано в следующей части листинга из tests.js : // test/tests.js запрашивает файл `index.js` из той же папки. const qx = require(' /'); // Вставьте ваш токен API сюда var config = { APItoken: 'API-TOKEN' , debug: true , 'url': 'https://quantumexperience.ng.bluemix.net/api' , 'hub': 'MY_HUB' , 'group': 'MY_GROUP' , 'project': 'MY_PROJECT' }; async function testBackends() { await qx.init(config); var result = await qx.getBackends(); console.log(\"---- BACKENDS ----\\n\" + JSON.stringify(result) + \"\\n-----\" ); } async function testJobs () { await qx.init(config); var filter = '{\"limit\":2}'; var jobs = await qx.getJobs(filter); console.log (\"---- JOBS----\\n\" + JSON.stringify(jobs) + \"\\n----\"); } // Вставьте все фрагменты тестов сюда… // .… try { testBackends(); testJobs (); // другие тесты…\n--- Страница 165 ---\nКлиент Node JS для IBMQuantumExperience 165 } catch (e){ console.error(e); } Чтобы выполнить тест, запустите node test\\tests.js в папке IBMQuan- tumExperience . Обратите внимание: я пропустил методы getJobs и getMy- credits , они остаются для вас в качестве упражнения. У вас достаточно знаний, чтобы легко реализовать и протестировать их. Поделитесь с миром — опубликуйте свой модуль Если хотите поделиться своей работой со всем миром, можете опублико - вать свой модуль в реестре npm. Для этого вы должны создать учетную запись пользователя на www.npmjs.com/ или выполнить это вручную, ис - пользуя команды: npm adduser npm publish Убедитесь, что вы документировали свой код, добавив документ на язы - ке разметки markdown (readme.md ) в корневую папку. После публикации перейдите по адресу https://npmjs.com/package/<package> и проверьте, дей - ствует ли ваш модуль. Теперь другие смогут установить его командой: npm instal l IBMQuantumExperience Разработчики Node JS могут отправлять эксперименты в Q Experience с помощью такого кода: const qx = require('IBMQuantumExperience'); … async function sendExperiment () { var config = { APItoken: 'API-TOKEN' , 'url': 'https://quantumexperience.ng.bluemix.net/api', 'debug': false}; await qx.init(config); var name = \"REST Experiment from Node JS #1\" var qasm = \"MY_QASM\"; var device = \"ibmqx4\"; var result = await qx.runExperiment(name, q asm, 1024, device); }\n--- Страница 166 ---\n166 Глава 3 . IBM Q Experience: платформа для вычислений в облаке В этой главе вы сделали первый шаг в карьере квантового программи - ста. IBM создала удивительную облачную платформу для изучения этих невероятных машин. Мы должны поблагодарить добрых людей из IBM за то, что они сделали эту платформу доступной для широкого использования. Сегодня квантовые компьютеры — это эксперименталь - ные машины, поэтому не ждите, что сможете приобрести их в местном магазине компьютерной техники. Тем не менее вскоре они будут массово использоваться в центрах обработки данных, поэтому сейчас самое время научиться квантовому программированию.\n--- Страница 167 ---\n4QISKit — отличный SDK для квантового программирования на Python В этой главе вы познакомитесь с QISKit — лучшим SDK для квантового программирования. Вы узнаете, как просто установить SDK в своей ло - кальной системе. Но прежде, чем писать первую квантовую программу, всегда полезно понять, что такое квантовые вычисления и чем они отлича - ются от классических. Для этой цели приведено очень простое объяснение состояний кубитов и квантовых вентилей с использованием линейной алгебры. В этой главе также показано, как квантовые вычисления могут в точности повторить классический аналог и, кроме того, ускорить полу - чение результатов. Далее в главе рассматривается строение квантовой программы, включая системные вызовы, форматы составления схем, квантовый ассемблер и многое другое. QISKit содержит набор полезных моделирующих устройств для локаль - ного или удаленного выполнения ваших программ, он также позволяет работать в режиме реального времени. Шаг за шагом вы узнаете, как за - пускать квантовые программы на реальном устройстве, предоставленном потрясающей облачной платформой IBM Q Experience. Итак, перейдите на свой Рабочий стол , и приступим.\n--- Страница 168 ---\n168 Глава 4 . QISKit — отличный SDK для программирования на Python Установка QISKit QISKit — это Quantum Information Software Kit, SDK для квантового программирования в облаке. Он написан на Python — мощном сценарном языке для решения научных задач. Мой опыт в основном связан с бизне - сом, и я мало писал на Python в последнее время, поэтому давайте рас - смотрим установку SDK как в Linux CentOS 6 или 7, так и в Windows 64. Начнем с самого простого (Windows), а затем перейдем к самому слож - ному (CentOS). Настройка в Windows QISKit требует Python 3.5 или более поздней версии. Если у вас Windows, то, скорее всего, Python не установлен. Если это так, вы можете получить установщики с веб-сайта Python.org . Загрузите установщик, запустите его и проверьте, произошла ли установка, выполнив в командном окне следующую команду: C:\\>Python -V Python 2.7.6 У меня старый добрый Python 2.7, а у вас может быть установлено не - сколько версий Python одновременно. Я скачал встраиваемый ZIP-файл и развернул его в C:\\Python36-64 , так что в моем случае: C:\\>C:\\Python36-64\\Python.exe -V Python 3.6.4 В Python есть замечательный менеджер пакетов pip (preferred installer program), который сильно упрощает установку модулей. Таким образом, чтобы установить QISKit, просто наберите в консоли: C:\\>pip install qiskit Вывод на экран должен выглядеть аналогично коду из листинга 4.1. Убе - дитесь, что не было сообщений об ошибках. Листинг 4.1. Установка QISKit в Windows 64 бит Collecting qiskit Using cached qiskit-0.4.11.tar.gz",
      "debug": {
        "start_page": 109,
        "end_page": 168
      }
    },
    {
      "name": "Глава 4. QISKit — отличный SDK для квантового программирования на Python 167",
      "content": "--- Страница 171 ---\nУстановка QISKit 171 Теперь установим и проверим pip: $ sudo yum -y install python36u-pip $ pip3.6 -V Наконец, нам нужно установить пакет python36u-devel из IUS, который предоставляет полезные библиотеки для разработки: $ sudo yum -y install python36u-devel Шаг 3. Создание виртуальной среды Этот шаг может быть полезен только в том случае, если у вас многополь - зовательская система с несколькими версиями Python и вы не хотите мешать другим пользователям. Например, чтобы создать виртуальную среду в своей домашней папке, выполните: $ mkdir $HOME/qiskit $ cd $HOME/qiskit $ python3.6 -m venv qiskit С помощью этой последовательности команд в домашней папке поль - зователя создается папка с названием qiskit , где будут храниться все ваши квантовые программы. В ней создается также виртуальная среда Python 3.6, названная qiskit . Чтобы активировать среду, выполните команду: $ source qiskit/bin/activate (qiskit) [centos@localhost qiskit]$ В виртуальной среде вы можете использовать команду python вместо python3.6 и pip вместо pip3.6 , если вам так нравится: $ python -V Python 3.6.4 СОВЕТ Если вы не активируете виртуальную среду, то используйте python3.6 и pip3.6 вместо python и pip.\n--- Страница 172 ---\n172 Глава 4 . QISKit — отличный SDK для программирования на Python Шаг 4. Установка QISKit Активируйте свою виртуальную среду и установите QISKit с помощью команды: $ pip install qiskit В листинге 4.2 показан стандартный вывод для предыдущей команды. Листинг 4.2. Установка QISKit в CentOS 6 Collecting qiskit Downloading qiskit-0.5.7.tar.gz (4.5MB) 100% |████████████████████| 4.5MB 183kB/s Collecting IBMQuantumExperience>=1.8.28 (from qiskit) Downloading IBMQuantumExperience-1.9.0-py3-none-any.whl Collecting matplotlib<2.2,>=2.1 (from qiskit) Downloading matplotlib-2.1.2.tar.gz (36.2MB) 100% |████████████████████| 36.2MB 18kB/s Complete output from command python setup.py egg_info: ==================================== Edit setup.cfg to change the build options BUILDING MATPLOTLIB matplotlib: yes [2.1.2] python: yes [3.6.4 (default, Dec 19 2017, 14:48:15) [GCC 4.4.7 20120313 (Red Hat 4.4.7-18)]] platform: yes [linux] … Installing collected packages: IBMQuantumExperience, numpy, python- dateutil, pytz, cycler, pyparsing, matplotlib, decorator, networkx, ply, scipy, mpmath, sympy, pillow, qiskit Running setup.py install for pycparser … done Running setup.py install for matplotlib … done Running setup.py install for networkx … done Running setup.py install for ply … done Running setup.py install for mpmath … done Running setup.py install for sympy … done Running setup.py install for qiskit … done Successfully installed IBMQuantumExperience-1.9.0 qiskit-0.4.11 requests-2.18.4 requests-ntlm-1.1.0 scipy-1.0.1 six-1.11.0 sympy-1.1.1 urllib3-1.22 (qiskit) [centos@localhost qiskit]$ СОВЕТ В виртуальной среде пакеты Python будут устанавливаться в домашнюю папку среды lib/python3.6/site-packages вместо системного пути, как показано на рис. 4.1.\n--- Страница 173 ---\nКубит 101: базовая алгебра 173 Рис. 4.1. Расположение папки виртуальной среды Python virtual Теперь мы готовы начать писать квантовый код. Посмотрим, как это делается. Кубит 101: базовая алгебра Прежде чем приступить к написанию квантовых программ, нужно не - много освежить знания в области фундаментальной математики, чтобы понимать, что происходит за кулисами. В главе 2 вы узнали, как кубит представляется сферой Блоха (см. рис. 2.7): это геометрическое представ - ление чистого состояния двухуровневой квантово-механической системы (кубита). Но, возможно, лучший способ понять основную модель кубита и влияние квантовых вентилей — воспользоваться его алгебраическим представлением. Для этого вам нужно вспомнить некоторые базовые по - нятия линейной алгебры, включая следующие. Линейные векторы . Про стые векторы вида , которые будут использо - ваться для представления базовых состояний кубита .\n--- Страница 174 ---\n174 Глава 4 . QISKit — отличный SDK для программирования на Python Комплексные числа . Комплексным называется число, состоящее из веще - ственной и мнимой частей, представляемое как a + bi, где . Обратите внимание на то, что комплексные числа не могут существовать в нашей физической реальности. Коэффициенты α, β состояния суперпозиции кубита являются комплексными числами. Комплексное сопряжение . Термин, который вы часто будете слышать в связи с квантовыми вентилями. Чтобы получить комплексное со - пряжение, просто поменяйте на противоположный знак при мнимой части: a + bi становится a – bi и наоборот. Произведение матриц . Если A является матрицей размерности n × m, а B — матрицей размерности m × p, то их произведение AB — это матри - ца размерности n × p, где m элементов строки матрицы A умножаются на m элементов столбца матрицы B, а произведения суммируются для получения элемента матрицы AB. Возьмите первую строку первой матрицы и умножьте каждый ее элемент на каждый элемент перво - го столбца второй матрицы, затем суммируйте произведения, чтобы получить первый элемент матрицы результатов (рис. 4.2). Не стоит паниковать, большинство матриц, которые мы рассмотрим, имеют размерность 2 × 2, а их элементами являются 0 и 1. Рис. 4.2. Базовая операция матричного произведения Алгебраическое представление квантового бита В классической модели основной единицей информации является бит, который представлен 0 или 1. На физическом уровне бит преобразуется в поток напряжения через транзистор. В квантовых вычислениях основной единицей является квантовый бит (кубит), который физически переводит - ся в манипуляции с фотонами, электронами или атомами. Алгебраически кубит представлен кет-вектором.\n--- Страница 175 ---\nКубит 101: базовая алгебра 175 ПРИМЕЧАНИЕ Обозначение «кет-вектор» было введено в 1939 году физиком Полом Дираком и известно также как нотация Дирака. Кет-вектор обычно представлен в виде вектора-столбца и обозначается . Скобочная нотация Дирака В нотации Дирака базовые квантовые состояния кубита представлены векторами и . Они называются вычислительными базисными со - стояниями. ПРИМЕЧАНИЕ Квантовое состояние кубита представляет собой вектор в двумерном комплексном векторном пространстве. Проиллюстрируем это на при - мере простого графа. На рис. 4.3 показано комплексное векторное пространство, используемое для представления состояния кубита. Слева изображено так называемое базисное состояние из двух единичных векторов для состояний и в нотации Дирака. Справа показано общее квантовое состояние, пред - ставляющее собой линейную комбинацию двух этих состояний. Таким образом, базисные состояния и общие квантовые состояния могут быть записаны как векторы: ; , где α и β — амплитуды единичного вектора. Обратите внимание, что амплитуда единичного вектора должна быть равна 1, в связи с чем α и β должны подчиняться ограничению | α|2 + |β|2 = 1. Это алгебраическое представление является ключом к пониманию воздействия логического вентиля на кубит, как вы увидите позже.\n--- Страница 176 ---\n176 Глава 4 . QISKit — отличный SDK для программирования на Python Рис. 4.3. Квантовые состояния кубита Так почему же состояние кубита представлено как вектор в более сложном представлении, чем его классический аналог? Зачем вообще использовать векторы? Причина в следующем: это позволяет построить лучшую модель вычислений, что будет видно, когда мы станем рассматривать квантовые вентили и суперпозицию состояний. В общем, квантовая механика — это теория, развивавшаяся на протяжении многих десятилетий, и, в конце концов, вектор — очень простой математический объект, который легко понять и которым просто манипулировать. Возможно, это лучший рабо - чий инструмент. Суперпозиция — это просто красивое слово Суперпозиция определяется физиками как свойство элементарных частиц находиться в нескольких состояниях одновременно. Если вам трудно по - нять эту концепцию, на помощь придет линейная алгебра. ПРИМЕЧАНИЕ Суперпозиция — это просто линейная комбинация состояний и , то есть , где длина вектора состояния равна 1, как показано на рис. 4.3.\n--- Страница 177 ---\nКубит 101: базовая алгебра 177 Скобочная нотация кажется слишком странной? Используйте векторы Если вам нравится алгебра и вы считаете, что скобочная нотация сбивает вас с толку, просто возьмите вместо нее знакомое векторное представле - ние. Таким образом, суперпозиция из предыдущего раздела может быть записана как: . Обратите внимание, что кет-векторы подчиняются тем же правилам, что и векторы. Например, для них справедливо умножение на скалярную величину: . Изменение состояния кубита с помощью квантовых вентилей Цель квантовых вентилей — управление состоянием кубита для дости - жения желаемого результата. Они являются основными строительными блоками квантовых вычислений так же, как классические логические элементы в классическом мире. Некоторые квантовые вентили являются эквивалентом классических аналогов. Рассмотрим их. Вентиль НЕ (Паули X) Самый простой вентиль, воздействующий на один кубит. Это квантовый эквивалент классического элемента НЕ, как и его аналог, он изменяет со - стояние кубита на противоположное, то есть: .\n--- Страница 178 ---\n178 Глава 4 . QISKit — отличный SDK для программирования на Python На суперпозицию вентиль X действует линейно, то есть он изменяет соответствующее состояние. Таким образом, становится , а ста- новится : . На квантовых схемах вентиль НЕ изображается как X, он известен также как вентиль Паули X (назван в честь австрийского физика Вольфганга Паули, одного из основателей квантовой механики). Начиная с базисного состояния для 0-го кубита, данное состояние распространяется по цепи, пока к нему не будет применено управляющее воздействие, а затем результат продолжит распространяться. Существует другой способ увидеть вентиль Х в действии — с помощью его матричного представления. Можно в точности увидеть, как состояние меняется на противоположное, используя матрицу Паули: . Состояние кубита меняется на противоположное с помощью матричного представления вентиля Х и векторо в и : ; . Существует еще более простая квантовая схема, самая простая из всех — квантовая проволока, обозначаемая греческой буквой «пси» , которая описывает вычислительное состояние во времени. Оно может показаться элементарным, но физически реализо - вать его сложнее всего. Из-за атомарного масштаба квантовая проволока (представьте себе фотоны, электроны или отдельные атомы) очень хрупка и подвержена ошибкам, обусловленным окружающей средой.\n--- Страница 179 ---\nКубит 101: базовая алгебра 179 Другим интересным свойством вентиля X является то, что два элемента НЕ в строке дают единичную матрицу (I) — очень важный инструмент в линейных преобразованиях. Давайте выполним расчеты. Чтобы понять, каково влияние схемы, посмотрим, что произойдет, когда мы перемножим две матрицы X: . Вентиль X — это простейший пример квантового логического элемента, схемы и вычислений. В следующем разделе рассмотрим истинно квантовый вентиль Адамара и то, как он может переключать суперпозиции с помощью схем и алгебры. Истинно квантовые вычисления: управление суперпозициями с помощью вентиля Адамара Воздействие вентиля Адамара на базисные состояния формально опре - деляется как: . Кроме того, суперпозиции состояний вентиль Адамара сопо - ставляет: . В схеме и матричном представлении фильтр Адамара воздействует на одиночный кубит. Применяя вентиль H к базисным состояниям и , получим: ; .\n--- Страница 180 ---\n180 Глава 4 . QISKit — отличный SDK для программирования на Python Так исходя из каких вычислительных соображений используется вентиль Адамара? Что он дает нам? Если не вдаваться в технические детали, ответ заключается в том, что вен - тиль Адамара расширяет диапазон состояний, возможных для квантовой схемы. Это важно, потому что расширение состояний позволяет находить быстрые способы решения и, следовательно, ускорять вычисления. Можно провести аналогию с игрой в шахматы. Например, если бы вашему слону было позволено двигаться, как ферзю и слону одновременно (расширение состояний), это дало бы вам преимущество в игре и позволило быстрее поставить мат сопернику. Увеличение мощности квантовой машины — вот что дает вентиль Адамара. Измерение квантового состояния сложнее, чем кажется Представьте, что в подвале вашего дома есть лаборатория. Вам даны кубит в состоянии и измерительный прибор, и вас просят вычислить коэффициенты α и β. То есть вычислить квантовое состояние. Задача может показаться простой, однако это невозможно сделать. Прин - ципы квантовой механики утверждают, что квантовое состояние системы непосредственно не наблюдается. Лучшее, что можно сделать, — угадать приблизительную информацию об α и β. Этот процесс называется изме - рением в вычислительном базисе. Результатом измерения квантового состояния являются классические биты: с вероятностью | α|2; с вероятностью | β|2. Таким образом, процесс измерения определяет вероятности для клас - сических битов 0 и 1 равными абсолютным значениям коэффициентов α и β, возведенным в квадрат. Представить на физическом уровне, как протекает этот процесс, можно наблюдением физического фотона, атома или электрона с помощью измерительного устройства. Поэтому при из - мерениях часто используются квантовые вентили.\n--- Страница 181 ---\nКубит 101: базовая алгебра 181 Измерение нарушает состояние квантовой системы, давая в результате классические биты. Важно помнить, что по завершении этого процесса коэффициенты α и β разрушаются. Это означает, что мы не можем хранить большие объемы информации в кубите. Представьте: если бы мы могли измерить точные значения α и β, то с помощью комплексных чисел тео - ретически можно было бы хранить бесконечное количество классической информации в состоянии кубита. Вычисляя точные значения α и β, мы могли бы извлечь всю эту информацию. Однако это невозможно. С точки зрения квантовой механики это недопустимо. Последнее замечание по поводу измерений касается нормализации кван - тового состояния: при измерении в вычислительном базисе сумма вероятностей для классических битов 0 и 1 должна быть равна 1. То есть: Вероятность(0) + Вероятность(1) = | α|2 + |β|2 = 1. Значит, длина вектора квантового состояния должна быть равна 1 (нор - мирована). Это происходит из-за того, что вероятности для измерения в сумме дают 1. В следующем разделе мы поговорим о том, как обобщаются однокубитные логические вентили, что они собой представляют и как используются для построения более сложных схем. Обобщенные однокубитные вентили До сих пор мы видели два простых вентиля X и H, представленных ма - трицами: . Вспомните также, что суперпозиция квантового состояния выражается как векто р . Тогда применение обоих вентилей к квантовому со - стоянию м ожет быть представлено в обобщенном виде для любой еди - ничной матрицы: , где U = H, X.\n--- Страница 182 ---\n182 Глава 4 . QISKit — отличный SDK для программирования на Python U называется обобщенным однобитовым вентилем с тем ограничением, что U должен быть унарным. ПРИМЕЧАНИЕ Матрица U является унитарной, если результатом ее умножения на эрмитово сопряженную U† является единичная матрица: U†U = I. Эрмитово сопряжение (https://en.wikipedia.org/wiki/Hermitian_con- jugate) обозначается символом † (https://en.wikipedia.org/wiki/Dagger): U† = (UT)*, то есть комплексное сопряжение транспонированной ма - трицы. Транспонированная матрица — это новая матрица, строки которой явля - ются столбцами первоначальной. Наприме р, если , то . Затем для получения эрмитова сопря жения возьмите ком - плексное сопряжение каждого элемен та. (К омплексным сопряжением a + bi, где a и b вещественные, является a – bi, то есть меняется на противо - положный знак при мнимой части, если таковая имеется.) Обратите внимание, что оба вентиля, H и X, должны быть унарными. Это очень просто проверить, вычислив X†X = I и H†H = I: ; . Унитарные матрицы хороши для квантовых вентилей Вопрос, который возникает после прочтения предыдущего раздела: зачем нужны все эти трудности? Почему вентили X и H должны быть унарны - ми? Ответ заключается в том, что унитарные матрицы сохраняют длину вектора. Это полезно для квантовых вентилей, потому что они требуют нормализации входных и выходных состояний (имеют длину вектора 1).\n--- Страница 183 ---\nКубит 101: базовая алгебра 183 На самом деле унитарные матрицы — это единственный тип матриц, со - храняющих длину, и, следовательно, единственный тип матриц, который можно использовать для квантовых вентилей. В общем, возникают более глубокие вопросы: почему квантовые вентили должны быть в первую очередь линейными и зачем вообще применять матричное представление? Мы постараемся ответить на них в следующем разделе, а пока нужно при - нять это как данность. Другие однокубитные вентили В предыдущем разделе мы рассмотрели однокубитные вентили X и H. В то же время существуют и другие однобитные вентили, которые полезны в квантовых вычислениях. У вентиля X есть два партнера: Y и Z. Они образуют трио, известное как вентили Паули ( σ): Эти три матрицы подходят для задач обработки информации, таких как сверхплотное кодирование (SDC) — процесс, который ориентирован на эффективное хранение классической информации в кубите. Они также используются при анализе свойств атома, таких как спин электрона. Вдобавок тесно связаны с тремя измерениями пространства XYZ. Вентиль вращения: Представляет собой уже знакомый нам поворот на угол θ в реальном пространстве. Это унитарная матрица, и в данном случае вентиль Т выполняет вращение на π/4 вокруг оси Z. Этот вентиль требуется для универсального контроля. Вентили также могут управлять многими кубитами, как мы увидим в следующем разделе. Запутывание кубитов с помощью управляемого вентиля НЕ Это последний вентиль в арсенале, необходимом для квантовых вычисле - ний. Управляемый вентиль НЕ (CNOT) представляет собой двухкубит - ный вентиль с четырьмя вычислительными состояниями.\n--- Страница 184 ---\n184 Глава 4 . QISKit — отличный SDK для программирования на Python Для суперпозиции вентиль CNOT с четырьмя базисными состояниями дает , где α, β, δ и γ — коэффициенты суперпозиции. Квантовая схема: Матричное представление оператора CNOT для базисных состояний:Символ «плюс» (+) называется управляемым кубитом, а серая точка (под ним) — это управляющий кубит. Вентиль CNOT выполняет простые действия: • если для управляющего кубита установлено состояние 1, то состояние управляемого кубита меняется на противоположное; • в противном случае ничего не происходит. Точнее, если первый бит является управля - ющим, то: • значение управляющего кубита 0 — ничего не выполнять; • значение управляющего кубита 0 — ничего не выполнять; • значение управляющего кубита 1 — изменить состояние второго на противоположное; • значение управляющего кубита 1 — изменить состояние второго на противоположное. Простое представление данных состояний: . ПРИМЕЧАНИЕ Вентиль CNOT необходим для запутывания, что критично для всех видов задач, включая квантовую телепортацию, сверхплотное кодиро - вание и практически любой квантовый алгоритм. Например, для того, чтобы запутать два кубита, нужно применить вентиль Адамара (Н) к первому кубиту и затем вентиль CNOT — ко второму, как показано далее.\n--- Страница 185 ---\nКубит 101: базовая алгебра 185 Для базисного состояния кубита (2) вентиль Адамара да ет . После применен ия вентиля CNOT состояние второго кубита изменяется на противоположное, если состояние управляющего соответствует 1, то есть . Это создает запутанное состояние между кубитами 1 и 2. В общем, вентиль CNOT и однокубитные вентили являются мощным арсеналом для квантовых вычислений. Поскольку они позволяют строить унитарные операции на любом количестве кубитов, их называют универ - сальными для квантовых вычислений. Это означает, что для создания квантового компьютера, который может решить любую квантовую задачу, достаточно использовать однокубитные вентили совместно с вентилем CNOT и вентилями измерения. Универсальные квантовые вычисления позволяют получить решение быстрее, чем классические Вы можете задаться вопросом: как все эти схемы и формулы из предыду - щего раздела помогут в решении вычислительных задач, которые легче и, скорее всего, дешевле решить в классической системе. Если принять во внимание так называемую битовую мощность классической системы: x → f(x), где при заданном входном значении x цель состоит в том, чтобы вычислить функцию f(x) по крайней мере за 2k–1 элементарных операции (где k — это битовая мощность), то универсальные квантовые вычисления могут обеспечить эквивалентную схему примерно того же размера, которая содержит ту же классическую модель: .\n--- Страница 186 ---\n186 Глава 4 . QISKit — отличный SDK для программирования на Python В этой схеме удивительно то, что иногда существуют быстрые пути реше - ния, обеспечивающие большую мощность квантовых вычислений и более быстрое получение результатов. Это означает, что вы можете вычислить f(x) менее чем за 2k–1 операции. Для некоторых квантовых алгоритмов, таких как факторизация, ускорение является экспоненциальным! Это ис - тинная сила квантовых систем. Итак, теперь, когда вы изучили базовую математическую модель квантовых схем, пришло время переключиться в режим программирования и посмотреть, как все это можно превратить в настоящую компьютерную программу, которая будет выполняться на реальном квантовом устройстве. Ваша первая квантовая программа Рассмотрим структуру квантовой программы на простейшем примере. В нем мы создадим один кубит, один классический регистр для его из - мерения, затем применим вентиль Паули Х (битовое инвертирование) к кубиту и, наконец, измерим его значение. Основной псевдокод про - граммы можно воспроизвести следующим образом. 1. Создать квантовую программу. 2. Создать один или несколько кубитов и классических регистров для их измерения. 3. Создать схему, которая объединит кубиты в устройство выполнения логических операций. 4. Применить квантовые вентили к кубитам для достижения желаемого результата. 5. Измерить кубиты в классических регистрах, чтобы получить конечный результат. 6. Скомпилировать программу. На данном шаге создается JSON-пред- ставление программы в специфическом формате, который будет описан позже в этом разделе. 7. Запустить на моделирующем или реальном квантовом устройстве. 8. Получить результаты.\n--- Страница 187 ---\nВаша первая квантовая программа 187 Теперь подробно рассмотрим как код на Python, так и схему в Composer. Листинг 4.3. Строение квантовой программы ############################# import sys import qiskit import logging from qiskit import QuantumProgram # Main sub def main(): # Создать программу qp = QuantumProgram() # Создать один кубит quantum_r = qp.create_quantum_register(\"qr\", 1) # Создать один классический регистр classical_r = qp.create_classical_register(\"cr\", 1) # Создать схему qp.create_circuit(\"Circuit\", [quantum_r], [classical_r]) # Получить схему по названию circuit = qp.get_circuit('Circuit') # Включить ведение журналов qp.enable_logs(logging.DEBUG); # Применить вентиль Паули X к первому кубиту в квантовом регистре \"qr\" circuit.x(quantum_r[0]) # Измерительный вентиль, приводящий нулевой кубит к классическому биту 0 circuit.measure(quantum_r[0], classical_r[0]) # Серверное моделирующее устройство backend = 'local_qasm_simulator' # Набор исполняемых схем circuits = ['Circuit'] # Компиляция вашей программы qobj = qp.compile(circuits, backend) # Запуск на моделирующем устройстве result = qp.run(qobj, timeout=240) # Вывод итоговых результатов print (str(result.get_counts('Circuit')))\n--- Страница 188 ---\n188 Глава 4 . QISKit — отличный SDK для программирования на Python ########################################### # Linux :main() # windows if __name__ == '__main__': main() Рассмотрим, что происходит в листинге 4.3. В строках 2–5 импортируются нужные библиотеки: sys (системная), qiskit (квантовые классы), logging (для отладки) и QuantumProgram — базового класса для всех программ. Затем в строке 11 создается QuantumProgram . Это точка доступа ко всем операциям. Для создания списка кубитов воспользуйтесь системным вызовом квантовой программы create_quantum_register(NAME, SIZE) , где NAME — это название списка регистров, а SIZE — количество кубитов. В данном случае оно равно 1 (строка 14). Для каждого кубита создайте классический регистр для проведения из - мерений с помощью системного вызова create_classical_register(NAME, SIZE) . Затем создайте схему, добавив системный вызов create_cir cuit(NAME, QUANTUM_SET, CLASSIC_SET ), где NAME — название схемы, QUANTUM_SET — список кубитов, а CLASSIC_SET — список классических регистров. Схе - ма — это логический блок, содержащий все кубиты и классические регистры (строка 20). При желании включите отладку с помощью системного вызова enable_ logs(LEVEL) , где LEVEL может иметь одно из значений logging.DEBUG , logging.INFO и т. д. (обычные журналы). Затем пропустите кубиты через квантовые вентили и выполните их измерения, чтобы получить результаты. В данном случае мы при - меняем вентиль Паули Х, который изменяет изначальное состояние кубита с на (строки 25–29). Наконец, скомпилируйте программу и запустите моделирующее или ре - альное устройство. В данном случае выполняем запуск на локальном мо - делирующем устройстве на Python ( local_qasm_simulator ) (строки 37–4 1).\n--- Страница 189 ---\nВаша первая квантовая программа 189 Разработчики под Windows, будьте внимательны! Вам нужно обернуть свою программу в функцию main и затем вызвать ее: if __name__ == '__main__': main() В Windows так придется сделать, потому что QISKit выполняет про - грамму с помощью асинхронных задач (исполнителей), а при запуске такой задачи подпроцесс сначала выполняет основной модуль. Таким об - разом, вам нужно защитить основной код, чтобы избежать рекурсивного создания подпроцессов. Я выяснил это на собственном горьком опыте, когда мои программы правильно работали в CentOS, но в Windows вы - давали ошибку: RuntimeError: An attempt has been made to start a new process before the current process has finished its bootstrapping phase. This probably means that you are not using fork to start your child processes and you have forgotten to use the proper idiom in the main module: if __name__ == '__main__': freeze_support() … The \"freeze_support()\" line can be omitted if the program is not going to be frozen to produce an executable. Это может создать затруднения для новичков в разработке на Python. Теперь запустите программу, чтобы увидеть вывод: INFO:qiskit._jobprocessor:<qiskit._result.Result object at 0x000000000D99F470> {'1': 1024} Результатом является документ в формате JSON {'1': 1024} , где 1 соот - ветствует результату измерения кубита (помните, что мы использовали вентиль X для инверсии бита), а 1024 — количество итераций с таким результатом. Вероятность получения данного результата рассчитывается как отношение количества итераций с ним (1024) к общему количеству итераций программы (1024). В данном случае P = 1024 / 1024 = 1.\n--- Страница 190 ---\n190 Глава 4 . QISKit — отличный SDK для программирования на Python ПРИМЕЧАНИЕ Квантовые компьютеры — это вероятностные машины. Всем измере - ниям сопутствует вероятность получения определенного результата. Листинг 4.3 может также быть описан эквивалентной квантовой схемой, быстро составленной в Composer в IBM Q Experience (рис. 4.4). Рис. 4.4. Эксперимент в Composer для листинга 4.3 Здесь показаны квантовая схема для листинга 4.3, результат экспери - мента и сопутствующая ему вероятность. Как видите, схема очень про - ста: в Composer нужно перетащить вентиль X в положение над нулевым кубитом, а затем выполнить измерение на этом же кубите. Composer по - кажется вам замечательным инструментом для построения относительно простых схем, их выполнения и визуализации результатов! Теперь давайте заглянем во внутренние компоненты SDK, чтобы увидеть, как обрабаты - вается этот код. Внутренние компоненты SDK: компиляция схемы и QASM На рис. 4.5 показаны внутренние процессы, происходящие при запуске вашей программы. QISKit компилирует схему (схемы) программы в документ в формате JSON, который будет отправлен на локальное моделирующее устройство.\n--- Страница 191 ---\nВаша первая квантовая программа 191 Управляющее устройство анализирует этот документ, запускает схему и возвращает документ в формате JSON без четкой структуры (скрытый от разработчика). QISKit обертывает результирующий JSON-документ в объект, до - ступный для основной программы. Например, вызов result.get_ counts('Circuit') извлекает численные данные из этого документа. Рис. 4.5. Схема последовательности действий между программой, QISKit и локальным моделирующим устройством Компиляция схемы В листинге 4.4 показан формат скомпилированной программы перед от - правкой на моделирующее устройство. В документе приводятся: идентификатор выполнения; заголовок с информацией о моделирующем устройстве, включая на - звание, количество кредитов, использованных при выполнении, коли - чество запусков;\n--- Страница 192 ---\n192 Глава 4 . QISKit — отличный SDK для программирования на Python раздел схем, содержащий массив объектов. Каждая схема содержит: •название; •заголовок (конфигурацию) с такой информацией, как карта связей кубитов, базовые (физические) вентили, начальное число времени выполнения и т. д.; •раздел скомпилированной схемы с заголовком, содержащим инфор - мацию о кубитах и классических регистрах, массивом операторов (или вентилей), примененных к схеме, и их параметрами. Листинг 4.4. Формат скомпилированной программы из листинга 4.3 { \"id\": \"aA46vJHgnKQko3u5L1QqbUDk31sY2m\", \"config\": { \"max_credits\": 10, \"backend\": \"local_qasm_simulator\", \"shots\": 1024 }, \"circuits\": [{ \"name\": \"Circuit\", \"config\": { \"coupling_map\": \"None\", \"layout\": \"None\", \"basis_gates\": \"u1,u2,u3,cx,id\", \"seed\": \"None\" }, \"compiled_circuit\": { \"operations\": [{ \"name\": \"u3\", \"params\": [3.141592653589793, 0.0, 3.141592653589793], \"texparams\": [\"\\\\pi\", \"0\", \"\\\\pi\"], \"qubits\": [0] }, { \"name\": \"measure\", \"qubits\": [0], \"clbits\": [0] }], \"header\": { \"number_of_qubits\": 1, \"qubit_labels\": [ [\"qr\", 0] ],\n--- Страница 193 ---\nВаша первая квантовая программа 193 \"number_of_clbits\": 1, \"clbit_labels\": [ [\"cr\", 1] ] } }, \"compiled_circuit_qasm\": \"OPENQASM 2.0;\\ninclude \\\"qelib1.inc \\\"; \\nqreg qr[1];\\ncreg cr[1];\\nu3(3.14159265358979,0,3.14159265358979) qr[0];\\ nmeasure qr[0] -> cr[0];\\n\" }] } Для того чтобы отобразить схему, скомпилированную в вашей програм - ме, распечатайте результат шага компиляции с помощью следующей команды: qobj = qp.compile(circuits, backend) print(str(qobj)) ПРИМЕЧАНИЕ Формат компиляции непрозрачен для программиста и предназначен не для прямого доступа, а через SDK API. Причина в том, что его формат может меняться от версии к версии. Однако всегда хорошо понимать, что происходит за кулисами. Результаты выполнения Это ответный документ от локального моделирующего устройства к QISKit. Формат документа показан в листинге 4.5. Наиболее значимая информация, содержащаяся в нем: статус запуска, время выполнения, название моделирующего устрой - ства и т. д.; результирующие данные. И х можно получить внутри вашей программы с помощью вызова print (str(result.get_counts('Circuit'))) .\n--- Страница 194 ---\n194 Глава 4 . QISKit — отличный SDK для программирования на Python Листинг 4.5. Документ с результатами от моделирующего устройства { \"backend\": \"local_qiskit_simulator\", \"id\": \"aA46vJHgnKQko3u5L1QqbUDk31sY2m\", \"result\": [{ \"data\": { \"counts\": { \"1\": 1024 }, \"time_taken\": 0.0780002 }, \"name\": \"Circuit\", \"seed\": 123, \"shots\": 1024, \"status\": \"DONE\", \"success\": true, \"threads_shot\": 4 }], \"simulator\": \"qubit\", \"status\": \"COMPLETED\", \"success\": true, \"time_taken\": 0.0780002 } Получить документ с результатами немного сложнее, потому что это объект без четкой структуры, недоступный для пользовательской про - граммы. Тем не менее вы можете сохранить скомпилированную схему из предыдущего раздела и вручную передать ее в моделирующее устройство, чтобы получить результат, показанный в листинге 4.5. Однако это задание оставлено для самостоятельного выполнения. Важно помнить, что до - кумент с результатами, как и формат компиляции, непрозрачен для про - граммиста. Причина в том, что их форматы могут меняться со временем. Тем не менее всегда полезно понимать, что происходит за кадром. ПРИМЕЧАНИЕ Разработчикам моделирующих устройств будет полезно разбираться в форматах компиляции и результатов. Например, вы можете со - хранить форматы компиляции и результатов для примера схемы, исправить ошибку в моделирующем устройстве на C++, передать схему и сравнить результаты. Таким образом, ваше моделирующее устройство можно легко интегрировать с SDK, чтобы остальные поль - зователи могли его опробовать.\n--- Страница 195 ---\nВаша первая квантовая программа 195 Код ассемблера Скомпилированная схема из листинга 4.4 включает раздел, который со - держит трансляцию программы на квантовый ассемблер (QASM), как показано в следующем отрывке: OPENQASM 2.0; include \"qelib1.inc\"; qreg qr[1]; creg cr[1]; x qr[0]; measure qr[0] -> cr[0]; ПРИМЕЧАНИЕ QASM полезен только тогда, когда запуск происходит на удаленном моделирующем устройстве, предоставляемом IBM Q Experience. Локальные моделирующие устройства QISKit Доступ к реальным квантовым устройствам в IBM Q Experience огра - ничен кредитами, количество которых уменьшается по мере использо - вания. Таким образом, не стоит запускать совсем простые программы, такие как в листинге 4.3. Для этой цели QISKit предоставляет множество моделирующих устройств, способных удовлетворить все потребности в тестировании. В табл. 4.1 приведен список локальных и удаленных моделирующих устройств, доступных через QISKit и IBM Q Experience на момент написания этой книги. Таблица 4.1. Список локальных и удаленных моделирующих устройств для IBM Q Experience Название Описание local_qasm_simulator Моделирующее устройство на Python, поставляемое по умолчанию в комплекте с QISKit. Надо отметить, что оно очень медленное local_clifford_simulator, также известный как local_qiskit_ simulatorВысокопроизводительное моделирующее устройство, написанное на C++, с реалистичной эмуляцией шума и ошибок Продолжение \n--- Страница 196 ---\n196 Глава 4 . QISKit — отличный SDK для программирования на Python Название Описание ibmqx_qasm_simulator Высокопроизводительное 24-кубитное удаленное моделирующее устройство на QASM, предоставляемое Q Experience. Это удаленное моделирующее устройство по умолчанию ibmqx_hpc_qasm_simulator Тридцатидвухкубитное сверхмощное параллельное моделирующее устройство, предоставляемое Q Experience. Это резервная замена для удаленного моделирующего устройства по умолчанию В качестве простого упражнения получите список моделирующих и реаль - ных устройств от IBM Q Experience, вставив в браузер следующий URL для REST API: https://quantumexperience.ng.bluemix.net/api/Backends?access_ token=ACCESS_TOKEN . Конечно, вам нужен токен доступа, который можно легко получить с по- мощью API удаленного доступа, рассмотренного в главе 3. Далее запустим нашу программу на других локальных моделирующих устройствах, вклю - чая удаленное моделирующее устройство от IBM Q Experience. Наконец, посмотрим, какое моделирующее устройство самое быстрое. Запуск на локальном моделирующем устройстве, написанном на C++ QISKit по умолчанию использует моделирующее устройство на чистом Python ( local_qasm_simulator ). Однако вы можете воспользоваться и бы- стродействующим моделирующим устройством на C ++ с реалистичным уровнем шума и ошибок, изменив название серверного ПО в своей про - грамме на local_clifford_simulator или local_qiskit_simulator (строка 35 в листинге 4.3). Но прежде, чем задействовать его, следует учесть неко - торые предостережения. Пользователям Linux . Данное моделирующее устройство работает на основе стандарта C++11, требующего gcc 5.3 или более поздней версии. Фактически это моделирующее устройство так и не было скомпили - ровано в моих системах CentOS 6 и 7 (вы же можете взять Windows).Таблица 4.1 (продолжение)\n--- Страница 197 ---\nВаша первая квантовая программа 197 Пользователям Windows . Python использует утилиту CMake для ком - пиляции моделирующего устройства на лету. В общем, источник по умолчанию не предоставляет решение Visual Studio для сборки в Windows. Тем не менее я подготовил одно решение и исправил пару ошибок, с которыми столкнулся в Windows 7. СОВЕТ Бинарный файл для 64-разрядной Windows для моделирующего устрой - ства на C++ можно найти в исходниках книги по адресу Ch04\\qiskit- simulator\\qiskit-simulator\\x64\\Debug. Программа Visual Studio 2017 так - же предоставляется, если вы хотите скомпилировать его самостоятельно. Убедитесь, что вы скопировали все файлы из этой папки в HOME\\Lib\\ site-packages\\qiskit\\backends, если их там нет. Запуск на удаленном моделирующем устройстве Для запуска на удаленном моделирующем устройстве, предоставляемом IBM Q Experience, нужно немного изменить листинг 4.3. Давайте посмотрим как. Первое, что нам потребуется, — дескриптор конфигурации IBM Q Experience с параметрами выполнения, приведенными в следующем отрывке: APItoken = 'YOU-API-TOKEN' config = { 'url': 'https://quantumexperience.ng.bluemix.net/api', # Следующий код понадобится только пользователям IBM Q 'hub': 'MY_HUB', 'group': 'MY_GROUP', 'project': 'MY_PROJECT' } СОВЕТ Предыдущий код должен храниться в отдельном файле (Qconfig.py) в той же папке, что и основная программа. Получите свой токен API из веб-консоли IBM Q Experience, как показано в главе 3, и вставьте его в код. Обратите внимание, что хаб, группу и проект указывают только корпоративные клиенты.\n--- Страница 198 ---\n198 Глава 4 . QISKit — отличный SDK для программирования на Python Затем импортируйте упомянутый ранее дескриптор в основную программу: # Конфигурация Q Experience import Qconfig # Main sub def main(): Наконец, замените исполняющее серверное ПО на удаленное моделиру - ющее устройство. 1. Измените название серверного ПО на ibmq_qasm_simulator . 2. Сообщите квантовой программе, что ей нужно использовать IBM Q Experience, установив параметры API с помощью системного вызова qp.set_api(Qconfig.APItoken, Qconfig.config['url']) , где APItoken и URL — значения, взятые из дескриптора конфигурации. 3. Выполните в IBM Q Experience посредством системного вызова result = qp.execute(circuits, backend, shots=512, max_credits=3 ). Обратите вни - мание на то, что мы не компилируем и не запускаем схему, как раньше. Поэтому вы должны удалить вызовы qobj = qp.compile(circuit, backend) и result = qp.run(qobj, wait = 2, timeout = 240). Изменения показаны в следующей команде. Убедитесь, что вы удалили результаты предыдущих компиляций и запустили системные вызовы, иначе программа не будет выполнена: backend = 'ibmqx_qasm_simulator' # Группа исполняемых схем circuits = ['Circuit'] # установите APIToken и url для API Q Experience qp.set_api(Qconfig.APItoken, Qconfig.config['url']) result = qp.execute(circuits, backend, shots=512, max_credits=3, wait=10, timeout=240) Наконец, запустите на выполнение и протестируйте. Должен получиться вывод, похожий на следующий: DEBUG:qiskit.backends._qeremote:Running on remote backend ibmq_qasm_ simulator with job id: 3677ff592e5e5a6fd31a569b0b4faf92\n--- Страница 199 ---\nВаша первая квантовая программа 199 INFO:qiskit._jobprocessor:<qiskit._result.Result object at 0x0000000004A35160> {'1': 512} Теперь соберем все вместе и посмотрим, какое моделирующее устройство самое быстрое. Я делаю ставку на C++. Наиболее быстро моделирующее устройство по результатам сравнения времени выполнения Я собрал статистику о времени выполнения для всех моделирующих устройств на машине с 64-битным процессором под управлением Windows 7. Невероятно, но самым быстрым оказалось удаленное моделирующее устройство IBM Q Experience, за которым следовали чистый Python и мой личный фаворит C++ (рис. 4.6). Рис. 4.6. Время выполнения для моделирующих устройств QISKit Несмотря на то что вызов проходит через сеть, удаленному моделиру - ющему устройству IBM Q Experience удается превзойти другие. Меня поразило то, что интерпретируемое моделирующее устройство на Python может быть быстрее реализации машинного кода. Вероятно, это связано с тем, что вызов машинного кода использует асинхронные задачи для по - рождения процесса моделирующего устройства на C++ и таким образом приводит к такому замедлению, что код на Python превосходит его. Теперь, когда вы узнали, как запустить программу на моделирующем устройстве, сделаем это на реальном.\n--- Страница 200 ---\n200 Глава 4 . QISKit — отличный SDK для программирования на Python Запуск на реальном квантовом устройстве Изменим программу из предыдущего раздела, чтобы усложнить схему. Листинг 4.6 показывает пример схемы, которая выполняет серию враще - ний на первом кубите квантового компьютера. Вращения демонстрируют использование физических затворов реального квантового процессора ibmqx4 u1, u2 и u3 для поворота кубита вокруг осей X, Y и Z сферы Блоха на θ, φ или λ градусов. ПРИМЕЧАНИЕ Сфера Блоха — это геометрическое представление кубита, где верх - няя часть оси Z отвечает базисному состоянию , а нижняя — . Поворот вокруг данной оси представляет собой вероятность того, что кубит коллапсирует в определенном направлении при выполнении измерения (рис. 4.7). Рис. 4.7. Представление кубита на сфере Блоха Физические вентили, известные также как базовые вентили, важны, пото - му что на их основе строятся более сл ожные логические элементы. Таким образом, в листинге 4.6 выполняются следующие шаги.\n--- Страница 201 ---\nВаша первая квантовая программа 201 1. Выделяются пять кубитов и пять классических измерительных реги - стров, соответствующих пяти кубитам, доступным в процессоре ibmqx4 в Q Experience (строки 17–20). 2. Затем на первом кубите выполняется последовательность вращений с использованием базисных элементов u1, u2 и u3 (строки 29–34). 3. Наконец, на кубите выполняется измерение, а результат сохраняется в классическом регистре. 4. Перед выполнением в качестве серверного ПО устанавливается ibmqx4 (пятикубитный процессор — строка 42), а токен аутентификации и URL- адрес API задаются через set_api(Qconfig.APItoken, Qconfig.config ['url']). 5. Для выполнения на реальном квантовом устройстве используйте си - стемный вызов execute QuantumProgram(NAMES, BACKEND, shots = SHOTS, max_credits = CREDITS, timeout = TIMEOUT) , где: •NAMES — список названий схем; •SHOTS — количество итераций, выполненных в схеме. Чем оно боль - ше, тем выше точность; •CREDITS — максимальное количество баллов, которое вы хотите по - тратить из своего банка кредитов на выполнение (15 — заданное по умолчанию начальное количество). Обратите внимание, что чем больше снимков вы сделаете, тем больше кредитов будет вычтено из банка. Следите за этим, чтобы не исчерпать кредиты; •TIMEOUT — тайм-аут чтения из удаленной конечной точки. ПРИМЕЧАНИЕ Квантовые программы или эксперименты на Python, выполненные на реальном устройстве, не записываются в разделе Composer-Scores IBM Q Experience. Это связано с тем, что Python неявно использует Jobs из REST API, который вместо этого помещает эксперимент в очередь вы - полнения. Если хотите записать то, что выполнили, в Composer, можете использовать веб-консоль или REST API, как показано в следующем разделе .\n--- Страница 202 ---\n202 Глава 4 . QISKit — отличный SDK для программирования на Python Листинг 4.6. Пример схемы № 2 import sys,time,math import qiskit import logging from qiskit import QuantumProgram # Конфигурация Q Experience import Qconfig # Main sub def main(): # Создать программу qp = QuantumProgram() # Создать один кубит quantum_r = qp.create_quantum_register(\"qr\", 5) # Создать один классический регистр classical_r = qp.create_classical_register(\"cr\", 5) # Создать схему circuit = qp.create_circuit(\"Circuit\", [quantum_r], [classical_r]) # Включить ведение журналов qp.enable_logs(logging.DEBUG); # Первый физический вентиль: u1( λ) к кубиту 0 circuit.u2(-4 *math.pi/3, 2 * math.pi, quantum_r[0]) circuit.u2(-3 *math.pi/2, 2 * math.pi, quantum_r[0]) circuit.u3(-math.pi, 0, -math.pi, quantum_r[0]) circuit.u3(-math.pi, 0, -math.pi/2, quantum_r[0]) circuit.u2(math.pi, -math.pi/2, quantum_r[0]) circuit.u3(-math.pi, 0, -math.pi/2, quantum_r[0]) # Измерительный вентиль, приводящий кубит 0 к классическому биту 0 circuit.measure(quantum_r[0], classical_r[0]) circuit.measure(quantum_r[1], classical_r[1]) circuit.measure(quantum_r[2], classical_r[2]) # Серверное ПО backend = 'ibmqx4' # Набор исполняемых схем circuits = ['Circuit'] # Установить APIToken и URL-адрес API Q Experience qp.set_api(Qconfig.APItoken, Qconfig.config['url'])\n--- Страница 203 ---\nВаша первая квантовая программа 203 result = qp.execute(circuits, backend, shots=512, max_credits=3, timeout=240) # Вывод полученных числовых значений print (\"Job id=\" + str(result.get_job_id()) + \" Status:\" + result.get_status()) ########################################### if __name__ == '__main__': start_time = time.time() main() print(\"--- %s seconds ---\" % (time.time() — start_time)) Квантовая схема для Composer Программу из листинга 4.6 также можно создать в Composer от IBM Q Experience с помощью удобного пользовательского интерфейса с поддерж - кой перетаскивания объектов мышью. Просто перетащите вентиль на ги - стограмму кубита (рис. 4.8), установите параметры для вентиля и, наконец, сохраните и запустите на моделирующем или реальном устройстве. Рис. 4.8. Схема для листинга 4.6, созданная в Composer от Q Experience Тем, кто предпочитает ассемблер, Composer позволяет копировать и встав - лять код непосредственно в консоль в режиме ассемблера (рис. 4.9). Он даже проанализирует любые синтаксические ошибки в вашем коде и покажет строки, в которых они содержатся. Есть несколько способов выполнить ваш эксперимент в IBM Q Experience. Один из самых интересных — воспользоваться их прекрасным REST A PI.\n--- Страница 204 ---\n204 Глава 4 . QISKit — отличный SDK для программирования на Python Рис. 4.9. Composer в режиме ассемблера для схемы, показанной на рис. 4.8 Выполнение с помощью вашего любимого клиента REST Это один из самых интересных способов взаимодействия с Q Experience. Используя простые REST-запросы, вы можете делать практически все, что делаете в Python или Composer: получить список устройств серверного ПО; получить аппаратные или калибровочные параметры для реальных устройств; получить информацию об очереди выполнения задания; получить статус задания или эксперимента; добавить или отменить задания; выполнить эксперимент и записать его в разделе Composer под назва - нием Scores . ПРИМЕЧАНИЕ REST API позволяет использовать любой язык, чтобы создать собствен - ный интерфейс для взаимодействия с Q Experience (даже браузер). Этот API подробно описан в главе 3.\n--- Страница 205 ---\nВаша первая квантовая программа 205 Существует два способа отправки экспериментов с использованием REST: через API заданий и выполнения. Посмотрим, как это делается. Запуск через API заданий Вы можете применить любимый браузерный REST-клиент для отправки эксперимента, приведенного в листинге 4.6. Например, с помощью Chrome YARC (еще один клиент REST) создайте HTTP-запрос POST к конечной точке: https://quantumexperience.ng.bluemix.net/api/Jobs?access_token=ACCESS_TOKEN . Самое сложное — получить токен доступа или ключ доступа. Для этого вы должны пройти аутентификацию, используя свой токен API или имя пользователя и пароль. Обратите внимание на то, что токен API не следу - ет путать с токеном доступа. Чтобы получить токен доступа, вы должны выполнить запрос аутентификации (см. раздел «Удаленный доступ через REST API» главы 3). ПРИМЕЧАНИЕ YARC от Chrome позволяет создавать запросы REST и сохранять их как избранные. Создайте запрос аутентификации для IBM Q Experience, как описано в главе 3, сохраните его как избранный и используйте каждый раз для получения токена доступа при тестировании других вызовов REST API. Полезные данные запроса представляют собой документ в формате JSON, показанный в листинге 4.7. Формат описан в табл. 4.2. Таблица 4.2. Формат запроса для API заданий Ключ Описание qasms Массив программ на ассемблере, записанных в одну строку и разделенных символами конца строки (\\n) Shots Количество итераций вашего кода backend Описание серверного ПО. В данном случае это ibmqx4 maxCredits Подсказка о том, сколько кредитов будет вычтено из баланса вашего счета\n--- Страница 206 ---\n206 Глава 4 . QISKit — отличный SDK для программирования на Python Листинг 4.7. HTTP-запрос для API заданий { \"qasms\": [{ \"qasm\": \"\\n\\ninclude \\\"qelib1.inc\\\";\\nqreg q[5];\\ncreg c[5];\\nu2 (-4*pi/3,2*pi) q[0];\\nu2(-3*pi/2,2*pi) q[0];\\nu3(-pi,0,-pi) q[0]; \\nu3(-pi,0,-pi/2) q[0];\\nu2(pi,-pi/2) q[0];\\nu3(-pi,0,-pi/2) q[0]; \\nmeasure q -> c;\\n\" }], \"shots\": 1024, \"backend\": { \"name\": \"ibmqx4\" }, \"maxCredits\": 3 } Получив токен доступа, скопируйте и вставьте полезные данные из листинга 4.7 в свой REST-клиент, отправьте и дождитесь ответа. Если все идет хорошо, вы должны увидеть ответ, похожий на приведенный в листинге 4.8. Листинг 4.8. HTTP-ответ от Q Experience { \"qasms\": [ { \"qasm\": \"\\n\\ninclude \\\"qelib1.inc\\\";\\nqreg q[5];\\ncreg c[5]; \\nu2(-4*pi/3,2*pi) q[0];\\nu2(-3*pi/2,2*pi) q[0];\\ nu3(-pi,0,-pi) q[0];\\nu3(-pi,0,-pi/2) q[0];\\nu2(pi,-pi/2) q[0];\\nu3(-pi,0,-pi/2) q[0];\\nmeasure q -> c;\\n\", \"status\": \"WORKING_IN_PROGRESS\", \"executionId\": \"e9d758c3480a54a6455f72c84c5cc2a6\" } ], \"shots\": 1024, \"backend\": { \"id\": \"c16c5ddebbf8922a7e2a0f5a89cac478\", \"name\": \"ibmqx4\" }, \"status\": \"RUNNING\", \"maxCredits\": 3, \"usedCredits\": 3, \"creationDate\": \"2018-04-24T00:12:07.847Z\", \"deleted\": false, \"id\": \"33d58594fcb7204e4d2ccdb65cd3c88c\", \"userId\": \"ef072577bd26831c59ddb212467821db\" }\n--- Страница 207 ---\nВаша первая квантовая программа 207 Частично формат ответа описан в табл. 4.3. Таблица 4.3. Формат ответа для API заданий Ключ Описание qasms Массив объектов, который содержит: • отправленный код; • статус времени выполнения — WORKING_IN_PROGRESS, COMPLETED или FAILED; • идентификатор выполнения для кода shots Количество итераций эксперимента backend Объект, содержащий такую информацию о серверном ПО, как название и идентификатор status Общий статус задания — RUNNING, COMPLETED или FAILED maxCredits Максимальное количество кредитов, используемое для этого запуска usedCredits Реальное количество кредитов, потраченных на запуск creationDate Дата создания задания deleted Истинно, если был отправлен запрос на удаление задания, иначе ложно. (Отмененные или удаленные задания удаляются из очереди не сразу, а через некоторое время) id Идентификатор задания userId Идентификатор хозяина ПРИМЕЧАНИЕ API заданий (а также выполнения) не документированы и не пред - назначены для прямого доступа в данный момент. Таким образом, со временем формат ответа может меняться. Возможно, в будущем это изменится и REST API станет частью официального SDK. Между тем наши с вами результаты могут различаться.\n--- Страница 208 ---\n208 Глава 4 . QISKit — отличный SDK для программирования на Python Запуск через API выполнения Основное различие между API выполнения и заданий заключается в том, что первый регистрирует эксперимент в Composer. Чтобы увидеть, как это происходит, создайте HTTP-запрос POST к конечной точке: https:// quantumexperience.ng.bluemix.net/api/codes/execute?access_token=TOKEN&shots= 1&seed=SEED&deviceRunType=ibmqx4 . Параметры запроса: access_token — ваш токен доступа; shots — количество итераций эксперимента; seed — случайное начальное число для выполнения (требуется только при запуске на моделирующем устройстве); deviceRunType — название устройства, на котором будет проводиться эксперимент. Полезные данные запроса приведены в листинге 4.9. Каждый эксперимент должен иметь название. Тип кода — QASM2, ассемблерный код должен быть записан в одну строку, разделенную символами конца строки ( \\n). Листинг 4.9. Полезные данные HTTP-запроса API выполнения { \"name\": \"Experiment #20180410193125\", \"codeType\": \"QASM2\", \"qasm\": \"\\n\\ninclude \\\"qelib1.inc\\\";\\nqreg q[5];\\ncreg c[5];\\nu2 (-4*pi/3,2*pi) q[0];\\nu2(-3*pi/2,2*pi) q[0];\\nu3(-pi,0,-pi) q[0];\\nu3 (-pi,0,-pi/2) q[0];\\nu2(pi,-pi/2) q[0];\\nu3(-pi,0,-pi/2) q[0]; \\nmeasure q -> c;\\n\" } Отправьте запрос, используя свой REST-клиент, и дождитесь результата. В листинге 4.10 приведен краткий формат ответа для эксперимента. СОВЕТ Избавьте себя от головной боли. Всегда проверяйте, подключено ли устройство к сети и записан ли код на qasm в одну строку, включающую символы конца строки (\\n), иначе у вас будет много проблем. Дважды и трижды проверьте это, или ваш запрос в большинстве случаев не будет успешно выполнен.\n--- Страница 209 ---\nВаша первая квантовая программа 209 Листинг 4.10. Формат ответа для API выполнения { \"startDate\": \"2018-04-24T22:31:23.555Z\", \"modificationDate\": 1524609083555, \"typeCredits\": \"plan\", \"status\": { \"id\": \"WORKING_IN_PROGRESS\" }, \"deviceRunType\": \"real\", \"ip\": { \"ip\": \"172.58.152.206\", \"country\": \"United States\", \"continent\": \"North America\" }, \"shots\": 1, \"paramsCustomize\": {}, \"deleted\": false, \"userDeleted\": false, \"id\": \"1203b1158e6ae537e8b770cb8049a6ae\", \"codeId\": \"e0f5c573eef75581cf16bce4187ecab8\", \"userId\": \"ef072577bd26831c59ddb212467821db\", \"infoQueue\": { \"status\": \"PENDING_IN_QUEUE\", \"position\": 108 }, \"code\": { \"type\": \"Algorithm\", \"active\": true, \"versionId\": 1, \"idCode\": \"e86d38c389f4449e62756922a1aa5729\", \"name\": \"Experiment #201\", \"jsonQASM\": { \"gateDefinitions\": [], \"topology\": \"3b8e671a5a3b56899e6e601e6a3816a1\", \"playground\": [ { \"name\": \"q\", \"line\": 0, \"gates\": [ … ] }, { \"name\": \"q\", \"line\": 4, \"gates\": [ { \"name\": \"measure\", \"qasm\": \"measure\",\n--- Страница 210 ---\n210 Глава 4 . QISKit — отличный SDK для программирования на Python \"position\": 10, \"measureCreg\": { \"line\": 5, \"bit\": 4 } } ] }, { \"name\": \"c\", \"line\": 0 } ], \"numberGates\": 7, \"hasMeasures\": true, \"numberColumns\": 11, \"include\": \"include \\\"qelib1.inc\\\";\" }, \"qasm\": \"\\n\\ninclude \\\"qelib1.inc\\\";\\nqreg q[5];\\ncreg c[5];\\nu2 (-4*pi/3,2*pi) q[0];\\nu2(-3*pi/2,2*pi) q[0];\\nu3(-pi,0,-pi) q[0]; \\nu3 (-pi,0,-pi/2) q[0];\\nu2(pi,-pi/2) q[0];\\nu3(-pi,0,-pi/2) q[0];\\nmeasure q -> c;\\n\", \"codeType\": \"QASM2\", \"creationDate\": \"2018-04-24T22:31:22.561Z\", \"deleted\": false, \"orderDate\": 1524609083391, \"userDeleted\": false, \"isPublic\": false, \"id\": \"e0f5c573eef75581cf16bce4187ecab8\", \"userId\": \"ef072577bd26831c59ddb212467821db\" } } В этом ответе содержится много информации, причем большая часть дан - ных хорошо понятна. Тем не менее в табл. 4.4 описаны наиболее важные значения. Таблица 4.4. Информация, возвращаемая для API выполнения Ключ Описание status Статус выполнения. Может принимать одно из следующих значений: WORKING_IN_PROGRESS, COMPLETED или FAILED deviceRunType Устройство, на котором будет запущен эксперимент: real (для реальных устройств) или simulator (для моделирующих устройств)\n--- Страница 211 ---\nКвантовый ассемблер: мощь, скрытая за кулисами 211 Ключ Описание infoQueue Информация об очереди выполнения, содержащая: • статус — PENDING_IN_QUEUE; • позицию в очереди code Очень подробное описание эксперимента, включающее: • квантовые вентили, параметры, позицию и многое другое; • код ассемблера; • разную информацию: название, тип, статус, версию и т. д. СОВЕТ После получения ответа войдите в консоль IBM Q Experience. Назва ние эксперимента должно отображаться в разделе Quantum Scores в Com poser. Квантовый ассемблер: мощь, скрытая за кулисами Вы, скорее всего, поняли, что происходит за кулисами, когда экспери - мент выполняется в Composer или REST-клиенте. Схема транслируется в квантовый ассемблер (QASM), а затем выполняется на реальном или моделирующем устройстве. Квантовый ассемблер является промежу - точным представлением кода высокого уровня Python и результатом сотрудничества между IBM Q Experience и сообществом разработчиков ПО с открытым исходным кодом. ПРИМЕЧАНИЕ QASM основан на классическом аналоге, который стал своего рода утраченным искусством. Тем не менее он не столь пугающий, как его собрат. Фактически в его основе действительно лежит грамматика классического ассемблера.\n--- Страница 212 ---\n212 Глава 4 . QISKit — отличный SDK для программирования на Python Формально жизненный цикл вашей программы на Python или схемы в Q Experience можно описать как нечто среднее между квантовой и клас- сической частями вычислений со следующими шагами. Компиляция . Это автономный шаг, выполняемый на классическом ком - пьютере. Когда работает схема, написанная на Python или составленная в Composer, классический компилятор переводит высокоуровневое представление (например, на Python) в промежуточное представление на QASM. Этот шаг имеет следующие характеристики: •конкретные параметры задачи еще неизвестны; •не требуется взаимодействие с квантовым компьютером; •можно скомпилировать классические процедуры в объектную про - грамму и выполнить первоначальную оптимизацию. Например, программа на Python, приведенная в листинге 4.6, и соответству- ющая схема, составленная в Composer, транслированы в ассемблер, показанный в листинге 4.11. Листинг 4.11. Код QASM для программы на Python из листинга 4.6 include \"qelib1.inc\"; qreg qr[5]; creg cr[5]; u2(-4.18879020478639,6.28318530717959) qr[0]; u2(-4.71238898038469,6.28318530717959) qr[0]; u3(-3.14159265358979,0,-3.14159265358979) qr[0]; u3(-3.14159265358979,0,-1.57079632679490) qr[0]; u2(3.14159265358979,-1.57079632679490) qr[0]; u3(-3.14159265358979,0,-1.57079632679490) qr[0]; measure qr[0] -> cr[0]; measure qr[1] -> cr[1]; measure qr[2] -> cr[2]; Генерация схемы . Код QASM из предыдущего шага передается на фазу генерации цепи. Этот шаг выполняется на классическом компьюте - ре, где известны конкретные параметры задачи и может произойти определенное взаимодействие с квантовым компьютером. Шаг имеет следующие характеристики: •это онлайн-фаза (происходит на квантовом компьютере); •выход представляет собой набор квантовых цепей или квантовых базовых блоков с соответствующими классическими инструкциями\n--- Страница 213 ---\nКвантовый ассемблер: мощь, скрытая за кулисами 213 управления и классическим объектным кодом, необходимым во время выполнения. Выполнение . Этот шаг производится на физическом квантовом ком - пьютере. Вход представляет собой набор квантовых схем, выраженных с использованием промежуточного представления квантовых схем. Они выполняются на контроллере низкого уровня, а выход представля - ет собой набор результатов измерений, возвращаемых из контроллера высокого уровня. Постобработка . Выполняется на классическом компьютере, будет получен набор обработанных результатов измерений. Выходные дан - ные являются окончательным результатом квантовых вычислений (рис. 4.10). Рис. 4.10. Результаты постобработки для жизненного цикла схемы из листинга 4.6 В общем, синтаксис квантового ассемблера не так страшен по сравнению с его классическим аналогом. На самом деле программировать напрямую на квантовом ассемблере оказывается проще и быстрее, чем на Python. Далее представлен набор простых приемов, которые можно использовать, если вы решите написать код непосредственно на QASM.\n--- Страница 214 ---\n214 Глава 4 . QISKit — отличный SDK для программирования на Python Всегда начинайте с включения заголовка qelib1.inc . Он содержит ап - паратные примитивы Q Experience (квантовые вентили). Логические элементы, представленные в этой библиотеке, описаны в табл. 4.5 для однокубитных и в табл. 4.6 для многокубитных вентилей. Таблица 4.5. Однокубитные вентили, представляемые квантовым ассемблером Название Описание u3(theta,phi,lambda) Однокубитный трехпараметрический двухимпульсный вентиль u2(phi,lambda) Однокубитный двухпараметрический одноимпульсный вентиль u1(lambda) Однопараметрический однокубитный вентиль Id Эквивалент матрицы тождественного преобразования или u(0,0,0) X Паули X или σx или инверсия битов Y Паули Y или σy Z Паули Z или σz rx(theta) Поворот вокруг оси X на θ градусов ry(theta) Поворот вокруг оси Y на θ градусов rz(Phi) Поворот вокруг оси Z на θ градусов H Адамара — переводит одиночный кубит в суперпозицию состояний S Квадратный корень из Z — вентиль фазового сдвига sqrt(Z) Sdg S† — эрмитово сопряжение S. Алгебраически это определено как комплексное сопряжение транспонированной матрицы sqrt(Z) T Вентиль фазового сдвига sqrt(S) Tdg Т† — эрмитово сопряжение sqrt(S) Таблица 4.6. Многокубитные вентили, представляемые квантовым ассемблером Название Описание cx c,t Управляемое НЕ (CNOT) — инвертирует состояние второго кубита (t), только если управляющий кубит (с) имеет значение 1. Используется для запутывания кубитов\n--- Страница 215 ---\nКвантовый ассемблер: мощь, скрытая за кулисами 215 Название Описание cz a,b Управляемый фазовый сдвиг — применяет фазовый сдвиг, только если управляющий кубит (а) имеет значение 1 cy a,b Управляемый Y — применяет Паули Y, только если управляющий кубит (а) имеет значение 1 ch a,b Управляемый H — переводит кубит (b) в суперпозицию, только если управляющий кубит (а) имеет значение 1 ccx a,b,c Трехкубитный вентиль Тоффоли — инвертирует состояние кубита с, только если управляющие кубиты а и b имеют значение 1 Объявить регистр (массив) кубитов просто. Например, объявление регистра, состоящего из пяти кубитов: qreg qr[5] . (Примечание: все инструкции разделяются точкой с запятой.) Чтобы объявить регистр, состоящий из пяти классических битов, ис - пользуйте creg cr[5] . Чтобы применить вентиль к определенному кубиту, просто введите название вентиля и управляемый кубит. Например, чтобы перевести первый кубит в суперпозицию (для квантового генератора случайных чисел), используйте hq[0] . Последним шагом в вашей программе всегда должно быть измерение кубита. Например, чтобы измерить кубит, который мы перевели в со- стояние суперпозиции, и сохранить его в первом классическом регистре, возьмите measure qr[0] -> cr[0] . Обратите внимание, что квантовые компьютеры являются вероятност - ными машинами, следовательно, невозможно узнать, в каком именно состоянии находится кубит (это запрещено квантовой механикой). Таким образом, мы получаем лишь вероятность того, что кубит на - ходится в состоянии 0 или 1. Для простого квантового генератора слу - чайных чисел на нулевом кубите h q[0], упомянутом ранее, мы можем использовать вероятность состояния 1 в качестве случайного числа. Это можно представить в виде графика, выдаваемого Composer в IBM Q Experience, когда результаты собираются после выполнения кода ассемблера (см. рис. 4.9).\n--- Страница 216 ---\n216 Глава 4 . QISKit — отличный SDK для программирования на Python Вы сделали первый шаг по карьерной лестнице в качестве квантового программиста, работающего в облаке. Используя высокоуровневый SDK для Python и мощный механизм квантового ассемблера, можно проводить эксперименты на потрясающей платформе IBM Q Experience. Эти навыки окажутся полезными через несколько лет, когда квантовые компьютеры начнут появляться в центрах обработки данных. В следующей главе мы перейдем на новый уровень, рассмотрев набор алгоритмов, которые де - монстрируют волшебство квантовой механики в вычислениях. Так что читайте дальше.\n--- Страница 217 ---\n5Запускаем движки: от квантовой генерации случайных чисел до телепортации с остановкой на сверхплотном кодировании В этой главе вы познакомитесь с тремя замечательными возможно - стями квантовых систем по обработке информации. Мы начнем с од- ной из самых простых процедур, исследуя принципиально случайную природу квантовой механики как источника истинной случайности. Далее в главе рассматриваются две взаимосвязанные процедуры, на - зываемые сверхплотным кодированием и квантовой телепортацией. Изучая сверхплотное кодирование, вы узнаете, как можно отправить два классических бита информации с помощью одного кубита. Читая о квантовой телепор тации — как квантовое состояние кубита можно воссоздать с помощью гибридной классическо-квантовой процедуры передачи информации. Все алгоритмы включают разработку схем для IBM Q Experience Composer, а также код на Python и QASM. Результаты разберем и проанализируем, так что начнем. Квантовый генератор случайных чисел В этом разделе вы узнаете, как вероятностную природу квантового ком - пьютера можно использовать для генерации случайных битов или чисел с помощью вентиля Адамара.\n--- Страница 218 ---\n218 Глава 5 . Запускаем движки: от случайных чисел до телепортации Генератор случайных битов на основе вентиля Адамара Вентиль Адамара — один из фундаментальных логических элементов квантовых информационных систем. Он применяется для перевода кубита в суперпозицию состояний. С алгебраической точки зрения описывается матрицей: . Чтобы лучше понять, каким образом данная матрица переводит кубит в суперпозицию, рассмотрим геометрическое представление одиночного кубита. На рис. 5.1 базисные состояния кубита описываются скобочной нотацией, где и . Вспомните из предыдущей главы, что кет-вектор — это п росто единичный вектор (вектор, длина которого равна 1). Таким образом, общее состояние (или суперпозиция) определяется единичным вектором , где α и β — комплексные коэффициенты. При - менение вентиля Н к базисным состояниям дает: ; и полученное методом суперпозиции состояние ψ: . В общем, вентиль Адамара расширяет диапазон состояний, возмож - ных для квантовой схемы. Это важно, потому что расширение со -",
      "debug": {
        "start_page": 171,
        "end_page": 218
      }
    },
    {
      "name": "Глава 5. Запускаем движки : от квантовой генерации случайных чисел до телепортации с остановкой на сверхплотном кодировании 217",
      "content": "--- Страница 219 ---\nКвантовый генератор случайных чисел 219 стояний позволяет искать быстрые способы решения, что ускоряет вычисления. Рис. 5.1. Геометрическое представление общего (полученного методом суперпозиции) состояния ψ кубита ПРИМЕЧАНИЕ Согласно принципам квантовой механики мы не можем с уверенностью предсказать значения коэффициентов α и β в предыдущих базисных состояниях, даже учитывая полное знание законов физики или изна - чальных условий, в которых находится частица. Лучшее, что мы можем сделать, — это рассчитать вероятность. С учетом этого реализация схемы генератора случайных битов упрощена настолько, насколько это возможно. В IBM Q Experience Composer соз - дайте схему с вентилем Адамара для первого кубита, а затем выполните измерение в базисном состоянии (рис. 5.2). Пожалуй, не стоит запускать ее на реальном устройстве, так как процесс может оказаться длительным (помните, что выполнение запланировано и может занять некоторое время в зависимости от количества заданий в очереди выполнения). К тому же каждое выполнение на реальном устройстве уменьшает количество ваших кредитов. Запустите схему на моделирующем устройстве, чтобы получить результат немедленно (рис. 5.3). Обратите внимание на то, что появление каждого результата\n--- Страница 220 ---\n220 Глава 5 . Запускаем движки: от случайных чисел до телепортации (0 или 1) имеет равную вероятность 1/2, поэтому мы можем создавать случайные данные: если вероятность для результата 1 > 1/2, получим 1, в противном случае — 0. Рис. 5.2. Схема для генератора случайных битов Рис. 5.3. Результаты выполнения для схемы, приведенной на рис. 5.2 Конечно, это очень неэффективный способ генерации случайных битов. Лучше было бы написать сценарий на Python с помощью QISKit для программного создания схемы в этом задании. В листинге 5.1 показан простой сценарий для генерации n случайных чисел с помощью x кубитов, где число битов равно 2x. По умолчанию сценарий генерирует десять восьмибитовых случайных чисел, используя",
      "debug": {
        "start_page": 219,
        "end_page": 220
      }
    },
    {
      "name": "Глава 6. Развлекаемся квантовыми играми 246",
      "content": "--- Страница 248 --- (продолжение)\nГлава 6 . Развлекаемся квантовыми играми обычный «Морской бой», в который мы все играли в детстве, но с кван- товым компьютером или моделирующим устройством на заднем плане. ПРИМЕЧАНИЕ Игру написал Джеймс Вуттон из Базельского университета. Она внесена в учебник по QISKit на Python. Модифицированная версия оригиналь - ного кода Вуттона доступна в исходниках для этой книги по адресу Workspace\\Ch06\\battleship\\BattleShip.py (за исключением ненужного текста с причудливым форматированием). Запустим программу и рассмотрим механику игры. Инструкции по настройке Запустите на выполнение программу BattleShip.py из исходников к этой книге, как описано далее. 1. Для CentOS 6 или 7 или любой ОС, подобной Fedora, активируйте виртуальную среду Python. Это необходимо, только если у вас есть несколько версий Python, например 2.7 и 3.6. Помните, что вы должны использовать версию 3.5 или более позднюю. Инструкции по настройке виртуальной среды Python приведены в главе 3. 2. Скопируйте сценарий из Workspace\\Ch06\\battleship\\BattleShip.py и файл конфигурации Qconfig.py из исходников книги в свое рабочее пространство и запустите его на выполнение, как показано в следующем фрагменте кода: # Активация виртуальной среды Python3 на $HOME/qiskit/qiskit $ source $HOME/qiskit/qiskit/bin/activate $ python BattleShip.py ############### Quantum Battle Ship ################## Do you want to play on the real device? (y/n) n Рассмотрим работу программы.\nГлава 6 . Развлекаемся квантовыми играми обычный «Морской бой», в который мы все играли в детстве, но с кван- товым компьютером или моделирующим устройством на заднем плане. ПРИМЕЧАНИЕ Игру написал Джеймс Вуттон из Базельского университета. Она внесена в учебник по QISKit на Python. Модифицированная версия оригиналь - ного кода Вуттона доступна в исходниках для этой книги по адресу Workspace\\Ch06\\battleship\\BattleShip.py (за исключением ненужного текста с причудливым форматированием). Запустим программу и рассмотрим механику игры. Инструкции по настройке Запустите на выполнение программу BattleShip.py из исходников к этой книге, как описано далее. 1. Для CentOS 6 или 7 или любой ОС, подобной Fedora, активируйте виртуальную среду Python. Это необходимо, только если у вас есть несколько версий Python, например 2.7 и 3.6. Помните, что вы должны использовать версию 3.5 или более позднюю. Инструкции по настройке виртуальной среды Python приведены в главе 3. 2. Скопируйте сценарий из Workspace\\Ch06\\battleship\\BattleShip.py и файл конфигурации Qconfig.py из исходников книги в свое рабочее пространство и запустите его на выполнение, как показано в следующем фрагменте кода: # Активация виртуальной среды Python3 на $HOME/qiskit/qiskit $ source $HOME/qiskit/qiskit/bin/activate $ python BattleShip.py ############### Quantum Battle Ship ################## Do you want to play on the real device? (y/n) n Рассмотрим работу программы.\n--- Страница 249 ---\nQuantum Battleship с изюминкой 249 Инициализация В листинге 6.1 демонстрируется инициализация сценария. Она начинается с выполнения основных задач Python. Загружаются системные библиотеки sys и QuantumProgram, необхо - димые для всех операций QISKit. Проверяется то, что вы используете Python 3.5 или более позднюю версию. Программа спрашивает, хотите ли вы задействовать моделирующее устройство или настоящий квантовый компьютер. Затем устанавлива - ется количество запусков на выполнение, по умолчанию 1024. Листинг 6.1. Инициализация сценария ################################# # Quantum Battleship из учебника @ # https://github.com/QISKit/qiskit-tutorial ################################## import sys # проверка версии PYTHON; поддерживаются только версии > 3.5 if sys.version_info < (3,5): raise Exception('Please use Python version 3.5 or greater.') from qiskit import QuantumProgram import Qconfig import getpass, random, numpy, math ## 1. Выбор серверного ПО: моделирующее устройство IBM (ibmqx_qasm_simulator) или реальный чип ibmqx2 d = input(\"Do you want to play on the real device? (y/n)\\n\").upper() if (d==\"Y\"): device = 'ibmqx2' else: device = 'ibmqx_qasm_simulator' # Обратите внимание, что устройством может быть 'ibmqx_qasm_simulator', # 'ibmqx2' или 'local_ qasm_simulator' # Установка количества запусков shots = 1024\n--- Страница 250 ---\n250 Глава 6 . Развлекаемся квантовыми играми СОВЕТ Чтобы запустить квантовую программу на реальном устройстве, вы должны поместить файл конфигурации (Qconfig.py) в то же место, что и основной сценарий. Конфигурация содержит требуемый токен API и конечную точку IBM Q Experience: APItoken = 'YOUR API TOKEN' config = { 'url': 'https://quantumexperience.ng.bluemix.net/api', } Теперь расставим несколько кораблей на игровом поле. Размещение кораблей на игровом поле В программе используется элементарный текстовый интерфейс для всего пользовательского ввода. В листинге 6.2 показана логика ввода кораблей для каждого игрока. Нажмите Enter, чтобы начать, и введите позиции трех кораблей для каждого игрока (нумерация позиций с нуля). Сценарий может сам выбрать случайные позиции либо игрок должен ввести позиции для трех кораблей. Позиции хранятся в двумерном списке shipPos , где shipPos[0] содер - жит позиции первого игрока, а shipPos[1] — второго. Помните, что для одного игрока доступно только три корабля. Листинг 6.2. Размещение кораблей на игровом поле ####### 2. Размещение кораблей на игровом поле игроком randPlace = input(\"> Press Enter to start placing ships…\\n\").upper() # В переменной ship[X][Y] будет храниться позиция Y-го корабля игрока X+1 shipPos = [ [-1]*3 for _ in range(2)] # Проход в цикле по обоим игрокам и трем кораблям для каждого for player in [0,1]:\n--- Страница 251 ---\nQuantum Battleship с изюминкой 251 # Если выбор производится не игроком, а случайным образом if ((randPlace==\"r\")|(randPlace==\"R\")): randPos = random.sample(range(5), 3) for ship in [0,1,2]: shipPos[player][ship] = randPos[ship] else: for ship in [0,1,2]: # Запрос позиции для каждого корабля choosing = True while (choosing): # Получить ввод игрока position = getpass.getpass(\"Player \" + str(player+1) + \", choose a position for ship \" + str(ship+1) + \" (0-4)\\ n\" ) # Проверка корректности ввода и запрос на повторный ввод if position.isdigit(): # Ответ должен быть целым числом position = int(position) # и находиться в диапазоне от 0 до 4 if (position in [0,1,2,3,4]) and (not position in shipPos[player]): shipPos[player][ship] = position choosing = False print (\"\\n\") elif position in shipPos[player]: print(\"\\nYou already have a ship there. Try again.\\n\") else: print(\"\\nThat's not a valid position. Try again.\\n\") else: print(\"\\nThat's not a valid position. Try again.\\n\") Далее показан стандартный вывод, очень простой, но пока этого доста - точно: Do you want to play on the real device? (y/n) n Player 1, choose a position for ship 1 (0, 1, 2, 3 or 4) 0 Player 1, choose a position for ship 2 (0, 1, 2, 3 or 4) 1 Player 1, choose a position for ship 3 (0, 1, 2, 3 or 4) 2 Player 2, choose a position for ship 1 (0, 1, 2, 3 or 4) 0\n--- Страница 252 ---\n252 Глава 6 . Развлекаемся квантовыми играми Player 2, choose a position for ship 2 (0, 1, 2, 3 or 4) 1 Player 2, choose a position for ship 3 (0, 1, 2, 3 or 4) 2 Интересные процессы пр оисходят в основном цикле. Рассмотрим его. Основной цикл и результаты В основном цикле выполняются следующие задания. Обоих игроков просят поместить по одной бомбе в позицию [0–4]. Количество бомб хранится в двумерном списке из пяти элементов (два игрока, пять счетчиков бомб). Обратите внимание, что игрок может бомбить одну и ту же позицию нескольк о раз; таким образом, если первый игрок наносит удар по нулевой позиции дважды, то bombs = [[2,0,0,0,0], [0,0,0,0,0]] . Создается QuantumProgram для хранения пяти кубитов (по одному на каждую позицию на доске) и пяти классических регистров, чтобы хранить результаты измерений. Если позиция бомбы совпадает с позицией корабля противника (из списка shipPos ), ущерб рассчитывается выполнением одного поворота вокруг оси X по количеству бомб с использо ванием частичного одно - кубитного вентиля НЕ: gridScript.u3(1/(ship +1) * math.pi, 0.0, 0.0, q[position]) . Обратите внимание, что эффективность бомбы также зависит от того, какой корабль бомбят (0, 1, 2). Для завершения схемы на кубите выполняется измерение для позиции, а результат сохраняется в соответствующем классическом регистре: gridScript.measure(q [position], c [position]) . Затем программа выполняется на целевом устройстве, а результаты со - храняются в двумерном списке grid. Например, если нулевая позиция первого игрока разбомблена, то grid = [[1,0,0,0,0], [0,0,0,0,0]] . Далее показано, как это происходит: results = Q_program.execute([\"gridScript\"], backend=device, shots=shots) grid[player] = results.get_counts(\"gridScript\")\n--- Страница 253 ---\nQuantum Battleship с изюминкой 253 Результаты проверяются на наличие ошибок. Если все верно, то про - цент ущерба рассчитывается в промежутке [0, 1], когда в списке grid содержится значение 1 для этой позиции. Проценты сохраняются в двумерном списке повреждений. Таким образом, ущерб [[0,95, 0, 0, 0, 0], [0, 0, 0, 0, 0]] указывает на то, что корабль первого игрока на нулевой позиции был уничтожен. Наконец, игрокам выводятся результаты. Процесс повторяется до тех пор, пока все корабли не будут уничтожены и не будет объявлен по - бедитель (листинг 6.3). Листинг 6.3. Основной цикл игры «Морской бой» ? 100 % |\\ /| | \\ / | | \\ / | | ? | | / \\ | | / \\ | |/ \\| ? ? ########### 3. Основной цикл # Каждая итерация начинается с опроса игроков о том, где # на игровом поле противника должна быть размещена бомба # Квантовый компьютер подсчитывает эффект от нанесенных ударов # и предоставляет результаты # Игра продолжается, пока все корабли одного из игроков # не будут уничтожены game = True # В переменной bombs[X][Y] хранится количество раз, когда позиция Y # была разбомблена игроком X+1 bomb = [ [0]*5 for _ in range(2)] # все значения инициализированы нулями # В переменной grid[player] будут храниться результаты для каждого игрока grid = [{},{}] while (game): input(\"> Press Enter to place some bombs…\\n\") # Обоих игроков спрашивают, где они хотят разместить бомбы for player in range(2): print(\"\\n\\nIt's now Player \" + str(player+1) + \"'s turn.\\n\") # Вопрос повторяется, пока не будет получено корректное значение choosing = True while (choosing):\n--- Страница 254 ---\n254 Глава 6 . Развлекаемся квантовыми играми # Получить ввод пользователя position = input(\"Choose a position to bomb (0, 1, 2, 3 or 4)\\n\") # Проверка корректности ввода # Запрос на повторный ввод, если предыдущий был некорректным if position.isdigit(): # ответ должен быть целым числом position = int(position) if position in range(5): bomb[player][position] = bomb[player][position] + 1 choosing = False print (\"\\n\") else: print(\"\\nThat's not a valid position. Try again.\\n\") else: print(\"\\nThat's not a valid position. Try again.\\n\") # Теперь мы создаем и запускаем на выполнение квантовую программу # для каждого игрока for player in range(2): if device=='ibmqx2': print(\"\\nUsing a quantum computer for Player \" + str(player+1) + \"'s ships.\\n\") else: print(\"\\nUsing the simulator for Player \" + str(player+1) + \"'s ships.\\n\") # Теперь настройка квантовой программы (QASM) для моделирования # сетки для данного игрока Q_program = QuantumProgram() # Установка APIToken и url-адреса API Q_program.set_api(Qconfig.APItoken, Qconfig.config[\"url\"]) # Объявление регистров пяти кубитов q = Q_program.create_quantum_register(\"q\", 5) # Объявление регистров пяти классических битов для хранения # результатов измерений c = Q_program.create_classical_register(\"c\", 5) # Создание схемы gridScript = Q_program.create_circuit(\"gridScript\", [q], [c]) # Добавление бомб (противника) for position in range(5): # Добавить столько бомб, сколько было помещено в данную позицию for n in range( bomb[(player+1)%2][position] ): # Эффективность бомбы # (квантовой операции, которую мы применим) # зависит от вида корабля for ship in [0,1,2]:\n--- Страница 255 ---\nQuantum Battleship с изюминкой 255 if ( position == shipPos[player][ship] ): frac = 1/(ship+1) # Добавление этой части вентиля НЕ в QASM gridScript.u3(frac * math.pi, 0.0, 0.0, q[position]) # Наконец, выполнение измерений for position in range(5): gridScript.measure(q[position], c[position]) # чтобы увидеть, какие действия должен выполнить квантовый # компьютер, мы можем вывести на печать файл c QASM # Эта строка обычно закомментирована #print( Q_program.get_qasm(\"gridScript\") ) # Скомпилировать и запустить на выполнение QASM results = Q_program.execute([\"gridScript\"], backend=device, shots=shots) # Извлечение данных grid[player] = results.get_counts(\"gridScript\") # Данные при желании можно проверить # Эти строки обычно закомментированы #print( grid[0] ) #print( grid[1] ) # Если один из запусков потерпел неудачу, сообщить об этом игрокам # и начать раунд заново if ( ( 'Error' in grid[0].values() ) or ( 'Error' in grid[1]. Values() ) ): print(\"\\nThe process timed out. Try this round again.\\n\") else: # Рассмотрим ущерб во всех кубитах (даже там, где нет кораблей) # Для каждого кубита каждого игрока будет сохранено значение # вероятности 1 damage = [ [0]*5 for _ in range(2)] # Для этого мы пройдем в цикле по всем пяти битовым строкам # каждого из игроков for player in range(2): for bitString in grid[player].keys(): # А затем по всем позициям for position in range(5): # Если в строке для данной позиции находится значение 1, # то распределение вероятности добавляется в ущерб # Помните, что бит нулевой позиции крайний справа\n--- Страница 256 ---\n256 Глава 6 . Развлекаемся квантовыми играми # и соответствует bitString[4] if (bitString[4-position]==\"1\"): damage[player][position] += grid[player] [bitString]/shots # Вывод результатов игрокам for player in [0,1]: input(\"\\nPress Enter to see the results for Player \" + str(player+1) + \"'s ships…\\n\") # Отчет о существенном ущербе по кубитам для кораблей; # в идеале это будет ненулевой ущерб, # таким образом, мы выбираем пороговое значение 5 % display = [\" ? \"]*5 # Перебрать в цикле кубиты для кораблей for position in shipPos[player]: # Если ущерб довольно велик, отобразить его if ( damage[player][position] > 0.1 ): if (damage[player][position]>0.9): display[position] = \"100 %\" else: display[position] = str(int( 100*damage[player] [position] )) + \"% \" print(\"Here is the percentage damage for ships that have been bombed.\\n\") print(display[ 4 ] + \" \" + display[ 0 ]) print(\" |\\ /|\") print(\" | \\ / |\") print(\" | \\ / |\") print(\" | \" + display[ 2 ] + \" |\") print(\" | / \\ |\") print(\" | / \\ |\") print(\" |/ \\|\") print(display[ 3 ] + \" \" + display[ 1 ]) print(\"\\n\") print(\"Ships with 95 % damage or more have been destroyed\\n\") print(\"\\n\") # Если все корабли одного игрока уничтожены, игра окончена # В идеале это предполагает 100%-ный ущерб, но мы остановимся # на 90 % опять же по причине шума if (damage[player][ shipPos[player][0] ]>.9) and (damage[player][ shipPos[player][1] ]>.9) and (damage[player][ shipPos[player][2] ]>.9): print (\"***All Player \" + str(player+1) + \"'s ships have been destroyed!***\\n\\n\") game = False\n--- Страница 257 ---\nQuantum Battleship с изюминкой 257 if (game is False): print(\"\") print(\"=======GAME OVER=======\") print(\"\") Обратите внимание, что если ущерб превысит 90 %, то корабль будет помечен как уничтоженный. В листинге 6.4 показаны результаты одного игрового взаимодействия. Листинг 6.4. Стандартный вывод для одного игрового взаимодействия > Press Enter to place some bombs… It's now Player 1's turn. Choose a position to bomb (0, 1, 2, 3 or 4) 0 It's now Player 2's turn. Choose a position to bomb (0, 1, 2, 3 or 4) 0 We'll now get the simulator to see what happens to Player 1's ships. We'll now get the simulator to see what happens to Player 2's ships. Press Enter to see the results for Player 1's ships… Here is the percentage damage for ships that have been bombed. ? 100 % |\\ /| | \\ / | | \\ / | | ? | | / \\ | | / \\ | |/ \\| ? ? Ships with 95% damage or more have been destroyed Press Enter to see the results for Player 2's ships… Here is the percentage damage for ships that have been bombed. ? 100 % |\\ /| | \\ / | | \\ / | | ? | | / \\ | | / \\ | |/ \\| ? ? Ships with 95 % damage or more have been destroyed\n--- Страница 258 ---\n258 Глава 6 . Развлекаемся квантовыми играми Таким образом, основной цикл продолжается до тех пор, пока не будет объявлен победитель. Итак, вы узнали, как можно реализовать простую игру, чтобы использовать квантовый компьютер для выполнения неслож - ных расчетов нанесенных повреждений путем поворотов кубита вокруг оси X. Эта версия довольно примитивна, но интересна. Однако мы можем сделать лучше. В следующем разделе усовершенствуем дизайн игры. Cloud Battleship: модификация удаленного доступа Действительно, здорово иметь возможность играть в «Морской бой» на квантовом компьютере через простой текстовый интерфейс, но гораздо круче играть в эту игру в браузере в облаке. В этом разделе мы модифи - цируем Quantum Battleship и улучшим ее дизайн, в чем игра, несомненно, нуждается (рис. 6.1). Рис. 6.1. Структура Quantum Battleship в облаке Идея заключается в следующем. Откажитесь от скучного текстового интерфейса в пользу HTML- страницы, которую можно развернуть в облаке.\n--- Страница 259 ---\nCloud Battleship: модификация удаленного доступа 259 Используйте общедоступный шлюзовой интерфейс (Common Gateway Interface, CGI) веб-сервера Apache для развертывания квантовой логики в сценарии. Дайте игроку возможность выбрать, на чем выполнять расчеты: на локальном или дистанционном моделирующем устройстве либо на реальном квантовом компьютере. Реализуем это в серии упражнений, описанных в следующих разделах. Упражнение 6.1. Разделение интерфейса пользователя и логики игры Один из основных принципов объектно-ориентированного программиро - вания таков: никогда не смешивайте представление (интерфейс пользо - вателя) и бизнес-логику. Спроектированные таким образом компоненты можно скомпилировать и повторно использовать где угодно. В случае с Battleship нам нужно выполнить следующее. Удалить или закомментировать первый раздел сценария, в котором считывается положение кораблей для каждого игрока (хороший кусок кода), стараясь не затронуть какие-либо структуры данных или пере - менные. Удалить или закомментировать все операторы вывода на печать и ввода с клавиатуры. Удалить основной цикл игры, в котором постоянно указывается позиция для бомбардировки. Сценарий должен завершиться после того, как он использует данные из HTTP-запроса. В нем не может быть бесконечных циклов, иначе запрос зависнет. Добавить в сценарий поддержку CGI в Python, чтобы из HTTP-запроса можно было прочитать данные, включая: •позиции кораблей для каждого игрока; •позиции и количество бомб для каждого игрока; •устройство для запуска квантовых вычислений.\n--- Страница 260 ---\n260 Глава 6 . Развлекаемся квантовыми играми Сценарий должен возвращать отчет о повреждениях (желательно в фор- мате JSON) через HTTP-ответ, чтобы браузер отображал его в JavaScript. Обратите внимание, что мы будем повторно использовать бо 'льшую часть кода: структуры данных, локальные переменные и квантовую логику. В этом заключается причина комментирования всех операторов для ввода данных и вывода на печать. Решение этого (как и всех остальных) упражнения приведено в конце данного раздела. Упражнение 6.2. Создание веб-интерфейса для игрового поля Создайте графический интерфейс пользователя для HTML по аналогии с текстовым, и используйте AJAX для асинхр онной отправки запросов в CGI-сценарий. Верните результаты нанесенного ущерба и, наконец, обновите игровые поля. Улучшенный дизайн можно увидеть на рис. 6.2. Рис. 6.2. Интерфейс пользователя для новой версии Quantum Battleship\n--- Страница 261 ---\nCloud Battleship: модификация удаленного доступа 261 В HTML-файле будет четыре игровых поля, в каждом 3 × 3 ячейки. Верхние игровые поля используются для того, чтобы разместить три корабля в пяти местоположениях, соответствующих кубитам. Их реа - лизуем в виде флажков ( <INPUT TYPE = \"checkbox\"> ). Мы воспользуемся CSS для замены кнопки-переключателя изображением, поэтому вместо нее при щелчке на ячейке будет переключаться изображение корабля. Нижние игровые поля позволят игрокам размещать бомбы в пяти местах при помощи все того же CSS, что и в предыдущем абзаце, но они будут реализованы как <INPUT TYPE = \"radio\"> , так что в каждом местоположе - нии может быть размещено несколько бомб. Несмотря на то что размер игрового поля 3 × 3, для пользовательского ввода доступны только пять местоположений, соответствующих каж - дому кубиту в квантовой программе. Для каждого местоположения корабля будут отображаться номер кубита и возвращаемый серверным ПО процент ущерба с цветной подсветкой. Механика игры точно такая же, как и в текстовой версии. Оба игрока размещают на игровых полях по три корабля, а затем каждый по очереди размещает бомбу и нажимает кнопку Submit (Отправить). CGI-сценарий Python получит запрос через AJAX, запустит квантовую программу, созданную в упражнении 6.1, и вернет результат для ущерба, который будет отображен в JavaScript. Обратите внимание, что все игровое состояние, массивы, переменные и другие данные хранятся в клиентском HTML, поэтому мы должны использовать AJAX для асинхронной отправки запроса, иначе данные будут потеряны при каждой отправке игроком. Обновлений страницы не будет. На рис. 6.3 показаны нижние игровые поля 3 × 3 ячейки, отображающие номера кубитов, количество щелчков на бомбе и изображения пере - ключателей, выводимые с использованием CSS. Когда каждый игрок размещает три корабля и выбирает место для бомбардировки, он нажи - мает кнопку Submit (Отправить) для отправки запроса на сервер AJAX. Кнопка сброса также доступна, чтобы игру можно было в любой момент перезапустить.\n--- Страница 262 ---\n262 Глава 6 . Развлекаемся квантовыми играми Рис. 6.3. Игровые поля с бомбами в Quantum Battleship Учтите, что все состояние сохраняется в клиенте (браузере). Никакие данные не будут храниться в сценарии Python, поскольку HTTP явля - ется протоколом запроса-ответа без сохранения состояния. Это озна - чает, что, когда запрос получен, программа выполняется веб-сервером, ответ печатается в буфере вывода запроса и программа завершается. Как и для предыдущего упражнения, решение находится в конце этого раздела. Упражнение 6.3. Развертывание и устранение неполадок на сервере Apache Теперь, когда все на месте, пришло время для развертывания на веб- сервере. Я буду использовать сервер Apache под названием HTTPD в CentOS 6, но он должен работать для любой версии CentOS, Fedora или\n--- Страница 263 ---\nCloud Battleship: модификация удаленного доступа 263 Red Hat (возможно, для любого текущего дистрибутива Linux с HTTPD). Имейте в виду, что каждый вариант имеет свои особенности при настрой - ке системного ПО. Например, CentOS фокусируется на стабильности и безопасности, что доставляет мне много головной боли при настройке HTTPD и Python. Решение 6.1. Программа на Python, позволяющая повторное использование В этом разделе представлен CGI-скрипт Python, который получает HTTPD-запрос от браузера и отвечает строкой в формате JSON, содер - жащей отчет о нанесенном ущербе и другую информацию. Первая часть программы осталась практически неизменной, за исключением того, что теперь ввод нужно проанализировать из HTTP-запроса с применением библиотеки cgi в Python (листинг 6.5). Листинг 6.5. Инициализация модульной версии Quantum Battleship import sys from qiskit import QuantumProgram import Qconfig import getpass, random, numpy, math import cgi import cgitb # Разрешите относительные зависимости, если вы клонируете QISKit # из репозитория Git и используете как глобальный sys.path.append(' / /qiskit-sdk-py/') # Отладка cgitb.enable(display=0, logdir=\".\") # В переменной ship[X][Y] будет храниться позиция Y-го корабля игрока X + 1 # все переменные инициализированы -1| (значение для невозможной позиции) shipPos = [ [-1]*3 for _ in range(2)] # В переменной bombs[X][Y] будет храниться количество раз, когда позицию Y # бомбил игрок X+1 bomb = [ [0]*5 for _ in range(2)] # все значения равны 0 В листинге 6.5 показана первая часть сценария. В шестой и седьмой строках импортируются библиотеки Python: cgi и cgitb (CGI Toolbox),\n--- Страница 264 ---\n264 Глава 6 . Развлекаемся квантовыми играми которые используются для чтения данных из HTTP-запросов и отладки CGI-программ соответственно. ПРИМЕЧАНИЕ Строки в следующем фрагменте кода активируют специальный об - работчик исключений, который будет отображать подробные отчеты в браузере в случае возникновения ошибки. import cgitb cgitb.enable() Имейте в виду, что при возникновении ошибки мы не можем показать внутреннюю информацию программы, так как клиент ожидает ответа в формате JSON. Вместо этого мы должны сохранять отчеты об ошибках в текущем рабочем каталоге при помощи кода, аналогичного следующему: cgitb.enable (display = 0, logdir = \".\") Этот код избавит от проблем во время разработки, поскольку любое ис - ключение будет сохранено в аккуратном HTML-документе в текущем рабочем каталоге. Формат документа показан в разделе «Устранение ошибок» данной главы. В листинге 6.5 также показаны структуры данных, используемые для хранения игрового состояния. Они те же самые, что и в старой версии: shipPos — двумерный список, в котором хранятся позиции для трех кораблей на игрока, инициализированные –1. Таким образом, shipPos = [[-1, -1, -1], [-1, -1, -1]]; bomb — двумерный список, в котором хранится количество бомб на пози - цию для каждого игрока. Инициализирован нулями: bomb = [[0,0,0,0,0], [0,0,0,0,0]] . Обратите внимание, что одну и ту же позицию можно бомбить несколько раз, поэтому необходимо хранить количество. Этот список будет исполь - зоваться для расчета ущерба, причиненного кораблю. Затем сценарий считывает игровые данные из HTTP-запроса (ли - стинг 6.6).\n--- Страница 265 ---\nCloud Battleship: модификация удаленного доступа 265 Листинг 6.6. Чтение данных из HTTP-запроса # CGI-анализ HTTP-запроса form = cgi.FieldStorage() ships1 = form[\"ships1\"].value ships2 = form[\"ships2\"].value bombs1 = form[\"bombs1\"].value bombs2 = form[\"bombs2\"].value # 'local_qasm_simulator', 'ibmqx_qasm_simulator' device = str(form[\"device\"].value) shipPos[0] = list(map(int, ships1.split(\",\"))) # [0,1,2] shipPos[1] = list(map(int, ships2.split(\",\"))) # [0,1,2] bomb[0] = list(map(int, bombs1.split(\",\"))) bomb[1] = list(map(int, bombs2.split(\",\"))) stdout = \"Ship Pos: \" + str(shipPos) + \" Bomb counts: \" + str(bomb) + \"<br>\" Чтобы прочитать данные из HTTP-запроса, используйте form = cgi.Fi- eldStorage() . Этот вызов CGI возвращает словарь или хеш-карту пар «ключ — значение», с помощью которой извлекаются параметры строки запроса. В данном конкретном случае ожидаются следующие значения: ships1 — трехэлементный массив данных в формате JSON с позициями корабля первого игрока; ships2 — трехэлементный массив данных в формате JSON с позициями корабля второго игрока; bombs1 — пятиэлементный массив данных в формате JSON со счетчи - ками бомб первого игрока; bombs2 — пятиэлементный массив данных в формате JSON со счетчи - ками бомб второго игрока; device — устройство, на котором будет выполняться квантовая про - грамма. Это может быть: •local_qasm_simulator — локальное моделирующее устройство, упа - кованное вместе с QISKit; •ibmq_qasm_simulator — удаленное моделирующее устройство, предо - ставляемое IBM; •ibmqx2 — пятикубитный квантовый процессор, предоставляемый IBM Q Experience.\n--- Страница 266 ---\n266 Глава 6 . Развлекаемся квантовыми играми Самое замечательное в Python — это то, что данные в формате JSON, предоставляемые HTTP-запросом, в два счета могут быть отображены в поддерживаемые им коллекции: shipPos[0] = list(map(int, ships1.split(\",\"))) bomb[0] = list(map(int, bombs1.split(\",\"))) ПРИМЕЧАНИЕ В Python системный вызов split(SEPARATOR) используется для созда - ния списка элементов типа String. Но нам нужен список целых чисел. Для его получения мы применяем системный вызов map(DATA-TYPE, LIST). Обратите внимание, что в Python 3 вызов map возвращает хеш-таблицу (словарь), поэтому мы должны использовать системный вызов list для преобразования в нужный нам список целых чисел. Это здорово, потому что сценарий может повторно задействовать старые структуры данных и получится сохранять большую часть квантовой логики не тронутой. Последняя строка листинга 6.6 — это просто строковый буфер стандарт - ного вывода, который будет возвращен браузеру для отладки. Наконец, в листинге 6.7 показана внутренняя логика сценария, которая по большей части остается нетронутой. Листинг 6.7. Основной раздел квантового сценария # В переменной grid[player] будут храниться результаты для поля каждого # игрока grid = [{},{}] # Теперь мы создаем и запускаем на выполнение квантовые программы, # которые реализуют на поле каждого игрока следующее for player in range(2): # Настройка квантовой программы (QASM) для моделирования сетки # данного игрока Q_program = QuantumProgram() Q_program.set_api(Qconfig.APItoken, Qconfig.config[\"url\"]) # Объявление регистра из пяти кубитов q = Q_program.create_quantum_register(\"q\", 5) # Объявление регистра из пяти классических битов для хранения\n--- Страница 267 ---\nCloud Battleship: модификация удаленного доступа 267 # результатов измерений c = Q_program.create_classical_register(\"c\", 5) # Создание схемы gridScript = Q_program.create_circuit(\"gridScript\", [q], [c]) # Добавление бомб (установленных противником) for position in range(5): # Добавляется столько бомб, сколько было помещено в данную позицию for n in range( bomb[(player+1)%2][position] ): # Эффективность бомбы # (квантовой операции, которая будет применена) # зависит от типа корабля for ship in [0,1,2]: if ( position == shipPos[player][ship] ): frac = 1/(ship+1) # Добавление этой части вентиля НЕ в QASM gridScript.u3(frac * math.pi, 0.0, 0.0, q[position]) # Наконец, выполнить измерения for position in range(5): gridScript.measure(q[position], c[position]) # Чтобы увидеть, какие действия должен выполнить квантовый # компьютер, мы можем вывести на печать файл c QASM # Эта строка обычно закомментирована #print( Q_program.get_qasm(\"gridScript\") ) # Скомпилировать и запустить на выполнение QASM results = Q_program.execute([\"gridScript\"], backend=device, shots=shots) # Извлечение данных grid[player] = results.get_counts(\"gridScript\") # Если один из запусков был неудачным, сообщить об этом игрокам # и начать раунд заново if ( ( 'Error' in grid[0].values() ) or ( 'Error' in grid[1]. Values() ) ): stdout += \"The process timed out. Try this round again.<br>\" else: # Рассмотрим ущерб во всех кубитах (даже там, где нет кораблей) damage = [ [0]*5 for _ in range(2)] # Для этого мы пройдем в цикле по всем пяти битовым строкам # каждого из игроков for player in range(2): for bitString in grid[player].keys(): # а затем по всем позициям\n--- Страница 268 ---\n268 Глава 6 . Развлекаемся квантовыми играми for p osition in range(5): # Если в строке для данной позиции находится значение 1, # то распределение вероятности добавляется в ущерб # Помните, что бит нулевой позиции — крайний справа # и соответствует bitString[4] if (bitString[4-position]==\"1\"): damage[player][position] += grid[player][bitString]/ shots stdout += \"Damage: \" + str(damage) + \"<br>\" В основной раздел первоначального сценария было внесено несколько небольших изменений. Все операторы вывода на печать были удалены. Вместо этого использу - ется стандартный выходной строковый буфер для возврата информации клиенту. Это сделано потому, что при выводе в Python информация бу - дет выгружаться непосредственно в HTTP-ответ, что испортит формат JSON, который мы должны вернуть обратно (JavaScript ожидает пра - вильный JSON от AJAX). Обратите внимание, что это необязательный, но полезный шаг, предназначенный для возврата отладочной информа - ции клиенту. В общем, вы можете обойти его, просто закомментировав все операторы вывода на печать (конечно, если произойдет ошибка, трудно будет разобраться, что пошло не так). Все операторы пользовательского ввода (считывание положения бомбы, нажатие клавиши Enter для продолжения и др.) были удалены. Помните, что позиции кораблей и счетчики бомб отображаются в коллекции из HTTP-запроса. Первоначальный сценарий использует бесконечный цикл while для чтения позиций бомбы. Этот цикл удален. Если этого не сделать, сце - нарий будет работать вечно и зависнет HTTP-запрос. Наконец, сценарий возвращает документ в формате JSON в браузер для обновления интерфейса пользователя (листинг 6.8). Листинг 6.8. Отправка ответа в браузер # Ответ print (\"Content-type: application/json\\n\\n\") print (\"{\\\"status\\\": 200, \\\"message\\\": \\\"\" + stdout + \"\\\", \\\"damage\\\":\" + str(damage) + \"}\")\n--- Страница 269 ---\nCloud Battleship: модификация удаленного доступа 269 Для пересылки ответа в браузер с помощью CGI в Python просто отправьте на печать стандартный HTTP-ответ, чтобы получить стандартный вывод, то есть один или несколько заголовков HTTP, за которыми следуют два символа перевода строки и тело ответа. Например, чтобы отправить до - кумент об ущербе в формате JSON, мы используем фрагмент: Content-type: application/json { \"status\" : 200, \"message\": \"Device ibmqx_qasm_simulator\", \"damage\": [[0.5, 0, 0, 0, 0], [0, 0.9, 0, 0, 0]]} Предыдущий документ в формате JSON указывает на повреждение qubit(0) первого игрока и qubit(1) второго игрока. Этот документ будет проанализирован с помощью кода AJAX браузера, и данные на экране будут обновлены. ПРИМЕЧАНИЕ Код для этого упражнения доступен в исходниках книги в файле Workspace\\Ch06\\battleship\\cgi-bin\\qbattleship.py. Решение 6.2. Интерфейс пользователя На веб-странице используется таблица 2 × 2 ячейки для отображения внутренних таблиц размерности 3 × 3, которые представляют собой игровые поля для размещения кораблей и бомб, как показано на рис. 6.4 и в листинге 6.9. Листинг 6.9. Код HTML для рис. 6.4 <form id=\"frm1\"> Device <select id=\"device\" name=\"device\"> <option value=\"local_qasm_simulator\">Local Simulator</option> <option value=\"ibmqx_qasm_simulator\">IBM Simulator</option> <option value=\"ibmqx2\">ibmqx2</option> </select> &nbsp;&nbsp;&nbsp;Place 3 ships per player, place a bomb & click submit. <table> <tr> <td> <div><h3>Player 1</h3></div>\n--- Страница 270 ---\n270 Глава 6 . Развлекаемся квантовыми играми Рис. 6.4. Интерфейс пользователя Quantum Battleship <script type=\"text/javascript\"> table(1, 's')</script> </td> <td> <div><h3>Player 2</h3></div> <script type=\"text/javascript\"> table(2, 's')</script> </td> </tr> <tr> <td> <div><h3>Player 1 Bombs</h3></div>\n--- Страница 271 ---\nCloud Battleship: модификация удаленного доступа 271 <script type=\"text/javascript\"> table(1, 'b')</script> </td> <td> <div><h3>Player 2 Bombs</h3></div> <script type=\"text/javascript\"> table(2, 'b')</script> </td> </tr> </table> </form> Рисование игровых полей 3 × 3 ячейки происходит динамически при по - мощи системного вызова document.write() (листинг 6.10). Листинг 6.10. Динамическое рисование таблиц с помощью document.write() // type: 's' (ship) = checkbox, 'b' (bomb) = radio function table (player, type) { var d = document; var html = '<table border=\"1\">\\n'; var qubit = 0; for ( var i = 0 ; i < 3 ; i ++) { html += '<tr>'; for ( var j = 0 ; j < 3 ; j ++) { if ( (i + j) % 2 == 0) { var id = 'p' + player + type + qubit++; // checkbox = ship, radio = bomb var itype = type == 's' ? 'checkbox' : 'radio'; var extra = type == 'b' ? ' onclick=\"cell_click_ bomb(this)\"' : ' onclick=\"return cell_click_ship(this)\"'; // <TD> SHIP-INDEX DAMAGE IMAGE </TD> html += '<td>' + (qubit — 1) + ' <span id=\"' + type + player + (qubit -1 ) + '\"> </span>' + '<input id=\"' + id + '\" name=\"' + id + '\" type=\"' + itype + '\"' + extra + '>' + '<label for=\"' + id + '\" class=\"ship\">&nbsp; </label></td>' } else { html += '<td>&nbsp;</td>'; } } html += '</tr>\\n'; } html += '</table>'; d.write(html); }\n--- Страница 272 ---\n272 Глава 6 . Развлекаемся квантовыми играми В табл. 6.1 приведены основные особенности интерфейса пользователя. Таблица 6.1. Интерфейс пользователя облачной версии Battleship, приемы и хитрости Мы скрываем флажки и переклю - чатели при помощи таблиц стилей. Селекторы в строках 1 и 2 исполь - зуют псевдокласс отрицания, чтобы скрыть правило от старых браузеров. Строки с 3-й по 5-ю задают ширину, поля и отступы для точного позицио - нирования альтернативной графики. В строке 6 устанавливается нулевое значение для непрозрачности, что делает стандартный интерфейс поль - зователя невидимымinput[type=checkbox]:not(old), input[type=radio ]:not(old){ width : 104px; margin : 0; padding : 0; opacity : 0; } Каждая ячейка в таблице кораблей отображает: • номер кубита; • элемент span для отображения процента нанесенного ущерба; • <INPUT type = \"checkbox\"> , модифицированный для использования изображения 100 × 100 пикселов вместо обычного элемента управления input[type=checkbox]:not(old) + label { display : inline-block; margin-left : –104px; padding-left : 104px; background : url(‘img/ship.png’) no-repeat 0 0; line-height : 100px; } Мы размещаем метку и выводим изо - бражение с неустановленным флажком. В строке 2 для метки устанавливается отображение в виде элемента inline-block, что позволяет в строке 6 задать высоту в соответствии с размерами альтернативной графики и центрировать текст по вертика - ли. В строке 3 используется отрицательное значение для поля (margin), чтобы покрыть пространство, в котором будет отображать - ся стандартный интерфейс пользователя, а в строке 4 применяется отступ, чтобы восстановить правильное положение текста метки. Используемое здесь значение 104 пиксела равно ширине изображения плюс некоторый дополнительный отступ, чтобы текст метки не был расположен слишком близко к изображению. В строке 5 показано изображение с неустановленным флажком в поле перед текстом метки\n--- Страница 273 ---\nCloud Battleship: модификация удаленного доступа 273 Каждая ячейка в таблице бомб со - держит: • номер кубита; • элемент span для отображения ко - личества бомб в данной позиции; • <INPUT type= \"radio\"> модифицированный для использо - вания изображения 100 × 100 пик - селов вместо обычного элемента управления Стиль, который применяется для форматирования бомб, приведен далее: input[type=radio ]:not(old) + label{ display : inline-block; margin-left : –104px; padding-left : 104x; background : url('img/bomb.png') no-repeat 0 0; line-height : 100px; } Затем отображаются выбранные картинки, для которы х установлены флажки и пере - ключатели: input[type=checkbox]:not(old):checked + label{ background-position : 0 –100px; } input[type=radio]:not(old):checked + label{ background-position : 0 –100px; } Поскольку мы объединили изображения для различных состояний в одно, приведен - ные ранее правила изменяют положение фона, чтобы показать соответствующее изображение Прекрасные библиотеки jQuery, Bootstrap и Bootstrap-Growl ис- пользуются для отображения сообщений и отладки информации в консоли JS: <script type=\"text/javascript\" src=\"js/log.js\"></script> <script type=\"text/javascript\" src=\"js/jquery.js\"></script> <script type=\"text/javascript\" src=\"js/bootstrap.js\"></script> <script type=\"text/javascript\" src=\"js/bootstrap-growl.js\"> </script> <script type=\"text/javascript\" src=\"js/notify.js\"></script>Чтобы HTML-код стал красивым, приме - няется типичная для проектирования GUI библиотека Bootstrap. Сообщения отобра - жаются на экране с помощью библиотеки Bootstrap-Growl из JS: notify('Bomb ready. Click Submit', info);\n--- Страница 274 ---\n274 Глава 6 . Развлекаемся квантовыми играми Правила игры и проверка данных Поскольку HTTP — это протокол без сохранения состояния, все структуры данных и логика проверки должны быть перенесены на сторону клиента. Например: игрокам нельзя разрешать размещать на доске более трех кораблей; запрещено менять судно после установки бомбы; бомбы нельзя устанавливать до того, как все игроки разместят свои корабли; для отслеживания щелчков кнопкой мыши используется глобальный массив счетчиков бомб var BOMBS = [[0,0,0,0,0], [0,0,0,0,0]] . Он соот - ветствует аналогу в Python bomb = [[0]*5 for _ in range(2)] . Эти правила можно применить, добавив обратный вызов при щелчке на ячейке корабля или бомбы (листинг 6.11). Листинг 6.11. Установление правил игры с помощью обратных вызовов в исходном коде книги в index.html // Вызывается при щелчке на ячейке корабля function cell_click_ship ( obj ) { var id = obj.id; var player = parseInt(id.charAt(1)); var qubit = parseInt(id.charAt(3)); var json = countShipsBombs(); LOGD('Cell Clicked ' + id + ' Counts:' + JSON.stringify(json)); if ( json.ships[0] > 3 || json.ships[1] > 3) { return error('All Players must place only 3 ships.'); } // Запрет на изменение кораблей после установки бомб if ( json.bombs[0] > 0 || json.bombs[1] > 0 ) { return error('No ship changes after bombs are placed.'); } return true; } // Вызывается при щелчке на ячейке бомбы function cell_click_bomb ( obj ) { var id = obj.id; // Для бомб: p[PLAYER]b[QUBIT] var player = parseInt(id.charAt(1)); var qubit = parseInt(id.charAt(3));\n--- Страница 275 ---\nCloud Battleship: модификация удаленного доступа 275 // Проверка: { 'ships': [s1, s2], 'bombs': [b1, b2]} var json = countShipsBombs(); LOGD('Bomb Clicked ' + id + ' Counts:' + JSON.stringify(json)); if ( json.ships[0] < 3 || json.ships[1] < 3) { $('#' + id).attr('checked', false); return error('All Players must place 3 ships first.'); } if ( mustSubmit) { return error('Bomb in place already. Click Submit.'); } // Проверка очереди игрока. Ошибки? var dif = (json.bombs[player – 1] + 1) – json.bombs[ 1 – (player – 1)]; if ( dif >= 2 ) { if ( BOMBS[player – 1 ][qubit] < 1 ) { $('#' + id).attr('checked', false); } return error(\"Not your turn. It's player \" + ((1-(player-1)) + 1) ); } // Подсчет бомб BOMBS[player – 1 ][qubit]++; // Присвоить счетчики: d[PLAYER][QUBIT] $('#b' + player + qubit).html(\"(\" + BOMBS[player – 1 ][qubit] + \")\"); // Бомбы на месте, нажать Подтвердить notify('Bomb ready. Click Submit', 'info'); mustSubmit = true; } function error (msg) { notify(msg, 'danger'); return false } Теперь да нные могут быть отправлены на сервер. Конечная точка и формат ответа Каждый запрос должен отправляться на веб-сервер асинхронно с исполь - зованием AJAX. Кроме того, строка запроса должна иметь определенный формат.\n--- Страница 276 ---\n276 Глава 6 . Развлекаемся квантовыми играми Для конечной точки http://localhost/~centos/battleship/cgi-bin/qiskit-driver.sh мы предполагаем, что: имя пользователя — centos ; код был развернут в домашней папке пользователя $HOME/centos/ public_html/battleship ; Python 3 необходимо активировать с помощью сценария-обертки qiskit-driver.sh . Это требуется только в том случае, если на хосте имеется несколько версий Python (см. далее раздел «Запуск нескольких версий Python»). Строка запроса должна содержать следующие значения: ship1 — разделенный запятыми список из трех позиций для кораблей первого игрока; ship2 — разделенный запятыми список из трех позиций для кораблей второго игрока; bombs1 — разделенный запятыми список из пяти бомб для первого игрока; bombs2 — разделенный запятыми список из пяти бомб для второго игрока; device — квантовое устройство, например local_qasm_simulator , ibmq_ qasm_simulator или ibmqx2 . Вот пример полного запроса AJAX для запуска на удаленном моделиру - ющем устройстве: http://localhost/~centos/battleship/cgi-bin/qiskit-driver.sh?ships1=0,1,2&s hips2=0,1,2&bombs1=0,1,0,0,0&bombs2=0,0,0,0,0&device=ibmqx_qasm_simulator Когда игрок нажимает кнопку Submit (Отправить), позиции кораблей ships1 и ships2 , а также счетчики бомб bombs1 и bombs2 собираются из дерева DOM и глобального массива BOMBS . Конечная точка и строка запроса определены, и HTTP-запрос GET отправляется через AJAX (листинг 6.12).\n--- Страница 277 ---\nCloud Battleship: модификация удаленного доступа 277 Листинг 6.12. Отправка данных на сервер в файле index.html function submit() { var frm = $('#frm1'); var url = \"cgi-bin/qiskit-driver.sh\"; // Формат данных: ships1=0,1,2&ships2=0,1,2&bombs1=0,1,0,0,0 // &bombs2=0,0,0,0,0 // Для кораблей указаны позиции по игрокам, // Для бомб указано количество для их позиций по игрокам // Корабли: три корабля на игрока, бомбы: пять счетчиков для позиций var data = \"; var s1 = \"; var s2 = \"; for ( var i = 0 ; i < 5 ; i++) { if ( $('#p1s' + i).prop('checked') ) s1 += ',' + i; if ( $('#p2s' + i).prop('checked') ) s2 += ',' + i; } // Удаление первой точки if (s1.length > 0) s1 = s1.substring(1); if (s2.length > 0) s2 = s2.substring(1); // Строка запроса data = 'ships1=' + s1 + '&ships2=' + s2 + '&bombs1=' + BOMBS[0].join(',') + '&bombs2=' + BOMBS[1].join(',') + '&device=' + $('#device').val(); LOGD('Url:' + url + ' data=' + data); // https://api.jquery.com/jquery.get/ $.get( url, data) .done(function (json) { handleResponse (json); }) .fail(function() { LOGD( \"error\" ); notify('Internal Server Error. Check logs.', 'danger'); }) } Если что-то пойдет не так, уведомление об ошибке будет отображаться на экране, в противном случае ожидаемый ответ в формате JSON будет отправлен обработчику. Посмотрим, как это происходит.\n--- Страница 278 ---\n278 Глава 6 . Развлекаемся квантовыми играми Обработчик ответов Задача обработчика ответа состоит в том, чтобы использовать ответ сер - вера и обновлять счетчики нанесенного ущерба, отображать сообщения об ошибках, если таковые имеются, или повторять этот процесс, пока не будет объявлен победитель. Процесс показан в листинге 6.13, но сначала рассмотрим имеющий большое значение формат ответа JSON: {\"status\":200,\"message\":\"OK\",\"damage\":[[0.475,0,0,0.70,0], [0.786,0.90,0,0,0.]]} Самым важным ключом является damage . Он содержит двумерный массив, представляющий для каждого игрока позиции, в которых корабль повре- жден. Значение ущерба находится в диапазоне от 0 до 1. Эти данные исполь - зуются обработчиком ответа для обновления интерфейса пользователя. Листинг 6.13. Обработчик ответа в файле index.html function handleResponse (json) { LOGD(\"Got: \" + JSON.stringify(json)) var damage = json.damage; var d1 = damage[0]; // ущерб для P1 var d2 = damage[1]; // ущерб для P2 for ( var i = 0 ; i < 5 ; i++) { var pct1 = (d1[i] * 100).toFixed(1); var pct2 = (d2[i] * 100).toFixed(1); var s1, c1, s2, c2; if ( pct1 < 90 ) { s1 = '[' + pct1 + '%]'; c1 = 'cyan'; } else { s1 = 'SUNK'; c1 = 'red'; notify('Player 1 Ship ' + i + ' sunk.', 'warning'); } if ( pct2 < 90 ) { s2 = '[' + pct2 + '%]'; c2 = 'cyan'; } else { s2 = 'SUNK'; c2 = 'red'; notify('Player 2 Ship ' + i + ' sunk.', 'warning'); }\n--- Страница 279 ---\nCloud Battleship: модификация удаленного доступа 279 //LOGD(i + ' s1=' + s1 + ' s2=' + s2 + ' d1=' + d1[i] + // ' d2=' + d2[i]); $('#s1' + i).html(s1).css('background-color', c1); $('#s2' + i).html(s2).css('background-color', c2); } // Результат игры: суммарный ущерб sum > 2.85 (0.95 * 3) = loss // https://www.w3schools.com/jsref/jsref_reduce.asp // array.reduce(function(total, currentValue, currentIndex, arr), // initialValue) var s1 = d1.reduce(function(total, currentValue, currentIndex, arr) { return total + currentValue}, 0); var s2 = d2.reduce(function(total, currentValue, currentIndex, arr) { return total + currentValue}, 0); var winner = 0; if ( s1 > 2.85) winner = 2; if ( s2 > 2.85) winner = 1; LOGD (\"Results Damage sums s1:\" + s1 + \" s2:\" + s2); if ( winner != 0) { notify ('** G.A.M.E O.V.E.R Player ' + winner + ' wins **', 'success'); gameover = true; } // Разрешить отправку $(\"#btnSubmit\").prop(\"disabled\", false); } Обработчик извлекает массив для ущерба и проходит в цикле по всем позициям, переводя ущерб для каждого игрока в проценты. Чтобы более эффектно продемонстрировать нанесенный урон, исполь - зуется цветная подсветка. Для каждого затонувшего корабля на экран выводятся сообщения (рис. 6.5). Рис. 6.5. Цветная подсветка поля для отображения ущерба\n--- Страница 280 ---\n280 Глава 6 . Развлекаемся квантовыми играми Если суммарный ущерб превышает предельное значение 90 % для всех кораблей игрока, объявляется победитель и игра заканчивается. Чтобы начать новую игру, нажмите кнопку Reset (Сбросить). Чтобы запустить игру заново, мы просто снимаем все флажки и переклю - чатели и обнуляем глобальный массив BOMBS (листинг 6.14). Листинг 6.14. Перезагрузка игры в исходном коде книги в index.html // Перезапуск игры вызывается при нажатии кнопки перезапуска function reset_click () { if ( ! confirm(\"Are you sure?\")) { return; } gameover = false; for ( var i = 0 ; i < 5 ; i++) { $('#p1s' + i).attr('checked', false); $('#p2s' + i).attr('checked', false); $('#p1b' + i).attr('checked', false); $('#p2b' + i).attr('checked', false); // элементы span с информацией $('#s1' + i).html(\"); $('#s2' + i).html(\"); $('#b1' + i).html(\"); $('#b2' + i).html(\"); BOMBS[0][i] = 0; BOMBS[1][i] = 0; } } Теперь пришло время для запуска, развертывания, тестирования и устра - нения неполадок, если это необходимо. Для разработки я использую CentOS 6, которая по умолчанию включает Python 2.7. Помните, что мы должны взять Python 3.5 или более поздней версии. ПРИМЕЧАНИЕ Листинги 6.9–6.12 находятся в исходниках книги в Workspace\\Ch06\\ battleship\\index.html, как и ресурсы, необходимые для развертывания игры в облаке.\n--- Страница 281 ---\nCloud Battleship: модификация удаленного доступа 281 Запуск нескольких версий Python В главе 3 объясняется, как установить и запустить Python 3.6 и Python 2.7 по отдельности. В данном конкретном случае сценарий-обертка исполь - зуется для активации Python 3 на сервере CGI перед вызовом квантовой программы: #!/bin/sh # Домашняя папка root=/home/centos program=qbattleship.py # Активация python 3 source $root/qiskit/qiskit/bin/activate # Выполнение квантовой программы на python python $program В предыдущем сценарии просто активируется Python 3 и вызывается реальная квантовая программа qbattleship.py . Это необходимо, иначе веб-сервер будет использовать версию Python по умолчанию (2.7) и про- грамма завершится с ошибкой, поскольку для QISKit требуется Python 3.5 или более поздней версии. Помните, что среда Python 3 была создана в домашней папке пользователя следующим образом: $ mkdir –p $HOME/qiskit $ cd $HOME/qiskit $ python3.6 -m venv qiskit Активация виртуальной среды: $ source qiskit/bin/activate Теперь наконец перейдем к развертыванию и тестированию. Надеюсь, что устранять ошибки не потребуется. Решение 6.3. Развертывание и тестирование В этом разделе мы развернем игру на HTTPD-сервере Apache и посмо - трим на нее в действии. Полный исходный код игры, включая все файлы поддержки, стили, изображения, оболочку CGI и квантовую программу, можно найти в исходниках книги, в разделе Workspace\\Ch06\\battleship . Расположение папок показано на рис. 6.6.\n--- Страница 282 ---\n282 Глава 6 . Развлекаемся квантовыми играми ПРИМЕЧАНИЕ В этом разделе предполагается, что вы уже установили HTTPD-сервер Apache в своей системе и служба по умолчанию настроена и работает правильно. Если это не так, исправить ситуацию можно, обратившись к учебным пособиям. Например, для CentOS 7 мне нравится www.liquidweb.com/ kb/how-to-install-apache-on-centos-7/. Рис. 6.6. Расположение папок для облачной Quantum Battleship 1. Создайте папку с названием public_html в своей домашней папке поль - зователя: $ mkdir $HOME/public_html 2. Создайте папку cgi-bin в public_html для хранения CGI-сценариев Python: $ mkdir $HOME/public_html/cgi-bin\n--- Страница 283 ---\nCloud Battleship: модификация удаленного доступа 283 3. Выполните конфигурацию сервера HTTPD, чтобы разрешить доступ как из public_html , так и из public_html/cgi-bin (листинг 6.15). Обра - тите внимание, что для cgi-bin требуется специальное разрешение для выполнения CGI-сценариев. 4. Если хотите использовать исходный код книги, скопируйте все файлы из Workspace\\Ch06\\battleship to public_html/battleship . 5. Убедитесь, что права доступа к файлам установлены корректно для папки public_html и всех вложенных папок и файлов. Это очень важно: если разрешения неправильные, браузер выдаст ответ «500 — Internal Server Error». Когда я выполнял тестирование на своем персональном компьютере с CentOS 6, основным источником головной боли было $ chmod -R 755 public_html . Листинг 6.15. Конфигурация, разрешающая HTTP-запросы из папки public_html (CentOS 6/Apache HTTPD 2.2) <IfModule mod_userdir.c> # UserDir disabled # # Чтобы разрешить запросам к /~user/ обращаться к папке public_html, # удалите строку \"UserDir disabled\" выше и взамен раскомментируйте # следующую строку: # UserDir public_html </IfModule> <Directory /home/*/public_html> AllowOverride FileInfo AuthConfig Limit Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec +ExecCGI AddHandler cgi-script .cgi <Limit GET POST OPTIONS> Order allow,deny Allow from all </Limit> </Directory> <Directory \"/home/*/public_html/cgi-bin\"> AllowOverride None Options ExecCGI SetHandler cgi-script </Directory>\n--- Страница 284 ---\n284 Глава 6 . Развлекаемся квантовыми играми СОВЕТ Чтобы разрешить запросы из public_html (см. листинг 6.15), необходимо, чтобы в httpd.conf был включен модуль userdir для Apache (раскоммен - тируйте LoadModule userdir_module modules / mod_userdir.so). Этот модуль может быть заблокирован по умолчанию. Скопируйте сценарий из листинга 6.15 в системную папку /etc/httpd/ conf.d . Она содержит файлы конфигурации, автоматически загружаемые HTTPD-сервером Apache при запуске. Теперь запустите сервер HTTPD в CentOS (обратите внимание: предполагается, что в вашей системе уже установлен HTTPD-сервер Apache): $ sudo service httpd start (CentOS 6) $ sudo systemctl start httpd (CentOS 7) Наконец, в качестве финального аккорда запустите браузер и перейдите по URL-адресу http://localhost/~centos/battleship/ (при условии, что имя поль - зователя — centos ). Надеюсь, проблем не будет и вы сможете начать играть в Quantum Battleship в облаке. Но если что-то пойдет не так, изучите при - веденный далее список проблем, с которыми я столкнулся при настройке. Устранение ошибок Большинство проблем, с которыми я столкнулся, были связаны с правами доступа к файлам из-за моей застарелой привычки использовать старый добрый HTTPD-сервер Apache. Особенность HTTPD-сервера Apache заключается в следующем: чтобы разрешить запросы из домашней папки пользователя (см. листинг 6.15), необходимо, чтобы модуль userdir был включен в конфигурации де - мона httpd.conf . В зависимости от вашей ОС этот модуль может быть заблокирован по умолчанию. Пользователи HTTPD 2.4 должны учесть: листинг 6.15 предназначен для Apache v2.2, а v2.4 может потребоваться другой синтаксис. HTTP-статус 500 — внутренняя ошибка сервера в браузере: убедитесь, что права доступа к файлам для public_html и всех вложенных файлов\n--- Страница 285 ---\nCloud Battleship: модификация удаленного доступа 285 и папок установлены на 755. Вы можете диагностировать это, посмотрев файлы журналов HTTPD, расположенные по адресам: /var/log/httpd/error_log /var/log/httpd/suexec.log Например, вот фрагмент из suexec.log , в котором говорится, что мои раз - решения некорректны: $ tail -f /var/log/httpd/suexec.log [2018-04-02 17:03:45]: cannot get docroot information (/home/centos) [2018-04-02 17:10:13]: uid: (500/centos) gid: (500/centos) cmd: first.cgi [2018-04-02 17:10:13]: directory is writable by others: (/home/centos/ public_html) ПРИМЕЧАНИЕ suEXEC — это функция веб-сервера Apache. Он позволяет пользовате - лям запускать приложения CGI и SSI от имени другого пользователя. В CentOS suEXEC записывает журналы в /var/log/httpd/suexec.log. Проблемное место SELinux — модуль безопасности ядра Linux, который обеспечивает механизм поддержки политик безопасности контроля до - ступа. В CentOS данная функция включена по умолчанию. Ее можно отключить временно в командной строке с помощью команды: $ sudo setenforce 0 или постоянно, отредактировав файл /etc/sysconfig/selinux и устано - вив для ключа SELINUX значение disabled : $ sudo vi /etc/sysconfig/selinux SELINUX=disabled SELINUXTYPE=targeted Обратите внимание, что SELinux может стать причиной проблем при вызове сценариев CGI или когда квантовая программа пытается выполнить код удаленно на моделирующем устройстве IBM либо на реальном устройстве. Ошибки Python: если в сценарии Python возникает какая-либо ошиб - ка, обработчик исключений CGI перехватывает ее и выдает красивую\n--- Страница 286 ---\n286 Глава 6 . Развлекаемся квантовыми играми HTML-страницу в текущем рабочем каталоге ( cgi-bin ). На рис. 6.7 показан вывод ошибки превышения лимита времени при выполнении на реальном квантовом устройстве ibmqx2. Рис. 6.7. Вывод ошибок в Python, созданный пакетом cgi Проблемы конфигурации API: если вы работаете на реальном кванто - вом устройстве, убедитесь, что конфигурация в Qconfig.py корректна (включая токен API для вашей учетной записи Q Experience), как по - казано в следующем фрагменте: APItoken = 'YOUR-API-TOKEN' config = { 'url': 'https://quantumexperience.ng.bluemix.net/api', } Обратите внимание, что Qconfig.py должен находиться в том же месте, что и квантовая программа qbattleship.py , то есть в папке cgi-bin . Тем не менее в игру можно внести дополнительные улучшения. Обсудим их в следующем разделе.\n--- Страница 287 ---\nCloud Battleship: модификация удаленного доступа 287 Дополнительные улучшения В Cloud Battleship, рассмотренной в предыдущем разделе, можно внести некоторые улучшения — наверняка вы сами заметите это, поиграв какое- то время. Вот список моих идей. Интерфейс пользователя отображает игровые поля с кораблями и бом- бами для обоих игроков. В настоящей игре «Морской бой» каждый игрок должен открыть собственное окно браузера, установить свои корабли и начать бомбардировку противника. Игровое состояние: корабль, позиции бомб и квантовое устройство хра - нятся на стороне клиента из-за того, что HTTP — это протокол без со - хранения состояния. То есть приходит запрос, запускается программа на Python, и ответ отправляется обратно. После этого вся память стирается. Настоящая игра должна использовать серверный лобби-клиент игрока для размещения игрового состояния (например, с применением сервера приложения) и координации взаимодействия между окнами браузера. Улучшенная версия Cloud Battleship Максимально улучшенная версия игры Cloud Quantum Battleship должна использовать два окна браузера для двух игроков с игровыми полями для размещения кораблей и бомб в каждом. Кроме того, HTTPD-сервер Apache нужно заменить сервером приложения, таким как Apache Tomcat, который способен хранить состояние игры. Схема показана на рис. 6.8. Элементарный лобби-клиент игры можно реализовать в виде веб- приложения Tomcat для хранения кораблей, позиций бомб и квантовых устройств. Веб-приложение может использовать средства времени выполнения операционной системы хоста, в данном случае API времени выполнения Java, чтобы вызвать квантовый сценарий Python, вернуть результаты нанесенного ущерба и отправить их каждому игроку. Чтобы избежать раздражающего постоянного обновления страниц, каждый браузер может подключаться через WebSocket к серверу прило - жений. Это позволит поддерживать постоянное соединение, а клиенты смогут быстро обмениваться текстовыми сообщениями JSON.\n--- Страница 288 ---\n288 Глава 6 . Развлекаемся квантовыми играми Рис. 6.8. Улучшенная версия Cloud Quantum Battleship Соединение через WebSocket Для того чтобы соединение происходило через WebSocket вместо AJAX, веб-страницу интерфейса пользователя следует немного изменить, как показано в листинге 6.16. СОВЕТ Проект Eclipse для этого раздела находится в исходниках книги в Work- space\\Ch06_BattleShip. Учитывая, что некоторые детали этого веб- приложения сложно реализуются, рекомендую открыть рабочее простран - ство в своей IDE и дальше читать, параллельно работая с ним. Надеюсь, что вы хорошо умеете писать приложения с помощью Eclipse/Tomcat.\n--- Страница 289 ---\nCloud Battleship: модификация удаленного доступа 289 Листинг 6.16. Код клиента WebSocket на JavaScript в WebContent/js/websocket.js // Конечная точка сервера WS (file: websocket.js) var END_POINT = \"ws://localhost:8080/BattleShip/WSBattleship\"; // Случайный ID, используемый для отслеживания клиента var CLIENT_ID = Math.floor(Math.random() * 10000); function WS_connect(host) { LOGD(\"WS Connect \" + host); if ('WebSocket' in window) { this.socket = new WebSocket(host); } else if ('MozWebSocket' in window) { this.socket = new MozWebSocket(host); } else { LOGE('Error: WebSocket is not supported by this browser.'); return; } this.socket.onopen = function() { LOGD('WS Opened ' + host); }; this.socket.onclose = function() { LOGD('WS Closed ' + host); }; this.socket.onmessage = function(message) { // { status: 200 , message :'…'} LOGD('OnMessage: ' + message.data); var json = JSON.parse(message.data); if ( json.status >= 300 && json.status < 400) { // Предупреждение notify(json.message, 'warning'); } if ( json.status >= 400 ) { // Ошибка notify(json.message, 'danger'); return; } handleResponse (json); }; } function WS_initialize () { var clientId = CLIENT_ID; var host = END_POINT; this.url = host + '?clientId=' + clientId;\n--- Страница 290 ---\n290 Глава 6 . Развлекаемся квантовыми играми WS_connect(this.url); }; function WS_send (text) { this.socket.send(text); }; На стороне клиента: все основные браузеры реализуют стандарт WebSocket, который ис - пользуется для поддержки долговременного соединения с сервером. Для этого в строке 2 создана конечная точка ws://localhost:8080/ BattleShip/WSBattleship . Обратите внимание, что этот параметр мож - но отправить в список конечных точек WebSocket как обычный URL. Таким образом, конечным URL для WS будет ws://localhost:8080/ BattleShip/WSBattleship?clientId=RANDOM-ID , где для отслеживания каждого из игроков применяется случайный ID; WebSocket использует в JavaScript системный обратный вызов для получения следующих событий: •socket.onopen — вызывается при открытии сокета, в строке 23 по - казан обратный вызов для обработки этого события; •socket.onclose — вызывается при разрыве соединения, например, когда браузер был закрыт или обновился либо упал сервер; •socket.onmessage — это самая важная функция обратного вызова, которая выполняется при получении сообщений в формате JSON, отправленных Python, как это было с AJAX в предыдущей версии. При загрузке страницы в браузере игрока клиент устанавливает соедине - ние при помощи обратного вызова DOM window.onload : function win_onload () { WS_initialize (); } window.onload = win_onload; На серверной стороне нам нужен сервер приложений с поддержкой WebSocket. К счастью, Tomcat в полной мере реализует стандарт WebSocket во всех операционных системах. В листинге 6.17 показана базовая реали - зация обработчика событий на стороне сервера WebSocket на Java.\n--- Страница 291 ---\nCloud Battleship: модификация удаленного доступа 291 Листинг 6.17. Структура обработчика событий на стороне сервера WebSocket (WSConnector.java) @ServerEndpoint(value = \"/WSBattleship\") public class WSConnector { // Установка соединений private static final List<WSConnectionDescriptor> connections = new CopyOnWriteArrayList<WSConnectionDescriptor>(); // Данные из игры Player-ID => {name: 'Player-1', ships: \"0,0,0:, // bombs: \"0,0,0,0,0 } private static final Map<String, JSONObject> data = new HashMap<String, JSONObject>(); /** Id клиента для данного WS */ String clientId; private String getSessionParameter (Session session, String key) { if ( ! session.getRequestParameterMap().containsKey(key)) { return null; } return session.getRequestParameterMap().get(key).get(0); } @OnOpen public void open(Session session) { clientId = getSessionParameter(session, \"clientId\"); // Проверка id клиента на уникальность WSConnectionDescriptor conn = findConnection(clientId); if ( conn != null) { unicast(conn.session, WSMessages.createStatusMessage(400 , \"Rejected duplicate session.\").toString()); } else { connections.add(new WSConnectionDescriptor(clientId, session)); } dumpConnections(\"ONOPEN \" + clientId ); } @OnClose public void end() { } @OnMessage public void incoming(String message) { WSConnectionDescriptor d = findConnection(clientId); try { JSONObject root = new JSONObject(message);\n--- Страница 292 ---\n292 Глава 6 . Развлекаемся квантовыми играми String name = root.getString(\"name\"); String action = root.optString(\"action\"); // перезапустить игру? if ( action.equalsIgnoreCase(\"reset\")) { multicat(WSMessages.createStatusMessage(300 , \"Game reset by \" + name).toString()); data.clear(); return; } // Валидация правил игры… // Выполнение скрипта Python linuxExecPython(args); } catch (Exception e) { LOGE(\"OnMessage\", e); } } @OnError public void onError(Throwable t) throws Throwable { LOGE(\"WSError: \" + t.toString()); } } В Java обработчики событий на стороне сервера WebSocket реализованы в соответствии со стандартом для аннотаций J2EE, что позволяет всем разработчикам повторно использовать код. В строке 1 листинга 6.17 в классе Java WSConnector определяется ан - нотация @ServerEndpoint(value = \"/WSBattleship\") . И это все, что нам нужно для создания обработчика событий на стороне сервера. Значение WSBattleship соответствует названию обработчика событий, таким об - разом, полное название конечной точки соединения с сервером будет ws://host:POT/Battleship/WSvattleship?QUERY-STRING . Обратные вызовы для событий открытия, закрытия и выдачи сообще - ния объявляются с помощью аннотаций @OnOpen , @OnClose и @OnMessage соответственно. Обратите внимание на то, что название метода несущественно, значи - мыми являются следующие параметры: •OnOpen — получает объект Session , который содержит информацию о соединении;\n--- Страница 293 ---\nCloud Battleship: модификация удаленного доступа 293 •OnClose — без параметров, выполняется при завершении соединения с браузером; •OnMessage — самый важный вызов в этом наборе. Он выполняется, когда клиент отправляет текстовое сообщение с данными в качестве параметра. Имейте в виду, что для каждого клиентского соединения будет создано по одному экземпляру класса WSConnector . В строке 5 для отслеживания всех клиентских соединений используется потокобезопасный стати - ческий список List<WSConnectionDescriptor> . В строке 5 объявляется статическая хеш-таблица для игровых данных, где ключом является ID игрока, а значением — объект JSON, отправленный браузером, напри - мер [Player-1 => {name: 'Player-1’, ships: \"0,0,0:, bombs: \"0,0,0,0,0\", device: \"local_qasm_ simulator\"}] . Когда происходит обратный вызов при получении сообщения (стро - ки 201–253 в файле WSConnector.java ), текстовое сообщение преоб - разуется в формат JSON, данные сохраняются в памяти, применяются правила игры и, если все корректно, вызывается скрипт Python с пози- циями кораблей и бомб. В конце полученные результаты отправляются каждому клиенту для обновления. Для отправки сообщения на сторону клиента можно использовать объект Session session.getBasicRemote().sendText(\"Some Text\") . Чтобы отправить групповое сообщение всем клиентам, можно восполь - зоваться списком сообщений: static void multicast ( String message ) { for ( WSConnectionDescriptor conn : connections) { conn.session.getBasicRemote().sendText(message) } } Вызов Python и установка прав доступа к файлам в Java Несмотря на то что язык Java спроектирован так, чтобы быть независи - мым от ОС, системные команды можно запустить с помощью системного вызова Runtime.getRuntime().exec(\"command\") .\n--- Страница 294 ---\n294 Глава 6 . Развлекаемся квантовыми играми В листинге 6.18 показан очень простой класс для выполнения команды и считывания ее стандартного вывода в строковый буфер. Листинг 6.18. Выполнение системных команд и извлечение результатов (SysRunner.java) public class SysRunner { final String command; final StringBuffer stdout = new StringBuffer(); final StringBuffer stderr = new StringBuffer(); public SysRunner(String command) { this.command = command; } public void run () throws IOException, InterruptedException { final Process process = Runtime.getRuntime().exec(command); pipeStream(process.getInputStream(), stdout); pipeStream(process.getErrorStream(), stderr); process.waitFor(); } private void pipeStream (InputStream is, StringBuffer buf) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(is)); String line; while ((line = br.readLine()) != null) { buf.append(line); } } public StringBuffer getStdOut () { return stdout; } public StringBuffer getStdErr () { return stderr; } } Чтобы получить выходные данные команды, используйте входной поток процесса, прочитайте из него данные и сохраните в строковом буфере (строки 17–24 в листинге 6.18): pipeStream(process.GetInputStream(), stdout) . Теперь у нас есть инструмент для запуска программы на Python, но нам все еще нужно иметь дело с правами доступа к файлам в Linux. Помните, что скрипт Python необходимо включить в само веб-приложение\n--- Страница 295 ---\nCloud Battleship: модификация удаленного доступа 295 (рис. 6.9). Поэтому, когда сервер приложений извлечет в файловую систе - му веб-приложение Battleship вместе с кодом Python, сценарий получит установленное по умолчанию право доступа к файлу 644 (не исполняе - мому в среде). Это приведет к сбою сценария при запуске. Рис. 6.9. Схема проекта J2EE для Cloud Battleship Чтобы установить корректные права доступа к файлам для кода Python внутри веб-приложения, выполните системную команду chmod с названия- ми файлов, как показано в следующем отрывке кода: // Получить путь к основному каталогу для кода Python // …webapps/BattleShip/python/ String root = IOTools.getResourceAbsolutePath(\"/\") + \" / /\"; // Нельзя использовать специальные символы *&$# String cmd = \"/bin/chmod 755 \" + base + \"python\" + File.separator; String[] names = { \"Qconfig.py\", \"qiskit-basic-test.py\" , \"qiskit-driver.sh\", \"qbattleship-sim.py\", \"qbattleship.py\"};\n--- Страница 296 ---\n296 Глава 6 . Развлекаемся квантовыми играми for (int i = 0; i < names.length; i++) { SysRunner r = new SysRunner(cmd + names[i]); r.run(); } Путь к основному каталогу установки приложения в Java можно получить с помощью отражения (reflection), как показано далее: public static String getResourceAbsolutePath(String resourceName) throws UnsupportedEncodingException { URL url = IOTools.class.getResource(resourceName); String path = URLDecoder.decode(url.getFile(), DEFAULT_ENCODING); // path -> Windows: /C:/…/Workspaces/…/ // path-> Linux: /home/users/foo… if ( path.startsWith(\"/\") && OS_IS_WINDOWS) { // Должен быть удален первый символ / (только в Windows!) path = path.replaceFirst(\"/\", \"\"); } return path; } Наконец, квантовую программу на Python можно выполнить из обратного вызова при получении сообщения WebSocket, как показано в листин - ге 6.19. Листинг 6.19. Выполнение квантовой программы и отправление результатов на сторону клиента // Аргументы: ships1=0,0,0 ships2=0,0,0 bombs1=0,0,0,0,0 bombs2=0,0,0,0,0 // device=local_qasm_simulator private void linuxExecPython (String args) throws Exception { // STDOUT {status: 200, message: 'Some text', damage: // [[0,0,0,0,0],[0,0,0,0,0]]} StringBuffer stdout = IOTools.executePython(SCRIPT_ROOT, args); JSONObject resp = new JSONObject(stdout.toString()); // Отправить назад клиентам в обратном порядке JSONArray damage = resp.getJSONArray(\"damage\"); resp.remove(\"damage\"); final int size = damage.length() – 1; for (int i = 0; i < connections.s ize(); i++) { resp.put(\"damage\", damage.get( size — i)); unicast(connections.get(i).session, resp.toString()); resp.remove(\"damage\"); } }\n--- Страница 297 ---\nCloud Battleship: модификация удаленного доступа 297 // Основной каталог: WEPAPP_PATH/python/qiskit-driver.sh // Аргументы: WEPAPP_PATH/python/qbattleship.py // 0,0,0 0,0,0 0,0,0,0,0 0,0,0,0,0 device public static StringBuffer executePython (String base, String args) throws IOException, InterruptedException { String driver = base + File.separator + \"python\" + File.separator + \"qiskit-driver.sh\"; String program = base + File.separator + \"python\" + File.separator + \"qbattleship.py\"; String cmd = driver + \" \" + program + ( args != null ? \" \" + args : \"\"); SysRunner r = new SysRunner(cmd); r.run(); return r.getStdOut(); } Чтобы выполнить квантовую программу на Python, код в листинге 6.19: получает расположение ( LOCATION ) каталога с кодом на Python внутри веб-приложения. Это TOMCAT-ROOT/webapps/Battleship/python ; выполняет скрипт драйвера LOCATION/qiskit-driver.sh LOCATION/ qbattleship.py с аргументами: •ships1 — расположение кораблей первого игрока; •ships2 — расположение кораблей второго игрока; •bombs1 — счетчики бомб первого игрока; •bombs2 — счетчики бомб второго игрока; •device — квантовое устройство; отправляет результаты клиентам. Наконец, из своей IDE экспортируйте веб-архив Cloud Quantum Battle- ship (WAR), разверните его в контейнере Tomcat и играйте из двух веб-браузеров, перейдя по адресу http://localhost:8080/BattleShip/ (рис. 6.10). И хотя я не сомневаюсь в том, что у вас достаточно опыта, все же на всякий случай приведу порядок действий. 1. Экспортируйте веб-приложение как веб-архив WAR и щелкните правой кнопкой мыши на проекте Ch06_Battleship в своей IDE (см. рис. 6.9). На - жмите ExportWeb Archive (Экспортировать Веб-архив) и выберите файл (то есть Ch06_Battleship.war ).\n--- Страница 298 ---\n298 Глава 6 . Развлекаемся квантовыми играми 2. Убедитесь в том, что Tomcat запущен и выполняется. Если он не уста- новлен в вашей ОС по умолчанию, то вам помогут следующие команды: yum -y install java (CentOS 6,7) yum -y install tomcat7 tomcat7-webapps tomcat7-admin-webapps (CentOS 6,7) service tomcat7 start (CentOS 6) systemctl start tomcat7 (CentOS 7) 3. Используйте интерфейс пользователя менеджера Tomcat, находя - щийся по адресу http://yourhost:8080/manager/ , чтобы загрузить и раз- вернуть архив в своем контейнере Tomcat в Linux. (Совет: менеджер запросит имя пользователя и пароль, если у вас их нет, отредактируйте файл /etc/tomcat7/tomcat-users.xml .) 4. Теперь у вас должна быть возможность указать два браузера на http:// localhost:8080/BattleShip/ (совет: веб-приложения Tomcat развернуты в папке /var/lib/tomcat7/webapps ). Есть проблемы? Проверьте журналы контейнера в /var/log/tomcat7/catalina.out . Рис. 6.10. Улучшенная версия Cloud Battleship с двумя браузерами В этой главе было показано, как популярную игру Battleship можно запустить на квантовом компьютере с применением однокубитных ча - стичных вентилей НЕ для вычисления степени повреждения корабля.\n--- Страница 299 ---\nCloud Battleship: модификация удаленного доступа 299 С этой целью был использован пример Quantum Battleship из учебника по QISKit. Кроме того, мы вывели игру на новый уровень, значительно улучшив пользовательский интерфейс. Вы узнали, как квантовый код можно вы - звать в облаке с помощью сценариев CGI через сервер Apache HTTPD. Дальнейшие улучшения были сделаны, чтобы можно было играть сразу в двух браузерах через контейнер Tomcat J2EE. Код Eclipse для обоих про - ектов доступен в исходниках книги в папках Workspace\\Ch06 и Workspace\\ Ch06_BattleShip соответственно. В следующей главе рассматриваются две игры-головоломки, которые демонстрируют удивительную мощь квантовых алгоритмов по сравнению с их классическими аналогами: загадка про фальшивую монету и магиче - ский квадрат Мермина — Переса. Это примеры квантовой псевдотелепа - тии, или способности игроков достигать результатов, которые возможны, только если они во время игры читали мысли друг друга.\n--- Страница 300 ---\n7Теория игр: с квантовой механикой преимущество всегда на вашей стороне В этой главе исследуются две игровые загадки, которые демонстрируют впечатляющее превосходство квантовых алгоритмов в сравнении с их классическими аналогами. Загадка про фальшивую монету. Это классическая задача на взвеши - вание, предложенная математиком Е. Д. Шеллом в 1945 году. В ней нужно при помощи лабораторных весов за ограниченное число взве - шиваний определить монету, вес которой отличается от веса других (фальшивую). Магический квадрат Мермина — Переса. Это пример квантовой псев - дотелепатии, или способности игроков достигать результатов, которые возможны, только если они во время игры читают мысли друг друга. В обоих случаях квантовые вычисления наделяют игроков псевдомаги - ческими способностями, как если бы они все время жульничали. Давайте посмотрим, как это происходит. Загадка про фальшивую монету У игрока есть восемь монет и лабораторные весы. Одна из монет фаль - шивая и поэтому весит меньше остальных. Вы можете найти ее? Давайте вкратце рассмотрим решение, которое показано на рис. 7.1.\n--- Страница 301 ---\nЗагадка про фальшивую монету 301 1. Положите монеты 1–3 на левую чашу весов, а 4–6 — на правую. От - ложите на время монеты 7 и 8. 2. Если перевесила правая чаша весов, то фальшивая — среди монет 1–3 (слева). Помните, что поддельная монета легче. Затем уберите монету 3 и положите на левую чашу весов монету 1, а на правую — монету 2. •Если перевешивает правая чаша, то фальшивая — монета 1. •Если перевешивает левая чаша, то фальшивая — монета 2. •Если весы уравновесились, то фальшивая — монета 3. 3. Если перевесила левая чаша весов, то фальшивая — среди монет 4–6. Уберите монету 6 и положите на левую чашу весов монету 4, а на пра - вую — монету 5. •Если перевешивает правая чаша, то фальшивая — монета 4. •Если перевешивает левая чаша, то фальшивая — монета 5. •Если весы уравновесились, то фальшивая — монета 6. 4. Если весы уравновесились, то фальшивая монета либо 7, либо 8. Поло - жите на левую чашу весов монету 7, а на правую — монету 8 и взвесьте. •Если перевешивает правая чаша, то фальшивая — монета 7. •Если перевешивает левая чаша, то фальшивая — монета 8. Классический алгоритм можно реализовать вне зависимости от обще - го числа монет N и количества фальшивых монет k. В целом временная сложность для обобщенной задачи о поддельной монете составляет O(k log(N/k)). ПРИМЕЧАНИЕ Было доказано, что для обнаружения одной фальшивой монеты при помощи лабораторных весов на классическом компьютере нужны ми - нимум две попытки.\n",
      "debug": {
        "start_page": 248,
        "end_page": 301
      }
    },
    {
      "name": "",
      "content": "Глава 7 . Теория игр: преимущество всегда на вашей стороне Рис. 7.1. Решение загадки про фальшивую монету для восьми монет Квантовый способ решения Хотите верьте, хотите нет, но существует квантовый алгоритм, который может найти фальшивую монету за одно квантовое взвешивание вне зависимости от количества монет N! Вообще говоря, для любого количе - ства фальшивых монет k независимо от N временная сложность такого алгоритма составляет O(k1/4). ПРИМЕЧАНИЕ Квантовый алгоритм определения фальшивой монеты является при - мером ускорения четвертой степени по сравнению с его классическим аналогом. Так, на рис. 7.2 показано превосходство квантового алгоритма над клас - сическим аналогом при решении загадки про фальшивую монету. Рас - смотрим его подробнее. Квантовый алгоритм поиска одной фальшивой\n--- Страница 303 ---\nЗагадка про фальшивую монету 303 монеты ( k = 1) можно разделить на три этапа: запрос к квантовым весам, создание квантовых весов и определение фальшивой монеты. Рис. 7.2. Сравнение временной сложности квантового и классического алгоритмов для загадки про фальшивую монету Шаг 1. Запрос к квантовым весам Квантовый алгоритм будет выполнять запрос к квантовым весам в супер - позиции. Чтобы сделать это, используем бинарную строку запроса для кодирования монет на чашах весов. Например, строка запроса 11101111 означает, что на весах лежат все монеты, кроме монеты с индексом 3. Весы уравновешены, если нет ни одной фальшивой монеты, и наклонены в ином случае. Это проиллюстрировано в следующей таблице. Количество монет N Индекс фальшивой монеты FСтрока запросаРезультат 8 3 11101111 Весы уравновешены (0) 8 3 11111111 Весы наклонены (1) Алгоритм действий следующий. 1. Использовать два квантовых регистра для запроса к квантовым весам, где первый регистр предназначен для строки запроса, а второй — для результата.\n--- Страница 304 ---\n304 Глава 7 . Теория игр: преимущество всегда на вашей стороне 2. Подготовить суперпозицию всех бинарных строк запроса с четным количеством единиц. 3. Для получения суперпозиции состояний с четным количеством единиц выполнить преобразование Адамара в базисном состоянии и прове - рить, является ли вес Хэмминга для | x| четным. Может быть показано, что вес Хэмминга для | x| является четным тогда и только тогда, когда x1 ⊕ x2 ⊕ … ⊕ xN = 0. ПРИМЕЧАНИЕ Вес Хэмминга (hw) строки — это количество символов, отличных от нулевого символа используемого алфавита. Например, hw(11101) = 4, hw(11101000) = 4, hw(000000) = 0. 4. Наконец, измерить второй регистр. Если наблюдается состояние , то первый регистр является суперпозицией всех желаемых бинарных строк запроса. Если получено , то нужно повторять процедуру, пока не будет наблюдаться состояние . Обратите внимание, что при каждом повторе вероятность успеха состав - ляет точно 0,5. Однако после нескольких повторов мы сможем получить желаемую суперпозицию состояний. В листинге 7.1 показана реализация квантовой программы для запроса к весам, а соответствующая графиче - ская схема приведена на рис. 7.3. ПРИМЕЧАНИЕ Для упрощения восприятия программа определения фальшивой мо - неты разбита на листинги 7.1–7.3. Хотя я рассчитываю, что вы сможете объединить эти листинги для запуска программы, полный код есть в ис- ходниках в файле Workspace\\Ch07\\p_counterfeitcoin.py.\n--- Страница 305 ---\nЗагадка про фальшивую монету 305 Листинг 7.1. Скрипт запроса к квантовым весам # ------- Запрос к квантовым весам Q_program = QuantumProgram() Q_program.set_api(Qconfig.APItoken, Qconfig.config[\"url\"]) # Создание numberOfCoins +1 квантовых/классических регистров # Один дополнительный кубит для запоминания результата # квантовых весов qr = Q_program.create_quantum_register(\"qr\", numberOfCoins + 1) # для запоминания измерения на qr cr = Q_program.create_classical_register(\"cr\", numberOfCoins + 1) circuitName = \"QueryStateCircuit\" circuit = Q_program.create_circuit(circuitName, [qr], [cr]) N = numberOfCoins # Создание равновзвешенной суперпозиции всех строк длиной N for i in range(N): circuit.h(qr[i]) # Выполнение XOR(x) с последовательным применением вентилей CNOT с qr[0] # по qr[N–1] и сохранением результата в qr[N] for i in range(N): circuit.cx(qr[i], qr[N]) # Измерение qr[N] и сохранение результата в cr[N]. продолжить, # если cr[N] равен нулю, в противном случае повторить измерение circuit.measure(qr[N], cr[N]) # Сделать запрос к квантовым весам, если значение нулевое для всех # cr[0] cr[N], подготовив состояние вентиля Адамара |1>, # то есть |0> - |1> в qr[N] circuit.x(qr[N]).c_if(cr, 0) circuit.h(qr[N]).c_if(cr, 0) # повторить заново вычисление при ненулевом cr[N] for i in range(N): circuit.h(qr[i]).c_if(cr, 2**N ) На рис. 7.3 приведена полная схема для загадки о фальшивой монете с во- семью монетами и одной фальшивой с индексом 6. На ней показаны все описанные здесь этапы для платформы IBM Q Experience. Второй этап алгоритма — создание весов.\n--- Страница 306 ---\n306 Глава 7 . Теория игр: преимущество всегда на вашей стороне Рис. 7.3. Квантовая схема для загадки про фальшивую монету с N = 8, k = 1 и фальшивой монетой с индексом 6 (этот граф в полную величину можно найти на странице загрузки исходного кода)\n--- Страница 307 ---\nЗагадка про фальшивую монету 307 Шаг 2. Создание квантовых весов В предыдущем разделе мы создали суперпозицию всех бинарных строк запроса, у которых вес Хэмминга четный. На данном шаге создаем кванто - вый балансир, устанавливая позицию фальшивой монеты. Таким образом, если k — позиция фальшивой монеты относительно бинарной строки , то квантовые весы вернут: . Это реализовано с помощью вентиля CNOT с xk в качестве управляющего кубита и второго регистра в качестве целевого (см. листинг 7.2). Листинг 7.2. Создание квантовых весов #----- Создать квантовые весы k = indexOfFalseCoin # Применить квантовые весы к желаемой суперпозиции состояний # (помеченной как cr, равное нулю) circuit.cx(qr[k], qr[N]).c_if(cr, 0) Шаг 3. Определение фальшивой монеты Чтобы выявить фальшивую монету после запроса к весам, примените пре - образование Адамара к бинарной строке запроса. Предполагается, что мы делаем запрос к квантовым весам с бинарными строками с четным весом Хэмминга, поэтому, выполнив измерение в вычислительном базисе по - сле преобразования Адамара, можем определить фальшивую монету, так как только ее метка отличается от меток большинства (см. листинг 7.3). Листинг 7.3. Определение фальшивой монеты # --- Определение фальшивой монеты # Применение преобразования Адамара к qr[0] qr[N-1] for i in range(N): circuit.h(qr[i]).c_if(cr, 0) # Измерение qr[0] qr[N–1] for i in range(N): circuit.measure(qr[i], cr[i])\n--- Страница 308 ---\n308 Глава 7 . Теория игр: преимущество всегда на вашей стороне results = Q_program.execute([circuitName], backend=backend, shots=shots) answer = results.get_counts(circuitName) print(\"Device \" + backend + \" counts \" + str(answer)) # Получение наиболее часто встречающейся метки for key in answer.keys(): normalFlag, _ = Counter(key[1:]).most_common(1)[0] for i in range(2,len(key)): if key[i] != normalFlag: print(\"False co in index is: \", len(key) - i - 1) Когда крайний слева бит равен 0, индекс фальшивой монеты можно определить, если найти ту, чей вес отличается от веса остальных. Напри - мер, при N = 8 и индексе фальшивой монеты 6 результат должен быть 010111111 или 001000000. Обратите внимание на то, что, поскольку мы используем cr[N] для управления операцией до начала и после запроса к весам: если крайний слева бит равен 0, то мы успешно определили фальшивую монету; если крайний слева бит равен 1, то мы не получили желаемой суперпо - зиции и должны повторить процесс сначала. При запуске программы на удаленном моделирующем устройстве IBM Q Experience будет получен результат, приведенный в исходниках книги Workspace\\Ch07\\p_counterfeitcoin.py . Обратите внимание, что я использую Windows: c:\\python36-64\\python.exe p_counterfeitcoin.py Device ibmq_qasm_simulator counts {'001000000': 1} False coin index is: 6 Если у вас нет доступа к исходникам книги, но вы все равно хотите по - экспериментировать с этим скриптом, то поместите отрывки кода из предыдущих разделов в скрипт-контейнер из листинга 7.4 (проверьте отступы, эта особенность синтаксиса Python просто сводит с ума). Листинг 7.4. Основной скрипт-контейнер для загадки про фальшивую монету import sys import matplotlib.pyplot as plt import numpy as np\n--- Страница 309 ---\nЗагадка про фальшивую монету 309 from math import pi, cos, acos, sqrt from collections import Counter from qiskit import QuantumProgram sys.path.append(' /Config/') import Qconfig # Импорт основных средств для вывода графики import basic plot tools from qiskit.tools.visualization import plot_histogram def main(M = 16, numberOfCoins = 8 , indexOfFalseCoin = 6 , backend = \"local_qasm_simulator\" , shots = 1 ): if numberOfCoins < 4 or numberOfCoins >= M: raise Exception(\"Please use numberOfCoins between 4 and \", M-1) if indexOfFalseCoin < 0 or indexOfFalseCoin >= numberOfCoins: raise Exception(\"indexOfFalseCoin must be between 0 and \", numberOfCoins-1) // Вставьте листинги 7.1–7.3 сюда ################################################# # main ################################################# if __name__ == '__main__': M = 8 # Максимальное количество доступных кубитов numberOfCoins = 4 # До M-1, где M — количество доступных кубитов indexOfFalseCoin = 2 # Должен быть 0, 1 numberOfCoins — 1 backend = \"ibmq_qasm_simulator\" #backend = \"ibmqx3\" shots = 1 # Мы проводим эксперимент с одним запуском main(M, numberOfCoins, indexOfFalseCoin, backend, shots) Обобщенный алгоритм для любого количества фальшивых монет Для загадки про фальшивую монету математики Терхал и Смолин в 1998 году создали обобщенный алгоритм для любого количества фаль - шивых монет ( k > 1). В их реализации используется модель «Б-оракул» («балансный оракул»), при этом: на вход поступает N бит x = x1x2…xn ∈ {0, 1}N; создается строка запроса, состоящая из N троек таких битов, что q = q1q2…qn Є {0, 1, −1}N, с одинаковым количеством 1 и –1;\n--- Страница 310 ---\n310 Глава 7 . Теория игр: преимущество всегда на вашей стороне ответом является один такой бит, что ПРИМЕЧАНИЕ Оракул является частью алгоритма, рассматриваемой как черный ящик. Он используется для упрощения схем и сравнения сложности квантовых и классических алгоритмов. Хороший оракул должен быть быстрым, универсальным и легко реализуемым. Пример применения Б-оракула для двух фальшивых монет с k = 2 и N = 6 приведен на рис. 7.4. Рис. 7.4. Модель Б-оракула для k = 2 и N = 6 В общем, загадка о фальшивой монете — типичный пример ускорения квантового алгоритма по сравнению с классическим аналогом. В следу - ющем разделе рассмотрим еще одну своеобразную псевдомагическую головоломку под названием «магический квадрат Мермина — Переса». Магический квадрат Мермина — Переса Это еще одна классическая загадка, впервые предложенная физиками Д. Мермином и А. Пересом в качестве примера квантовой псевдотеле - патии, или способности двух игроков общаться сверхъестественным об -\n--- Страница 311 ---\nМагический квадрат Мермина — Переса 311 разом незаметно для наблюдателей. Это возможно благодаря волшебству запутывания. Рассмотрим ее подробнее. Два игрока, Алиса и Боб, ведут игру против арбитра. Магический ква - драт — это матрица размерностью 3 × 3 со следующими правилами (рис. 7.5). Все элементы представлены либо 0, либо 1, так что сумма элементов в каждой строке четная, а в каждом столбце — нечетная. Игра называ - ется магическим квадратом, потому что подобный квадрат невозмо - жен. Как показано на рис. 7.5, не существует верной комбинации, где сумма строк четная, а столбцов — нечетная (возьмите бумагу и ручку и проверьте сами). Это обусловлено нечетным количеством элементов в матрице. Арбитр отправляет целое число a ∈ {1, 2, 3} Алисе, а b ∈ {1, 2, 3} — Бобу. Ответом Алисы должна быть a-я строка квадрата, ответом Боба — b-й столбец. Алиса и Боб выигрывают, если сумма элементов Алисы четная, а Боба — нечетная и в пересечении их ответов находятся одинаковые значения. В противном случае побеждает арбитр. Перед стартом Алиса и Боб могут разработать стратегию и обменяться информацией. Например, могут решить давать ответы при помощи матрицы, приведенной на рис. 7.5. Однако им не разрешается общаться во время игры. Рис. 7.5. Магический квадрат Мермина — Переса\n--- Страница 312 ---\n312 Глава 7 . Теория игр: преимущество всегда на вашей стороне К примеру, в приведенной ранее матрице, если бы арбитр отправил a = 1 Алисе и b = 2 — Бобу, ответом Алисы было бы 110 (первая строка), а Боба — 100 (второй столбец). Элементы, находящиеся на пересечении ответов (первой строки и второго столбца), одни и те же (1), поэтому Алиса и Боб выигрывают. Можно показать, что в классическом варианте максимальная вероятность победы для Алисы и Боба состав ляет 8/9. То есть в данном квадрате восемь из девяти перестановок являются выигрышными. Поэтому максимальная вероятность победы Алисы и Боба — 88,8 %. Протестируем это утверждение на простом примере, чтобы доказать, что максимальная вероятность выигрыша для классической версии магиче - ского квадрата действительно составляет 8/9 (88,88 %). Упражнение для магического квадрата Мермина — Переса 1. Создайте магический квадрат, аналогичный приведенному на рис. 7.5, используя бинарный код (1, –1) вместо (1, 0), где произведение эле - ментов строки 1 (четное), а произведение элементов столбца — –1 (не - четное). Подтвердите, что это фактически невозможно. 2. Создайте таблицу перестановок для значений a и b арбитра при помощи квадрата из первого шага, включающую: •номер перестановки; •значения для a и b; •ответы Алисы и Боба; •значения на пересечении ответов Алисы и Боба (помните, они должны быть одинаковыми, чтобы Алиса и Боб победили); •результат итерации игры: Win = W (победа), Loose = L (пораже - ние). 3. Наконец, рассчитайте вероятность победы и докажите, что максимально она составляет 8/9. ( Примечание: ответ приведен в конце главы. )\n--- Страница 313 ---\nМагический квадрат Мермина — Переса 313 Квантовая стратегия победы Благодаря мощи квантовой механики и магии запутывания результаты Алисы и Боба можно значительно улучшить. Фактически они могут вы - игрывать в 100 % случаев, как если бы общались телепатически (отсюда и термин «псевдотелепатия»). Квантовая стратегия победы впервые была предложена Брассардом и его коллегами, она подразделяется на три этапа. 1. Общее запутанное состояние . Это ключ к победам Алисы и Боба в 100 % случаев. 2. Унитарные преобразования входных данных Алисы и Боба. Так создаются ответы, которые отправляются арбитру. 3. Измерения в вычислительном базисе . Конечный этап создания оконча - тельного ответа. Общее запутанное состояние В квантовой стратегии победы у Алисы и Боба общее запутанное со - стояние: . Для реализации схемы требуются два кубита для Алисы и два кубита для Боба (рис. 7.6). Рис. 7.6. Запутанное состояние для магического квадрата\n--- Страница 314 ---\n314 Глава 7 . Теория игр: преимущество всегда на вашей стороне Известно, что преобразование Адамара сопоставляет базисному со - стоянию: . Применение данного преобразования к первым двум кубитам дает: . Затем к первым двум кубитам применяется вентиль Z. Помните, что он оставляет нулевое состояние неизменным и переводит 1 в –1, меняя на противоположный знак при третьем члене в приведенном ранее вы - ражении. На данном этапе состояние принимает вид: . Затем для запутывания кубитов 0–2 и 1–3 применяется вентиль CNOT: . Наконец, состояния двух последних кубитов меняются на противопо - ложные: . Скрипт Python для создания запутанного состояния приведен в листин - ге 7.5. Листинг 7.5. Квантовая стратегия победы, запутанное состояние # Создание запутанного состояния Q_program = QuantumProgram() Q_program.set_api(Qconfig.APItoken, Qconfig.config[\"url\"]) # Четыре кубита (Alice = 2, Bob = 2) N = 4 # Создание регистров qr = Q_program.create_quantum_register(\"qr\", N) # для запоминания результата измерения на qr cr = Q_program.create_classical_register(\"cr\", N)\n--- Страница 315 ---\nМагический квадрат Мермина — Переса 315 circuitName = \"sharedEntangled\" sharedEntangled = Q_program.create_circuit(circuitName, [qr], [cr]) # Создание равновзвешенной суперпозиции всех строк длиной 2 for i in range(2): sharedEntangled.h(qr[i]) # Амплитуда отрицательная, если количество единиц нечетное for i in range(2): sharedEntangled.z(qr[i]) # Копирование содержимого первых двух кубитов в последние два кубита for i in range(2): sharedEntangled.cx(qr[i], qr[i+2]) # Изменение состояния последних двух кубитов на противоположное for i in range(2,4): sharedEntangled.x(qr[i]) Теперь, когда у Алисы и Боба есть общее запутанное состояние, они могут начать игру и получить входные данные от арбитра. Унитарные преобразования Получив свои входные данные a ∈ {1, 2, 3} и b ∈ {1, 2, 3}, Алиса и Боб при - меняют к общим запутанным состояниям следующие унитарные преоб - разования: A1, A2, A3 для Алисы и B1, B2, B3 — для Боба1. 1 Применяют только одно из них соответственно полученному от арбитра номеру. — Примеч. науч. ред.\n--- Страница 316 ---\n316 Глава 7 . Теория игр: преимущество всегда на вашей стороне ПРИМЕЧАНИЕ Обратите внимание, что, применив приведенные ранее преобразования к своим запутанным состояниям, Алиса и Боб смогут создать первые два бита соответствующих ответов арбитру. В листинге 7.6 показаны унитарные преобразования для Алисы и Боба, а соответствующие им графические схемы приведены в табл. 7.1. Листинг 7.6. Унитарные преобразования для Алисы и Боба #------ Схемы для операций, производимых Алисой и Бобом. # Сначала определяем управляемые U-вентили, необходимые # для назначения фаз from math import pi def ch(qProg, a, b): \"\"\" Controlled-Hadamard gate \"\"\" qProg.h(b) qProg.sdg(b) qProg.cx(a, b) qProg.h(b) qProg.t(b) qProg.cx(a, b) qProg.t(b) qProg.h(b) qProg.s(b) qProg.x(b) qProg.s(a) return qProg def cu1pi2(qProg, c, t): \"\"\" Controlled-u1(phi/2) gate \"\"\" qProg.u1(pi/4.0, c) qProg.cx(c, t) qProg.u1(-pi/4.0, t) qProg.cx(c, t) qProg.u1(pi/4.0, t) return qProg def cu3pi2(qProg, c, t): \"\"\" Controlled-u3(pi/2, -pi/2, pi/2) gate \"\"\" qProg.u1(pi/2.0, t) qProg.cx(c, t) qProg.u3(-pi/4.0, 0, 0, t) qProg.cx(c, t) qProg.u3(pi/4.0, -pi/2.0, 0, t) return qProg\n--- Страница 317 ---\nМагический квадрат Мермина — Переса 317 #---------------------------------------------------------------------- # Определение схем, которые Алиса и Боб используют # для всех своих входных данных: 1, 2, 3 # Словарь для операций и схем Алисы aliceCircuits = {} # Квантовые схемы для входных данных Алисы 1, 2, 3 for idx in range(1, 4): circuitName = \"Alice\"+str(idx) aliceCircuits[circuitName] = Q_program.create_circuit(circuitName, [qr], [cr]) theCircuit = aliceCircuits[circuitName] if idx == 1: # Схема для A_1 theCircuit.x(qr[1]) theCircuit.cx(qr[1], qr[0]) theCircuit = cu1pi2(theCircuit, qr[1], qr[0]) theCircuit.x(qr[0]) theCircuit.x(qr[1]) theCircuit = cu1pi2(theCircuit, qr[0], qr[1]) theCircuit.x(qr[0]) theCircuit = cu1pi2(theCircuit, qr[0], qr[1]) theCircuit = cu3pi2(theCircuit, qr[0], qr[1]) theCircuit.x(qr[0]) theCircuit = ch(theCircuit, qr[0], qr[1]) theCircuit.x(qr[0]) theCircuit.x(qr[1]) theCircuit.cx(qr[1], qr[0]) theCircuit.x(qr[1]) elif idx == 2: theCircuit.x(qr[0]) theCircuit.x(qr[1]) theCircuit = cu1pi2(theCircuit, qr[0], qr[1]) theCircuit.x(qr[0]) theCircuit.x(qr[1]) theCircuit = cu1pi2(theCircuit, qr[0], qr[1]) theCircuit.x(qr[0]) theCircuit.h(qr[0]) theCircuit.h(qr[1]) elif idx == 3: theCircuit.cz(qr[0], qr[1]) theCircuit.swap(qr[0], qr[1]) # Не поддерживается в composer theCircuit.h(qr[0]) theCircuit.h(qr[1]) theCircuit.x(qr[0]) theCircuit.x(qr[1]) theCircuit.cz(qr[0], qr[1]) theCircuit.x(qr[0]) theCircuit.x(qr[1])\n--- Страница 318 ---\n318 Глава 7 . Теория игр: преимущество всегда на вашей стороне # Измерение первых двух кубитов в вычислительном базисе theCircuit.measure(qr[0], cr[0]) theCircuit.measure(qr[1], cr[1]) # Словарь для операций и схем Боба bobCircuits = {} # Квантовые схемы для Боба при получении входных данных 1, 2, 3 for idx in range(1,4): circuitName = \"Bob\"+str(idx) bobCircuits[circuitName] = Q_program.create_circuit(circuitName, [qr], [cr]) theCircuit = bobCircuits[circuitName] if idx == 1: theCircuit.x(qr[2]) theCircuit.x(qr[3]) theCircuit.cz(qr[2], qr[3]) theCircuit.x(qr[3]) theCircuit.u1(pi/2.0, qr[2]) theCircuit.x(qr[2]) theCircuit.z(qr[2]) theCircuit.cx(qr[2], qr[3]) theCircuit.cx(qr[3], qr[2]) theCircuit.h(qr[2]) theCircuit.h(qr[3]) theCircuit.x(qr[3]) theCircuit = cu1pi2(theCircuit, qr[2], qr[3]) theCircuit.x(qr[2]) theCircuit.cz(qr[2], qr[3]) theCircuit.x(qr[2]) theCircuit.x(qr[3]) elif idx == 2: theCircuit.x(qr[2]) theCircuit.x(qr[3]) theCircuit.cz(qr[2], qr[3]) theCircuit.x(qr[3]) theCircuit.u1(pi/2.0, qr[3]) theCircuit.cx(qr[2], qr[3]) theCircuit.h(qr[2]) theCircuit.h(qr[3]) elif idx == 3: theCircuit.cx(qr[3], qr[2]) theCircuit.x(qr[3]) theCircuit.h(qr[3]) # Измерение 3-го и 4-го кубитов в вычислительном базисе theCircuit.measure(qr[2], cr[2]) theCircuit.measure(qr[3], cr[3]) В табл. 7.1 показаны квантовые схемы для унитарных преобразований A1–2 и B1–3 для IBM Q Experience Composer.\n--- Страница 319 ---\nМагический квадрат Мермина — Переса 319Таблица 7.1. Квантовые схемы для унитарных преобразований из листинга 7.6 Преобразование Схема Продолжение \n--- Страница 320 ---\n320 Глава 7 . Теория игр: преимущество всегда на вашей сторонеПреобразование Схема Таблица 7.1 (продолжение)\n--- Страница 321 ---\nМагический квадрат Мермина — Переса 321 Обратите внимание, что в табл. 7.1 не включено преобразование A3 ввиду того, что Composer не поддерживает вентиль SWAP, который необходим для кода из листинга 7.6. Тем не менее это не значит, что квантовую программу нельзя запустить на моделирующем или реальном устройстве. Это просто означает, что схема не будет создана в Composer. Поэтому на последнем шаге Алиса и Боб измеряют свои кубиты в вы- числительном базисе. Измерение в вычислительном базисе После измерения у Алисы и Боба есть по два бита, которые представляют результаты измерений. Чтобы получить последний бит и, таким образом, окончательный ответ, они применяют свои правила проверки четности. То есть у Алисы сумма должна быть четной, а у Боба — нечетной, напри - мер для a = 2, для b = 3 (табл. 7.2): Таблица 7.2. Перестановки ответов для магического квадрата при a = 2, b = 3 ψ Ответ Алисы Ответ Боба Квадрат 000 001 000 100 011 010 011 111 Продолжение \n--- Страница 322 ---\n322 Глава 7 . Теория игр: преимущество всегда на вашей стороне ψ Ответ Алисы Ответ Боба Квадрат 101 010 101 111 110 001 110 101 В листинге 7.7 показан фрагмент скрипта для прохода в цикле по всем раундам магического квадрата. Проход в цикле по a[1, 3] и b[1, 3] включительно. Для каждых ( a, b) схемы Алисы (Alice-a) и Боба (Bob-b) возвращаются в исходное состояние из листинга 7.6. Общее запутанное состояние ψ и схемы Алисы и Боба загружаются для запуска на моделирующее или реальное квантовое устройство. Для Алисы и Боба из ответа извлекается по два бита, например {'0011': 1}. Применение правил проверки четности: у Алисы сумма должна быть четной, а у Боба — нечетной. В конце ответ проверяется на корректность и отображается вероят - ность победы. Листинг 7.7. Скрипт для всех раунд ов магического квадрата def all_rounds(backend, real_dev, shots=10): nWins = 0 nLost = 0 for a in range(1,4): for b in range(1,4):Таблица 7.2 (продолжение)\n--- Страница 323 ---\nМагический квадрат Мермина — Переса 323 print(\"Asking Alice and Bob with a and b are: \", a,b) rWins = 0 rLost = 0 aliceCircuit = aliceCircuits[\"Alice\" + str(a)] bobCircuit = bobCircuits[\"Bob\" + str(b)] circuitName = \"Alice\" + str(a) + \"Bob\"+str(b) Q_program.add_circuit(circuitName, sharedEntangled+aliceCircuit+ bobCircuit) if real_dev: ibmqx2_backend = Q_program.get_backend_ configuration(backend) ibmqx2_coupling = ibmqx2_backend['coupling_map'] results = Q_program.execute([circuitName], backend=backend, shots=shots , coupling_map=ibmqx2_coupling, max_credits=3, wait=10, timeout=240) else: results = Q_program.execute([circuitName], backend=backend, shots=shots) answer = results.get_counts(circuitName) for key in answer.keys(): kfreq = answer[key] # Частоты появления ключей, полученные при измерениях aliceAnswer = [int(key[-1]), int(key[-2])] bobAnswer = [int(key[-3]), int(key[-4])] if sum(aliceAnswer) % 2 == 0: aliceAnswer.append(0) else: aliceAnswer.append(1) if sum(bobAnswer) % 2 == 1: bobAnswer.append(0) else: bobAnswer.append(1) if(aliceAnswer[b-1] != bobAnswer[a-1]): #print(a, b, \"Alice and Bob lost\") nLost += kfreq rLost += kfreq else: #print(a, b, \"Alice and Bob won\") nWins += kfreq rWins += kfreq print(\"\\t#wins = \", rWins, \"out of \", shots, \"shots\") print(\"Number of Games = \", nWins+nLost) print(\"Number of Wins = \", nWins) print(\"Winning probabilities = \", (nWins*100.0)/(nWins+nLost))\n--- Страница 324 ---\n324 Глава 7 . Теория игр: преимущество всегда на вашей стороне ################################################# # main ################################################# if __name__ == '__main__': backend = \"ibmq_qasm_simulator\" #backend = \"ibmqx2\" real_dev = False all_rounds(backend, real_dev) Запуск листинга 7.7 на удаленном моделирующем устройстве IBM Q Ex- perience показан в листинге 7.8. Листинг 7.8. Упрощенный стандартный вывод для запуска всех раундов магического квадрата c:\\python36-64\\python.exe p_magicsq.py For a = 1, b = 1 ibmq_qasm_simulator answer: 1000 Alice: [0, 0, 0] Bob:[0, 1, 0] ibmq_qasm_simulator answer: 1010 Alice: [0, 1, 1] Bob:[0, 1, 0] ibmq_qasm_simulator answer: 1111 Alice: [1, 1, 0] Bob:[1, 1, 1] ibmq_qasm_simulator answer: 0111 Alice: [1, 1, 0] Bob:[1, 0, 0] ibmq_qasm_simulator answer: 0000 Alice: [0, 0, 0] Bob:[0, 0, 1] ibmq_qasm_simulator answer: 0101 Alice: [1, 0, 1] Bob:[1, 0, 0] # 10 побед при 10 запусках For a = 1, b = 2 ibmq_qasm_simulator answer: 1000 Alice: [0, 0, 0] Bob:[0, 1, 0] ibmq_qasm_simulator answer: 1001 Alice: [1, 0, 1] Bob:[0, 1, 0] ibmq_qasm_simulator answer: 1111 Alice: [1, 1, 0] Bob:[1, 1, 1] ibmq_qasm_simulator answer: 0110 Alice: [0, 1, 1] Bob:[1, 0, 0] ibmq_qasm_simulator answer: 0000 Alice: [0, 0, 0] Bob:[0, 0, 1] ibmq_qasm_simulator answer: 0001 Alice: [1, 0, 1] Bob:[0, 0, 1] # 10 побед при 10 запусках For a = 3, b = 3 ibmq_qasm_simulator answer: 1000 Alice: [0, 0, 0] Bob:[0, 1, 0] ibmq_qasm_simulator answer: 1011 Alice: [1, 1, 0] Bob:[0, 1, 0] ibmq_qasm_simulator answer: 1101 Alice: [1, 0, 1] Bob:[1, 1, 1] ibmq_qasm_simulator answer: 1110 Alice: [0, 1, 1] Bob:[1, 1, 1] ibmq_qasm_simulator answer: 0111 Alice: [1, 1, 0] Bob:[1, 0, 0] ibmq_qasm_simulator answer: 0010 Alice: [0, 1, 1] Bob:[0, 0, 1] # 10 побед при 10 запусках Number of Games = 90 Number of Wins = 90 Winning probability = 100.0 ПРИМЕЧАНИЕ При запуске на реальном устройстве вероятность выигрыша не будет 100%-ной из-за шумов окружающей среды и ошибок вентилей .\n--- Страница 325 ---\nМагический квадрат Мермина — Переса 325 Ответы для упражнения с магическим квадратом 1. Магический квадрат, в котором произведение строки четное, а про- изведение столбца — нечетное, приведен далее. На самом деле такого квадрата не бывает ввиду нечетного числа клеток. 2. Таблица перестановок для квадрата из первого ответа. N a b Алиса Боб Пересечение Победа/ поражение (W/L) 1 1 1 –1, –1, 1 –1, –1, –1 –1/–1 W 2 1 2 –1, –1, 1 –1, 1, 1 –1/–1 W 3 1 3 –1, –1, 1 1, –1, ? (1) 1/1 W 4 2 1 –1, 1, –1 –1, –1, –1 –1/–1 W 5 2 2 –1, 1, –1 –1, 1, 1 1/1 W 6 2 3 –1, 1, –1 1, –1, ? (1) –1/–1 W 7 3 1 –1, 1, ? (–1) –1, –1, –1 –1/–1 W 8 3 2 –1, 1, ? (–1) –1, 1, 1 1/1 W 9 3 3 –1, 1, ? (–1) 1, –1, ? (1) –1/1 L 3. Обратите внимание, что на предыдущем шаге в строках 7–9 ответ Алисы должен быть –1, поэтому произведение может быть четным (1). К тому же в столбцах 3, 6 и 9 ответ Боба должен быть 1, в связи с чем произведение может быть нечетным ( −1). Наконец, вероятность рас - считывается делением общего числа побед на общее количество пере - становок. Таким образом: . Из этой главы вы узнали, как квантовая запутанность может обеспечить значительное ускорение по сравнению с классическими вычислениями. Для квантовых весов можно добиться ускорения четвертой степени при\n--- Страница 326 ---\n326 Глава 7 . Теория игр: преимущество всегда на вашей стороне решении классических головоломок, таких как загадка про фальшивую монету. В других, таких как магический квадрат, запутывание наделяет игроков псевдомагической телепатией. Если бы Брассард и его коллеги смогли придумать квантовую стратегию выигрыша в блек-джек или покер, мы бы точно сорвали большой куш в Вегасе. В целом эта глава показала, что квантовая механика столь же запутанная, причудливая и увлекательная, как и всегда. Она никогда не разочаровывает. В следующей, последней главе рассказывается о самом, пожалуй, из - вестном квантовом алгоритме — пресловутой факторизации целых чисел Шора. Это алгоритм, который может нанести сокрушительный удар по асимметричному шифрованию!\n--- Страница 327 ---\n8Алгоритмы Гровера и Шора: ускоренный поиск и угроза основам асимметричного шифрования В этой главе мы завершим свои изыскания рассмотрением двух алгорит - мов, которые вызвали волнение по поводу возможностей практических квантовых вычислений. Алгоритм поиска Гровера . Это неструктурированный алгоритм кванто - вого поиска, созданный Ловом Гровером. Он способен с высокой веро - ятностью определять входные данные с помощью функции — черного ящика или оракула. Алгоритм позволяет найти элемент за шагов, тогда как среднее значение для классического аналога — N / 2 шагов. Алгоритм факторизации целых чисел Шора . Печально известная кван - товая факторизация, которая, по словам экспертов, сможет поставить на колени современное асимметричное шифрование. По алгоритму Шора целые числа можно факторизовать приблизительно за log( n3) шагов, в отличие от наиболее быстрого классического алгоритма — метода решета числового поля, которому требуется шагов. Давайте начнем.\n",
      "debug": {
        "start_page":302,
        "end_page":327
      }
    },
    {
      "name": "Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Квантовый неструктурированный поиск",
      "content": "--- Страница 328 ---\n328 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Квантовый неструктурированный поиск Алгоритм Гровера — это неструктурированная процедура квантового поиска, предназначенная для нахождения строки из n бит в числовом «стоге сена» из N элементов. Как показано на рис. 8.1, квантовый алгоритм Гровера дает значительное ускорение шагов. Может показаться, что это не так уж и много в сравнении с классическим решением, но, когда речь идет о миллионах строк, квадратный корень из 106 намного меньше, чем 106. Рис. 8.1. Временная сложность неструктурированного поиска Если x — элемент, который мы ищем, то алгоритм Гровера можно описать с помощью следующего псевдокода. 1. Подготовка входных данных при заданной функции (оракула) f: {0, 1… N – 1} → {0, 1}. Обратите внимание, что размер ввода равен 2n, где n — это количество битов, а N — количество шагов, или размер «стога сена». Конечная цель состоит в том, чтобы найти x, при котором f(x) = 1. 2. Приведение всех входных кубитов в состояние суперпозиции. 3. Выполнение инверсии фаз на входных кубитах. 4. Выполнение инверсии относительно среднего значения на входе. 5. Повторение шагов 3 и 4 минимум раз. Существует большая вероят - ность того, что x будет найден на этой стадии.\n--- Страница 329 ---\nКвантовый неструктурированный поиск 329 Давайте внимательнее рассмотрим критические шаги фазовой инверсии и инверсии относительно среднего значения. Фазовая инверсия Это первый шаг в алгоритме, и он должен выполняться в суперпозиции всех состояний в «стоге сена». Если искомый элемент равен x′, где f (x′) = 1, то суперпозицию можно выразить как . В конечном счете фазовая инверсия выполняет следующее: То есть если данный x не является искомым элементом ( x ≠ x′), то он остав - ляет суперпозицию без изменений. В противном случае он инвертирует фазу (знак «минус» перед комплексным коэффициентом αх'|x′〉 кубита, см. графическое представление на рис. 8.2). Рис. 8.2. Графическое представление фазовой инверсии Это первый шаг в алгоритме Гровера: мы увидим, как инверсия фазы помогает найти искомый элемент, но сейчас рассмотрим второй шаг — инверсию относительно среднего значения.\n--- Страница 330 ---\n330 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Инверсия относительно среднего значения С учетом приведенной ранее суперпозиции определяем среднее значение μ как среднее значение амплитуд: . Теперь мы должны зеркально отобразить амплитуды относительно этого среднего значения, то есть: . Чтобы можно было лучше понять это, на рис. 8.3 приведено графическое представление инверсии относительно среднего значения. Рис. 8.3. Графическое представление инверсии относительно среднего значения Здесь показано полученное методом суперпозиции состояние кубитов, которое определяется как волновая функция ψ. Среднее значение μ этой функции на графике представлено горизонтальной линией. Инверсия относительно среднего значения выполняет зеркальное отражение волны (показана пунктирной линией). Это эквивалентно повороту волны от - носительно оси μ. Давайте разберемся во всем этом, объединив все шаги, чтобы увидеть их в действии. На рис. 8.4 показано следующее. Суперпозиция всех кубитов переводит вс е амплитуды в . Затем фазовая инверсия переводит амплитуду для x' в . Обратите внимание, что здесь есть эффект небольшого сни жения среднего значе - ния μ (см. рис. 8.4, шаг 2).\n--- Страница 331 ---\nКвантовый неструктурированный поиск 331 Рис. 8.4. Одна итерация алгоритма Гровера После инверсии относительно среднего значения средняя амплитуда немного уменьшится, но x' так же, как и , поднимется выше среднего значения μ. Если повторить эту последовательность шагов, то амплитуда x' будет увеличиватьс я примерно на , пока после приблизительно шагов не станет равн ой . В этот момент, если мы измерим наши кубиты, вероятность нахождения x' (искомого элемента) согласно принципам квантовой механики равна квадрату амплитуды, что составляет 1/2. Таким образом, все готово. Примерно за шагов мы нашли отмечен - ный элемент x'. Теперь соберем все это в квантовой схеме с соответствующей реализацией в коде. Практическая реализация Рассмотрим схему для алгоритма Гровера в IBM Q Experience. Она демонстрирует одну итерацию алгоритма при помощи двух кубитов (рис. 8.5).\n--- Страница 332 ---\n332 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Рис. 8.5. Квантовая схема для алгоритма Гровера с двумя кубитами и A = 01 Скрипт Python для создания схемы, изображенной на рис. 8.5, дан в ли- стинге 8.1. Листинг 8.1. Скрипт Python для схемы, приведенной на рис. 8.5 import sys,time,math # Импорт QISKit from qiskit import QuantumCircuit, QuantumProgram # Конфигурация Q Experience sys.path.append(' /Config/') import Qconfig # Импорт базовых средств отображения графики from qiskit.tools.visualization import plot_histogram # Установка значений входных битов, которые будут использоваться для поиска def input_phase (circuit, qubits): # Раскомментировать при A = 00 # Закомментировать при A = 11 circuit.s(qubits[0]) #circuit.s(qubits[1]) return # circuit — двухкубитная схема для алгоритма Гровера # qubits — массив кубитов (размером 2) def invert_over_the_mean (circuit, qubits): for i in range (2): circuit.h(qubits[i]) circuit.x(qubits[i]) circuit.h(qubits[1]) circuit.cx(qubits[0], qubits[1]) circuit.h(qubits[1]) for i in range (2): circuit.x(qubits[i]) circuit.h(qubits[i])\n--- Страница 333 ---\nКвантовый неструктурированный поиск 333 def invert_phase (circuit, qubits): # Оракул circuit.h(qubits[1]) circuit.cx(qubits[0], qubits[1]) circuit.h(qubits[1]) def main(): # Настройка квантовой программы qp = QuantumProgram() qp.set_api(Qconfig.APItoken, Qconfig.config[\"url\"]) # Создание кубитов/регистров size = 2 q = qp.create_quantum_register('q', size) c = qp.create_classical_register('c', size) # Квантовая схема grover = qp.create_circuit('grover', [q], [c]) # 1. Перевод всех кубитов в суперпозицию for i in range (size): grover.h(q[i]) # Настройка входных данных input_phase(grover, q) # 2. Фазовая инверсия invert_phase(grover, q) input_phase(grover, q) # 3. Инверсия относительно среднего значения invert_over_the_mean (grover, q) # Измерение for i in range (size): grover.measure(q[i], c[i]) circuits = ['grover'] # Выполнение квантовой схемы на моделирующем устройстве backend = \"local_qasm_simulator\" # Количество запусков эксперимента shots = 1024 result = qp.execute(circuits, b ackend=backend, shots=shots , max_credits=3, timeout=240) counts = result.get_counts(\"grover\") print(\"Counts:\" + str(counts))\n--- Страница 334 ---\n334 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза # Необязательно #plot_histogram(counts) ########################################### # main if __name__ == '__main__': start_time = time.time() main() print(\"--- %s seconds ---\" % (time.time() — start_time)) В листинге 8.1 выполняется одна итерация алгоритма Гровера с двумя битами на входе и использованием двух кубитов. И хотя в предыду - щем разделе утверждается, что общее количество итераций задается приблизительно шагами, для инверсии относительно среднего значения необходимо это число умножить на π/4 и округлить в мень- шую сторону (floor) (см. доказательство на рис. 8.8). Следователь - но, мы получае м , где N = 2bits. Тогда для двух бит . Скрипт начинается с создания квантовой схемы с двумя кубитами и двумя классическими регистрами для хранения результатов изме - рения на них. Затем все кубиты переводятся в суперпозицию при помощи вентиля Адамара. Прежде чем выполнить итерацию, подготавливаются входные данные с использованием фазового вентиля (S) и правил из табл. 8.1. Таблица 8.1. Правила подготовки входных данных для листинга 8.1 Входные данные (А) Вентили/кубиты 00 S(01) 10 S(0) 01 S(1) 11 Ничего Затем выполняется инверсия фаз, а следом за ней — инверсия отно - сительно среднего значения входных кубитов в соответствии с одной итерацией алгоритма.\n--- Страница 335 ---\nКвантовый неструктурированный поиск 335 Наконец, измеряются результаты и схема выполняется на локальном или удаленном моделирующем устройстве. Выводятся полученные численные значения. Обобщенная схема В целом схему, представленную на рис. 8.5, можно обобщить для любого количества входных кубитов (рис. 8.6). Рис. 8.6. Обобщенная форма алгоритма Гровера для произвольного числа кубитов Первый блок на рис. 8.6 переводит все кубиты в суперпозицию при - менением вентиля Адамара к входным данным размера n. Это шаг инициализации. Затем в схему фазовой инверсии (Uf) подаются входные данные в супер - позиции и входные значения фаз (знак «минус»). Это позво - ляет установить желаемую фазу именно там, где нужно. Таким образом, получены выходные данные . Но как можно достичь такого результата? Ответ: желаемый эффект был получен с по- мощью исключающего ИЛИ к входному состоянию со знаком «минус» (рис. 8.7). В третьей строке таблицы истинности для исключающего ИЛИ между f(x) и b (в правой части рис. 8.7) показан эффект применения фазовой инверсии.\n--- Страница 336 ---\n336 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Рис. 8.7. Схема для фазовой инверсии Наконец, как показано на рис. 8.3, инверсия относительно среднего зна - чения — то же самое, что и отражение о тносительно . Для лучшего понимания полученное методо м суперпозиции состояние ψ и среднее значение μ могут быть представлены в виде векторов в двумерном пространстве (см. рис. 8.8). Чтобы отразить ψ, создайте вектор, ортого - нальный к μ, а затем — проекцию ψ в новый квадрант под тем же углом θ. Рис. 8.8. Схема для инверсии относительно среднего значения Доказательство того, что инверсия относительно среднего значения вы - полняет преобразование , состоит из трех этапов, которые приведены на схеме на рис. 8.8.\n--- Страница 337 ---\nКвантовый неструктурированный поиск 337 1. Преобразование в вектор, состоящий из нулей, . Это достига - ется применением вентиля Адамара к входным данным. 2. Отражение относительно вектора из нулей . Это можно сделать, умножив его на разреженную матрицу . 3. Обратное преобразование в еще одним применением вентиля Адамара. Тогда: (8.1) Обратите внимание, что и . Наконец, применение матрицы (8.1) к состо янию дает Таким образом, получен алгоритм Гровера для неструктурированного по - иска. Он быстрый, мощный и скоро будет вовсю использоваться в центрах обработки данных для ускорения любых видов поиска в базах данных.\n--- Страница 338 ---\n338 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Поскольку он значительно производительнее классического собрата, существует вероятность того, что через несколько лет, когда квантовые компьютеры станут более доступными для коммерческого применения, бо'льшая часть поисков в Интернете будет выполняться при помощи этой квантовой рабочей лошадки. Прежде чем мы закончим, стоит отме - тить, что на момент написания книги какой-либо полезной реализации или эксперимента, который может найти что-то реальное, для IBM Q Experience не существует. Надеюсь, это изменится в будущем, но пока алгоритм Гровера хорошо работает в теории. В следующем разделе мы эффектно завершим книгу рассмотрением знаменитого алгоритма Шора для факторизации целых чисел. Факторизация целых чисел при помощи алгоритма Шора Игра в кошки-мышки между криптографией и криптоанализом про - должается: первая разрабатывает новые способы шифрования наших ежедневно создаваемых данных, а второй ищет слабые места, чтобы их взломать. Современное асимметричное шифрование опирается на хорошо известную сложность факторизации очень больших простых чисел (в диа - пазоне сотен цифр). В этом разделе рассматривается внутренняя работа алгоритма Шора — метода, который дает экспоненциальное ускорение для факторизации целых чисел при помощи квантового компьютера. Затем поговорим о реализации с использованием библиотеки под названием ProjectQ. Далее мы смоделируем целочисленные выборки и оценим ре - зультаты. Наконец, рассмотрим текущие и перспективные направления факторизации целых чисел в квантовых системах. Квантовая факторизация бросает вызов асимметричному шифрованию В основополагающей статье Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer Питер Шор предложил ме - тод квантовой факторизации, использующий принцип, давно известный математикам: найти период (также известный как порядок) элемента a\n--- Страница 339 ---\nФакторизация целых чисел при помощи алгоритма Шора 339 в мультипликативной группе по модулю N, то есть такое наименьшее по - ложительное целое число, что: , где N — число, раскладываемое на множители; r — период a по модулю N. ПРИМЕЧАНИЕ Факторизация больших целых чисел — это задача, которая занимала умы математиков на протяжении тысячелетий. В 1976 году Г. Л. Миллер предположил, что с помощью случайных чисел факторизацию можно свести к нахождению периода элемента по модулю N, что значительно упрощает данную задачу. Это основная идея алгоритма Шора. Ученый разделил свой алгоритм на три этапа, два из которых выполняются на классическом компьютере за полиномиальное время. 1. Подготовка входных данных . Выполняется на классическом компьютере за полиномиальное время log( N). 2. Нахождение периода r элемента a, при котором , по- средством квантовой схемы. Согласно Шору, для этого потребуется O((log N)2(log log N)(log log log N)) шагов на квантовом компьютере. 3. Обработка выходных данных . Выполняется на классическом компью - тере за полиномиальное время log( N). Почему этот метод вызывает такую обеспокоенность? Сравните его времен - ную сложность (О) с этим же параметром действующего классического чем - пиона — метода решета числового поля. Данные приведены в табл. 8.2 (вклю - чает еще одного лидера — популярный алгоритм квадратичного решета). Таблица 8.2. Временная сложность популярных алгоритмов факторизации Алгоритм Временная сложность Шора Решета числового поля Квадратичного решета\n--- Страница 340 ---\n340 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Невероятно, но алгоритм Шора имеет полиномиальную временную слож - ность, намного превосходящую экспоненциальное время алгоритма реше - та числового поля — самого быстрого известного метода факторизации на классическом компьютере. На самом деле эксперты подсчитали, что алгоритм Шора может разложить на простые множители целое число, состоящее более чем из 200 цифр, за считаные минуты. Такой прорыв мог бы сотрясти основы современного асимметричного шифрования, которое используется при генерации ключей шифрования для всех на - ших веб-коммуникаций. ПРИМЕЧАНИЕ Симметричное шифрование очень устойчиво к квантовым вычислениям и, следовательно, к алгоритму Шора. Но пока рано паниковать: до практической реализации на реальном квантовом компьютере еще далеко. Тем не менее данный алгоритм мож - но смоделировать в классической системе с помощью ProjectQ — пре - красной библиотеки Python. Мы познакомимся с ее реализацией позже, а в следующем разделе посмотрим, как можно эффективно решить задачу факторизации, определив период. Нахождение периода Нахождение периода является базовым блоком алгоритма Шора. При по- мощи модульной арифметики данная задача может быть сведена к поиску периода (r) функции f(x) = ax mod N (рис. 8.9). На рис. 8.9 приведен пример периодической функции f(x) с периодом r = 4. Чтобы алгоритм был осуществим, f(x) должна отвечать трем условиям. 1. f(x) однозначная для каждого периода, то есть значения f(x) не должны повторяться. На рис. 8.9 данные значения представлены вершинами всех линий за период.\n--- Страница 341 ---\nФакторизация целых чисел при помощи алгоритма Шора 341 Рис. 8.9. Периодическая функция f(x) 2. Для любого количества периодов M период r должен быть делителем. Например, при M = 100 и периоде r = 4 отношение M / r = 25. 3. Результат деления M на r должен быть больше, чем r, то есть M > r2. Алгоритм Шора преобразует f(x) в квантовую схему Uf, где входные кубиты находятся в суперпозиции. Измерив второй регистр1 в Uf, мы можем увидеть значения ампли туд , показанные на графике амплитуд на рис. 8.9. Здесь амплитуд ы отстоят друг от друга на четыре деления, что является искомым периодом. В данном частном случае мы получаем периодические суперпозиции с r = 4. Но что нам делать с ними? Алгоритм Шора использует еще один прием — квантовое пре - образование Фурье. 1 Судя по всему, автор использует такие два регистра: набор входных кубитов и на- бор выходных кубитов (операции могут производиться над обоими). Здесь речь должна идти о том, что при применении f(x) на состояние суперпозиции получается запутанное состояние типа | x1, f(x1)〉 + |x2, f(x2)〉 (как на рисунке), и, если произве - сти измерение над вторым регистром (то есть выходными кубитами), то получим амплитуды, о которых пишет автор. — Примеч. науч. ред.\n--- Страница 342 ---\n342 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Преобразование Фурье Преобразование Фурье — это процесс изменения данных, который до - пускает сдвиги во входных данных без изменения распределения вы - ходных данных. Это хорошо, потому что теперь у нас есть периодическая суперпозиция, где ненулевые амплитуды кратны периоду (рис. 8.10). Рис. 8.10. Преобразование Фурье, показывающее периодическую суперпозицию Но каким будет выходное значение преобразования Фурье? И чем оно нам поможет? Ответ: его выходным значением является случайное число, кратное M / r. В данном случае при M = 100 и r = 4 получаем случайное число, кратное 100 / 4 = 25, что соответствует нашей цели. Посмотрим, как это происходит. Передача результатов преобразования Фурье в алгоритм Евклида для нахождения наибольшего общего делителя После многократного выполнения преобразования Фурье мы получим множество случайных M / r. Например, можем получить 50, 75, 25 и т. д.\n--- Страница 343 ---\nФакторизация целых чисел при помощи алгоритма Шора 343 Теперь, если мы применим к случайным выходным результатам алгоритм Евклида для нахождения наибольшего общего делителя (НОД), то, раз - делив M на НОД, найдем период r. Таким образом: r = M / НОД(50, 75…) = 100 / 25 = 4. Это краткое описание алгоритма нахождения периода с использованием квантовой схемы. Чтобы понять, каким образом с помощью данного метода можно эффективно найти множитель, приведу пример факторизации числа N = 21. Решение задачи основано на двух весьма эффективных операциях: модульной арифметике: a = b(mod N). Например, 3 = 15(mod 12); НОД( a, b). Например, НОД(15, 21) = 3. Тогда при N = 21 нужно решить уравнение x2 ≡ 1(mod 21). А именно найти такой нетривиальный квадратный корень x, что: N является делителем ( x + 1)( x – 1); N не является делителем ( x ± 1). Наконец, восстановить простой множитель, применив НОД( N, x + 1). Чтобы найти нетривиальный множитель для N = 21, выберем случайным образом x. Например, при N = 21 выбираем x = 2, тогда: 20 ≡ 1 (mod 21) 21 ≡ 2 (mod 21) 22 ≡ 4 (mod 21) 23 ≡ 8 (mod 21) 24 ≡ 16 (mod 21) 25 ≡ 11 (mod 21) 26 ≡ 1 (mod 21). Получен период r = 6. В данном случае 26 = (23)2. Значит, 23 = 8 — нетривиальный множитель, при котором 21 является делителем (8 + 1)(8 – 1). Наконец, мы восстанав - ливаем значение множителя с помощью НОД( N, x + 1) = НОД(21, 9) = 3. Вообще говоря, нужно выбрать x случайным образом и затем пройти в ци- кле по x0, x1… xr ≡ mod N. Если нам повезло и r четный, то ( xr/2)2 ≡ 1(mod N). И тогда существует нетривиальный квадратный корень 1 mod N.\n--- Страница 344 ---\n344 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза ПРИМЕЧАНИЕ Было доказано, что вероятность того, что нам повезет и r окажется чет - ным, а x2 ≡ 1 (mod N), равна 1/2. Однако, учитывая высокую вероятность успеха, это незначительно в общем масштабе. Теперь запустим алгоритм, воспользовавшись прекрасной библиотекой Python под названием ProjectQ. Алгоритм Шора с использованием ProjectQ ProjectQ — это платформа с открытым исходным кодом для квантовых вычислений, которая реализует алгоритм Шора при помощи схемы, пред - ложенной Стефаном Борегаром1. В ней применяются 2 n + 3 кубитов, где n — количество битов факторизуемого числа N. Метод Борегара подраз - деляется на следующие шаги. 1. Если N четное, возвращается множитель 2. 2. Классическим способом определяется, выполняется ли N = pq при p ≥ 1 и q ≥ 2, и если да, то возвращается множитель p (на классическом компьютере это можно выполнить за полиномиальное время). 3. Выбирается такое случайное число a, что 1 < a ≤ N – 1. При помощи алгоритма Евклида для нахождения наибольшего общего делителя определяем, верно ли, что НОД( a, N) > 1. Если да, то возвращается множитель НОД( a, N). 4. Для нахождения порядка r для a по модулю N используется квантовая схема. На квантовом компьютере данный шаг выполняется за полино - миальное время. 5. Если r нечетное или r четное, но ar/2 = –1(mod N), то происходит пере - ход к шагу 3. В противном случае вычисляется НОД( ar / 2 – 1, N) или НОД( ar / 2 + 1, N). Выполняется проверка, является ли одно из этих значений нетривиальным множителем N, и если да, то возвращается данный множитель (на классическом компьютере это может быть вы - полнено за полиномиальное время). 1 Beauregard S. Circuit for Shor’s algorithm using 2n+3 qubits. De 'partement de Physique et, Universite ' de Montre 'al.\n--- Страница 345 ---\nФакторизация целых чисел при помощи алгоритма Шора 345 Борегар находит период, выполнив несколько управляемых суммиро - ваний и умножений в пространстве Фурье, чтобы найти решение f(x) = = ax(mod N) → ar ≡ 1 mod N (рис. 8.11). Управляемый умножитель Ua производит отображение , где: •a — это классическое взаимно простое с модулем число, которое используется как основание для ax(mod N); •x — квантовый регистр; •c — регистр таких управляющих кубитов, что Ua = ax(mod N), если c = 1, и x в ином случае. Рис. 8.11. Квантовая схема Борегара для нахождения периода Управляемый умножитель Ua, в свою очередь, реализован как ряд мо - дульных сумматоров с двойным управлением, при которых: •если оба управляющих кубита c1 = c2 = 1, то на выходе . То есть это a + b(mod N) в пространстве Фурье. Обратите внимание, что этот вентиль складывает два числа: взаимно простое с модулем a и квантовое b;\n--- Страница 346 ---\n346 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза •если оба управляющих кубита, c1 и c2, находятся в состоянии , то . Модульный сумматор с двойным управлением построен на основе квантовой суммирующей схемы по Драперу. В данной схеме реализо - вано сложение классического значения ( a) с квантовым значением ( b) в пространстве Фурье. Факторизация с помощью ProjectQ Установим ProjectQ и протестируем алгоритм. В первую очередь восполь - зуемся менеджером пакетов Python для загрузки и установки ProjectQ (для простоты я использую Windows; пользователи Linux должны сле - довать той же процедуре): C:\\> pip install projectq Затем возьмите скрипт shor.py из папки с примерами для ProjectQ или исходников книги ( Workspace\\Ch08\\p08.shor.py ). Запустите его и введите факторизуемое число (листинг 8.2). Листинг 8.2. Алгоритм Шора с ProjectQ в действии C:\\>python shor.py Number to factor: 21 Factoring N = 21: Factors found : 7 * 3 = 21 Gate class counts: AllocateQubitGate : 166 CCR : 1467 CR : 7180 CSwapGate : 50 CXGate : 200 DeallocateQubitGate : 166 HGate : 2600 MeasureGate : 11 R : 608 XGate : 206 Gate counts: Allocate : 166\n--- Страница 347 ---\nФакторизация целых чисел при помощи алгоритма Шора 347 CCR(0.098174770425) : 18 CCR(0.196349540849) : 30 CCR(0.392699081699) : 70 CCR(0.490873852124) : 18 CCR(0.785398163397) : 80 CCR(0.981747704246) : 38 CCR(1.079922474671) : 20 CCR(1.178097245096) : 16 R(5.252350217719) : 1 R(5.301437602932) : 1 R(5.497787143782) : 1 X : 206 Max. width (number of qubits) : 13. --- 5.834410190582275 seconds --- При N = 21 скрипт выдает набор весьма полезных статистических данных, таких как: количество задействованных кубитов . При N = 21 нужно пять кубитов, тогда общее количество кубитов 2 · 5 + 3 = 13; общее количество использованных вентилей по типам . В данном случае с двойным управлением CCR = 1467, CR = 7180, CSwap = 50, CX = 200, R = 608, X = 206 и т. д. до общего количества 12 646 квантовых вен - тилей. В ProjectQ квантовая схема для нахождения периода с помощью алгорит - ма Борегара приведена в листинге 8.3. Функция run_shor принимает три аргумента: •квантовый движок или моделирующее устройство, предоставля - емое ProjectQ; •N — факторизуемое число; •a — взаимно простое с модулем число, которое используется в ка- честве основания для ax mod N. Затем функция проходит в цикле от a = 0 до a = ln (N) с входным кван - товым регистром x в суперпозиции и выполняется квантовая схема для f(a) = ax mod N (рис. 8.11).\n--- Страница 348 ---\n348 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Далее выполняется преобразование Фурье на регистре x, зависящем от предыдущих выходных значений, и производятся измерения. Наконец, измеренные значения суммируются, суммой является число в пределах [0, 1]. Затем выполняется разложение в цепную дробь, чтобы вернуть делитель или возможное значение периода ( r). Листинг 8.3. Квантовая подпрограмма для нахождения периода в ProjectQ def run_shor(eng, N, a): n = int(math.ceil(math.log(N, 2))) x = eng.allocate_qureg(n) X | x[0] measurements = [0] * (2 * n) # будет хранить 2n результатов измерений ctrl_qubit = eng.allocate_qubit() for k in range(2 * n): current_a = pow(a, 1 << (2 * n — 1 — k), N) # Одна итерация QPE с одним кубитом H | ctrl_qubit with Control(eng, ctrl_qubit): MultiplyByConstantModN(current_a, N) | x # Выполнить инверсию QFT --> повороты в зависимости # от предыдущих выходных значений for i in range(k): if measurements[i]: R(-math.pi/(1 << (k – i))) | ctrl_qubit H | ctrl_qubit # и измерить Measure | ctrl_qubit eng.flush() measurements[k] = int(ctrl_qubit) if measurements[k]: X | ctrl_qubit Measure | x # Перевод измеренных значений в числа, лежащие в пределах [0, 1) y = sum([(measurements[2 * n — 1 — i]*1. / (1 << (i + 1))) for i in range(2 * n)])\n--- Страница 349 ---\nФакторизация целых чисел при помощи алгоритма Шора 349 # Разложение на множители для получения делителя (или периода?) r = Fraction(y).limit_denominator(N-1).denominator # Возврат (возможного) значения периода return r В следующем пункте приведен набор результатов факторизации для раз - личных значений N. Результаты моделирования Квантовая подпрограмма для нахождения периода в ProjectQ создается моделированием квантовой схемы на классическом компьютере, из-за чего ее применение для факторизации больших чисел нецелесообразно. Фактически она не способна разложить число, состоящее более чем из четырех цифр, на домашнем компьютере за приемлемое время. В табл. 8.3 приведен набор результатов для различных значений N — от 15 до 2491, полученных на моем ноутбуке. Таблица 8.3. Результаты факторизации различных значений N Число N Кубиты Время, с Память, Мбайт Количество квантовых вентилей 15 11 2,44 50 CCR = 792; CR = 3186; CSwap = 32; CX = 128; H = 1408; R = 320; X = 130; Measure = 9 105 17 27,74 200 CCR = 3735; CR = 25 062; CSwap = 98; CX = 392; H = 6666; R = 1568; X = 393; Measure = 15 Продолжение \n--- Страница 350 ---\n350 Глава 8 . Алгоритмы Гровера и Шора: ускоренный поиск и угроза Число N Кубиты Время, с Память, Мбайт Количество квантовых вентилей 1150 25 17 542,12 (4,8 ч)500 CCR = 15 366; CR = 139 382; CSwap = 242; CX = 968; H = 24 222; R = 5829; X = 981; Measure = 23 2491 27 246 164,74 (68,3 ч)2048 CCR = 20 601; CR = 194 670; CSwap = 288; CX = 1152; H = 31 126; R = 7509; X = 1166; Measure = 25 На факторизацию четырехзначного числа 2491 ушло более 68 часов на 64-разрядном ПК с Windows 7, с процессором Intel Core i-5, с тактовой частотой 2,6 ГГц и с 16 Гбайт оперативной памяти. Я попытался раз - ложить немного большее N = 8122, но через неделю сдался. В целом эти результаты показывают, что алгоритм можно успешно смоделировать для небольших N, однако его необходимо реализовать на реальном квантовом компьютере, чтобы проверить его действительную мощь. В этой главе мы завершили свои исследования двумя алгоритмами, которые вызвали волнения по поводу возможностей практических квантовых вычислений. Это алгоритм Гровера — неструктурированный метод квантового поиска, способный находить входные данные в среднем за √N шагов, что намного быстрее, чем лучшее классическое решение со средним значением N / 2 шагов. Предполагаю, что в будущем все поиски в Интернете будут выполняться при помощи алгоритма Гровера. Алгоритм Шора для факторизации на квантовом компьютере, по словам экспертов, может заменить современное асимметричное шифрование. Возможно, это самый известный квантовый алгоритм, он является яр -Таблица 8.3 (продолжение)\n--- Страница 351 ---\nФакторизация целых чисел при помощи алгоритма Шора 351 ким примером мощных квантовых вычислений, обеспечивая экспонен - циальное ускорение по сравнению с лучшим классическим решением. Наконец, я хотел бы подвести итог, сказав, что изо всех сил пытался объяснить сложные концепции квантовых вычислений, смешивая мате - матику, программное обеспечение и столько числовых данных, сколько смог собрать. Множество чашек кофе было выпито, много бессонных ночей было потрачено на написание этой книги. Я надеюсь, что вам понравилось читать эту книгу так же, как мне — писать ее. И помните слова великого физика Ричарда Фейнмана: «Если кто-то говорит вам, что он понимает квантовую механику, это значит, что он не понимает квантовую механику».\n--- Страница 352 ---\nВладимир Силва Разработка с использованием квантовых компьютеров Перевел с английского К. Синица Заведующая редакцией Ю. Сергиенко Руководитель проекта С. Давид Ведущий редактор Н. Гринчик Научный редактор М. Коробко Литературный редактор Н. Рощина Художественный редактор Н. Васильева Корректоры Е. Павлович, Т. Радецкая Верстка Г. Блинов Изготовлено в России. Изготовитель: ООО «Прогресс книга». Место нахождения и фактический адрес: 194044, Россия, г. Санкт-Петербург, Б. Сампсониевский пр., д. 29А, пом. 52. Тел.: +78127037373. Дата изготовления: 01.2019. Наименование: книжная продукция. Срок годности: не ограничен. Налоговая льгота — общероссийский классификатор продукции ОК 034-2014, 58.11.12 — Книги печатные профессиональные, технические и научные. Импортер в Беларусь: ООО «ПИТЕР М», 220020, РБ, г. Минск, ул. Тимирязева, д. 121/3, к. 214, тел./факс: 208 80 01. Подписано в печать 18.12.19. Формат 70х100/16. Бумага офсетная. Усл. п. л. 28,380. Тираж 700. Заказ 0000. Отпечатано в ОАО «Первая Образцовая типография». Филиал «Чеховский Печатный Двор». 142300, Московская область, г. Чехов, ул. Полиграфистов, 1. Сайт: www.chpk.ru. E-mail: marketing@chpk.ru Факс: 8(496) 726-54-10, телефон: (495) 988-63-87",
      "debug": {
        "start_page":328,
        "end_page":352
      }
    }
  ]
}