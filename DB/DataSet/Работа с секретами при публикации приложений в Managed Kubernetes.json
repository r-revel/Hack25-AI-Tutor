{
  "title": "Работа с секретами при публикации приложений в Managed Kubernetes",
  "chapters": [
    {
      "name": "Работа с секретами при публикации приложений в Managed Kubernetes",
      "content": "Практические руководства Evolution    \n\n # Работа с секретами при публикации приложений в Managed Kubernetes   Эта статья полезна?          \nПриложения, развернутые в кластерах Kubernetes, часто требуют подключения к базам данных или внешним сервисам.\nОднако чувствительные данные, например логины, пароли или ключи API, не следует хранить в открытом виде в манифестах.\nЗащищенное хранение таких данных — одна из ключевых задач обеспечения безопасности приложений.\nС помощью этого руководства вы научитесь подключать Flask-приложение к PostgreSQL с использованием встроенных в Kubernetes секретов для хранения логина и пароля от базы данных PostgreSQL в сервисе Managed Kubernetes на платформе Cloud.ru Evolution.\nВы будете использовать следующие сервисы:\n- Виртуальные машины — сервис, в рамках которого предоставляется виртуальная машина.\n- Managed Kubernetes — сервис управления кластерами Kubernetes на вычислительных ресурсах облака.\n- Artifact Registry для хранения, совместного использования и управления Docker-образами и Helm-чартами.\n- sNAT-шлюзы — сервис управления сетевыми шлюзами облака.\n- kubectl — инструмент командной строки, позволяющий запускать команды для кластеров Kubernetes.\n- Docker — система контейнеризации.\nШаги:\n1. Разверните необходимые ресурсы в облаке.\n2. Создайте секрет и базу данных PostgreSQL.\n3. Соберите и загрузите образ приложения в Artifact Registry Cloud.ru.\n4. Разверните Flask-приложение в Managed Kubernetes.\n5. Проверьте результат.\n\n## Перед началом работы\n1. Зарегистрируйтесь в личном кабинете Cloud.ru.\nЕсли вы уже зарегистрированы, войдите под своей учетной записью.\n2. Убедитесь, что у вас достаточно прав для создания реестра и загрузки артефактов в сервисе Artifact Registry.\n\n## 1. Разверните необходимые ресурсы в облаке\n1. Создайте кластер Managed Kubernetes с хотя бы одной группой узлов.\n2. Создайте виртуальную машину в той же зоне доступности, что и кластер.\nВ сетевых настройках ВМ выберите параметр Подсеть с публичным IP.\nС виртуальной машины вы будете подключаться к кластеру Managed Kubernetes.\n3. Выполните подключение к кластеру Managed Kubernetes с ВМ:\n1. Подключитесь к ВМ по SSH.\n2. На ВМ установите kubectl и cloudlogin.\n3. Подключитесь с ВМ к кластеру Managed Kubernetes.\n4. Проверьте подключение:\n```\nkubectl get nodes\n```\n\nЕсли отобразится список узлов, подключение настроено.\n4. Создайте sNAT-шлюз в той же зоне доступности, что и кластер.\nОн понадобится для работы с внешними образами, например postgres.\n\n## 2. Создайте секрет и базу данных PostgreSQL\nЭтот шаг выполняется на виртуальной машине, с которой выполнено подключение к созданному кластеру Managed Kubernetes.\n1. Создайте секрет, содержащий логин и пароль для PostgreSQL:\n```\nkubectl create secret generic pg-secret \\   --from-literal=POSTGRES_USER=demo \\   --from-literal=POSTGRES_PASSWORD=supersecret\n```\n\nЭтот секрет будет использоваться как самой базой данных, так и приложением-клиентом для подключения.\nРезультат:\n```\nsecret/pg-secret created\n```\n2. Создайте файл postgres-deployment.yaml:\n```\napiVersion: apps/v1kind: Deploymentmetadata:   name: postgresspec:   replicas: 1   selector:      matchLabels:         app: postgres   template:      metadata:         labels:            app: postgres      spec:         containers:          - name: postgres            image: postgres:15            env:             - name: POSTGRES_USER               valueFrom:                  secretKeyRef:                     name: pg-secret                     key: POSTGRES_USER             - name: POSTGRES_PASSWORD               valueFrom:                  secretKeyRef:                     name: pg-secret                     key: POSTGRES_PASSWORD            ports:             - containerPort: 5432---apiVersion: v1kind: Servicemetadata:   name: postgresspec:   selector:      app: postgres   ports:    - port: 5432      targetPort: 5432   clusterIP: \"\"\n```\n3. Примените манифест:\n```\nkubectl apply -f postgres-deployment.yaml\n```\n\nРезультат:\n```\ndeployment.apps/postgres createdservice/postgres created\n```\n\n## 3. Соберите и загрузите образ приложения в Artifact Registry Cloud.ru\nНа этом шаге вы создадите Docker-образ Flask-приложения, которое подключается к PostgreSQL, и загрузите его в Artifact Registry Cloud.ru.\nИспользование собственного образа в Artifact Registry гарантирует, что приложение будет работать с нужными зависимостями и будет доступно для вашего кластера без внешних зависимостей.\nПримечание Если вы хотите пропустить сборку, можете перейти к шагу 4 и использовать тестовый образ kollekcioner47/secretapp из Docker Hub.\nОднако в рамках этого практического руководства рекомендуется использовать свой образ в Artifact Registry, так как это целевой сценарий для продакшн-развертывания.\nЕсли вы загрузите в реестр случайный или неполный образ без описанных ниже настроек Dockerfile, приложение не запустится, так как в нем не будут установлены необходимые библиотеки, например Flask, psycopg2-binary и другие.\n1. Подготовьте приложение.\nНа отдельной виртуальной машине с установленным Docker создайте файл app.py:\n```\nimport osimport psycopg2from flask import Flask\napp = Flask(__name__)\n@app.route(\"/\")def index():   conn = psycopg2.connect(   dbname=\"postgres\",   user=os.getenv(\"POSTGRES_USER\"),      password=os.getenv(\"POSTGRES_PASSWORD\"),   host=\"postgres\",   port=\"5432\"   )   cur = conn.cursor()   cur.execute(\"SELECT version();\")   result = cur.fetchone()   cur.close()   conn.close()   return f\"Connected to PostgreSQL: {result}\"\nif __name__ == \"__main__\":   app.run(host=\"0.0.0.0\", port=5000)\n```\n2. Создайте Dockerfile:\n```\nFROM python:3.10-slimWORKDIR /appCOPY app.py .RUN apt-get update && apt-get install -y gcc libpq-dev && \\   pip install flask psycopg2-binary && \\   apt-get cleanCMD [\"python\", \"app.py\"]\n```\n3. Подготовьте среду для сборки образа приложения и его загрузки в Artifact Registry.\nДля этого выполните шаги 2–6 инструкции.\n4. Соберите и загрузите образ:\n```\ndocker build -t <your-registry-uri>/secretapp:latest .docker push <your-registry-uri>/secretapp:latest\n```\n\nГде <your-registry-uri> — URI реестра из сервиса Artifact Registry.\n\n## 4. Разверните Flask-приложение в Managed Kubernetes\nНа этом шаге вы развернете приложение, которое подключается к PostgreSQL с использованием Kubernetes Secret.\nЕсли вы выполнили шаг 3, используйте образ из своего Artifact Registry.\nЕсли вы пропустили шаг 3, укажите тестовый образ kollekcioner47/secretapp из Docker Hub.\nРаботоспособность образа в этом случае не гарантируется при измененных настройках.\n1. Создайте файл app-deployment.yaml:\n```\napiVersion: apps/v1kind: Deploymentmetadata:  name: pg-clientspec:  replicas: 1  selector:    matchLabels:      app: pg-client  template:    metadata:      labels:        app: pg-client    spec:      containers:        - name: pg-client          image: <your-registry-uri>/secretapp:latest  # basic scenario          # image: kollekcioner47/secretapp            # alternative scenario          env:            - name: POSTGRES_USER              valueFrom:                secretKeyRef:                  name: pg-secret                  key: POSTGRES_USER            - name: POSTGRES_PASSWORD              valueFrom:                secretKeyRef:                  name: pg-secret                  key: POSTGRES_PASSWORD          ports:            - containerPort: 5000---apiVersion: v1kind: Servicemetadata:  name: pg-client-servicespec:  selector:    app: pg-client  ports:    - port: 80      targetPort: 5000  type: LoadBalancer\n```\n2. Примените манифест:\n```\nkubectl apply -f app-deployment.yaml\n```\n\nРезультат:\n```\ndeployment.apps/pg-client createdservice/pg-client-service created\n```\n\n## 5. Проверьте результат\nУбедитесь, что приложение работает корректно.\n1. Получите внешний IP:\n```\nkubectl get svc pg-client-service\n```\n2. Перейдите по адресу http://<external-ip> в браузере.\nЕсли все настроено верно, в веб-интерфейсе отобразится текст с версией PostgreSQL, например:\n```\nConnected to PostgreSQL: ('PostgreSQL 15.14 (Debian 15.14-1.pgdg13+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 14.2.0-19) 14.2.0, 64-bit',)\n```\n\nЭто означает, что Flask-приложение развернуто в Kubernetes и успешно подключено к базе данных: приложение выполняет SQL-запрос SELECT VERSION(), получает из PostgreSQL строку с номером версии и отображает ее на странице.\nТаким образом, вы развернули контейнерное Flask-приложение в Kubernetes и использовали  Secret для безопасного хранения логина и пароля к базе данных.\n\n## Результат\nВы научились:\nЭтот подход можно использовать в реальных проектах при развертывании микросервисов и работе с конфиденциальными данными.\n\n  [© 2025 Cloud.ru](https://cloud.ru)",
      "debug": {
        "start_page": 1,
        "end_page": 1
      }
    }
  ]
}