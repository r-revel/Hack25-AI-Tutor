{
  "title": "Создаем нейронную сеть [2017] Тарик Рашид",
  "chapters": [
    {
      "name": "Глава 1. Как работают нейронные сети 19",
      "content": "--- Страница 19 ---\nЖдем ваших отзывов! Вы, читатель этой книги, и есть главный ее критик. Мы ценим ваше мнение и хотим знать, что было сделано нами правильно, что можно было сделать лучше и что еще вы хотели бы увидеть издан­ ным нами. Нам интересны любые ваши замечания в наш адрес. Мы ждем ваших комментариев и надеемся на них. Вы можете прислать нам бумажное или электронное письмо либо просто посе­ тить наш сайт и оставить свои замечания там. Одним словом, любым удобным для вас способом дайте нам знать, нравится ли вам эта кни­ га, а также выскажите свое мнение о том, как сделать наши книги более интересными для вас. Отправляя письмо или сообщение, не забудьте указать название книги и ее авторов, а также свой обратный адрес. Мы внимательно ознакомимся с вашим мнением и обязательно учтем его при отборе и подготовке к изданию новых книг. Наши электронные адреса: E-mail: in fo @ d ia le k tik a .c o m WWW: h ttp : / / w w w .d ia le k tik a .co m Наши почтовые адреса: в России: 195027, Санкт-Петербург, Магнитогорская ул., д. 30, ящик 116 в Украине: 03150, Киев, а/я 152\n--- Страница 20 ---\nГЛАВА 1 Как работают нейронные сети Черпайте вдохновенье в окружающих вас мелочах . Что легко одному, трудно другому Компьютеры, в сущности, — это не более чем калькуляторы, спо­ собные выполнять арифметические операции с огромной скоростью. Эта особенность компьютеров позволяет им отлично справляться с задачами, аналогичными тем, которые решаются с помощью каль­ куляторов: суммирование чисел с целью определения объемов про­ даж, применение процентных ставок для начисления налогов или построение графиков на основе существующих данных. Даже просмотр телевизионных программ или прослушивание по­ токовой музыки через Интернет с помощью компьютера не требует чего-то большего, чем многократное выполнение простых арифмети­ ческих операций. Возможно, вы будете удивлены, но реконструкция видеокадра, состоящего сплошь из единиц и нулей, которые посту­ пают на ваш компьютер по сети, осуществляется путем выполнения арифметических действий, лишь ненамного более сложных, чем суммирование чисел, которое вы проходили в школе. Безусловно, сложение чисел с гигантской скоростью — тысячи или миллионы операций в секунду — это впечатляющий эффект, но его нельзя назвать проявлением искусственного интеллекта. Даже если человеку трудно складывать в уме большие числа, данный процесс вовсе не требует особого интеллекта. Для таких вычисле­ ний достаточно способности следовать элементарным инструкциям, и именно это происходит внутри любого компьютера.\n--- Страница 21 ---\nА теперь перевернем все вверх тормашками и поставим столы на компьютеры! Взгляните на приведенные ниже иллюстрации и убедитесь в том, что для вас не составляет труда распознать то, что на них изображено. Мы с вами, посмотрев на эти фотографии, легко определим, что на них изображены соответственно люди, кот и дерево. Мы способны практически мгновенно и с высокой точностью распознавать объек­ ты, на которые направляем свой взгляд, и при этом очень редко оши­ баемся. В процессе анализа изображений и классификации объектов наш мозг обрабатывает огромные объемы информации. Компьютеру труд­ но решать подобные задачи, а точнее — невероятно трудно. Задача Компьютер Человек Быстрое умножение тысяч больших чисел Легко Трудно Распознавание конкретного человека среди толпы на фотографииТрудно Легко Мы догадываемся, что для распознавания образов требуется че­ ловеческий интеллект — то, чего недостает машинам, какими бы сложными и мощными мы их ни создавали, а все потому, что они — не люди. Но это как раз тот тип задач, в отношении которых мы и хотели бы сделать компьютеры более эффективными, поскольку они рабо­ тают быстрее и никогда не устают. В свою очередь, именно для реше­ ния подобных задач и ведутся работы по созданию искусственного интеллекта. 20 Глава 1. Как работают нейронные сети\n--- Страница 22 ---\nКонечно же, компьютеры всегда будут начиняться электроникой, и потому задачей искусственного интеллекта является поиск пред­ писаний, или алгоритмов, основанных на новых подходах к реше­ нию трудных задач, о которых идет речь. Резю ме • Одни задачи, как, например, перемножение миллионов пар чисел, просты для компьютера, но трудны для человека. • Но есть и такие задачи, как, к примеру, распознавание лиц людей в толпе на фотографии, которые трудны для компьютера, но просты для человека. Простая прогнозирующая машина Начнем с простого и будем постепенно усложнять задачу. Вообразите простую прогнозирующую машину (предиктор), ко­ торая получает вопрос, совершает некий “мыслительный” процесс и выдает ответ. Все происходит примерно так, как в приведенном выше примере с распознаванием образов, в котором входная инфор­ мация воспринималась нашими глазами, далее наш мозг анализиро­ вал изображение, после чего мы делали выводы относительно того, какие объекты имеются на данном изображении. Это можно пред­ ставить с помощью следующей схемы. Но компьютеры не могут по-настоящему думать (вспомните, что они всего лишь усовершенствованные калькуляторы), поэтому мы используем другую терминологию, более точно соответствующую тому, что происходит на самом деле. Простая прогнозирующая машина 21вопрос ответ анализ\n--- Страница 23 ---\nввод вывод Компьютер получает входную информацию, выполняет некоторые расчеты и выдает результат. Этот процесс схематически представлен на следующей иллюстрации. Входная информация, заданная в виде “3x4” , обрабатывается с возможной заменой операции умножения более простыми операциями сложения, и выдается выходной резуль­ тат “ 12” . ввод 3 X 4 Возможно, вы подумали: “Ну и что здесь особенного?” Не пере­ живайте, все нормально. Пока что мы используем простые и хорошо знакомые примеры для введения понятий, которые далее будут при­ менены к более интересным нейронным сетям. Давайте чуть усложним задачу. Представьте, что машина должна преобразовывать километры в мили. 22 Глава 1. Как работают нейронные сетиобработка (расчет) расчет 4 + 4 + 4вывод 1Z расчет ???километры мили\n--- Страница 24 ---\nПредположим, что формула, преобразующая километры в мили, нам неизвестна. Все, что мы знаем, — это то, что данные единицы измерения связаны между собой линейной зависимостью. Это озна­ чает, что если мы удвоим количество миль, то количество киломе­ тров, соответствующее данному расстоянию, также удвоится. Такая зависимость воспринимается нами интуитивно. Существование линейного соотношения между километрами и милями дает нам ключ к разгадке формулы для вычислений. Она должна иметь следующий вид: мили = километры х с, где с — констан­ та, величину которой мы пока что не знаем. Единственными дополнительными подсказками нам могут слу­ жить отдельные примеры правильного выражения расстояний в ки­ лометрах и милях. Эти примеры будут выступать как бы в роли экс­ периментальных данных, отражающих истинное положение вещей, которые мы используем для проверки своей научной теории. Истинный пример Километры Мили 1 0 0 2 1 0 0 62,37 Что нам нужно сделать для того, чтобы определить недостающую величину константы? Давайте просто подставим в формулу какое- либо случайное значение! Например, предположим, что с=0,5, и по­ смотрим, что при этом произойдет. Здесь мы подставляем в формулу мили = километры х с значение 100 вместо километры и текущее пробное значение 0,5 вместо кон­ станты с. В результате мы получаем ответ: 50 миль. Простая прогнозирующая машина 23мили SOкилометры ХООмили - километры к 0.5\n--- Страница 25 ---\nНу хорошо. Это вовсе неплохо, если учесть, что значение с=0,5 было выбрано случайным образом! Но мы знаем, что оно не совсем точное, поскольку пример 2 истинного соотношения говорит нам о том, что правильный ответ — 62,137. Мы ошиблись на 12,137. Это число представляет величину ошиб­ ки, т.е. разность между истинным значением из нашего списка при­ меров и расчетным значением. ошибка = истина - расчет = 62,137 - 50 =12,137 километры Ю О ошибка 12,137 Что дальше? Мы знаем, что ошиблись, и нам известна величина ошибки. Вместо того чтобы видеть в этой ошибке повод для отчая­ ния, мы используем эту информацию для того, чтобы предложить более удачное пробное значение константы с, чем первое. Вернемся к ошибке. Мы ошиблись на 12,137 в сторону меньших значений. Так как формула для преобразования километров в мили линейная, мили = километры х с, мы знаем, что увеличение с приведет к увеличению результирующего значения. Давайте немного подправим с, заменив значение 0,5 значением 0,6, и посмотрим, к чему это приведет. 24 Глава 1. Как работают нейронные сетирасчетные мили 5 0 правильный ответ 6 2 ,1 3 7мили = километры 0 ,5\n--- Страница 26 ---\nПриняв для с значение 0,6, мы получаем мили = километры х с = = 100 х 0, 6 = 60. Это уже лучше, чем предыдущий ответ — 50. Налицо явный прогресс! Теперь ошибка уменьшилась до 2,137. Вполне возможно, что с та­ кой ошибкой мы могли бы даже смириться. ошибка 2 ,1 3 7 Здесь важно то, что величина ошибки подсказала нам, в каком на­ правлении следует откорректировать величину с. Мы хотели увели­ чить выходной результат 50, поэтому немного увеличили с. Вместо того чтобы использовать алгебру для нахождения точной величины поправки, на которую следует изменить значение с, мы продолжим использовать подход, заключающийся в постепенном уточнении значения этой константы. Если вы не уверены в правиль­ ности такого подхода и считаете, что было бы намного проще сразу определить точный ответ, то имейте в виду, что существует множе­ ство более интересных задач, для которых не существует простых математических формул, связывающих между собой входные и вы­ ходные значения. Именно поэтому нам и нужны более сложные ме­ тоды наподобие нейронных сетей. Повторим уже знакомые нам действия. Выходной результат 60 все еще слишком мал. Давайте вновь немного изменим константу с, увеличив ее значение с 0,6 до 0,7. Простая прогнозирующая машина 25километры гоорасчетные мили < Ь О правильный ответ 6 2 ,1 3 7м и л и = километры х 0,ь\n--- Страница 27 ---\nО, нет! Мы перестарались и получили результат, превышающий правильный ответ. Предыдущая ошибка была равна 2,137, а теперь она составляет -7,683. Знак “минус” просто свидетельствует о том, что вместо недооценки истинного результата произошла его пере­ оценка (напомню, что величина ошибки определяется выражением правильное значение минус расчетное значение). Итак, с=0,б было гораздо лучше, чем с=0,7. Сейчас мы могли бы признать величину ошибки при с=0, 6 удовлетворительной и закон­ чить это упражнение. Но мы все-таки продвинемся еще чуть дальше. Почему бы нам не попытаться ввести очень малую поправку и увели­ чить значение с с 0,6 до, скажем, 0,61? 6 2 ,1 3 7 26 Глава 1. Как работают нейронные сетикилометры 1 Орасчетные мили 7 0 правильный ответ Ь 2 ,1 3 7 ошибка -7 ,8 6 3 километры 1 ООрасчетные мили 6 1 правильный ответ ошибка 1 ,1 3 7\n--- Страница 28 ---\nЭто дает нам гораздо лучший результат, чем предыдущие, по­ скольку теперь выходное значение 61 отличается от правильного значения 62,137 всего лишь на 1,137. Итак, последняя попытка научила нас тому, что величину поправ­ ки к величине с необходимо каждый раз определять заново. Если выходной результат приближается к правильному ответу, т.е. если ошибка уменьшается, то не следует оставлять величину поправки прежней. Тем самым мы избегаем переоценки значения по сравне­ нию с истинным, как это было ранее. Опять-таки, не отвлекаясь на поиск точных способов определения величины с и по-прежнему фокусируя внимание на идее ее постепен­ ного уточнения, мы можем предположить, что поправка должна вы­ ражаться некоторой долей ошибки. Это интуитивно понятно: боль­ шая ошибка указывает на необходимость введения большей поправ­ ки, тогда как малая ошибка нуждается в незначительной поправке. Хотите — верьте, хотите — нет, но то, что мы сейчас сделали, пере­ дает суть процесса обучения нейронной сети. Мы тренировали маши­ ну так, чтобы ее предсказания становились все более и более точными. Нам стоит сделать небольшую паузу, чтобы поразмышлять над сле­ дующим: мы не находили точного решения задачи в один прием, как это часто делается при решении школьных или научных задач. Вместо этого мы предприняли совершенно иной подход, заключающийся в многократных попытках проверки пробного значения и его уточне­ ния. Такие процессы иногда называют итеративными, что как раз и оз­ начает постепенное, шаг за шагом, улучшение искомого результата. Резю ме • У всех полезных компьютерных систем имеются каналы ввода и вывода, между которыми над данными выполняются некоторые вычисления. В случае нейрон­ ных сетей это не так. • Если точные принципы функционирования какой-либо системы нам неизвест­ ны, то мы пытаемся получить представление о том, как она работает, используя модель с регулируемыми параметрами. Если бы мы не знали, как преобразо­ вать километры в мили, то могли бы использовать для этой цели линейную функцию в качестве модели с регулируемым наклоном. • Неплохим способом улучшения подобных моделей является настройка пара­ метров на основании сравнения результатов модели с точными результатами в известных примерах. Простая прогнозирующая машина 27\n--- Страница 29 ---\nЗадачи классификации и прогнозирования очень близки Мы назвали описанную ранее простую машину прогнозирующей, поскольку она получает входные данные и делает определенный про­ гноз относительно того, какими должны быть выходные данные. Мы улучшали прогнозы, регулируя внутренний параметр на основании величины ошибки, которую определяли, сравнивая прогноз с извест­ ным точным значением. Взгляните на иллюстрацию ниже, на которой приведена диаграм­ ма, представляющая результаты измерения размеров садовых жуков. На диаграмме отчетливо видны две группы данных. Гусеницы уже и длиннее, а божьи коровки шире и короче. 28 Глава 1. Как работают нейронные сети\n--- Страница 30 ---\nПомните наш предиктор, который пытался правильно вычислить количество миль, соответствующее заданному количеству километ­ ров? В основу этого предиктора была положена настраиваемая линей­ ная функция. Надеюсь, вы не забыли, что график зависимости выход­ ных значений линейной функции от ее входных значений представ­ ляет собой прямую линию. Изменение настраиваемого параметра с приводит к изменению крутизны наклона этой прямой линии. Что получится, если мы наложим на этот график прямую линию? Мы не можем использовать прямую линию точно так же, как раньше, когда преобразовывали одно число (километры) в другое (мили), но, возможно, в данном случае нам удастся отделить с ее по­ мощью один тип данных от другого. Задачи классификации и прогнозирования очень близки 29\n--- Страница 31 ---\nЕсли бы на показанном выше графике прямая линия отделяла гусениц от божьих коровок, то мы могли бы воспользоваться ею для классификации неизвестных жуков, исходя из результатов из­ мерений. Однако имеющаяся линия не справляется с этой задачей, поскольку половина гусениц находится по ту же сторону линии, что и божьи коровки. Давайте проведем другую линию, изменив наклон, и посмотрим, что при этом произойдет. На этот раз линия оказалась еще менее полезной, поскольку во­ обще не отделяет один вид жуков от другого. Сделаем еще один заход. 30 Глава 1. Как работают нейронные сети\n--- Страница 32 ---\nВот это другое дело! Линия отчетливо отделяет гусениц от божьих коровок. Теперь мы можем использовать ее в качестве классифика­ тора жуков. Мы предполагаем, что не существует никаких других видов жу­ ков, кроме тех, которые показаны на диаграмме, но на данном этапе это не является недостатком подхода — мы просто пытаемся проил­ люстрировать суть идеи простого классификатора. А теперь представьте, что в следующий раз наш компьютер ис­ пользует робота для того, чтобы тот отобрал очередного жука и вы­ полнил необходимые замеры. Тогда полученную линию можно будет использовать для корректного отнесения жука к семейству гусениц или семейству божьих коровок. Задачи классификации и прогнозирования очень близки 31\n--- Страница 33 ---\nВзглянув на следующий график, вы увидите, что неизвестный жук относится к семейству гусениц, поскольку попадает в область над линией. Несмотря на свою простоту эта классификация уже яв­ ляется довольно мощным инструментом! Только что вы имели возможность убедиться в том, насколько по­ лезными могут быть предикторы с линейной функцией в качестве инструмента классификации вновь поступающих данных. Однако мы обошли вниманием один существенный момент. Как нам узнать, какой наклон прямой является подходящим? Как улуч­ шить линию, если она не разделяет должным образом две разновид­ ности жуков? 32 Глава 1. Как работают нейронные сети\n--- Страница 34 ---\nОтвет на этот вопрос также имеет самое непосредственное отноше­ ние к способности нейронной сети обучаться, к рассмотрению чего мы и переходим. Тренировка простого классификатора Сейчас мы займемся тренировкой (обучением) нашего линейного классификатора и научим его правильно классифицировать жуков, относя их к гусеницам или божьим коровкам. Как вы видели ранее, речь идет об уточнении наклона разграничительной линии, отделяю­ щей на графике одну группу точек данных, соответствующих парам значений длины и ширины, от другой. Как мы это сделаем? Вместо того чтобы заранее разработать подходящую научную тео­ рию, мы нащупаем правильный путь методом проб и ошибок. Это по­ зволит нам лучше понять математику, скрытую за этими действиями. Нам нужны примеры для тренировки классификатора. Чтобы не усложнять себе жизнь, мы ограничимся двумя простыми примера­ ми, приведенными ниже. Пример Ширина Длина Ж ук 1 3,0 1,0 Божья коровка 2 1,0 3,0 Гусеница У нас есть пример жука, имеющего ширину 3,0 и длину 1,0, кото­ рый, как нам известно, является божьей коровкой. Второй пример относится к жуку, имеющему большую длину — 3,0 и меньшую ши­ рину — 1,0, которым является гусеница. Мы знаем, что данные в этом наборе примеров являются истин­ ными. Именно с их помощью будет уточняться значение константы в функции классификатора. Примеры с истинными значениями, ко­ торые используются для обучения предиктора или классификатора, называют тренировочными данными. Отобразим эти два примера тренировочных данных на диаграмме. Визуализация данных часто помогает лучше понять их природу, по­ чувствовать их, чего нелегко добиться, просто вглядываясь в список или таблицу, заполненную числами. Тренировка простого классификатора 33\n--- Страница 35 ---\nНачнем со случайной разделительной линии, потому что нужно ведь с чего-то начинать. Вспомните линейную функцию из примера с преобразованием километров в мили, параметр которой мы настра­ ивали. Мы можем сделать то же самое и сейчас, поскольку раздели­ тельная линия в данном случае прямая: у = Ах Мы намеренно используем здесь имена х и у , а не длина и ширина, поскольку, строго говоря, в данном случае линия не служит предик­ тором. Она не преобразует ширину в длину, как ранее километры переводились в мили. Вместо этого она выступает в качестве разде­ лительной линии, классификатора. 34 Глава 1. Как работают нейронные сети\n--- Страница 36 ---\nВероятно, вы обратили внимание на неполную форму уравнения у=Ах, поскольку полное уравнение прямой линии имеет следующий вид: у=Ах+В. Мы намеренно делаем этот сценарий с садовыми жука­ ми максимально простым. Ненулевое значение В просто соответству­ ет линии, которая не проходит через начало координат на диаграм­ ме, что не добавляет в наш сценарий ничего нового. Ранее было показано, что параметр А управляет наклоном линии. Чем больше А, тем больше крутизна наклона. Для начала примем, что А=0,25. Тогда разделительная линия описы­ вается уравнением у=0,25х. Отобразим эту линию в графическом виде на той же диаграмме, на которой отложены тренировочные данные. Тренировка простого классификатора 35\n--- Страница 37 ---\nБлагодаря графику мы безо всяких вычислений сразу же видим, что линия у=0,25х не является хорошим классификатором. Она не отделяет один тип жуков от другого. Например, мы не можем делать утверждения наподобие “Если точка данных располагается над ли­ нией, то она соответствует гусенице” , поскольку точно там же рас­ полагаются и данные божьей коровки. Интуитивно мы понимаем, что правый край линии следует немно­ го приподнять. Мы устоим перед соблазном сделать это, глядя на ди­ аграмму и проводя подходящую линию вручную. Мы хотим прове­ рить, не удастся ли нам подобрать для этого подходящий повторяе­ мый рецепт, последовательность команд, которую компьютерщики называют алгоритмом. Обратимся к первому тренировочному примеру, соответствующе­ му божьей коровке: ширина — 3,0 и длина — 1,0. Если бы мы те­ стировали функцию у=Ах с этим примером, в котором х равен 3,0, то получили бы следующий результат: У - (0,25) * (3,0) =0,75 Функция, в которой для параметра А установлено начальное слу­ чайно выбранное значение, равное 0,25, сообщает, что для жука ши­ риной 3,0 длина должна быть равна 0,75. Мы знаем, что это слиш­ ком мало, поскольку согласно тренировочным данным длина жука равна 1,0. Итак, налицо расхождение, или ошибка. Точно так же, как в при­ мере с предиктором, преобразующим километры в мили, мы можем использовать величину этой ошибки для получения информации о том, каким образом следует корректировать параметр А. Однако сначала давайте подумаем, каким должно быть значе­ ние у. Если положить его равным 1,0, то линия пройдет через точку с координатами ( х , у ) = ( 3,0; 1,0), соответствующую божьей коровке. Само по себе это неплохо, но это не совсем то, что нам нужно. Нам желательно, чтобы линия проходила над этой точкой. Почему? Да потому, что мы хотим, чтобы точки данных божьей коровки лежали под линией, а не на ней. Линия должна служить разделителем меж­ ду точками данных божьих коровок и гусениц, а не предсказывать длину жука по известной ширине. 36 Глава 1. Как работают нейронные сети\n--- Страница 38 ---\nВ связи с этим попробуем нацелиться на значение у=1,1 при х=3,0. Оно лишь ненамного больше 1,0. Вместо него можно было бы взять зна­ чение 1,2 или 1,3, но никак не 10 или 100, поскольку с большой долей вероятности это привет к тому, что прямая будет проходить над всеми точками данных, как божьих коровок, так и гусениц, в результате чего она станет полностью бесполезной в качестве разделителя. Следовательно, мы выбираем целевое значение 1,1 и определяем ошибку Е с помощью следующей формулы: ошибка = желаемое целевое значение - фактический результат Или (после подстановки значений): Е = 1 ,1 -0 ,7 5 = 0,35 Помня о пользе визуализации информации, обратимся к приве­ денной ниже диаграмме, на которой в графическом виде представле­ ны ошибка, а также целевое и расчетное значения. Вы спросите: а каким образом наше знание величины ошибки Е может помочь в нахождении лучшего значения для параметра А? Это очень важный вопрос. Тренировка простого классификатора 37\n--- Страница 39 ---\nДавайте на время отступим от этой задачи и немного порассужда­ ем. Мы хотим использовать ошибку в значении у , которую назвали Е , для нахождения искомого изменения параметра А . Для этого нам нужно знать, как эти две величины связаны между собой. Каково со­ отношение между А и Е ? Если бы это было нам известно, то мы могли бы понять, как изменение одной величины влияет на другую. Начнем с линейной функции для классификатора: у = Ах Нам уже известно, что начальные попытки присвоения пробных значений параметру А привели к неверным значениям у , если ориен­ тироваться на тренировочные данные. Пусть t — корректное целе­ вое значение. Чтобы получить его, мы должны ввести в А небольшую поправку. Для таких поправок в математике принято использовать символ Д , означающий “небольшое изменение” . Запишем соответ­ ствующее уравнение: t = (А + Д А ) х Отобразим это соотношение в графическом виде на диаграмме, на которой показаны линии для двух значений наклона: А и А + ДА. 38 Глава 1. Как работают нейронные сети\n--- Страница 40 ---\nВспомните, что ошибку Е мы определили как разность между же­ лаемым корректным значением у и расчетным значением, получен­ ным для текущего пробного значения А . Таким образом, Е = t - у . Запишем это в явном виде: t - у = (А + Д А ) х - Ах Раскрыв скобки и приведя подобные члены, получаем: E = t - y = Ax+ (ДА) х - Ах Е = (ДА)х Это просто замечательно! Ошибка Е связана с ДА очень простым со­ отношением. Оно настолько простое, что поначалу я даже засомне­ вался, не кроется ли где-то ошибка, но оно оказалось действительно верным. Как бы то ни было, это простое соотношение значительно упрощает нашу работу. Делая подобного рода выкладки, можно легко забыть о первона­ чальной задаче. Сформулируем простыми словами то, чего мы хоте­ ли добиться. Мы хотели узнать, каким образом можно использовать информа­ цию об ошибке Е для определения величины поправки к А , которая изменила бы наклон линии таким образом, чтобы классификатор лучше справлялся со своими функциями. Преобразуем последнее уравнение, чтобы найти выражение для ДА: Д А = Е / х Есть! Это и есть то волшебное выражение, которое мы искали. Теперь мы можем использовать ошибку Е для изменения наклона классифицирующей линии на величину ДА в нужную сторону. Примемся за дело — обновим начальный наклон линии. Когда х был равен 3,0, ошибка была равна 0,35. Таким образом, ДА = Е / х превращается в 0,35 / 3,0 = 0,1167. Это означает, что те­ кущее значение А=0,25 необходимо изменить на величину 0,1167. Отсюда следует, что новое, улучшенное значение А равно (А + Д А ), т.е. 0,25 + 0,1167 = 0,3667. Не составляет труда убедиться в том, что Тренировка простого классификатора 39\n--- Страница 41 ---\nрасчетное значение у при новом значении А равно, как и следовало ожидать, 1,1 — желаемому целевому значению. Ух ты! У нас получилось! Все работает, и мы располагаем методом для улучшения параметра А , если известна текущая ошибка. Давайте поднажмем. Закончив с первым примером, потренируемся на втором. Он дает нам следующие истинные данные: х = 1 , 0 и у = 3 , 0 . Посмотрим, что получится, если вставить х = 1 , 0 в линейную функ­ цию, в которой теперь используется обновленное значение А = 0 , 3 6 6 7 . Мы получаем у = 0,3667 * 1,0 = 0,3667. Это очень далеко от значения у = 3 , 0 в тренировочном примере. Используя те же рассуждения, что и перед этим, когда мы нащу­ пывали путь к построению такой линии, которая не пересекала бы тренировочные данные, а проходила над ними или под ними, мы мо­ жем задать желаемое целевое значение равным 2,9. При этом данные тренировочного примера, соответствующего гусеницам, находятся над линией, а не на ней. Ошибка Е равна (2,9 - 0,3667) = 2,5333. Эта ошибка больше предыдущей, но если хорошо подумать, то у нас ведь был всего лишь один пример для обучения линейной функ­ ции, который отчетливо смещал функцию в своем направлении. Опять обновим А , как делали до этого. Соотношение ДА = Е / х дает 2,5333 / 1,0 = 2,5333. Это означает, что после очередного обновления параметр А принимает значение 0,3667 + 2,5333 = 2,9. Отсюда сле­ дует, что для х = 1 , 0 функция возвращает в качестве ответа значение 2,9, которое и является желаемым целевым значением. Мы проделали довольно большую работу, поэтому можем снова передохнуть и визуализировать полученные результаты. На следую­ щей диаграмме представлены начальная линия, линия, обновленная после обучения на первом тренировочном примере, и окончательная линия, обновленная на втором тренировочном примере. 40 Глава 1. Как работают нейронные сети\n--- Страница 42 ---\nНо погодите! Что произошло? Глядя на график, мы видим, что нам не удалось добиться того наклона прямой, которого мы хотели. Она не обеспечивает достаточно надежное разделение областей диа­ граммы, занимаемых точками данных божьих коровок и гусениц. Ну что тут сказать? Мы получили то, что просили. Линия обнов­ ляется, подстраиваясь под то целевое значение у, которое мы задаем. Что-то здесь не так? А ведь действительно, если мы будем про­ должать так и далее, т.е. просто обновлять наклон для очередного примера тренировочных данных, то все, что мы будем каждый раз получать в конечном счете, — это линию, проходящую вблизи точки данных последнего тренировочного примера. В результате этого мы отбрасываем весь предыдущий опыт обучения, который могли бы ис­ пользовать, и учимся лишь на самом последнем примере. Как исправить эту ситуацию? Легко! И эта идея играет ключевую роль в машинном обучении. Мы сглаживаем обновления, т.е. немного уменьшаем величину по­ правок. Вместо того чтобы каждый раз с энтузиазмом заменять А Тренировка простого классификатора 41\n--- Страница 43 ---\nновым значением, мы используем лишь некоторую долю поправки ДА, а не всю ее целиком. Благодаря этому мы движемся в том направ­ лении, которое подсказывает тренировочный пример, но делаем это осторожно, сохраняя некоторую часть предыдущего значения, ко­ торое было получено в результате, возможно, многих предыдущих тренировочных циклов. Мы уже видели, как работает эта идея сгла­ живания в примере с преобразованием километров в мили, когда из­ меняли параметр с лишь на некоторую долю фактической ошибки. У такого сглаживания есть еще один очень мощный и полезный побочный эффект. Если тренировочные данные не являются надеж­ ными и могут содержать ошибки или шум (а в реальных измерениях обычно присутствуют оба этих фактора), то сглаживание уменьшает их влияние. Ну что ж, сделаем перерасчет, на этот раз добавив сглаживание в формулу обновления: Д А = L (Е / X ) Фактор сглаживания, обозначенный здесь как L, часто называют коэффициентом скорости обучения. Выберем L=0,5 в качестве ра­ зумного начального приближения. Это означает, что мы собираем­ ся использовать поправку вдвое меньшей величины, чем без сгла­ живания. Повторим все расчеты, используя начальное значение А*0,25. Первый тренировочный пример дает нам у = О ,25*3,0 = 0,75. При це­ левом значении 1,1 ошибка равна 0,35. Поправка равна Д А = L (Е / х) = 0,5 * 0,35 / 3,0 = 0,0583. Обновленное значение А равно 0,25 + + 0,0583 = 0,3083. Проведение расчетов с этим новым значением А для тренировочно­ го примера при х=3,0 дает у = 0,3083 * 3,0 = 0 , 9250. Как видим, рас­ положение этой линии относительно тренировочных данных оказа­ лось неудачным — она проходит ниже значения 1,1, но этот резуль­ тат не так уж и плох, если учесть, что это была всего лишь первая попытка. Главное то, что мы движемся в правильном направлении от первоначальной линии. 42 Глава 1. Как работают нейронные сети\n--- Страница 44 ---\nПерейдем ко второму набору тренировочных данных при х=1,0. Используя А=0,3083, мы получаем у= 0,3083 * 1,0 = 0,3083. Желае­ мым значением было 2,9, поэтому ошибка составляет (2,9 - 0,3083) = = 2,5917. Поправка Д А = L (Е / х) = 0,5 * 2,5917 / 1,0 = 1,2958. Теперь обновленное значение А равно 0,3083 + 1,2958 = 1,6042. Вновь отобразим на диаграмме начальный, улучшенный и оконча­ тельный варианты линии, чтобы убедиться в том, что сглаживание обновлений приводит к более удовлетворительному расположению разделительной линии между областями данных божьих коровок и гусениц. Это действительно отличный результат! Всего лишь с двумя простыми тренировочными примерами и от­ носительно простым методом обновления мы, используя сглажива­ ние скорости обучения, смогли очень быстро получить хорошую раз­ делительную линию у=Ах, где А=1,6042. Тренировка простого классификатора 43\n--- Страница 45 ---\nНе будем преуменьшать свои достижения. Нам удалось создать автоматизированный метод обучения классификации на примерах, который, несмотря на простоту подхода, продемонстрировал замеча­ тельную эффективность. Великолепно! Резюме • Чтобы понять соотношение между выходной ошибкой линейного классифика­ тора и параметром регулируемого наклона, достаточно владеть элементарной математикой. Зная это соотношение, можно определить величину изменения наклона, необходимую для устранения выходной ошибки. • Недостаток прямолинейного подхода к регулировке параметров заключается в том, что модель обновляется до наилучшего соответствия только последнему тренировочному примеру, тогда как все предыдущие примеры не принимаются во внимание. Одним из неплохих способов устранения этого недостатка являет­ ся уменьшение величины обновлений с помощью коэффициента скорости обу­ чения, чтобы ни один отдельно взятый тренировочный пример не доминировал в процессе обучения. • Тренировочные примеры, взятые из реальной практики, могут быть искажены шумом или содержать ошибки. Сглаживание обновлений способствует ограни­ чению влияния подобных ложных примеров. Иногда одного классификатора недостаточно Как вы имели возможность убедиться, рассмотренные нами прос­ тые предикторы и классификаторы, относящиеся к числу тех, кото­ рые получают некоторые входные данные, выполняют соответствую­ щие вычисления и выдают ответ, довольно эффективны. И все же их возможностей недостаточно для решения более интересных задач, к которым мы намереваемся применять методы нейронных сетей. Ограничения линейного классификатора продемонстрированы ниже на простом, но весьма показательном примере. Но почему мы должны заниматься этим вместо того, чтобы сразу же перейти к обсуждению ней­ ронных сетей? Дело в том, что от понимания сути указанных ограниче­ ний зависит один из ключевых элементов проектирования нейронных сетей, так что этот вопрос стоит того, чтобы его обсудить. 44 Глава 1. Как работают нейронные сети\n--- Страница 46 ---\nМы отойдем от темы садовых жучков и обратимся к логическим (булевым) функциям. Не беспокойтесь, если эта терминология вам ни о чем не говорит. Джордж Буль — математик и философ, с именем ко­ торого связаны такие простые функции, как логические И и ИЛИ. Функции булевой логики — это своего рода “ мыслительные” функции со своим языком. Если мы говорим “Ты получишь пудинг только в том случае, если уже съел овощи И все равно голоден” , то мы используем булеву функцию И. Результат булевой функции И истинен только тогда, когда истинны (выполняются) оба условия. Он не будет истинным, если истинно только одно из условий. Поэтому, если я голоден, но еще не съел овощи, то не получу свой пудинг. Аналогично, если мы говорим “Ты можешь погулять в парке, если сегодня выходной ИЛИ у тебя отпуск” , то используем булеву функ­ цию ИЛИ. Результат булевой функции ИЛИ истинен, если истинным является хотя бы одно из условий. Вовсе не обязательно, чтобы все ус­ ловия были истинными, как в случае функции И. Поэтому, если се­ годня не выходной день, но у меня отпуск, то я могу погулять в парке. Ранее мы представляли функцию в виде машины, которая прини­ мает некоторые входные данные, выполняет определенные действия и выдает один ответ. Значение истина часто представляется в компьютерах как число 1, а значение ложь — как число 0. В приведенной ниже таблице резуль­ таты работы логических функций И и ИЛИ представлены с использо­ ванием этой лаконичной нотации для всех комбинаций входных зна­ чений А и В. Иногда одного классификатора недостаточно 45\n--- Страница 47 ---\nВходное значение А Входное значение В Логическое И Логическое ИЛИ 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 1 Здесь отчетливо видно, что результат функции И будет истинным только тогда, когда истинны и А, и В. Булевы функции играют очень важную роль в информатике, и первые электронные вычислительные устройства фактически со­ бирались из крохотных электрических схем, выполняющих логичес­ кие операции. Даже арифметические операции выполнялись с ис­ пользованием этих схем, которые сами по себе всего лишь выполня­ ли простые булевы операции. Представьте себе простой линейный классификатор, который должен использовать тренировочный набор данных для выяснения того, управляются ли данные логической функцией. Задачи такого рода естественным образом возникают перед учеными, исследую­ щими причинно-следственные связи или корреляцию наблюдаемых величин. Например, требуется найти ответ на следующий вопрос: “Повышается ли вероятность заболевания малярией в тех местно­ стях, в которых постоянно идут дожди И температура превышает 35 градусов?” Или такой: “Повышается ли вероятность заболевания малярией, если выполняется любое (булева функция ИЛИ) из этих условий?” Взгляните на приведенную ниже диаграмму, где значения на двух входах логической функции, А и В, представляют координаты точек на графике. Вы видите, что только в том случае, когда оба входных значения истинны, т.е. каждое из них равно 1, выходной результат, выделенный зеленым цветом, является истинным. Ложные выход­ ные значения обозначены красным цветом. 46 Глава 1. Как работают нейронные сети\n--- Страница 48 ---\nНа диаграмме также показана прямая линия, отделяющая крас­ ную область от зеленой. Эта линия представляет линейную функ­ цию, которую можно использовать для обучения линейного класси­ фикатора, что мы делали ранее. Мы не будем проводить соответствующие вычисления, как в пре­ дыдущих примерах, поскольку ничего принципиально нового это не даст. В действительности можно было бы предложить много других ва­ риантов проведения разделительной линии, которые работали бы столь же удовлетворительно, но главный вывод из этого примера за­ ключается в том, что простой линейный классификатор вида у=ах+Ь можно обучить работе с булевой функцией И. А теперь взгляните на аналогичное графическое представление бу­ левой функции ИЛИ. Иногда одного классификатора недостаточно 47\n--- Страница 49 ---\nНа этот раз красной оказалась лишь точка (0,0), поскольку ей со­ ответствуют ложные значения на обоих входах, А и В. Во всех других комбинациях значений хотя бы одно из них является истинным, и по­ этому для них результат является истинным. Вся прелесть этой диа­ граммы заключается в том, что она наглядно демонстрирует возмож­ ность обучения линейного классификатора работе с функцией ИЛИ. Существует еще одна булева функция, исключающее ИЛИ, кото­ рая дает истинный результат только в том случае, если лишь одно из значений на входах А и В истинно, но не оба. Таким образом, если оба входных значения ложны или оба истинны, то результат будет лож­ ным. Все вышесказанное резюмировано в приведенной ниже таблице. Входное значение А Входное значение В Исключающее ИЛИ 0 0 0 0 1 1 1 0 1 1 1 0 48 Глава 1. Как работают нейронные сети\n--- Страница 50 ---\nВзгляните на диаграмму, соответствующую этой функции. Вот вам и проблема! Мы не видим способа разделить зеленую и красную области одной прямой линией. В действительности так оно и есть: невозможно провести одну прямую линию таким образом, чтобы она успешно отделила красные точки данных от зеленых для функции исключающего ИЛИ. Это означает, что простой линейный классификатор не в состоянии об­ учиться работе с функцией исключающего ИЛИ, если предоставить ему тренировочные данные, управляемые этой функцией. Только что мы продемонстрировали главное ограничение простого линейного классификатора: такие классификаторы оказываются не­ пригодными, если базовая задача не допускает разделения данных одной прямой линией. Но ведь мы хотим, чтобы нейронные сети можно было использо­ вать для решения самого широкого круга задач, даже тех, которые не допускают линейного разделения данных. Иногда одного классификатора недостаточно 49\n--- Страница 51 ---\nСледовательно, нам необходимо найти какой-то выход из этой си­ туации. К счастью, такой выход существует: совместное использование нескольких классификаторов. Его иллюстрирует приведенная ниже диаграмма с двумя разделительными линиями. Эта идея занимает центральное место в теории нейронных сетей. Теперь вам должно быть ясно, что с помощью множества прямых линий можно разде­ лить желаемым образом любую сколь угодно сложную конфигура­ цию областей, подлежащих классификации. Прежде чем мы займемся созданием нейронных сетей, которые предполагают существование нескольких классификаторов, работа­ ющих совместно, снова обратимся к природе и рассмотрим работу мозга животных, аналогии с которым послужили толчком к разра­ ботке подходов на основе нейронных сетей. 50 Глава 1. Как работают нейронные сети\n--- Страница 52 ---\nРезюме • Простой линейный классификатор не в состоянии разделить нужным образом области данных, если данные не управляются простым линейным процессом. Это было продемонстрировано на примере данных, управляемых логической функцией исключающего ИЛИ. • Однако эта проблема решается очень просто: для разграничения данных, кото­ рые не удается разделить одной прямой линей, следует использовать множес­ тво линейных классификаторов. Нейроны — вычислительные машины, созданные природой Ранее говорилось о том, что мозг животных ставил ученых в тупик, поскольку даже у столь малых представителей живой природы, как попугаи, он демонстрирует несравненно большие способности, чем цифровые компьютеры с огромным количеством электронных вычис­ лительных элементов и памятью невероятных объемов, работающих на частотах, недостижимых для живого мозга из плоти и крови. Тогда внимание сосредоточили на архитектурных различиях. В тра­ диционных компьютерах данные обрабатываются последовательно, по четко у станов ленным правилам. В их холодных запрограммирован­ ных расчетах нет места неоднозначности и неясности. С другой сторо­ ны, постепенно становилось понятно, что мозг животных, несмотря на кажущуюся замедленность его рабочих ритмов по сравнению с ком­ пьютерами, обрабатывает сигналы параллельно и что неопределенность является существенной отличительной чертой его деятельности. Рассмотрим строение базовой структурно-функциональной едини­ цы биологического мозга — нейрона. Нейроны — вычислительные машины, созданные природой 51\n--- Страница 53 ---\nНесмотря на то что нейроны существуют в различных формах, все они передают электрические сигналы от одного конца нейрона к дру­ гому — от дендритов через аксоны до терминал ей. Далее эти сигна­ лы передаются от одного нейрона к другому. Именно благодаря тако­ му механизму вы способны воспринимать свет, звук, прикосновение, тепло и т.п. Сигналы от специализированных рецепторных нейронов доставляются по вашей нервной системе до мозга, который в основ­ ном также состоит из нейронов. На приведенной ниже иллюстрации показана схема строения ней­ ронов мозга попугая, представленная одним испанским нейробиоло­ гом в 1899 году. На ней отчетливо видны важнейшие компоненты нейрона — дендриты и терминали. Сколько нейронов нам нужно для выполнения интересных, более сложных задач? 52 Глава 1. Как работают нейронные сети\n--- Страница 54 ---\nВ головном мозге человека, являющемся самым развитым, насчи­ тывается около 100 миллиардов нейронов. Мозг дрозофилы (плодо­ вой мушки) содержит примерно 100 тысяч нейронов, но она способна летать, питаться, избегать опасности, находить пищу и решать мно­ жество других довольно сложных задач. Это количество — 100 ты­ сяч — вполне сопоставимо с возможностями современных компьюте­ ров, и поэтому в попытке имитации работы такого мозга есть смысл. Мозг нематоды (круглого червя) насчитывает всего 302 нейрона — ничтожно малая величина по сравнению с ресурсами современных цифровых компьютеров! Но этот червь способен решать такие до­ вольно сложные задачи, которые традиционным компьютерам на­ много больших размеров пока что не по силам. В чем же секрет? Почему биологический мозг обладает столь заме­ чательными способностями, несмотря на то что работает медленнее и состоит из относительно меньшего количества вычислительных элементов по сравнению с современными компьютерами? Сложные механизмы функционирования мозга (например, наличие сознания) все еще остаются загадкой, но мы знаем о нейронах достаточно мно­ го для того, чтобы можно было предложить различные способы вы­ полнения вычислений, т.е. различные способы решения задач. Рассмотрим, как работает нейрон. Он принимает поступающий электрический сигнал и вырабатывает другой электрический сиг­ нал. Это очень напоминает работу моделей классификатора или пре­ диктора, которые получают некоторые входные данные, выполняют определенные вычисления и выдают результат. Так можем ли мы представить нейроны в виде линейных функций по аналогии с тем, что мы делали до этого? Нет, хотя сама по себе эта идея неплохая. Вырабатываемый нейроном выходной сигнал не явля­ ется простой линейной функцией входного сигнала, т.е. выходной сиг­ нал нельзя представить в виде выход = ( * вход) + ( другая константа). Согласно результатам наблюдений нейроны не реагируют немед­ ленно, а подавляют входной сигнал до тех пор, пока он не возрастет до такой величины, которая запустит генерацию выходного сигнала. Это можно представить себе как наличие некоего порогового значе­ ния, которое должно быть превышено, прежде чем будет сгенери­ рован выходной сигнал. Сравните поведение воды в чашке: вода не Нейроны — вычислительные машины, созданные природой 53\n--- Страница 55 ---\nсможет выплеснуться, пока чашка не наполнится. Интуитивно это понятно — нейроны пропускают лишь сильные сигналы, несущие полезную информацию, но не слабый шум. Идея вырабатывания вы­ ходного сигнала лишь в случаях, когда амплитуда входного сигнала достигает достаточной величины, превышающей некоторый порог, проиллюстрирована ниже в графическом виде. Функция, которая получает входной сигнал, но генерирует вы­ ходной сигнал с учетом порогового значения, называется функцией активации. С математической точки зрения существует множество таких функций, которые могли бы обеспечить подобный эффект. В качестве примера можно привести ступенчатую функцию. 54 Глава 1. Как работают нейронные сети\n--- Страница 56 ---\nНетрудно заметить, что для слабых входных значений выходное значение равно нулю. Но стоит превысить входной порог, как на вы­ ходе появляется сигнал. Искусственный нейрон с таким поведением напоминал бы настоящий биологический нейрон. Это очень хорошо описывается термином, который используется учеными: они гово­ рят, что нейрон возбуждается при достижении входным сигналом порогового значения. Ступенчатую функцию можно усовершенствовать. Представленную ниже S-образную функцию называют сигмоидой, или сигмоидальной функцией. Резкие прямоугольные границы ступенчатой функции в ней сглажены, что делает ее более естественной и реалистичной. Природа не любит острых углов! Нейроны — вычислительные машины, созданные природой 55\n--- Страница 57 ---\nСглаженная S-образная сигмоида — это и есть то, что мы бу­ дем использовать для создания собственной нейронной сети. Исследователями в области искусственного интеллекта использу­ ются также другие функции аналогичного вида, но сигмоида проста и очень популярна, так что она будет для нас отличным выбором. Сигмоида, которую иногда называют также логистической функ­ цией, описывается следующей формулой: Это выражение не настолько устрашающее, как поначалу может показаться. Буквой е в математике принято обозначать константу, равную 2,71828 Это очень интересное число, которое встречается во многих областях математики и физики, а причина, по которой я использовал в нем многоточие ( ), заключается в том, что запись десятичных знаков может быть продолжена до бесконечности. Для подобных чисел существует причудливое название — трансцендент­ ные числа. Все это, конечно, интересно, но для наших целей вполне достаточно считать, что это число просто равно 2,71828. Входное зна­ чение берется с отрицательным знаком, и е возводится в степень -х. Результат прибавляется к 1, что дает нам 1+е'\\ Наконец, мы обраща­ ем последнюю сумму, т.е. делим 1 на 1+е\\ Это и есть то, что делает приведенная выше функция с входным значением х для того, чтобы предоставить нам выходное значение у. Поэтому на самом деле ниче­ го страшного в ней нет. Просто ради интереса следует отметить, что при нулевом значении х выражение е * принимает значение 1, поскольку возведение любого числа в нулевую степень всегда дает 1. Поэтому у становится равным 1 / (1 + 1) или просто 1/2, т.е. половине. Следовательно, базовая сиг­ моида пересекает ось у при у=1/2. Существует еще одна, очень веская, причина для того, чтобы из множества всех S-образных функций, которые можно было бы ис­ пользовать для определения выходного значения нейрона, выбрать 56 Глава 1. Как работают нейронные сети\n--- Страница 58 ---\nименно сигмоиду. Дело в том, что выполнять расчеты с сигмоидой намного проще, чем с любой другой S-образной функцией, и вскоре вы на практике убедитесь в том, что это действительно так. Вернемся к нейронам и посмотрим, как мы можем смоделировать искусственный нейрон. Первое, что следует понять, — это то, что реальные биологические нейроны имеют несколько входов, а не только один. Мы уже сталки­ вались с этим на примере булевой логической машины с двумя вхо­ дами, поэтому идея более чем одного входа не будет для вас чем-то новым или необычным. Но что нам делать со всеми этими входами? Мы будем просто ком­ бинировать их, суммируя соответствующие значения, и результи­ рующая сумма будет служить входным значением для сигмоиды, управляющей выходным значением. Такая схема отражает принцип работы нейронной сети. Приведенная ниже диаграмма иллюстриру­ ет идею комбинирования входных значений и сравнения результи­ рующей суммы с пороговым значением. Если комбинированный сигнал недостаточно сильный, то сигмои­ да подавляет выходной сигнал. Если же сумма х достаточно велика, то функция возбуждает нейрон. Интересно отметить, что даже если только один сигнал достаточно сильный, в то время как все осталь­ ные имеют небольшую величину, то и этого может вполне хватить для возбуждения нейрона. Более того, нейрон может возбудиться Нейроны — вычислительные машины, созданные природой 57\n--- Страница 59 ---\nи тогда, когда каждый из сигналов, взятых по отдельности, имеет недостаточную величину, но, будучи взятыми вместе, они обеспе­ чивают превышение порога. В этом уже чувствуется прототип более сложных и в некотором смысле неопределенных вычислений, на ко­ торые способны подобные нейроны. Электрические сигналы воспринимаются дендритами, где они комбинируются, формируя более сильный сигнал. Если этот сигнал превышает порог, нейрон возбуждается, и сигнал передается через аксон к терминалам, откуда он поступает на дендриты следующего нейрона. Связанные таким способом нейроны схематически изобра­ жены на приведенной ниже иллюстрации. На этой схеме бросается в глаза то, что каждый нейрон принимает входной сигнал от нескольких находящихся перед ним нейронов и, в свою очередь, также передает сигнал многим другим в случае воз­ буждения. Одним из способов воспроизведения такого поведения нейронов, наблюдаемого в живой природе, в искусственной модели является создание многослойных нейронных структур, в которых каждый нейрон соединен с каждым из нейронов в предшествующем и после­ дующем слоях. Эта идея поясняется на следующей иллюстрации. 58 Глава 1. Как работают нейронные сети\n--- Страница 60 ---\nНа этой иллюстрации представлены три слоя, каждый из которых включает три искусственных нейрона, или узла. Как нетрудно заме­ тить, здесь каждый узел соединен с каждым из узлов предшествую­ щего и последующего слоев. Прекрасно! Но в какой части этой застывшей структуры заключена способность к обучению? Что мы должны регулировать, реагируя на данные тренировочных примеров? Есть ли здесь параметр, кото­ рый можно было бы улучшать подобно тому, как ранее мы делали это с наклоном прямой линейного классификатора? Наиболее очевидной величиной, регулировать которую мы могли бы, является сила связи между узлами. В пределах узла мы могли бы регулировать суммирование входных значений или же форму сигмо­ иды, но это уже немного сложнее предыдущей регулировки. Если работает более простой подход, то давайте им и ограничимся! На следующей диаграмме вновь показаны соединенные между собой Нейроны — вычислительные машины, созданные природой 59\n--- Страница 61 ---\nузлы, но на этот раз с каждым соединением ассоциируется опреде­ ленный вес. Низкий весовой коэффициент ослабляет сигнал, высо­ кий — усиливает его. Следует сказать несколько слов о небольших индексах, указанных рядом с коэффициентами. Например, символ W2 3 обозначает весовой коэффициент, связанный с сигналом, который передается от узла 2 данного слоя к узлу 3 следующего слоя. Следовательно, W x 2 — это весовой коэффициент, который ослабляет или усиливает сигнал, передаваемый от узла 1 к узлу 2 следующего слоя. Чтобы проиллю­ стрировать эту идею, на следующей диаграмме оба этих соединения между первым и вторым слоями выделены цветом. 60 Глава 1. Как работают нейронные сети\n--- Страница 62 ---\nВы могли бы вполне обоснованно подвергнуть сомнению данный замысел и задаться вопросом о том, почему каждый узел слоя дол­ жен быть связан с каждым из узлов предыдущего и последующего слоев. Это требование не является обязательным, и слои можно со­ единять между собой любым мыслимым способом. Мы не рассматри­ ваем здесь другие возможные способы по той причине, что благодаря однородности описанной схемы полного взаимного соединения ней­ ронов закодировать ее в виде компьютерных инструкций на самом деле значительно проще, чем любую другую схему, а также потому, что наличие большего количества соединений, чем тот их обязатель­ ный минимум, который может потребоваться для решения опреде­ ленной задачи, не принесет никакого вреда. Если дополнительные соединения действительно не нужны, то процесс обучения ослабит их влияние. Что под этим подразумевается? Это означает, что, как только сеть научится улучшать свои выходные значения путем уточнения весо­ вых коэффициентов связей внутри сети, некоторые веса обнулятся или станут близкими к нулю. В свою очередь, это означает, что такие связи не будут оказывать влияния на сеть, поскольку их сигналы не Нейроны — вычислительные машины, созданные природой 61\n--- Страница 63 ---\nбудут передаваться. Умножение сигнала на нулевой вес дает в ре­ зультате нуль, что означает фактический разрыв связи. Резюме • Биологический мозг демонстрирует выполнение таких сложных задач, как управление полетом, поиск пищи, изучение языка или избегание встреч с хищ­ никами, несмотря на меньший объем памяти и меньшую скорость обработки информации по сравнению с современными компьютерами. • Кроме того, биологический мозг невероятно устойчив к повреждениям и несо­ вершенству обрабатываемых сигналов по сравнению с традиционными компью­ терными системами. • Биологический мозг, состоящий из взаимосвязанных нейронов, является источ­ ником вдохновения для разработчиков систем искусственного интеллекта. Распространение сигналов по нейронной сети Приведенная выше картинка с тремя слоями нейронов, каждый из которых связан с каждым из нейронов в предыдущем и следую­ щем слоях, выглядит довольно привлекательно. Однако интуиция подсказывает нам, что рассчитать распростране­ ние входных сигналов по всем слоям, пока они не превратятся в вы­ ходные сигналы, не так-то просто, и нам, скажем так, придется хо­ рошенько потрудиться! Я согласен, что эта работа непростая, но также важно показать, как работает этот механизм, чтобы мы всегда четко представляли себе, что происходит в нейронной сети на самом деле, даже если впо­ следствии мы используем компьютер, который выполнит вместо нас всю работу. Поэтому мы попытаемся проделать необходимые вычис­ ления на примере меньшей нейронной сети, состоящей всего лишь из двух слоев, каждый из которых включает по 2 нейрона, как по­ казано ниже. 62 Глава 1. Как работают нейронные сети\n--- Страница 64 ---\nПредположим, что сигналам на входе соответствуют значения 1,0 и 0,5. Как и раньше, каждый узел превращает сумму двух входных сиг­ налов в один выходной с помощью функции активации. Мы также 1 будем использовать сигмоиду У = ^ + е - х > с которой вы до этого позна­ комились, где х — это сумма сигналов, поступающих в нейрон, а у — выходной сигнал этого нейрона. Распространение сигналов по нейронной сети 63\n--- Страница 65 ---\nА что насчет весовых коэффициентов? Это очень хороший во­ прос: с какого значения следует начать? Давайте начнем со случай­ ных весов: • w i , i = 0 ’ 9 * W l,2 = 0’ 2 • = 0,3 * W2,2 = 0 ’ 9 Выбор случайных начальных значений — не такая уж плохая идея, и именно так мы и поступали, когда ранее выбирали случайное начальное значение наклона прямой для простого линейного клас­ сификатора. Случайное значение улучшалось с каждым очередным тренировочным примером, используемым для обучения классифика­ тора. То же самое должно быть справедливым и для весовых коэффи­ циентов связей в нейронных сетях. В данном случае, когда сеть небольшая, мы имеем всего четыре весовых коэффициента, поскольку таково количество всех возмож­ ных связей между узлами при условии, что каждый слой содержит по два узла. Ниже приведена диаграмма, на которой все связи про­ маркированы соответствующим образом. Приступим к вычислениям! 64 Глава 1. Как работают нейронные сети\n--- Страница 66 ---\nПервый слой узлов — входной, и его единственное назначение — представлять входные сигналы. Таким образом, во входных узлах функция активации к входным сигналам не применяется. Мы не выдвигаем в отношении этого никаких разумных доводов и просто принимаем как данность, что первый слой нейронных сетей являет­ ся всего лишь входным слоем, представляющим входные сигналы. Вот и все. С первым слоем все просто — никаких вычислений. Далее мы должны заняться вторым слоем, в котором потребует­ ся выполнить некоторые вычисления. Нам предстоит определить входной сигнал для каждого узла в этом слое. Помните сигмоиду I / =— ^ — ? В этой функции х — комбинированный сигнал на входе 1 + е узла. Данная комбинация образуется из необработанных выходных сигналов связанных узлов предыдущего слоя, сглаженных весовыми коэффициентами связей. Приведенная ниже диаграмма аналогич­ на тем, с которыми вы уже сталкивались, но теперь на ней указано сглаживание поступающих сигналов за счет применения весовых ко­ эффициентов связей. Для начала сосредоточим внимание на узле 1 слоя 2. С ним свя­ заны оба узла первого, входного слоя. Исходные значения на этих входных узлах равны 1,0 и 0,5. Связи первого узла назначен весовой Распространение сигналов по нейронной сети 65\n--- Страница 67 ---\nкоэффициент 0,9, связи второго — 0,3. Поэтому сглаженный вход­ ной сигнал вычисляется с помощью следующего выражения: х= ( выход первого узла* вес связи) + + ( выход второго узла * вес связи) х= (1,0 * 0,9) + (0,5 * 0,3) х = 0, 9 + 0,15 х = 1, 05 Без сглаживания сигналов мы просто получили бы их сумму 1,0 + 0,5, но мы этого не хотим. Именно с весовыми коэффициента­ ми будет связан процесс обучения нейронной сети по мере того, как они будут итеративно уточняться для получения все лучшего и луч­ шего результата. Итак, мы уже имеем значение х=1,05 для комбинированного сгла­ женного входного сигнала первого узла второго слоя и теперь рас­ полагаем всеми необходимыми данными, чтобы рассчитать для это­ го узла выходной сигнал с помощью функции активации у =-----—.1 + е Попробуйте справиться с этим самостоятельно, используя калькуля­ тор. Вот правильный ответ: у = 1 / (1 + 0,3499) = 1 / 1,3499. Таким об­ разом, у=0,7408. Отличная работа! Мы рассчитали фактический выходной сигнал для одного из двух выходных узлов сети. Повторим те же вычисления для оставшегося узла — узла 2 второ­ го слоя, т.е. вновь вычислим сглаженный входной сигнал с помощью следующего выражения: х = ( выход первого узла * вес связи) + + ( выход второго узла * вес связи) х= (1,0 * 0,2) + (0,5 * 0,8) х = 0,2 + 0,4 х = 0, б Располагая значением х, можно рассчитать выходной сигнал узла с помощью функции активации: у=1/ (1 + 0,5488) = 1 /1 , 5 4 8 8 . Таким образом, у=0,6457. 66 Глава 1. Как работают нейронные сети\n--- Страница 68 ---\nРассчитанные нами выходные сигналы сети представлены на при­ веденной ниже диаграмме. Как видите, чтобы получить всего лишь два выходных сигнала для весьма простой нейронной сети, нам пришлось хорошо потру­ диться. Лично я не был бы в восторге от необходимости проведения аналогичных расчетов вручную в случае более крупных сетей! К сча­ стью, для выполнения подобных вычислений идеально подходят компьютеры, которые могут быстро справиться с этой работой, из­ бавив вас от лишних хлопот. Однако даже с учетом этого я не горел бы желанием выписывать соответствующие программные инструкции для сети, насчитываю­ щей более двух слоев, каждый из которых может включать 4, 8 или даже 100 узлов. Стоит ли говорить о том, насколько это утомитель­ ное занятие, к тому же оно чревато большим количеством ошибок и опечаток, что вообще может сделать выполнение расчетов практи­ чески невозможным. Но нам повезло. Математики разработали чрезвычайно компакт­ ный способ записи операций того типа, которые приходится выполнять для вычисления выходного сигнала нейронной сети, даже если она со­ держит множество слоев и узлов. Эта компактность благоприятна не только для людей, которые выписывают или читают соответствующие Распространение сигналов по нейронной сети 67\n--- Страница 69 ---\nформулы, но и для компьютеров, поскольку программные инструкции получаются более короткими и выполняются намного быстрее. В этом компактном подходе предполагается использование мат­ риц, к рассмотрению которых мы сейчас и приступим. Какая все-таки отличная вещь — умножение матриц! Матрицы пользуются ужасной репутацией. Они вызывают вос­ поминания о тех долгих и утомительных часах, которые в студен­ ческие годы приходилось тратить на, казалось бы, совершенно бес­ цельное и никому не нужное занятие — перемножение матриц. Перед этим мы вручную выполнили вычисления для двухслойной сети, содержащей всего лишь по 2 узла в каждом слое. Однако даже в этом случае объем работы оказался довольно большим, а что тогда можно сказать, например, о сети, состоящей из пяти слоев по 100 уз­ лов? Уже сама по себе запись всех необходимых выражений была бы сложной задачей. Составление комбинаций сигналов, умноже­ ние на подходящие весовые коэффициенты, применение сигмоиды для каждого узла Ух! Так чем же нам могут помочь матрицы? Они будут нам полезны в двух отношениях. Во-первых, они обеспечивают сжатую запись операций, придавая им чрезвычайно компактную форму. Это боль­ шой плюс для нас, поскольку такая работа утомительна, требует концентрации внимания и чревата ошибками. Во-вторых, в боль­ шинстве компьютерных языков программирования предусмотрена работа с матрицами, а поскольку многие операции при этом повто­ ряются, компьютеры распознают это и выполняют их очень быстро. Резюмируя, можно сказать, что матрицы позволяют формулиро­ вать задачи в более простой и компактной форме и обеспечивают их более быстрое и эффективное выполнение. Теперь, когда вам известны причины, по которым мы собираемся воспользоваться матрицами несмотря на возможный горький опыт знакомства с ними в студенческие годы, давайте демистифицируем матрицы, начав работать с ними. 68 Глава 1. Как работают нейронные сети\n--- Страница 70 ---\nМатрица — это всего лишь таблица, прямоугольная сетка, образо­ ванная числами. Вот и все. Все, что связано с матрицами, ничуть не сложнее этого. Если вы уже пользовались электронными таблицами, то никаких сложностей при работе с числами, располагающимися в ячейках сет­ ки, у вас возникнуть не должно. Ниже показан пример рабочего ли­ ста Excel с числовой таблицей. При обозначении матриц принято указывать сначала количество строк, а затем количество столбцов. Поэтому размерность данной ма­ трицы не 3x2, а 2x3. Какая все-таки отличная вещь — умножение матриц! 69Это и есть матрица — таблица или сетка, образованная числами, точно так же, как и следующий пример матрицы размером 2x3.\n--- Страница 71 ---\nКроме того, иногда матрицы заключают в квадратные скобки, иногда — в круглые, как это сделали мы. На самом деле матрицы не обязательно должны состоять из чисел. Они могут включать величины, которым мы дали имена, но не при­ своили фактических значений. Поэтому на следующей иллюстрации также показана матрица с элементами в виде переменных, каждая из которых имеет определенный смысл и может иметь значение, просто мы пока не указали, что это за значения. Чем полезны матрицы, вам станет понятно, когда мы рассмотрим, как они умножаются. Возможно, вы это помните еще из курса выс­ шей математики, а если нет, то освежите свою память. Вот пример умножения одной простой матрицы на другую. Как видите, эта операция не сводится к простому перемножению соответствующих элементов. Левый верхний элемент не равен 1*5, как и правый нижний — не 4*8. 70 Глава 1. Как работают нейронные сети\n--- Страница 72 ---\nВместо этого матрицы умножаются по другим правилам. Возможно, вы и сами догадаетесь, по каким именно, если вниматель­ но присмотритесь к примеру. Если нет, то взгляните на приведенную ниже иллюстрацию, где показано, как получается ответ для левого верхнего элемента. Вы видите, что верхний левый элемент вычисляется с использо­ ванием верхней строки первой матрицы и левого столбца второй. Мысленно перебирая обе последовательности элементов, пере­ множьте их попарно и сложите полученные результаты. Таким об­ разом, чтобы вычислить левый верхний элемент результирующей матрицы, мы начинаем перемещаться вдоль верхней строки первой матрицы, где находим число 1, а начиная перемещение вниз по ле­ вому столбцу второй матрицы, находим число 5. Мы перемножа­ ем их и запоминаем результат, который равен 5. Мы продолжаем перемещаться вдоль ряда и вниз по столбцу и находим элементы 2 и 7. Результат их перемножения, равный 14, мы также запоми­ наем. При этом мы уже достигли конца строки и столбца, поэто­ му суммируем числа, которые перед этим запомнили, и получаем в качестве результата число 19. Это и есть левый верхний элемент результирующей матрицы. Описание получилось длинным, но выполнение самих действий не отнимает много времени. Продолжите далее самостоятельно. На приведенной ниже иллюстрации показано, как вычисляется правый нижний элемент результирующей матрицы. Какая все-таки отличная вещь — умножение матриц! 71\n--- Страница 73 ---\nВы вновь можете видеть, как, используя строку и столбец, кото­ рые соответствуют искомому элементу (в данном случае вторая стро­ ка и второй столбец), мы получаем два произведения, ) и (4*8), сложение которых дает 18 + 32 = 50. Продолжая действовать в таком же духе, находим, что левый нижний элемент равен (3*5) + (4*7) = 15 + 28 = 43, а правый верх­ ний — (1*6) + (2*8) = 6 + 16 = 22. На следующей иллюстрации продемонстрировано использование переменных вместо чисел: Это всего лишь другой способ описания подхода, с помощью ко­ торого мы умножаем матрицы. Используя буквы, вместо которых могут быть подставлены любые числа, мы даем общее описание это­ го подхода. Такое описание действительно является более общим, чем предыдущее, поскольку применимо к матрицам различных размеров. 72 Глава 1. Как работают нейронные сети\n--- Страница 74 ---\nГоворя о применимости описанного подхода к матрицам любо­ го размера, следует сделать одну важную оговорку: умножаемые матрицы должны быть совместимыми. Вы поймете, в чем здесь дело, вспомнив, как отбирали попарно элементы из строк первой матрицы и столбцов второй: этот метод не сможет работать, если количество элементов в строке не будет совпадать с количеством элементов в столбце. Поэтому вы не сможете умножить матрицу 2x2 на матрицу 5x5. Попытайтесь это сделать, и сами увидите, по­ чему это невозможно. Чтобы матрицы можно было умножить, ко­ личество столбцов в первой из них должно совпадать с количеством строк во второй. В разных руководствах этот тип матричного умножения может встречаться под разными названиями: скалярное произведение, то­ чечное произведение или внутреннее произведение. В математике возможны и другие типы умножения матриц, такие как перекрест­ ное произведение, но мы будем работать с точечным произведением матриц. Но почему мы должны углубляться в дебри этого ужасного мат­ ричного умножения и отвратительной алгебры? На то есть серьезная причина Крепитесь! Посмотрим, что произойдет, если заменить буквы словами, име­ ющими более непосредственное отношение к нашей нейронной сети. На приведенной ниже иллюстрации вторая матрица имеет размер­ ность 2x1, но матричная алгебра остается прежней. Иначе как магией это никак не назовешь! Первая матрица содержит весовые коэффициенты для связей между узлами двух слоев, вторая — сигналы первого, входного слоя. Результатом умножения этих двух матриц является объеди­ ненный сглаженный сигнал, поступающий на узлы второго слоя. Присмотритесь повнимательнее, и вы это поймете. На первый узел поступает сумма двух сигналов — сигнала input_l, умноженного Какая все-таки отличная вещь — умножение матриц! 73\n--- Страница 75 ---\nна весовой коэффициент w x х , и сигнала input_2, умноженного на ве­ совой коэффициент w 2 х . Это значения х до применения к ним функ­ ции активации. Представим все это в более наглядной форме с помощью иллю­ страции. Описанный подход чрезвычайно полезен. Почему? Потому что в его рамках все вычисления, которые необ­ ходимы для расчета входных сигналов, поступающих на каждый из узлов второго слоя, могут быть выражены с использованием матрич­ ного умножения, обеспечивающего чрезвычайно компактную форму записи соответствующих операций: X = W I 74 Глава 1. Как работают нейронные сети\n--- Страница 76 ---\nЗдесь W — матрица весов, I — матрица входных сигналов, а X — результирующая матрица комбинированных сглаженных сигна­ лов, поступающих в слой 2. Символы матриц часто записывают с использованием полужирного шрифта, чтобы подчеркнуть, что данные символы представляют матрицы, а не просто одиночные числа. Теперь нам не нужно заботиться о том, сколько узлов входит в каждый слой. Увеличение количества слоев приводит лишь к уве­ личению размера матриц. Но количество символов в записи при этом не увеличивается. Она остается по-прежнему компактной, и мы про­ сто записываем произведение матриц в виде W -I, независимо от ко­ личества элементов в каждой из них, будь это 2 или же 200! Если используемый язык программирования распознает матрич­ ную нотацию, то компьютер выполнит все трудоемкие расчеты, свя­ занные с вычислением выражения X = W • I, без предоставления ему отдельных инструкций для каждого узла в каждом слое. Это просто фантастика! Затратив немного времени на то, чтобы по­ нять суть матричного умножения, мы получили в свое распоряже­ ние мощнейший инструмент для реализации нейронных сетей без каких-либо особых усилий с нашей стороны. А что насчет функции активации? Здесь все просто и не требует при­ менения матричной алгебры. Все, что нам нужно сделать, — это приме- 1нить сигмоиду у =------— к каждому отдельному элементу матрицы X .1 + е Это звучит слишком просто, но так оно и есть, поскольку нам не приходится комбинировать сигналы от разных узлов: это уже сдела­ но, и вся необходимая информация уже содержится в X. Как мы уже видели, роль функции активации заключается в применении порого­ вых значений и подавлении ненужных сигналов с целью имитации поведения биологических нейронов. Поэтому результирующий вы­ ходной сигнал второго слоя можно записать в таком виде: О = сигмоида(X) Здесь символом О , выделенным полужирным шрифтом, обозна­ чена матрица, которая содержит все выходные сигналы последнего слоя нейронной сети. Какая все-таки отличная вещь — умножение матриц! 75\n--- Страница 77 ---\nВыражение X = W • I применяется для вычисления сигналов, про­ ходящих от одного слоя к следующему слою. Например, при нали­ чии трех слоев мы просто вновь выполним операцию умножения ма­ триц, использовав выходные сигналы второго слоя в качестве вход­ ных для третьего, но, разумеется, предварительно скомбинировав их и сгладив с помощью дополнительных весовых коэффициентов. На данном этапе мы закончили с теорией и теперь должны посмо­ треть, как она работает, обратившись к конкретному примеру, кото­ рый на этот раз будет представлять нейронную сеть несколько боль­ шего размера, с тремя слоями по три узла. Резюме • Многие вычисления, связанные с распространением сигналов по нейронной сети, могут быть выполнены с использованием операции матричного умножения. • Использование матричного умножения обеспечивает компактную запись выра­ жений, размер которых не зависит от размеров нейронной сети. • Что немаловажно, операции матричной алгебры изначально предусмотрены в ряде языков программирования, благодаря чему могут выполняться быстро и эффективно. Пример использования матричного умножения в сети с тремя слоями Мы пока еще не использовали матрицы для выполнения расче­ тов, связанных с вычислением сигналов на выходе нейронной сети. Кроме того, мы пока что не обсуждали примеры с более чем двумя слоями, что было бы гораздо интереснее, поскольку мы должны по­ смотреть, как обрабатываются выходные сигналы промежуточного слоя в качестве входных сигналов последнего, третьего слоя. На следующей диаграмме представлен пример нейронной сети, включающей три слоя по три узла. Чтобы избежать загромождения диаграммы лишними надписями, некоторые веса на ней не указаны. 76 Глава 1. Как работают нейронные сети\n--- Страница 78 ---\nМы начнем со знакомства с общепринятой терминологией. Как мы знаем, первый слой — входной, а второй — выходной. Промежуточный слой называется скрытым слоем. Это звучит зага­ дочно и таинственно, но, к сожалению, здесь нет ничего загадочно­ го и таинственного. Такое название закрепилось за промежуточным слоем из-за того, что его выходные сигналы не обязательно проявля­ ются как таковые, отсюда и термин “скрытый” . Приступим к работе над примером, представленным на этой диа­ грамме. Входными сигналами нейронной сети являются следующие: 0,9; 0,1 и 0,8. Поэтому входная матрица I имеет следующий вид. Пример использования матричного умножения в сети с тремя слоями 77Это было просто, т.е. с первым слоем мы закончили, поскольку его единственная задача — просто представлять входной сигнал.\n--- Страница 79 ---\nСледующий на очереди — промежуточный слой. В данном случае нам придется вычислить комбинированные (и сглаженные) сигналы для каждого узла этого слоя. Вспомните, что каждый узел проме­ жуточного скрытого слоя связан с каждым из узлов входного слоя, поэтому он получает некоторую часть каждого входного сигнала. Однако сейчас мы будем действовать более эффективно, чем раньше, поскольку попытаемся применить матричный метод. Как уже было показано, сглаженные комбинированные входные сигналы для этого слоя определяются выражением X = W -I, где I — матрица входных сигналов, a W — матрица весов. Мы располагаем матрицей I, но что такое W ? Некоторые из весовых коэффициентов (выбранные случайным образом) показаны на диаграмме для этого примера, но не все. Ниже представлены все весовые коэффициен­ ты (опять-таки, каждый из них выбирался как случайное число). Никакие особые соображения за их выбором не стояли. Как нетрудно заметить, весовой коэффициент для связи между первым входным узлом и первым узлом промежуточного скрытого слоя W j j=0,9, как и на приведенной выше диаграмме. Точно так же весовой коэффициент для связи между вторым входным узлом и вто­ рым узлом скрытого слоя w 22 =0,8. На диаграмме не показан весовой коэффициент для связи между третьим входным узлом и первым уз­ лом скрытого слоя w 3 j=0,4. Постойте-ка, а почему мы снабдили матрицу W индексом “входной_ скрытый”? Да потому, что матрица К в х о д н о й с к р ы т ы й содержит весовые ко­ эффициенты для связей между входным и скрытым слоями. Коэф­ фициенты для связей между скрытым и выходным слоями будут содер­ жаться в другой матрице, которую мы обозначим как И с к р ы т ы й в ы х о д н о й . Эта вторая матрица И с к р ы т ы й _В Ь 1 Х 0 Д Н 0 Й , элементы которой, как и эле­ менты предыдущей матрицы, представляют собой случайные числа, 78 Глава 1. Как работают нейронные сети\n--- Страница 80 ---\nприведена ниже. Например, вы видите, что весовой коэффициент для связи между третьим скрытым узлом и третьим выходным уз­ лом w 3 з=0,9. Отлично, необходимые матрицы получены. Продолжим нашу работу и определим комбинированный сглажен­ ный сигнал для скрытого слоя. Кроме того, мы должны присвоить ему описательное имя, снабженное индексом, который указывает на то, что это входной сигнал для скрытого, а не последнего слоя. Назовем соответствующую матрицу Х с к р ы т ы й : X =W • Iскрытый входной_скрытый Мы не собираемся выполнять вручную все действия, связанные с перемножением матриц. Выполнение этой трудоемкой работы мы будем поручать компьютеру, ведь именно с этой целью мы использу­ ем матрицы. В данном случае готовый ответ выглядит так. Пример использования матричного умножения в сети с тремя слоями 79\n--- Страница 81 ---\nЯ получил этот ответ с помощью компьютера, и вы научитесь де­ лать это, используя язык программирования Python, о чем мы по­ говорим далее. Мы не будем заниматься этим сейчас, чтобы пока что не отвлекаться на обсуждение программного обеспечения. Итак, мы располагаем комбинированными сглаженными вход­ ными сигналами скрытого промежуточного слоя, значения которых равны 1,16; 0,42 и 0,62. Для выполнения всех необходимых вычис­ лений были использованы матрицы. Это достижение, которым мы вправе гордиться! Отобразим входные сигналы для скрытого второго слоя на диа­ грамме. Пока что все хорошо, но нам еще остается кое-что сделать. Как вы помните, чтобы отклик слоя на входной сигнал как можно лучше имитировал аналогичный реальный процесс, мы должны применить к узлам функцию активации. Так и поступим: °скрЫТЫй = с и гм о и д а (Х скры ты й 80 Глава 1. Как работают нейронные сети\n--- Страница 82 ---\nПрименяя сигмоиду к каждому элементу матрицы Хскры ты й, мы по­ лучаем матрицу выходных сигналов скрытого промежуточного слоя. Для уверенности давайте проверим, правильно ли вычислен пер­ вый элемент. Наша сигмоида имеет вид у = — -— . Полагая х=1,16, получаем е1 Д в = 0,3135. Это означает, что у = 1 / (1 + 0,3135) = 0,761. Нетрудно заметить, что все возможные значения этой функции находятся в пределах от 0 до 1. Вернитесь немного назад и взгляните на график логистической функции, если хотите убедиться в том, что это действительно так. Ух! Давайте немного передохнем и подытожим, что мы к этому времени успели сделать. Мы рассчитали прохождение сигнала через промежуточный слой, т.е. определили значения сигналов на его вы­ ходе. Для полной ясности уточним, что эти значения были получены путем применения функции активации к комбинированным вход­ ным сигналам промежуточного слоя. Обновим диаграмму в соответ­ ствии с этой новой информацией Пример использования матричного умножения в сети с тремя слоями 81\n--- Страница 83 ---\nЕсли бы это была двухслойная нейронная сеть, то мы сейчас оста­ новились бы, поскольку получили выходные сигналы второго слоя. Однако мы продолжим, поскольку есть еще и третий слой. Как рассчитать прохождение сигнала для третьего слоя? Точно так же, как и для второго, поскольку эта задача на самом деле ни­ чем не отличается от предыдущей. Нам известна величина входных сигналов, получаемых третьим слоем, как ранее была известна ве­ личина входных сигналов, получаемых вторым слоем. У нас также есть весовые коэффициенты для связей между узлами, ослабляющие сигналы. Наконец, чтобы отклик сети максимально правдоподобно имитировал естественный процесс, мы по-прежнему можем приме­ нить функцию активации. Поэтому вам стоит запомнить следующее: независимо от количества слоев в нейронной сети, вычислительная процедура для каждого из них одинакова — комбинирование вход­ ных сигналов, сглаживание сигналов для каждой связи между уз­ лами с помощью весовых коэффициентов и получение выходного сигнала с помощью функции активации. Нам безразлично, сколько слоев образуют нейронную сеть — 3, 53 или 103, ведь к любому из них применяется один и тот же подход. 82 Глава 1. Как работают нейронные сети\n--- Страница 84 ---\nИтак, продолжим вычисления и рассчитаем сглаженный комби­ нированный входной сигнал X = W • I для третьего слоя. Входными сигналами для третьего слоя служат уже рассчитанные нами выходные сигналы второго слоя 0с к р ы т ы й . При этом мы должны использовать весовые коэффициенты для связей между узлами вто­ рого и третьего слоев И с к р ы т ы й в ы х о д н о й , а не те, которые мы уже исполь­ зовали для первого и второго слоев. Следовательно, мы имеем: X = W . - О _выходной скрытый_выходной скрытый Поэтому, действуя, как и прежде, мы получаем для сглаженных комбинированных входных сигналов последнего выходного слоя следующее выражение: Обновленная диаграмма отражает наш прогресс в расчете преоб­ разования начальных сигналов, поступающих на узлы первого слоя, в сглаженные комбинированные сигналы, поступающие на узлы по­ следнего слоя, в процессе их распространения по нейронной сети. Пример использования матричного умножения в сети с тремя слоями 83\n--- Страница 85 ---\nВсе, что нам остается, — это применить сигмоиду, и сделать это не составляет труда. Есть! Мы получили сигналы на выходе нейронной сети. Опять- таки, отобразим текущую ситуацию на обновленной диаграмме. 84 Глава 1. Как работают нейронные сети\n--- Страница 86 ---\nТаким образом, в нашем примере нейронной сети с тремя слоя­ ми выходные сигналы имеют следующую величину: 0,726;ы 0,708 и 0,778. Итак, нам удалось успешно описать распространение сигналов по нейронной сети, т.е. определить величину выходных сигналов при заданных величинах входных сигналов. Что дальше? Наш следующий шаг заключается в сравнении выходных сигна­ лов нейронной сети с данными тренировочного примера для опреде­ ления ошибки. Нам необходимо знать величину этой ошибки, чтобы можно было улучшить выходные результаты путем изменения пара­ метров сети. Пожалуй, эта часть работы наиболее трудна для понимания, по­ этому мы будем продвигаться не спеша, постепенно знакомясь с ос­ новными идеями в процессе работы. Корректировка весовых коэффициентов в процессе обучения нейронной сети Ранее мы улучшали поведение простого линейного классифика­ тора путем регулирования параметра наклона линейной функции Корректировка весовых коэффициентов в процессе обучения нейронной сети 85\n--- Страница 87 ---\nузла. Мы делали это, руководствуясь текущей величиной ошибки, т.е. разности между ответом, вырабатываемым узлом, и известным нам истинным значением. Ввиду простоты соотношения между ве­ личинами ошибки и поправки это было несложно. Как нам обновлять весовые коэффициенты связей в случае, если выходной сигнал и его ошибка формируются за счет вкладов более чем одного узла? Эту задачу иллюстрирует приведенная ниже диа­ грамма. Когда на выходной узел поступал сигнал только от одного узла, все было намного проще. Но как использовать ошибку выходного сигнала при наличии двух входных узлов? Использовать всю величину ошибки для обновления только одного весового коэффициента не представляется разумным, поскольку при этом полностью игнорируются другая связь и ее вес. Но ведь величина ошибки определяется вкладами всех связей, а не только одной. Правда, существует небольшая вероятность того, что за ошибку ответственна только одна связь, но эта вероятность пренебрежимо мала. Если мы изменили весовой коэффициент, уже имеющий “пра­ вильное” значение, и тем самым ухудшили его, то при выполнении нескольких последующих итераций он должен улучшиться, так что не все потеряно. Один из возможных способов состоит в том, чтобы распределить ошибку поровну между всеми узлами, вносящими вклад, как пока­ зано на следующей диаграмме. 86 Глава 1. Как работают нейронные сети\n--- Страница 88 ---\nСуть другой идеи также заключается в том, чтобы распределять ошибку между узлами, однако это распределение не обязано быть равномерным. Вместо этого большая доля ошибки приписывается вкладам тех связей, которые имеют больший вес. Почему? Потому что они оказывают большее влияние на величину ошибки. Эту идею иллюстрирует следующая диаграмма. В данном случае сигнал, поступающий на выходной узел, форми­ руется за счет двух узлов. Весовые коэффициенты связей равны 3,0 и 1,0. Распределив ошибку между двумя узлами пропорционально их весам, вы увидите, что для обновления значения первого, боль­ шего веса следует использовать 3/4 величины ошибки, тогда как для обновления значения второго, меньшего веса — 1/4. Мы можем расширить эту идею на случаи с намного большим ко­ личеством узлов. Если бы выходной узел был связан со ста входны­ ми узлами, мы распределили бы выходную ошибку между всеми ста Корректировка весовых коэффициентов в процессе обучения нейронной сети 87\n--- Страница 89 ---\nсвязями пропорционально их вкладам, размер которых определяет­ ся весами соответствующих связей. Как вы могли заметить, мы используем весовые коэффициенты в двух целях. Во-первых, они учитываются при расчете распростра­ нения сигналов по нейронной сети от входного слоя до выходного. Мы интенсивно использовали их ранее именно в таком качестве. Во-вторых, мы используем веса для распространения ошибки в об­ ратном направлении — от выходного слоя вглубь сети. Думаю, вы не будете удивлены, узнав, что этот метод называется обратным рас­ пространением ошибки (обратной связью) в процессе обучения ней­ ронной сети. Если бы выходной слой имел два узла, мы повторили бы те же действия и для второго узла. Второй выходной узел будет характе­ ризоваться собственной ошибкой, распределяемой аналогичным об­ разом между соответствующим количеством входных узлов. Теперь продолжим наше рассмотрение. Обратное распространение ошибок от большего количества выходных узлов На следующей диаграмме отображена простая сеть с двумя вход­ ными узлами, но на этот раз с двумя выходными узлами. 88 Глава 1. Как работают нейронные сети\n--- Страница 90 ---\nОшибка может формироваться на обоих узлах — фактически эта ситуация очень похожа на ту, которая возникает, когда сеть еще не обучалась. Вы видите, что для коррекции весов внутренних связей нужна информация об ошибках в обоих узлах. Мы можем использо­ вать прежний подход и распределять ошибку выходного узла между связанными с ним узлами пропорционально весовым коэффициен­ там соответствующих связей. В действительности тот факт, что сейчас имеется более чем один выходной узел, ничего не меняет. Мы просто повторяем для второго узла те же действия, которые уже выполняли для первого. Почему все так просто? Эта простота объясняется тем, что связи одного вы­ ходного узла не зависят от связей другого. Между этими двумя на­ борами связей отсутствует какая-либо зависимость. Вернемся к диаграмме, на которой ошибка на первом выходном узле обозначена как ег Не забывайте, что это разность между же­ лаемым значением, предоставляемым тренировочными данными t 1 ? и фактическим выходным значением ог Таким образом, = (tj - Oj). Ошибка на втором выходном узле обозначена как е2 . На диаграмме видно, что ошибка распределяется пропорцио­ нально весам связей, обозначенным как w n и w 2 1 . Точно так же ошиб­ ка е2 должна распределяться пропорционально весам w 1 2 и w 2 2 . Чтобы у вас не возникало никаких сомнений в правильности получаемых результатов, запишем эти доли в явном виде. Ошибка информирует о величинах поправок для весов wn и w 2 1 . При ее распределении между узлами доля ег, информация о которой ис­ пользуется для обновления wn, определяется следующим выраже­ нием: Обратное распространение ошибок от большего количества выходных узлов 89\n--- Страница 91 ---\nДоля ех , используемая для обновления w 2 1 , определяется аналогич­ ным выражением: Возможно, эти выражения несколько смущают вас, поэтому рас­ смотрим их более подробно. За всеми этими символами стоит очень простая идея, которая заключается в том, что узлы, сделавшие боль­ ший вклад в ошибочный ответ, получают больший сигнал об ошиб­ ке, тогда как узлы, сделавшие меньший вклад, получают меньший сигнал. Если w u в два раза превышает w 2 1 (скажем, w x x =6, a w 2 X =3), то доля ех , используемая для обновления w u, составляет 6/(6+3) = 6/9 = 2/3. Тогда для другого, меньшего веса w 2 X должно остаться 1/3 ех , что можно подтвердить с помощью выражения ЗДб+З) = 3/9, результат которого действительно равен 1/3. Как и следовало ожидать, при равных весах будут равны и соот­ ветствующие доли. Давайте в этом убедимся. Пусть w n=4 и w 2 X =4, тог­ да в обоих случаях доля будет составлять 4Д4+4) = 4/8 = 1/2. Прежде чем продолжить, сделаем паузу и вернемся на шаг на­ зад, чтобы оценить то, что мы уже успели сделать. Мы знали, что при определении величины поправок для некоторых внутренних параметров сети, в данном случае — весов связей, необходимо ис­ пользовать величину ошибки. Вы видели, как это делается для ве­ сов, которые сглаживают входные сигналы последнего, выходного слоя нейронной сети. Вы также видели, что увеличение количества выходных узлов не усложняет задачу, поскольку мы повторяем одни и те же действия для каждого выходного узла. Замечательно! Но как быть, если количество слоев превышает два? Как обнов­ лять веса связей для слоев, далеко отстоящих от последнего, выход­ ного слоя? 90 Глава 1. Как работают нейронные сети\n--- Страница 92 ---\nОбратное распространение ошибок при большом количестве слоев На следующей диаграмме представлен пример простой нейронной сети с тремя слоями: входным, скрытым и выходным. Продвигаясь в обратном направлении от последнего, выходного слоя (крайнего справа), мы видим, как информация об ошибке в вы­ ходном слое используется для определения величины поправок к ве­ совым коэффициентам связей, со стороны которых к нему поступа­ ют сигналы. Здесь использованы более общие обозначения ев ы х о д н о й для выходных ошибок и wc b для весов связей между скрытым и вы­ ходным слоями. Мы вычисляем конкретные ошибки, ассоциируе­ мые с каждой связью, путем распределения ошибки пропорциональ­ но соответствующим весам. Графическое представление позволяет лучше понять, какие вы­ числения следует выполнить для дополнительного слоя. Мы просто берем ошибки ес к р ы т ы й на выходе скрытого слоя и вновь распределяем их по предшествующим связям между входным и скрытым слоями пропорционально весовым коэффициентам w . Следующая диаграм­ ма иллюстрирует эту логику. Обратное распространение ошибок при большом количестве слоев 91\n--- Страница 93 ---\nПри наличии большего количества слоев мы просто повторили бы описанную процедуру для каждого слоя, продвигаясь в обратном направлении от последнего, выходного слоя. Идея распространения этого потока информации об ошибке (сигнала об ошибке) интуитив­ но понятна. Вы еще раз имели возможность увидеть, почему этот процесс описывается термином обратное распространение ошибок. Если мы сначала использовали ошибку ев ы х о д н о й выходного сиг­ нала узлов выходного слоя, то какую ошибку ес к р ы т ы й мы собираем­ ся использовать для узлов скрытого слоя? Это хороший вопрос, по­ скольку мы не можем указать очевидную ошибку для узла в таком слое. Из расчетов, связанных с распространением входных сигналов в прямом направлении, мы знаем, что у каждого узла скрытого слоя в действительности имеется только один выход. Вспомните, как мы применяли функцию активации к взвешенной сумме всех входных сигналов данного узла. Но как определить ошибку для такого узла? У нас нет целевых или желаемых выходных значений для скры­ тых узлов. Мы располагаем лишь целевыми значениями узлов по­ следнего, выходного слоя, и эти значения происходят из трениро­ вочных примеров. Попытаемся найти вдохновение, взглянув еще раз на приведенную выше диаграмму. С первым узлом скрытого слоя ассоциированы две исходящие из него связи, ведущие к двум уз­ лам выходного слоя. Мы знаем, что можем распределить выходную ошибку между этими связями, поступая точно так же, как и прежде. 92 Глава Как работают нейронные сети\n--- Страница 94 ---\nЭто означает, что с каждой из двух связей, исходящих из узла про­ межуточного слоя, ассоциируется некоторая ошибка. Мы могли бы воссоединить ошибки этих двух связей, чтобы получить ошибку для этого узла в качестве второго наилучшего подхода, поскольку мы не располагаем фактическим целевым значением для узла про­ межуточного слоя. Следующая диаграмма иллюстрирует эту идею: На диаграмме отчетливо видно, что именно происходит, однако для уверенности давайте разберем ее более детально. Нам необходи­ мы величины ошибок для узлов скрытого слоя, чтобы использовать их для обновления весовых коэффициентов связей с предыдущим слоем. Обозначим эти ошибки как ес к р ы т ы й . Но у нас нет очевидного ответа на вопрос о том, какова их величина. Мы не можем сказать, что ошибка — это разность между желаемым или целевым выход­ ным значением этого узла и его фактическим выходным значением, поскольку данные тренировочного примера предоставляют лишь целевые значения для узлов последнего, выходного слоя. Они не го­ ворят абсолютно ничего о том, какими должны быть выходные сиг­ налы узлов любого другого слоя. В этом и заключается суть сложив­ шейся головоломки. Мы можем воссоединить ошибки, распределенные по связям, ис­ пользуя обратное распространение ошибок, с которым вы уже позна­ комились. Поэтому ошибка на первом скрытом узле представляет со­ бой сумму ошибок, распределенных по всем связям, исходящим из Обратное распространение ошибок при большом количестве слоев 93\n--- Страница 95 ---\nэтого узла в прямом направлении. На приведенной выше диаграмме показано, что имеется некоторая доля выходной ошибки ев ы х о д н о й v приписываемая связи с весом w n, и некоторая доля выходной ошиб- к и е выхоД ной 2> приписываемая связи с весом w 1 2 . Вышесказанное можно записать в виде следующего выражения: Чтобы проиллюстрировать, как эта теория выглядит на практике, приведем диаграмму, демонстрирующую обратное распространение ошибок в простой трехслойной сети на примере конкретных данных. Проследим за обратным распространением одной из ошибок. Вы видите, что после распределения ошибки 0,5 на втором узле вы­ ходного слоя между двумя связями с весами 1,0 и 4,0 мы получа­ ем доли, равные 0,1 и 0,4 соответственно. Также можно видеть, что объединенная ошибка на втором узле скрытого слоя представляет 94 Глава 1. Как работают нейронные сети\n--- Страница 96 ---\nсобой сумму распределенных ошибок, в данном случае равных 0,48 и 0,4, сложение которых дает 0,88. На следующей диаграмме демонстрируется применение той же методики к слою, который предшествует скрытому. Резюме • Нейронные сети обучаются посредством уточнения весовых коэффициентов своих связей. Этот процесс управляется ошибкой — разностью между пра­ вильным ответом, предоставляемым тренировочными данными, и фактическим выходным значением. • Ошибка на выходных узлах определяется простой разностью между желаемым и фактическим выходными значениями. • В то же время величина ошибки, связанной с внутренними узлами, не столь очевидна. Одним из способов решения этой проблемы является распределение ошибок выходного слоя между соответствующими связями пропорционально весу каждой связи с последующим объединением соответствующих разрознен­ ных частей ошибки на каждом внутреннем узле. Обратное распространение ошибок при большом количестве слоев 95\n--- Страница 97 ---\nОписание обратного распространения ошибок с помощью матричной алгебры Можем ли мы упростить трудоемкие расчеты, используя возмож­ ности матричного умножения? Ранее, когда мы проводили расчеты, связанные с распространением входных сигналов в прямом направ­ лении, это нам очень пригодилось. Чтобы посмотреть, удастся ли нам представить обратное распростра­ нение ошибок с помощью более компактного синтаксиса матриц, опи­ шем все шаги вычислительной процедуры, используя матричные обо­ значения. Кстати, тем самым мы попытаемся векторизовать процесс. Возможность выразить множество вычислений в матричной фор­ ме позволяет нам сократить длину соответствующих выражений и обеспечивает более высокую эффективность компьютерных рас­ четов, поскольку компьютеры могут использовать повторяющийся шаблон вычислений для ускорения выполнения соответствующих операций. Отправной точкой нам послужат ошибки, возникающие на выхо­ де нейронной сети в последнем, выходном слое. В данном случае вы­ ходной слой содержит только два узла с ошибками ех и е2 : Далее нам нужно построить матрицу для ошибок скрытого слоя. Эта задача может показаться сложной, поэтому мы будем выполнять ее по частям. Первую часть задачи представляет первый узел скры­ того слоя. Взглянув еще раз на приведенные выше диаграммы, вы увидите, что ошибка на первом узле скрытого слоя формируется за счет двух вкладов со стороны выходного слоя. Этими двумя сигнала­ ми ошибок являются ех * * г и/ (w n + w 2 1 ) и е2 * w 1 2 / (w 1 2 + w 2 2 ). А теперь обратите внимание на второй узел скрытого слоя, и вы вновь уви­ дите, что ошибка на нем также формируется за счет двух вкладов: 96 Глава 1. Как работают нейронные сети\n--- Страница 98 ---\n• i * W 2 1 / (W 2 1 + W u) и e2 * W 2 2 / (w2 2 + W 1 2 ) . Ранее мы уже видели, как рабо­ тают эти выражения. Итак, для скрытого слоя мы имеем следующую матрицу, которая выглядит немного сложнее, чем мне хотелось бы. Было бы здорово, если бы это выражение можно было переписать в виде простого перемножения матриц, которыми мы уже распола­ гаем. Это матрицы весовых коэффициентов, прямого сигнала и вы­ ходных ошибок. Преимущества, которые можем при этом получить, огромны. К сожалению, легкого способа превратить это выражение в сверх­ простое перемножение матриц, как в случае распространения сигна­ лов в прямом направлении, не существует. Распутать все эти доли, из которых образованы элементы большой матрицы, непросто. Было бы замечательно, если бы мы смогли представить эту матрицу в виде комбинации имеющихся матриц. Что можно сделать? Нам позарез нужен способ, обеспечивающий возможность использования матричного умножения, чтобы повы­ сить эффективность вычислений. Ну что ж, дерзнем! Взгляните еще раз на приведенное выше выражение. Вы видите, что наиболее важная для нас вещь — это умножение выходных ошибок е п на связанные с ними веса w Чем больше вес, тем большая доля ошиб­ ки передается обратно в скрытый слой. Это важный момент. В дро­ бях, являющихся элементами матрицы, нижняя часть играет роль нормирующего множителя. Если пренебречь этим фактором, можно потерять лишь масштабирование ошибок, передаваемых по меха­ Описание обратного распространения ошибок с помощью матричной алгебры 97\n--- Страница 99 ---\nнизму обратной связи. Таким образом, выражение «j * w n/ (wn + w 2 1 ) упростится до ej * w n. Сделав это, мы получим следующее уравнение. Эта матрица весов напоминает ту, которую мы строили ранее, но она повернута вокруг диагонали, так что правый верхний элемент те­ перь стал левым нижним, а левый нижний — правым верхним. Такая матрица называется транспонированной и обозначается как w T . Ниже приведены два примера транспонирования числовых ма­ триц, которые помогут вам лучше понять смысл операции транспо­ нирования. Вы видите, что она применима даже в тех случаях, когда количество столбцов в матрице отличается от количества строк. Итак, мы достигли того, чего хотели, — применили матричный подход к описанию обратного распространения ошибок: 98 Глава 1. Как работают нейронные сети\n--- Страница 100 ---\nКонечно, это просто замечательно, но правильно ли мы поступили, отбросив нормирующий множитель? Оказывается, что эта упрощен­ ная модель обратного распространения сигналов ошибок работает ничуть не хуже, чем более сложная, которую мы разработали перед этим. В блоге, посвященном данной книге, вы найдете публикацию, в которой представлены результаты расчетов обратного распростра­ нения ошибки, выполненных несколькими различными способами: http://makeyourownneuralnetwork.blogspot.со.uk/2016/07/ error-backpropagation-revisted.html Если наш простой подход действительно хорошо работает, мы оставим его! Немного подумав, можно прийти к выводу, что даже в тех случа­ ях, когда в обратном направлении распространяются слишком боль­ шие или слишком малые ошибки, сеть сама все исправит при выпол­ нении последующих итераций обучения. Важно то, что при обрат­ ном распространении ошибок учитываются весовые коэффициенты связей, и это наилучший показатель того, что мы пытаемся справед­ ливо распределить ответственность за возникающие ошибки. Мы проделали большую работу, очень большую! • Обратное распространение ошибок можно описать с помощью матричного ум­ ножения. • Это позволяет нам записывать выражения в более компактной форме, незави­ симо от размеров нейронной сети, и обеспечивает более эффективное и быс­ трое выполнение вычислений компьютерами, если в языке программирования предусмотрен синтаксис матричных операций. • Отсюда следует, что использование матриц обеспечивает повышение эффек­ тивности расчетов как для распространения сигналов в прямом направлении, так и для распространения ошибок в обратном направлении. Описание обратного распространения ошибок с помощью матричной алгебры 99Резюме\n--- Страница 101 ---\nСделайте вполне заслуженный перерыв, поскольку следующий те­ оретический раздел потребует от вас концентрации внимания и при­ ложения умственных усилий. Как мы фактически обновляем весовые коэффициенты Однако мы пока что не приступили к решению главной задачи — обновлению весов связей в нейронной сети. Мы работали в этом на­ правлении и уже почти достигли намеченной цели. Нам осталось ра­ зобрать лишь одну ключевую идею, чтобы больше не было никаких неясностей. К этому моменту мы научились рассчитывать обратное распро­ странение ошибок до каждого слоя сети. Зачем нам это нужно? Затем, что ошибки подсказывают нам, как должны быть изменены веса связей, чтобы улучшить результирующий общий ответ на вы­ ходе нейронной сети. В основном это то, что мы делали с линейным классификатором еще в начале главы. Однако узлы — это не простые линейные классификаторы. В уз­ лах сигналы суммируются с учетом весов, после чего к ним применя­ ется сигмоида. Но как нам все-таки справиться с обновлением весов для связей, соединяющих эти более сложные узлы? Почему бы не ис­ пользовать алгебру для непосредственного вычисления весов? Последний путь нам не подходит ввиду громоздкости соответ­ ствующих выкладок. Существует слишком много комбинаций ве­ сов и слишком много функций, зависящих от функций, завися­ щих от других функций и т.д., которые мы должны комбинировать в ходе анализа распространения сигнала по сети. Представьте себе хотя бы небольшую нейронную сеть с тремя слоями и тремя нейро­ нами в каждом слое, подобную той, с которой мы перед этим рабо­ тали. Как отрегулировать весовой коэффициент для связи между первым входным узлом и вторым узлом скрытого слоя, чтобы сигнал на выходе третьего узла увеличился, скажем, на 0,5? Даже если бы вам повезло и вы сделали это, достигнутый результат мог бы быть разрушен настройкой другого весового коэффициента, улучшающего сигнал другого выходного узла. Как видите, эти расчеты далеко не тривиальны. 100 Глава 1. Как работают нейронные сети\n--- Страница 102 ---\nЧтобы убедиться в том, насколько они не тривиальны, достаточ­ но взглянуть на приведенное ниже устрашающее выражение, кото­ рое представляет выходной сигнал узла выходного слоя как функ­ цию входных сигналов и весовых коэффициентов связей для простой нейронной сети с тремя слоями по три узла. Входной сигнал на узле i равен х., весовой коэффициент для связи, соединяющей входной узел i с узлом j скрытого слоя, равен w . ^ Аналогичным образом вы­ ходной сигнал узла j скрытого слоя равен х., а весовой коэффициент для связи, соединяющей узел j скрытого слоя с выходным узлом к, равен w . к . Необычный символ £а ь означает суммирование следующего за ним выражения по всем значениям между а и Ь. Ничего себе! Лучше держаться от этого подальше. А не могли бы мы вместо того, чтобы пытаться выглядеть очень умными, просто перебирать случайные сочетания весовых коэффи­ циентов, пока не будет получен устраивающий нас результат? Этот вопрос не столь уж наивен, как могло бы показаться, особен­ но когда задача действительно трудная. Такой подход называется методом грубой силы. Некоторые люди пытаются использовать ме­ тоды грубой силы для того, чтобы взламывать пароли, и это может сработать, если паролем является какое-либо осмысленное слово, причем не очень длинное, а не просто набор символов. Такая зада­ ча вполне по силам достаточно мощному домашнему компьютеру. Но представьте, что каждый весовой коэффициент может иметь 1000 возможных значений в диапазоне от -1 до +1, например 0,501, -0,203 или 0,999. Тогда в случае нейронной сети с тремя слоями Как мы фактически обновляем весовые коэффициенты 101\n--- Страница 103 ---\nпо три узла, насчитывающей 18 весовых коэффициентов, мы долж­ ны были бы протестировать 18 тысяч возможностей. Если бы у нас была более типичная нейронная сеть с 500 узлами в каждом слое, то нам пришлось бы протестировать 500 миллионов различных значе­ ний весов. Если бы для расчета каждого набора комбинаций требо­ валась одна секунда, то для обновления весов с помощью всего лишь одного тренировочного примера понадобилось бы примерно 16 лет. Тысяча тренировочных примеров — и мы имели бы 16 тысяч лет! Как видите, подход, основанный на методе грубой силы, практи­ чески нереализуем. В действительности по мере добавления в сеть новых слоев, узлов или вариантов перебора весов ситуация очень бы­ стро ухудшается. Эта головоломка не поддавалась математикам на протяжении мно­ гих лет и получила реальное практическое разрешение лишь в 1960- 1970-х годах. Существуют различные мнения относительно того, кто сделал это впервые или совершил ключевой прорыв, но для нас важно лишь то, что это запоздалое открытие послужило толчком к взрывному развитию современной теории нейронных сетей, кото­ рая сейчас способна решать некоторые весьма впечатляющие задачи. Но все же, как нам разрешить эту явно трудную проблему? Хотите верьте, хотите нет, но вы уже владеете средствами, с помощью кото­ рых сможете справиться с этим самостоятельно. Все, что вам для это­ го нужно знать, мы уже обсуждали. Теперь можем продолжить. Самое главное, что требуется от нас, — это не бояться пессимизма. Математические выражения, позволяющие определить выходной сигнал нейронной сети при известных весовых коэффициентах, не­ обычайно сложны, и в них нелегко разобраться. Количество различ­ ных комбинаций слишком велико для того, чтобы пытаться тестиро­ вать их поочередно. Для пессимизма есть и ряд других причин. Тренировочных дан­ ных может оказаться недостаточно для эффективного обучения сети. В тренировочных данных могут быть ошибки, в связи с чем спра­ ведливость нашего предположения о том, что они истинны и на них можно учиться, оказывается под вопросом. Количество слоев или узлов в самой сети может быть недостаточным для того, чтобы пра­ вильно моделировать решение задачи. Это означает, что предпринимаемый нами подход должен быть реалистичным и учитывать указанные ограничения. Если мы будем 102 Глава 1. Как работают нейронные сети\n--- Страница 104 ---\nследовать этим принципам, то, возможно, найдем решение, которое, даже не будучи идеальным с математической точки зрения, даст нам лучшие результаты, поскольку не будет основано на ложных идеали­ стических допущениях. Проиллюстрируем суть наших рассуждений на следующем примере. Представьте себе ландшафт с очень сложным рельефом, имеющим воз­ вышения и впадины, а также холмы с предательскими буграми и яма­ ми. Вокруг так темно, что ни зги не видно. Вы знаете, что находитесь на склоне холма, и вам нужно добраться до его подножия. Точной кар­ ты местности у вас нет. Но у вас есть фонарь. Что вы будете делать? Пожалуй, вы воспользуетесь фонарем и осмотритесь вокруг себя. Света фонаря не хватит для дальнего обзора, и вы наверняка не сможете ос­ мотреть весь ландшафт целиком. Но вы сможете увидеть, по какому участку проще всего начать спуск к подножию холма, и сделаете не­ сколько небольших шагов в этом направлении. Действуя подобным об­ разом, вы будете медленно, шаг за шагом, продвигаться вниз, не распо­ лагая общей картой и заблаговременно проложенным маршрутом. Математическая версия этого подхода называется методом гра­ диентного спуска, и причину этого нетрудно понять. После того как вы сделали шаг в выбранном направлении, вы вновь осматриваетесь, чтобы увидеть, какой путь ведет вас к цели, и делаете очередной шаг в этом направлении. Вы продолжаете действовать точно так же до тех пор, пока благополучно не спуститесь к подножию холма. А теперь представьте, что этим сложным ландшафтом являет­ ся математическая функция. Метод градиентного спуска позволяет Как мы фактически обновляем весовые коэффициенты 103\n--- Страница 105 ---\nнаходить минимум, даже не располагая знаниями свойств этой функции, достаточными для нахождения минимума математически­ ми методами. Если функция настолько сложна, что простого способа нахождения минимума алгебраическими методами не существует, то мы можем вместо этого применить метод градиентного спуска. Ясное дело, он может не дать нам точный ответ, поскольку мы приближа­ емся к ответу шаг за шагом, постепенно улучшая нашу позицию. Но это лучше, чем вообще не иметь никакого ответа. Во всяком случае, мы можем продолжить уточнение ответа еще более мелкими шагами по направлению к минимуму, пока не достигнем желаемой точности. А какое отношение имеет этот действительно эффективный метод градиентного спуска к нейронным сетям? Если упомянутой сложной функцией является ошибка сети, то спуск по склону для нахожде­ ния минимума означает, что мы минимизируем ошибку. Мы улуч­ шаем выходной сигнал сети. Это именно то, чего мы хотим! Чтобы вы все наглядно усвоили, рассмотрим использование мето­ да градиентного спуска на простейшем примере. Ниже приведен график простой функции у = (х - 1)2 + 1. Если бы это была функция, описывающая ошибку, то мы должны были бы найти значение х , которое минимизирует эту функцию. Представим на минуту, что мы имеем дело не со столь простой функцией, а с го­ раздо более сложной. 104 Глава 1, Как работают нейронные сети\n--- Страница 106 ---\nГрадиентный спуск должен с чего-то начинаться. На графике по­ казана случайно выбранная начальная точка. Подобно покорителю гор, мы исследуем место, в котором находимся, и видим, в каком на­ правлении идет спуск. Наклон кривой также обозначен на графике, и в данном случае ему соответствует отрицательный градиент. Мы хотим следовать в направлении вниз, поэтому движемся вдоль оси х вправо. Таким образом, мы немного увеличиваем х. Это первый шаг нашего альпиниста. Вы видите, что мы улучшили нашу позицию и продвинулись ближе к фактическому минимуму. Представим, что мы начали спуск с какого-то другого места, как показано на следующем графике. На этот раз наклон почвы под нашими ногами положителен, по­ этому мы движемся влево, т.е. немного уменьшаем х. И вновь вы видите, что мы улучшили наше положение, приблизившись к фак­ тическому минимуму. Мы можем продолжать действовать в том же духе до тех пор, пока изменения не станут настолько малыми, что мы будем считать, что достигли минимума. Необходимым усовершенствованием этого метода должно быть изменение величины шагов во избежание перескока через минимум, что приведет к бесконечным прыжкам вокруг него. Вообразите, что мы оказались на расстоянии 0,5 метра от истинного минимума, но Как мы фактически обновляем весовые коэффициенты 105\n--- Страница 107 ---\nдлина нашего шага всегда равна 2 метра. Тогда мы будем постоянно пропускать минимум, поскольку на каждом шаге в его направлении мы будем перескакивать через него. Если мы будем уменьшать ве­ личину шага пропорционально величине градиента, то по мере при­ ближения к минимуму будем совершать все более мелкие шаги. При этом мы предполагаем, что чем ближе к минимуму, тем меньше на­ клон. Для большинства гладких (непрерывно дифференцируемых) функций такое предположение вполне приемлемо. Оно не будет справедливым лишь по отношению к экзотическим зигзагообразным функциям со взлетами и провалами в точках, которые математики называют точками разрыва. Идея уменьшения величины шага по мере уменьшения величины градиента, являющейся хорошим индикатором близости к миниму­ му, иллюстрируется следующим графиком. Кстати, обратили ли вы внимание на то, что мы изменяем х в направлении, противоположном направлению градиента? Положительный градиент означает, что мы должны уменьшить х. Отрицательный градиент требует увеличения х. Все это отчетливо видно на графике, но это легко упустить из виду и пойти совершенно неправильным путем. 106 Глава 1. Как работают нейронные сети\n--- Страница 108 ---\nИспользуя метод градиентного спуска, мы не пытались находить истинный минимум алгебраическим методом, поскольку сделали вид, будто функция у = ( х - 1)2 + 1 для этого слишком сложна. Даже если бы мы не могли определить наклон кривой с математической точностью, мы могли бы оценить его, и, как нетрудно заметить, это все равно вело бы нас в правильном общем направлении. Вся мощь этого метода по-настоящему проявляется в случае функ­ ций, зависящих от многих параметров. Например, вместо зависимос­ ти у от х мы можем иметь зависимость от a , b , с , d , е и f. Вспомните, что функция выходного сигнала, а вместе с ней и функция ошибки зависят от множества весовых коэффициентов, которые часто исчис­ ляются сотнями! Следующий график вновь иллюстрирует метод градиентного спус­ ка, но на этот раз применительно к более сложной функции, завися­ щей от двух параметров. График такой функции можно представить в трех измерениях, где высота представляет значение функции. Как мы фактически обновляем весовые коэффициенты 107\n--- Страница 109 ---\nВозможно, глядя на эту трехмерную поверхность, вы задумались над тем, может ли метод градиентного спуска привести в другую до­ лину, которая расположена справа. В действительности этот вопрос можно обобщить: не приводит ли иногда метод градиентного спуска в ложную долину, поскольку некоторые сложные функции имеют множество долин? Что такое ложная долина? Это долина, которая не является самой глубокой. Тогда на поставленный вопрос следует дать утвердитель­ ный ответ: да, такое может происходить. На следующей иллюстрации показаны три варианта градиентного спуска, один из которых приводит к ложному минимуму. Давайте немного передохнем и соберемся с мыслями. Резюме • Метод градиентного спуска — это действительно хороший способ нахождения минимума функции, и он прекрасно работает, когда функция настолько слож­ на, что ее математическая обработка алгебраическими методами сопряжена с большими трудностями. • Более того, этот метод хорошо работает в случае функций многих перемен­ ных, когда другие методы не срабатывают либо их невозможно реализовать на практике. • Данный метод также устойчив к наличию дефектных данных и не заведет вас далеко в неправильную сторону, если функция не описывается идеально или же время от времени мы совершаем неверные шаги. Выходной сигнал нейронной сети представляет собой сложную, трудно поддающуюся описанию функцию со многими параметрами, весовыми коэффициентами связей, которые влияют на выходной 108 Глава 1. Как работают нейронные сети\n--- Страница 110 ---\nсигнал. Так можем ли мы использовать метод градиентного спуска для определения подходящих значений весов? Можем, если пра­ вильно выберем функцию ошибки. Функция выходного сигнала сама по себе не является функцией ошибки. Но мы знаем, что можем легко превратить ее в таковую, по­ скольку ошибка — это разность между целевыми тренировочными значениями и фактическими выходными значениями. Однако здесь есть кое-что, чего следует остерегаться. Взгляните на приведенную ниже таблицу с тренировочными данными и факти­ ческими значениями для трех выходных узлов вместе с кандидатами на роль функции ошибок. Выход сетиЦелевой результатОшибка (целевое- фактическое)Ошибка |целевое- фактическое|Ошибка (целевое- фактическое)2 0,4 0,5 0,1 0,1 0,01 0,8 0,7 - 0 ,1 0,1 0,01 1,0 1,0 0 0 0 Сумма 0 0,2 0,02 Нашим первым кандидатом на роль функции ошибки является простая разность значений (целевое - фактическое) . Это кажется вполне разумным, не так ли? Но если вы решите использовать сумму ошибок по всем узлам в качестве общего показателя того, насколько хорошо обучена сеть, то эта сумма равна нулю! Что случилось? Ясно, что сеть еще недостаточно натренирована, поскольку выходные значения двух узлов отличаются от целевых значений. Но нулевая сумма означает отсутствие ошибки. Это объяс­ няется тем, что положительная и отрицательная ошибки взаимно сократились. Отсюда следует, что простая разность значений, даже если бы их взаимное сокращение было неполным, не годится для ис­ пользования в качестве меры величины ошибки. Пойдем другим путем, взяв абсолютную величину разности. Формально это записывается как | целевое-фактическое | и означает, что знак результата вычитания игнорируется. Это могло бы срабо­ тать, поскольку в данном случае ничто ни с чем не может сократить­ ся. Причина, по которой данный метод не получил популярности, Как мы фактически обновляем весовые коэффициенты 109\n--- Страница 111 ---\nсвязана с тем, что при этом наклон не является непрерывной функ­ цией вблизи минимума, что затрудняет использование метода гра­ диентного спуска, поскольку мы будем постоянно совершать скачки вокруг V-образной долины, характерной для функции ошибки по­ добного рода. При приближении к минимуму наклон, а вместе с ним и величина шага изменения переменной, не уменьшается, а это озна­ чает риск перескока. Третий вариант заключается в том, чтобы использовать в качестве меры ошибки квадрат разности: (целевое-фактическое)2 . Существует несколько причин, по которым третий вариант предпочтительнее второго, включая следующие: • он упрощает вычисления, с помощью которых определяется ве­ личина наклона для метода градиентного спуска; • функция ошибки является непрерывно гладкой, что обеспечи­ вает нормальную работу метода градиентного спуска ввиду от­ сутствия провалов и скачков значений функции; • по мере приближения к минимуму градиент уменьшается, что означает снижение риска перескока через минимум, если ис­ пользуется уменьшение величины шагов. А возможны ли другие варианты? Да, вы вправе сконструировать любую сложную функцию, которую считаете нужной. Одни из них могут вообще не работать, другие могут хорошо работать для опреде­ ленного круга задач, а третьи могут работать действительно хорошо, но их чрезмерная сложность приводит к неоправданным затратам ресурсов. А тем временем мы вышли на финишную прямую! Чтобы воспользоваться методом градиентного спуска, нам нужно определить наклон функции ошибки по отношению к весовым коэф­ фициентам. Это требует применения дифференциального исчисле­ ния. Возможно, вы уже знакомы с ним, а если не знакомы или вам требуется освежить свою память, то обратитесь к приложению А. Дифференциальное исчисление — это просто математически строгий подход к определению величины изменения одних величин при из­ менении других. Например, оно позволяет ответить на вопрос о том, как изменяется длина пружины в зависимости от величины усилия, 110 Глава 1, Как работают нейронные сети\n--- Страница 112 ---\nприложенного к ее концам. В данном случае нас интересует зависи­ мость функции ошибки от весовых коэффициентов связей внутри нейронной сети. Иными словами, нас интересует, насколько величи­ на ошибки чувствительна к изменениям весовых коэффициентов. Начнем с рассмотрения графика, поскольку это всегда позволяет почувствовать под ногами твердую почву, когда пытаешься решать трудную задачу. Этот график в точности повторяет один из тех, которые приводи­ лись ранее, чтобы подчеркнуть, что мы не делаем ничего принци­ пиально нового. На этот раз функцией, которую мы пытаемся ми­ нимизировать, является ошибка на выходе нейронной сети. В этом простом примере показан лишь один весовой коэффициент, но мы знаем, что в нейронных сетях их будет намного больше. На следующей диаграмме отображаются два весовых коэффици­ ента, и поэтому функция ошибки графически отображается в виде трехмерной поверхности, высота расположения точек которой из­ меняется с изменением весовых коэффициентов связей. Как видите, теперь процесс минимизации ошибки больше напоминает спуск в до­ лину по рельефной местности. Как мы фактически обновляем весовые коэффициенты 111\n--- Страница 113 ---\nВизуализировать многомерную поверхность ошибки как функ­ ции намного большего количества параметров значительно труд­ нее, но идея нахождения минимума методом градиентного спуска остается той же. Сформулируем на языке математики, чего мы хотим: Это выражение представляет изменение ошибки Е при изменении веса w jk . Это и есть тот наклон функции ошибки, который нам нужно знать, чтобы начать градиентный спуск к минимуму. Прежде чем мы развернем это выражение, временно сосредоточим внимание только на весовых коэффициентах связей между скрытым слоем и последним выходным слоем. Интересующая нас область вы­ делена на приведенной ниже диаграмме. К связям между входным и скрытым слоями мы вернемся позже. 112 Глава 1. Как работают нейронные сети\n--- Страница 114 ---\nМы будем постоянно ссылаться на эту диаграмму, дабы в про­ цессе вычислений не забыть о том, что в действительности означает каждый символ. Пусть вас это не смущает, поскольку шаги вычис­ лительной процедуры не являются сложными и будут объясняться, а все необходимые понятия ранее уже обсуждались. Прежде всего запишем в явном виде функцию ошибки, которая представляет собой сумму возведенных в квадрат разностей между целевым и фактическим значениями, где суммирование осуществля­ ется по всем п выходным узлам. Здесь мы всего лишь записали, что на самом деле представляет со­ бой функция ошибки Е. Мы можем сразу же упростить это выражение, заметив, что вы­ ходной сигнал оп на узле п зависит лишь от связей, которые с ним соединены. Для узла к это означает, что выходной сигнал ок зависит лишь от весов w .k , поскольку эти веса относятся к связям, ведущим к узлу к. Это можно рассматривать еще и как то, что выходной сигнал узла к не зависит от весов w .b, где b не равно к , поскольку связь между Как мы фактически обновляем весовые коэффициенты 113\n--- Страница 115 ---\nэтими узлами отсутствует. Вес w jb относится к связи, ведущей к вы­ ходному узлу Ь , но не к . Это означает, что мы можем удалить из этой суммы все сигналы оп кроме того, который связан с весом w .k , т.е. ок . В результате мы полностью избавляемся от суммирования! Отличный трюк, который вам стоит запомнить на будущее. Если вы уже успели выпить свой кофе, то, возможно, сообрази­ ли, что это означает ненужность суммирования по всем выходным узлам для нахождения функции ошибки. Мы уже видели, чем это объясняется: тем, что выходной сигнал узла зависит лишь от веду­ щих к нему связей и их весовых коэффициентов. Этот момент часто остается нераскрытым во многих учебниках, которые просто приво­ дят выражение для функции без каких-либо пояснений. Как бы то ни было, теперь мы имеем более простое выражение: А сейчас мы используем некоторые средства дифференциального исчисления. Помните, что при необходимости восстановить в памяти необходимые знания вы всегда можете заглянуть в приложение А. Член — константа и поэтому не изменяется при изменении w jk , т.е. не является функцией w jk . Было бы очень странно, если бы ис­ тинные примеры, предоставляющие целевые значения, изменялись в зависимости от весовых коэффициентов! В результате у нас остает­ ся член ок , который, как мы знаем, зависит от w .k , поскольку весовые коэффициенты влияют на распространение в прямом направлении сигналов, которые затем превращаются в выходные сигналы ок . Чтобы разбить эту задачу дифференцирования на более простые части, мы воспользуемся цепным правилом (правило дифференциро­ вания сложных функций). Прочитать о нем можно в приложении А. 114 Глава 1. Как работают нейронные сети\n--- Страница 116 ---\nТеперь мы можем разделаться с каждой из этих частей по отдель­ ности. С первой частью мы справимся легко, поскольку для это­ го нужно всего лишь взять простую производную от квадратичной функции. В результате получаем: Со второй частью придется немного повозиться, но и это не вызо­ вет больших затруднений. Здесь о к — это выходной сигнал узла к , который, как вы помните, получается в результате применения сиг­ моиды к сигналам, поступающим на данный узел. Для большей яс­ ности запишем это в явном виде: Здесь о . — выходной сигнал узла предыдущего скрытого слоя, а не выходной сигнал узла последнего слоя. Как продифференцировать сигмоиду? Мы могли бы это сделать са­ мостоятельно, проведя сложные и трудоемкие вычисления в соответ­ ствии с изложенными в приложении А фундаментальными идеями, однако эта работа уже проделана другими людьми. Поэтому мы про­ сто воспользуемся уже известным ответом, как это ежедневно дела­ ют математики по всему миру. Дифференцирование некоторых функций приводит к выражени­ ям устрашающего вида. В случае же сигмоиды результат получается очень простым. Это одна из причин широкого применения сигмоиды в качестве функции активации в нейронных сетях. Как мы фактически обновляем весовые коэффициенты 115\n--- Страница 117 ---\nИспользуя этот впечатляющий результат, получаем следующее выражение: А откуда взялся последний сомножитель? Это результат приме­ нения цепного правила к производной сигмоиды, поскольку выра­ жение под знаком функции сигм оида () также должно быть продиф­ ференцировано по переменной w jk . Это делается очень просто и дает в результате ог Прежде чем записать окончательный ответ, избавимся от множи­ теля 2 в начале выражения. Мы вправе это сделать, поскольку нас интересует только направление градиента функции ошибки, так что этот множитель можно безболезненно отбросить. Нам совершенно безразлично, какой множитель будет стоять в начале этого выраже­ ния, 2, 3 или даже 100, коль скоро мы всегда будем его игнориро­ вать. Поэтому для простоты избавимся от него. Окончательное выражение, которое мы будем использовать для изменения веса w .k , выглядит так. Ух ты! У нас все получилось! Это и есть то магическое выражение, которое мы искали. Оно яв­ ляется ключом к тренировке нейронных сетей. Проанализируем вкратце это выражение, отдельные части которо­ го выделены цветом. Первая часть, с которой вы уже хорошо знако­ мы, — это ошибка (целевое значение минус фактическое значение). 116 Глава 1. Как работают нейронные сети\n--- Страница 118 ---\nСумма, являющаяся аргументом сигмоиды, — это сигнал, поступаю­ щий на узел выходного слоя, и для упрощения вида выражения мы могли бы обозначить этот сигнал просто как i k. Он выступает в ка­ честве входного сигнала узла к до применения функции активации. Последняя часть — это выходной сигнал узла j предыдущего скры­ того слоя. Рассмотрение полученного выражения именно в таком ракурсе позволяет лучше понять связь физической картины проис­ ходящего с наклоном функции и в конечном счете с уточнением ве­ совых коэффициентов. Это поистине фантастический результат, и мы можем заслужен­ но гордиться собой. Путь к этому результату многим людям дается с большим трудом. Нам осталось сделать совсем немного, и мы достигнем цели. Выражение, с которым мы совладали, предназначено для уточнения весовых коэффициентов связей между скрытым и выходным слоями. Мы должны завершить работу и найти наклон аналогичной функции ошибки для коэффициентов связей между входным и скрытым слоями. Можно было бы вновь произвести полностью все математические выкладки, но мы не будем этого делать. Мы воспользуемся описан­ ной перед этим физической интерпретацией составляющих выраже­ ния для производной и реконструируем его для интересующего нас нового набора коэффициентов. При этом необходимо учесть следую­ щие изменения. • Первая часть выражения для производной, которая ранее была выходной ошибкой (целевое значение минус фактическое зна­ чение), теперь становится рекомбинированной выходной ошиб­ кой скрытых узлов, рассчитываемой в соответствии с механиз­ мом обратного распространения ошибок, с чем вы уже знако­ мы. Назовем ее • Вторая часть выражения, включающая сигмоиду, остается той же, но выражение с суммой, передаваемое функции, теперь от­ носится к предыдущим слоям, и поэтому суммирование осу­ ществляется по всем входным сигналам скрытого слоя, сгла­ женным весами связей, ведущих к скрытому узлу j. Мы могли бы назвать эту сумму ij. Как мы фактически обновляем весовые коэффициенты 117\n--- Страница 119 ---\n• Последняя часть выражения приобретает смысл выходных сиг­ налов о4 узлов первого слоя, и в данном случае эти сигналы яв­ ляются входными. Тем самым нам удалось изящно избежать излишних трудоемких вычислений, в полной мере воспользовавшись всеми преимуще­ ствами симметрии задачи для конструирования нового выражения. Несмотря на всю ее простоту, это очень мощная методика, взятая на вооружение выдающимися математиками и учеными. Овладев ею, вы, несомненно, произведете на коллег большое впечатление! Итак, вторая часть окончательного ответа, к получению которого мы стремимся (градиент функции ошибки по весовым коэффициен­ там связей между входным и скрытым слоями), приобретает следу­ ющий вид: На данном этапе нами получены все ключевые магические выра­ жения, необходимые для вычисления искомого градиента, который мы используем для обновления весовых коэффициентов по резуль­ татам обучения на каждом тренировочном примере, чем мы сейчас и займемся. Не забывайте о том, что направление изменения коэффициентов противоположно направлению градиента, что неоднократно демон­ стрировалось на предыдущих диаграммах. Кроме того, мы сглажи­ ваем интересующие нас изменения параметров посредством коэффи­ циента обучения, который можно настраивать с учетом особенностей конкретной задачи. С этим подходом вы также уже сталкивались, когда при разработке линейных классификаторов мы использова­ ли его для уменьшения негативного влияния неудачных примеров на эффективность обучения, а при минимизации функции ошиб­ ки — для того, чтобы избежать постоянных перескоков через мини­ мум. Выразим это на языке математики: 118 Глава 1. Как работают нейронные сети\n--- Страница 120 ---\nОбновленный вес w jk — это старый вес с учетом отрицательной поправки, величина которой пропорциональна производной функ­ ции ошибки. Поправка записана со знаком “минус” , поскольку мы хотим, чтобы вес увеличивался при отрицательной производной и уменьшался при положительной, о чем ранее уже говорилось. Символ а (альфа) — это множитель, сглаживающий величину изме­ нений во избежание перескоков через минимум. Этот коэффициент часто называют коэффициентом обучения. Данное выражение применяется к весовым коэффициентам свя­ зей не только между скрытым и выходным, но и между входным и скрытым слоями. Эти два случая различаются градиентами функ­ ции ошибки, выражения для которых приводились выше. Прежде чем закончить с этим примером, посмотрим, как будут выглядеть те же вычисления в матричной записи. Для этого сделаем то, что уже делали раньше, — запишем, что собой представляет каж­ дый элемент матрицы изменений весов. Я опустил коэффициент обучения а, поскольку это всего лишь константа, которая никак не влияет на то, как мы организуем мат­ ричное умножение. Матрица изменений весов содержит значения поправок к весовым коэффициентам w .k для связей между узлом j одного слоя и узлом к следующего слоя. Вы видите, что в первой части выражения справа Как мы фактически обновляем весовые коэффициенты 119\n--- Страница 121 ---\nот знака равенства используются значения из следующего слоя (узел к ) , а во второй — из предыдущего слоя (узел j ) . Возможно, глядя на приведенную выше формулу, вы заметили, что горизонтальная матрица, представленная одной строкой, — это транспонированная матрица сигналов о; на выходе предыдущего слоя. Цветовое выделение элементов матриц поможет вам понять, что ска­ лярное произведение матриц отлично работает и в этом случае. Используя символическую запись матриц, мы можем привести эту формулу к следующему виду, хорошо приспособленному для ре­ ализации в программном коде на языке, обеспечивающем эффектив­ ную работу с матрицами. | Фактически это выражение совсем не сложное. Сигмоиды исчезли из поля зрения, поскольку они скрыты в матрицах выходных сигна­ лов ок узлов. Вот и все! Работа сделана. Резюме • Ошибка нейронной сети является функцией весов внутренних связей. • Улучшение нейронной сети означает уменьшение этой ошибки посредством из­ менения указанных весов. • Непосредственный подбор подходящих весов наталкивается на значительные трудности. Альтернативный подход заключается в итеративном улучшении ве­ совых коэффициентов путем уменьшения функции ошибки небольшими шага­ ми. Каждый шаг совершается в направлении скорейшего спуска из текущей по­ зиции. Этот подход называется градиентным спуском. • Градиент ошибки можно без особых трудностей рассчитать, используя диффе­ ренциальное исчисление. 120 Глава 1. Как работают нейронные сети\n--- Страница 122 ---\nПример обновления весовых коэффициентов Проиллюстрируем применение описанного метода обновления ве­ совых коэффициентов на конкретном примере с использованием чис­ ловых данных. С представленной ниже сетью мы уже работали, но в этот раз бу­ дут использованы заданные значения выходных сигналов первого и второго узлов скрытого слоя, o._j и о)-2. Эти значения лишь иллюс­ трируют применение методики и выбраны произвольно, а не вычис­ лены, как это следовало бы сделать, по известным выходным сигна­ лам входного слоя. Мы хотим обновить весовой коэффициент wn для связи между скрытым и выходным слоями, текущее значение которого равно 2,0. Запишем еще раз выражение для градиента ошибки. * • Разберем это выражение по частям. • Первая часть (tk - ok ) — это уже известная вам по предыду­ щим диаграммам ошибка 6j=0,8. Пример обновления весовых коэффициентов 121\n--- Страница 123 ---\n• Сумма S.w ^O j, передаваемая сигмоидам, равна (2,0 * 0,4) + (3,0 * *0,5) = 2,3. • Тогда сигмоида 1/(1 + е 2 ,3 ) равна 0,909. Следовательно, проме­ жуточное выражение равно 0,909 * (1 - 0,909) = 0,083. • Последняя часть — это просто сигнал о., которым в данном слу­ чае является сигнал о}-1, так как нас интересует вес w n, где j= l. Поэтому данная часть просто равна 0,4. Перемножив все три части этого выражения и не забыв при этом о начальном знаке “минус” , получаем значение -0,0265. При коэффициенте обучения, равном 0,1, изменение веса соста­ вит -0,1 * (-0,0265) = +0,002650. Следовательно, новое значение w n, определяемое суммой первоначального значения и его изменения, составит 2,0 + 0,00265 = 2,00265. Это довольно небольшое изменение, но после выполнения сотен или даже тысяч итераций весовые коэффициенты в конечном счете образуют устойчивую конфигурацию, которая в хорошо натрениро­ ванной нейронной сети обеспечит получение выходных сигналов, со­ гласующихся с тренировочными примерами. Подготовка данных В этом разделе мы обсудим, как лучше всего подготовить трени­ ровочные данные и случайные начальные значения весовых коэф­ фициентов и даже спланировать выходные значения таким обра­ зом, чтобы процесс обучения имел все шансы на успех. Совершенно верно, вы все правильно прочитали! Не все попыт­ ки использования нейронных сетей заканчиваются успехом, и на то есть множество причин. Некоторые из них можно устранить за счет продуманного отбора тренировочных данных и начальных значений весовых коэффициентов, а также тщательного планиро­ вания схемы выходных сигналов. Рассмотрим все эти факторы по­ очередно. 122 Глава 1. Как работают нейронные сети\n--- Страница 124 ---\nВходные значения Взгляните на приведенный ниже график сигмоиды. Как нетрудно заметить, при больших значениях входного сигнала кривая функ­ ции заметно спрямляется. Значительное спрямление функции активации служит источни­ ком проблем, поскольку для усваивания сетью новых значений весов используется градиент. Посмотрите еще раз на выражение для изме­ нений весовых коэффициентов. Оно зависит от градиента функции активации. Использование небольших значений градиента равно­ сильно ограничению способности сети к обучению. Это называется насыщением нейронной сети. Отсюда следует, что для входных сиг­ налов лучше задавать небольшие значения. Любопытно, что при этом их нельзя задавать и слишком малыми, поскольку они тоже входят в указанное выражение для изменений весовых коэффициентов. Слишком малые значения входных сигна­ лов могут быть проблематичными еще и потому, что при обработке очень больших или очень малых значений точность компьютерных вычислений значительно снижается. Подготовка данных 123\n--- Страница 125 ---\nНеплохим решением этой проблемы является масштабирование входных сигналов до значений в интервале от 0,0 до 1,0. Иногда для входных сигналов вводят небольшое смещение, скажем, 0,01, с целью недопущения нулевых входных сигналов, которые неприят­ ны тем, что при о^0 выражение для поправки к весам обнуляется, тем самым лишая сеть способности к обучению. Выходные значения Выходные значения нейронной сети — это сигналы, появляющи­ еся на узлах последнего слоя. Если мы используем функцию акти­ вации, которая не обеспечивает получение значений свыше 1,0, то было бы глупо пытаться устанавливать значения большей величины в качестве целевых. Вспомните о том, что логистическая функция не дотягивает даже до значения 1,0 — она только приближается к нему. В математике это называется асимптотическим стремлением к 1,0. Следующий график наглядно демонстрирует, почему логистичес­ кая функция активации не может обеспечить получение значений, превышающих 1,0 или меньших нуля. Если мы все же установим целевые значения в этих недостижи­ мых, запрещенных диапазонах, то тренировка сети приведет к еще большим весовым коэффициентам в попытке добиться все боль­ ших и больших значений выходных сигналов, которые фактичес­ ки никогда не могут быть достигнуты вследствие использования 124 Глава 1 * Как работают нейронные сети\n--- Страница 126 ---\nфункции активации. Мы понимаем, что это так же плохо, как и на­ сыщение сети. Поэтому мы должны масштабировать наши целевые выходные значения таким образом, чтобы они были допустимыми при данной функции активации, одновременно заботясь о том, чтобы избежать значений, которые в действительности никогда не могут быть до­ стигнуты. Общепринято использовать диапазон значений от 0,0 до 1,0, но некоторые разработчики используют диапазон от 0,01 до 0,99, по­ скольку значения 0,0 и 1,0, с одной стороны, не являются подходя­ щими целевыми значениями, а с другой — могут приводить к чрез­ мерно большим значениям весовых коэффициентов. Случайные начальные значения весовых коэффициентов Здесь применима та же аргументация, что и в случае входных и выходных сигналов. Мы должны избегать больших начальных значений весовых коэффициентов, поскольку использование функ­ ции активации в этой области значений может приводить к насыще­ нию сети, о котором мы только что говорили, и снижению способнос­ ти сети обучаться на лучших значениях. Один из возможных вариантов — прибегнуть к выбору значе­ ний из случайного равномерного распределения чисел в диапазоне от -1,0 до +1,0. Это гораздо лучше, чем использовать, скажем, диа­ пазон чисел от -1000 до +1000. Возможен ли лучший вариант? Вполне вероятно. Математики и ученые-компьютерщики разработали подходы, по­ зволяющие определять эмпирические правила для задания случай­ ных начальных значений весовых коэффициентов в зависимости от конкретной конфигурации сети и используемой функции актива­ ции. Соответствующие рецепты в высшей степени специфичны, но, невзирая на это, мы рискнем подступиться к ним! Мы не будем вдаваться в детали математических выкладок, но центральная идея заключается в том, что если на узел нейрон­ ной сети поступает множество сигналов, причем поведение этих сигналов хорошо определено, они не достигают слишком боль­ ших значений и не распределены каким-то невероятным образом, то весовые коэффициенты не должны нарушать такое состояние Подготовка данных 125\n--- Страница 127 ---\nсигналов в процессе их объединения и обработки функцией акти­ вации. Иными словами, мы не должны использовать весовые коэф­ фициенты, разрушающие результаты наших попыток тщательно масштабировать входные сигналы. Суть эмпирического правила, к которому пришли математики, заключается в том, что весовые коэффициенты инициализируются числами, случайно выбираемы­ ми из диапазона, грубая оценка которого определяется обратной ве­ личиной квадратного корня из количества связей, ведущих к узлу. Таким образом, если к каждому узлу ведут три связи, то началь­ ные значения весов не должны превышать значение 1/(V3) = 0,577. Если же каждый узел имеет 100 входящих связей, то веса должны находиться в диапазоне, ограниченном значением l/(V l00) = 0,1. Интуитивно это понятно. Некоторые слишком большие веса сме­ стили бы функцию активации в область больших значений, что при­ вело бы к ее насыщению. И чем больше связей приходится на узел, тем больше складывается весовых коэффициентов. Поэтому эмпи­ рическое правило, которое уменьшает диапазон значений весовых коэффициентов с увеличением количества связей на узел, находит логическое объяснение. Если вы уже знакомы с идеей выборочных значений, извлекае­ мых из распределений вероятностей, то поймете, что это правило фактически относится к нормальному распределению, для которо­ го среднее значение равно нулю, а стандартное отклонение равно обратной величине корня из количества связей, ведущих к узлу. Однако не будем слишком строго придерживаться этой рекомен­ дации, поскольку она предполагает выполнение довольно большо­ го количества условий, которые не всегда соблюдаются, таких как альтернативное использование гиперболического тангенса th( ) в качестве функции активации и специфическое распределение входных сигналов. Следующий график иллюстрирует в наглядной форме как простой подход, так и более сложный, в котором используется нормальное распределение. 126 Глава 1, Как работают нейронные сети\n--- Страница 128 ---\nВ любом случае никогда не задавайте для начальных весов равные значения, особенно нулевые. Это был бы крайне неудачный вариант! Этот вариант был бы неудачным по той причине, что в таком случае все узлы сети получили бы одинаковые сигналы, и сигналы на выходе каждого узла были бы одинаковыми. Если затем присту­ пить к обновлению весов с использованием механизма обратного распространения ошибки, то ошибка распределится равномерно. Вы ведь не забыли, что ошибка распределяется между узлами пропор­ ционально весам. Это приведет к одинаковым поправкам для всех весовых коэффициентов, что, в свою очередь, вновь приведет к ве­ сам, имеющим одинаковые значения. Подобная симметрия играет крайне отрицательную роль, ведь если правильно натренированная сеть должна иметь неодинаковые значения весовых коэффициентов (что характерно для большинства задач), то вы никогда не достигне­ те этого состояния. Еще худший выбор — нулевые значения, поскольку они полно­ стью “убивают” входной сигнал. В этом случае функция обновления весов, которая зависит от входных сигналов, обнуляется, тем самым полностью исключая саму возможность обновления весов. Подготовка данных 127\n--- Страница 129 ---\nСуществует множество других мер, которые можно предпринять для улучшения процедур подготовки входных данных, задания весо­ вых коэффициентов и организации желаемых выходных значений. С учетом целей книги изложенные идеи достаточно просты, чтобы быть понятными, и в то же время достаточно эффективны, так что на этом мы и остановимся. Резюме • Нейронные сети не работают удовлетворительно, если входные и выходные данные, а также начальные значения весовых коэффициентов не согласуются со структурой сети и спецификой конкретной задачи. • Распространенной проблемой является насы щ ение сети — ситуация, когда большие значения сигналов, часто обусловленные большими значениями ве­ совых коэффициентов, приводят к сигналам, попадающим в область близких к нулю значений градиента функции активации. Результатом этого является снижение способности сети обучаться на лучших значениях весовых коэффи­ циентов. • Другую проблему представляют нулевые значения сигналов или весов. Эти значения также полностью лишают сеть возможности обучаться на лучших зна­ чениях весовых коэффициентов. • Значения весовых коэффициентов внутренних связей должны быть случайны­ ми и небольшими, но не нулевыми. Иногда используют более сложные пра­ вила, включающие, например, уменьшение значений весовых коэффициентов с увеличением количества связей, ведущих к узлу. • Входные сигналы должны масштабироваться до небольших, но ненулевых значений. Обычно используют диапазоны значений от 0,01 до 0,99 и от -1.0 до +1,0 в зависимости от того, какой из них лучше соответствует специфике задачи. • Выходные сигналы должны находиться в пределах диапазона, который способна обеспечить функция активации. Значения, меньшие или равные 0 и большие или равные 1, не совместимы с логистической сигмоидой. Установка тренировочных целевых значений за пределами допустимого диапазона при­ ведет к еще большим значениям весов и в конечном счете к насыщению сети. Неплохим диапазоном является диапазон значений от 0,01 до 0,99. 128 Глава 1. Как работают нейронные сети",
      "debug": {
        "start_page": 19,
        "end_page": 129
      }
    },
    {
      "name": "Глава 2. Создаем нейронную сеть на Python 129",
      "content": "--- Страница 130 --- (продолжение)\nГЛАВА 2 Создаем нейронную сеть на Python Чт обы по-наст оящ ему в чем-то разобраться, нуж но сделат ь эт о самому. Н ачинай с малого затем наращивай. В этой главе мы создадим собственную нейронную сеть. Для этого мы используем компьютер, поскольку, как вы уже знаете, нам при­ дется выполнить тысячи вычислений. С помощью компьютеров это можно сделать очень быстро и без потери точности. Мы будем сообщать компьютеру, что ему следует сделать, исполь­ зуя понятные ему инструкции. Компьютерам трудно понять обыч­ ный человеческий язык с присущими ему неточностью и неодно­ значностью, который мы применяем в повседневном общении. Если уж люди часто не могут договориться между собой, то что говорить о компьютерах! Python Мы будем использовать язык программирования Python. С него удобно начинать, поскольку он прост в изучении. Инструкции, на­ писанные на Python одними людьми, легко читают и понимают дру­ гие люди. Кроме того, этот язык очень популярен и применяется во многих областях, включая научные исследования, преподавание, глобальные инфраструктуры, а также анализ данных и искусствен­ ный интеллект. Python все шире изучают в школах, а достигшая не­ вероятных масштабов популярность микрокомпьютеров Raspberry Pi сделала Python доступным для еще более широкого круга людей, включая детей и студентов.\nГЛАВА 2 Создаем нейронную сеть на Python Чт обы по-наст оящ ему в чем-то разобраться, нуж но сделат ь эт о самому. Н ачинай с малого затем наращивай. В этой главе мы создадим собственную нейронную сеть. Для этого мы используем компьютер, поскольку, как вы уже знаете, нам при­ дется выполнить тысячи вычислений. С помощью компьютеров это можно сделать очень быстро и без потери точности. Мы будем сообщать компьютеру, что ему следует сделать, исполь­ зуя понятные ему инструкции. Компьютерам трудно понять обыч­ ный человеческий язык с присущими ему неточностью и неодно­ значностью, который мы применяем в повседневном общении. Если уж люди часто не могут договориться между собой, то что говорить о компьютерах! Python Мы будем использовать язык программирования Python. С него удобно начинать, поскольку он прост в изучении. Инструкции, на­ писанные на Python одними людьми, легко читают и понимают дру­ гие люди. Кроме того, этот язык очень популярен и применяется во многих областях, включая научные исследования, преподавание, глобальные инфраструктуры, а также анализ данных и искусствен­ ный интеллект. Python все шире изучают в школах, а достигшая не­ вероятных масштабов популярность микрокомпьютеров Raspberry Pi сделала Python доступным для еще более широкого круга людей, включая детей и студентов.\n--- Страница 131 ---\nВ приложении вы найдете инструкции относительно того, как на­ строить Raspberry Pi Zero для выполнения всей работы по созданию собственной нейронной сети с помощью Python. Raspberry Pi Zero — это чрезвычайно дешевый небольшой компьютер, стоимость кото­ рого в настоящее время составляет около 5 долларов. Это не опечат­ ка — он действительно стоит всего 5 долларов! О Python, как и о любом другом языке программирования, мож­ но рассказать много чего, но в книге мы сосредоточимся на созда­ нии собственной нейронной сети и будем изучать Python лишь в том объеме, который необходим для достижения этой конкретной цели. Интерактивный Python = I Python Мы не будем самостоятельно устанавливать Python вместе со все­ возможными расширениями, предназначенными для математичес­ ких вычислений и построения графиков, поскольку эта процедура может сопровождаться различными ошибками в процессе установ­ ки, вызванными неопытностью пользователя. Вместо этого мы вос­ пользуемся готовым решением с заранее подготовленными пакета­ ми, которое называется IPython. Оболочка IPython содержит язык программирования Python и не­ сколько расширений для выполнения численного и графического ана­ лиза данных, включая те, которые нам понадобятся. Она предостав­ ляет удобное средство интерактивной разработки Jupyter Notebook (блокнот)1 , напоминающее обычный блокнот, которое идеально под­ ходит для оперативной проверки новых идей и анализа результатов. При этом отпадает необходимость заботиться о размещении файлов программ, интерпретаторов и библиотек, что могло бы отвлекать ваше внимание от сути задачи, особенно если что-то идет не так. Посетите сайт ip y t h o n . o r g , на котором предлагаются различные варианты установки IPython. Я использую пакет Anaconda, который можно загрузить на сайте h t t p ://w w w .c o n t in u u m .io /d o w n lo a d s . ‘ Автором использовалась интерактивная оболочка IPython Notebook. В послед­ них версиях IPython, в том числе в той, которая использовалась при подготов­ ке перевода, эта оболочка называется Jupyter Notebook, чем подчеркивается ее совместимость не только с Python, но и с другими языками программирова­ ния. — Примеч. ред. 130 Глава 2. Создаем нейронную сеть на Python\n--- Страница 132 ---\nВозможно, к тому времени, когда вы его посетите, сайт будет выглядеть иначе, но сути дела это не меняет. Сначала перейдите на вкладку, соответствующую используемой вами операционной сис­ теме: Windows, OS X или Linux. После этого обязательно выберите для загрузки версию Python 3.6, а не 2.7. Версия Python 3 внедряется все более высокими темпами, и бу­ дущее принадлежит ей. Python 2.7 уже надежно прижился, но нам нужно смотреть вперед и начинать использовать Python 3 при всяком удобном случае, особенно для новых проектов. Сейчас большинство компьютеров 64-разрядные, и для них следует загружать именно эту версию Python. Установка 32-разрядной версии может понадобиться разве что для компьютеров, выпущенных более десяти лет назад. Установите IPython, следуя приведенным на сайте инструкциям. Этот процесс не должен вызвать у вас никаких затруднений. Простое введение в Python Мы будем предполагать, что вы успешно справились с установкой IPython, следуя приведенным на сайте инструкциям, и теперь у вас есть доступ к этой оболочке. Простое введение в Python 131\n--- Страница 133 ---\nБлокноты Запустив интерактивную оболочку Jupyter Notebook (Блокнот), щел­ кните на кнопке N ew у правого края окна и выберите в открывшемся меню пункт P y th o n 3, что приведет к открытию пустого блокнота. Блокнот интерактивен, т.е. ожидает от вас ввода команды, вы­ полняет то, что вы ему приказали, выводит ответ и вновь переходит в состояние ожидания следующей команды или вопроса. В общем, он ведет себя как послушный робот-лакей, знающий толк в матема­ тике и обладающий тем дополнительным качеством, что никогда не устает. При решении задач даже средней сложности имеет смысл разбивать их на части. Так легче структурировать логику задачи, а если что-то пойдет не так, особенно в большом проекте, вам будет проще найти ту его часть, в которой произошла ошибка. В терминологии IPython та­ кие части называются ячейками (cells). В показанном выше блокноте ячейка пуста, и вы, наверное, заметили мерцающий курсор, который приглашает вас ввести в нее какую-нибудь команду. Давайте прикажем компьютеру что-то сделать. Например, попро­ сим его перемножить два числа, скажем, умножить 2 на 3. Введите в ячейку текст “ 2*3” (кавычки вводить не следует) и щелкните на кнопке ru n cell (выполнить ячейку), напоминающей кнопку вос­ произведения в проигрывателе. Компьютер должен быстро выпол­ нить ваш приказ и вернуть следующий результат. 132 Глава 2. Создаем нейронную сеть на Python\n--- Страница 134 ---\nКак видите, компьютер выдал правильный результат: “6” . Только что мы предоставили компьютеру нашу первую инструкцию и успешно получили корректный ответ. Это была наша первая ком­ пьютерная программа! Не обращайте внимания на надписи “In [1]” и “Out[l]’\\ которыми в IPython помечаются инструкция и ответ. Так оболочка напоминает вам о том, что именно вы просили сделать (input) и что вы получаете в ответ (output). Числа в скобках указывают на последовательность вопросов и ответов, что весьма удобно, когда вы то и дело вносите в код исправления и заново выполняете инструкции. Python — это просто Когда я говорил, что Python — это простой язык программиро­ вания, я был совершенно серьезен. Перейдите к следующей ячейке “In []” , введите представленный ниже код и выполните его, щелкнув на кнопке запуска. В отношении инструкций, записанных на ком­ пьютерном языке, широко применяется термин код. Вместо щелчка на кнопке запуска кода можете воспользоваться комбинацией кла­ виш <Ctrl+Enter>, если вам, как и мне, этот способ более удобен. print(\"Hello World!\") В ответ компьютер должен просто вывести в окне фразу “Hello World!” Простое введение в Python 133\n--- Страница 135 ---\nКак видите, ввод инструкции, предписывающей вывод фразы “Hello World!” , не привел к удалению предыдущей ячейки с содер­ жащимися в ней собственной инструкцией и собственным выводом. Это средство оказывается очень полезным при поэтапном создании решений из нескольких частей. Посмотрим, что произойдет при выполнении следующего кода, который демонстрирует одну ключевую идею. Введите и выполните этот код в новой ячейке. Если новая пустая ячейка не отображает­ ся в окне, щелкните на кнопке с изображением знака “плюс” , после наведения на которую указателя мыши высвечивается подсказка Insert Cell Below (вставить ячейку снизу). х = 10 print(х) print(х+5) у = х+7 print(у) print (z) Первая строка, х = 10, выглядит как математическая запись, ут­ верждающая, что х равно 10. В Python это означает, что в вирту­ альное хранилище под названием х заносится значение 10. Данную простую концепцию иллюстрирует следующая диаграмма. 134 Глава 2. Создаем нейронную сеть на Python\n--- Страница 136 ---\nЗначение “ 10” остается в хранилище до тех пор, пока в нем не возникнет необходимость. Вас не должна озадачить инструкция print (х), поскольку это инструкция вывода информации на экран, с которой вы уже сталкивались. Она выдаст хранящееся в х значение, которое равно 10. Но почему будет выведено “ 10” , а не “х”? Потому что Python всегда старается вычислить все, что только можно, а х можно вычислить и получить значение 10, которое и выводится. В следую­ щей строке, которая содержит инструкцию print (х+5), вычисляется выражение х+5, приводящее в конечном счете к значению 10+5, или 15. Поэтому мы ожидаем, что на экран будет выведено “ 15” . Следующая строка с инструкцией у=х+7 также не собьет вас с тол­ ку, если вы будете руководствоваться той идеей, что Python стремится выполнить все возможные вычисления. В этой инструкции мы пред­ писываем сохранить значение в новом хранилище, которое теперь на­ зывается у , но при этом возникает вопрос, а какое именно значение мы хотим сохранить? В инструкции указано выражение х + 7 , которое равно 10+7, т.е. 17. Таким образом, именно это значение и будет со­ хранено в у, и следующая инструкция выведет его на экран. А что произойдет со строкой print (z), если мы не назначили z ни­ какого значения, как это было сделано в случае х и у? Мы получим сообщение об ошибке, в вежливой форме информирующее нас о не­ корректности предпринимаемых нами действий и пытающееся быть максимально полезным, чтобы мы могли устранить ошибку. Должен заметить, что сообщения об ошибках не всегда успешно справляются со своей задачей — оказать помощь пользователю (причем этот недо­ статок характерен для большинства языков программирования). Простое введение в Python 135\n--- Страница 137 ---\nРезультаты выполнения описанного кода, включая вежливое со­ общение об ошибке “паше V is not defined” (имя ‘z’ не определено), можно увидеть на следующей иллюстрации. Вышеупомянутые хранилища, обозначенные как х и у и исполь­ зуемые для хранения таких значений, как 10 и 17, называют пере­ менными. В языках программирования переменные используются для создания обобщенных наборов инструкций по аналогии с тем, как математики используют алгебраические символы наподобие “х” и “у” для формулировки утверждений общего характера. 136 Глава 2. Создаем нейронную сеть на Python\n--- Страница 138 ---\nАвтоматизация работы Компьютеры великолепно подходят для многократного выполне­ ния однотипных задач — они не размышляют и производят вычис­ ления намного быстрее, чем это удается делать людям с помощью калькуляторов! Посмотрим, сможем ли мы заставить компьютер вывести квадра­ ты первых десяти натуральных чисел, начиная с нуля: 0 в квадрате, 1 в квадрате, 2 в квадрате и т.д. Мы ожидаем получить следующий ряд чисел: 0, 1, 4, 9, 16, 25 и т.д. Мы могли бы самостоятельно произвести все эти вычисления, а затем просто использовать инструкции вывода print (0), print (1), print (4) и т.д. Это сработает, но ведь наша цель заключается в том, чтобы всю вычислительную работу вместо нас выполнил компьютер. Более того, при этом мы упустили бы возможность создать типовой набор инструк­ ций, позволяющий выводить квадраты чисел в любом заданном диапа­ зоне. Для этого нам нужно сначала вооружиться несколькими новыми идеями, к освоению которых мы сейчас и приступим. Введите в очередную пустую ячейку следующий код: list( range(10) ) Вы должны получить список из десяти чисел от 0 до 9. Это прос­ то замечательно: мы заставили компьютер выполнить всю работу по созданию списка, дав ему соответствующее поручение. Теперь мы хозяева, а компьютер — наш слуга! Вероятно, вы удивлены тем, что список содержит числа от 0 до 9, а не от 1 до 10. Это не случайно. Многое из того, что связано с ком­ пьютерами, начинается с 0, а не с 1. Я много раз спотыкался на этом, полагая, что компьютерный список начинается с 1, а не с 0. Упорядоченные списки широко используются в качестве счетчиков при многократном выполнении некоторых вычислений и, в частнос­ ти, когда используются итеративные функции. Простое введение в Python 137\n--- Страница 139 ---\nВозможно, вы заметили, что мы опустили ключевое слово p r in t , которое использовали при выводе фразы “Hello World!” , как, впро­ чем, обошлись без него и при вычислении произведения 2*3. Использование ключевого слова p r i n t не является обязательным при работе с Python в интерактивном режиме, поскольку оболочка знает, что мы хотим увидеть результат введенной инструкции. Распространенным способом многократного выполнения вычисле­ ний с помощью компьютера является использование так называемых циклов. Слово “цикл” правильно передает суть происходящего, когда некоторые действия повторяются снова и снова, возможно, даже бес­ конечное число раз. Вместо того чтобы приводить формальное опреде­ ление цикла, гораздо полезнее рассмотреть конкретный простой при­ мер. Введите и выполните в новой ячейке следующий код. for n in range(1 0 ): prin t(n ) pass p r in t(\"го то во \") Здесь имеются три новых элемента, которые мы последовательно обсудим. Первая строка содержит выражение ra n g e ( 1 0 ) , с которым вы уже знакомы. Оно создает список чисел от 0 до 9. Конструкция f o r n in — это тот элемент, который создает цикл и заставляет выполнять некоторые действия для каждого числа из списка, организуя счетчик путем назначения текущего значения пе­ ременной п. Ранее мы уже обсуждали присваивание значений пере­ менным, и здесь происходит то же самое: при первом проходе цикла выполняется присваивание п = 0, а при последующих — присваивание п =1, п=2 и так до тех пор, пока мы не дойдем до последнего элемента списка, для которого будет выполнено присваивание п = 9. Вы, несомненно, сразу же поймете смысл инструкции p r i n t (п) в следующей строке, которая просто выводит текущее значение п. Но обратите внимание на отступ перед текстом p r i n t ( п ) . В Python отступы играют важную роль, поскольку намеренно используются для того, чтобы показать подчиненность одних инструкций другим, в данном случае циклу, созданному с помощью конструкции f o r n in . Инструкция p a s s сигнализирует о конце цикла, и следующая стро­ ка, записанная с использованием обычного отступа, не является час­ тью цикла. Это означает, что мы ожидаем, что слово “готово” будет 138 Глава 2. Создаем нейронную сеть на Python\n--- Страница 140 ---\nвыведено только один раз, а не десять. Представленный ниже ре­ зультат подтверждает наши ожидания. Теперь вам должно быть понятно, что для получения квадратов чисел следует выводить на экран значения п*п. В действительнос­ ти мы можем поступить еще лучше и выводить фразы наподобие “Квадрат числа 3 равен 9” . Заметьте, что в инструкции переменные не заключаются в кавычки и поэтому вычисляются. for n in range (10) : print(\"Квадрат числа\", п, \"равен\", п*п) pass print(\"готово\") Результат приведен ниже. Простое введение в Python 139\n--- Страница 141 ---\nЭто уже довольно сильный пример! Мы можем заставить ком­ пьютер очень быстро выполнить большой объем работы, используя минимальный набор инструкций. Точно так же мы, если бы захо­ тели, легко могли бы увеличить число итераций до пятидесяти или даже тысячи с помощью выражений ra n g e (5 0 ) или r a n g e ( 1 0 0 0 ) . Попробуйте сделать это самостоятельно! Комментарии Прежде чем знакомиться с другими чудесными и невероятными по своим возможностям командами Python, взгляните на приведен­ ный ниже простой код. # следующая инструкция выводит куб числа 2 print(2**3) Первая строка начинается с символа решетки (#). Python игнорирует все строки, начинающиеся с этого символа. Однако эти строки не бес­ полезны: с их помощью мы можем оставлять в коде полезные коммен­ тарии, которые помогут понять его предназначение другим людям или даже нам самим, если мы обратимся к нему после долгого перерыва. Поверьте мне, вы скажете себе “спасибо” за то, что не поленились снабдить код комментариями, особенно если речь идет о сложных или менее очевидных фрагментах кода. Я не раз пытался расшифро­ вать написанный собственноручно код, задавая себе вопрос: “А чего, собственно говоря, я хотел этим добиться?” Функции В главе 1 мы интенсивно работали с математическими функция­ ми. Мы относились к ним как к неким машинам, которые получают входные данные, выполняют некую работу и выдают результат. Эти функции действовали самостоятельно, и мы могли их многократно использовать. Многие языки программирования, включая Python, упрощают создание повторно используемых инструкций. Подобно математичес­ ким функциям такие многократно используемые фрагменты кода, если они определены надлежащим образом, могут действовать авто­ номно и обеспечивают создание более короткого элегантного кода. 140 Глава 2. Создаем нейронную сеть на Python\n--- Страница 142 ---\nПочему сокращается объем кода? Потому что вызывать функцию, обращаясь к ее имени, во сто крат лучше, чем каждый раз полнос­ тью записывать образующий эту функцию код. А что означает “определены надлежащим образом” ? Это означа­ ет, что вы четко определили, какие входные данные ожидает функ­ ция и какой тип выходных данных она выдает. Некоторые функции в качестве входных данных принимают только числа, и поэтому им нельзя передавать состоящие из букв слова. И вновь, вы лучше всего сможете оценить плодотворность идеи ис­ пользования функций, если мы обратимся к конкретному примеру. Введите и выполните следующий код. # функция, которая принимает два числа в качестве входных данных i и выводит их среднее значение def среднее(х,у): print(\"первое число х) print(\"второе число у) а = (х + у) /2.0 print(\"среднее значение равно\", а) return а Обсудим, что делают эти команды. Первые две строки, начинаю­ щиеся с символов #, Python игнорирует, но мы используем их в ка­ честве комментария для потенциальных читателей кода. Следующая за ними конструкция def среднее (х, у) : сообщает Python, что мы со­ бираемся определить новую повторно используемую функцию. Здесь def (от англ, define — определить) — ключевое слово; среднее — имя, которое мы даем функции. Его можно выбирать произвольно, но лучше всего использовать описательные имена, которые напом­ нят нам о том, для чего данная функция фактически предназначена. Конструкция в круглых скобках (х,у) сообщает Python, что функ­ ция принимает два входных значения, которые в пределах последу­ ющего определения функции обозначаются как х и у. В некоторых языках программирования требуется, чтобы вы указывали, объекты какого типа представляют переменные, но Python этого не делает, и впоследствии может лишь по-дружески пожурить вас за использо­ вание переменной не по назначению, например за то, что вы пытае­ тесь использовать слово, как будто оно является числом, или еще за какую-нибудь несуразицу подобного рода. Простое введение в Python 141\n--- Страница 143 ---\nТеперь, когда мы объявили Python о своем намерении определить функцию, мы должны сообщить, что именно делает эта функция. Определение функции вводится с отступом, что отражено в приве­ денном выше коде. В некоторых языках для того, чтобы было по­ нятно, к каким частям программы относятся те или иные фрагменты кода, используется множество всевозможных скобок, но создатели Python осознавали, что обилие скобок затрудняет чтение кода, тог­ да как отступы позволяют с первого взгляда получить представление о его структуре. В отношении целесообразности такого подхода мне­ ния разделились, поскольку люди часто попадают в ловушку, забы­ вая о важности отступов, но лично мне данная идея очень нравится! Это одна из самых полезных идей, зародившихся в чересчур заум­ ном мире компьютерного программирования. Понять смысл кода в определении функции среднее (х, у) вам будет совсем несложно, поскольку в нем используется все то, с чем вы уже сталкивались. Этот код выводит числа, передаваемые функции при ее вызове. Для вычисления среднего значения выводить аргументы во­ все не обязательно, но мы делаем это для того, чтобы было совершенно понятно, что происходит внутри функции. В следующей инструкции вычисляется величина (х + у) / 2.0 , и полученное значение присваи­ вается переменной а. Мы выводим среднее значение исключительно для контроля того, что происходит в коде. Последняя инструкция — return а. Она завершает определение функции и сообщает Python, что именно должна вернуть функция в качестве результата, подобно машинам, которые мы ранее обсуждали. Запустив этот код, вы увидите, что ничего не произошло. Никакие числа не выведены. Дело в том, что мы всего лишь определили функ­ цию, но пока что не вызвали ее. На самом деле Python зарегистри­ ровал функцию и будет держать ее наготове до тех пор, пока мы не захотим ее использовать. Введите в следующей ячейке среднее (2,4), чтобы активизировать функцию для значений 2 и 4. Кстати, в мире компьютерного програм­ мирования это называется вызовом функции. В соответствии с на­ шими ожиданиями данная функция выведет два входных значения и их вычисленное среднее. Кроме того, вы увидите ответ, выведен­ ный отдельно, поскольку вызовы функций в интерактивных сеансах Python сопровождаются последующим выводом возвращаемого ими 142 Глава 2. Создаем нейронную сеть на Python\n--- Страница 144 ---\nзначения. Ниже показано определение функции, а также результаты ее вызова с помощью инструкции среднее (2,4) и инструкции сред­ нее (2 0 0 , 3 0 1 ) с большими значениями. Поэкспериментируйте само­ стоятельно, вызывая функцию с различными входными значениями. Возможно, вы обратили внимание на то, что в коде функции сред­ нее двух значений находится путем деления не на 2, а на 2,0. Почему мы так поступили? Это особенность Python, которая мне самому не нравится. Если бы мы делили на 2, то результат был бы округлен до ближайшего целого в меньшую сторону, поскольку Python рас­ сматривал бы 2 просто как целое число. Это не изменило бы резуль­ тат вызова среднее ( 2 , 4 ) , поскольку 6/2 равно 3, т.е. целому числу. Однако в случае вызова среднее ( 2 0 0 ,3 0 1 ) среднее значение, равное 501/2, т.е. 250,5, было бы округлено до значения 250. Я считаю это неразумным, но об этом стоит помнить, если ваш код ведет себя не совсем так, как ожидается. Деление же на 2,0 сообщает Python, что в наши намерения действительно входит работа с числами, которые могут иметь дробную часть, и мы не хотим, чтобы они округлялись. Немного передохнем и поздравим себя. Мы определили повторно используемую функцию — один из наиболее важных и мощных эле­ ментов как математики, так и компьютерного программирования. Простое введение в Python 143\n--- Страница 145 ---\nМы будем применять повторно используемые функции при написа­ нии кода собственной нейронной сети. Например, имеет смысл создать повторно используемую функцию, которая реализовала бы вычисления с помощью сигмоиды, чтобы ее можно было вызывать много раз. Массивы Массивы — это не более чем таблицы значений, и они действи­ тельно оказываются очень кстати. Как и в случае таблиц, вы може­ те ссылаться на конкретные ячейки по номерам строк и столбцов. Наверное, вам известно, что именно таким способом можно ссылать­ ся на ячейки в электронных таблицах (например, В1 или С5) и про­ изводить над ними вычисления (например, C3+D7). Когда дело дойдет до написания кода нашей нейронной сети, мы используем массивы для представления матриц входных сигналов, весовых коэффициентов и выходных сигналов. Но не только этих, а также матриц, представляющих сигналы внутри нейронной сети и их распространение в прямом направлении, и матриц, представля­ ющих обратное распространение ошибок. Поэтому давайте познако­ мимся с массивами. Введите и выполните следующий код: import пшпру Что делает этот код? Команда im p o r t сообщает Python о необхо­ димости привлечения дополнительных вычислительных ресурсов из другого источника для расширения круга имеющихся инструментов. 144 Глава 2. Создаем нейронную сеть на Python\n--- Страница 146 ---\nВ некоторых случаях эти дополнительные инструменты являются частью Python, но они не находятся в состоянии готовности к немед­ ленному использованию, чтобы без надобности не отягощать Python. Чаще всего расширения не относятся к основному инструментарию Python, но создаются сторонними разработчиками в качестве вспо­ могательных ресурсов, доступных для всеобщего использования. В данном случае мы импортируем дополнительный набор инструмен­ тов, объединенных в единый модуль под названием пшпру. Пакет п ш п ру очень популярен и предоставляет ряд полезных средств, вклю­ чая массивы и операции над ними. Введите в следующей ячейке приведенный ниже код. а=numpy.zeros( [3,2] ) print(а) В этом коде импортированный модуль numpy используется для соз­ дания массива размерностью 3x2, во всех ячейках которого содер­ жатся нулевые значения. Мы сохраняем весь массив в переменной а, после чего выводим ее на экран. Результат подтверждает, что массив действительно состоит из нулей, хранящихся в виде таблицы с тре­ мя строками и двумя столбцами. А теперь модифицируем содержимое этого массива и заменим не­ которые из его нулей другими значениями. В приведенном ниже коде показано, как сослаться на конкретные ячейки для того, чтобы заменить хранящиеся в них значения новыми. Это напоминает об­ ращение к нужным ячейкам электронной таблицы. а [ 0,0] = 1 а [ 0 ,1 3 =2 а[1,0 ] = 9 а [2,1 ] = 1 2 print(а) Простое введение в Python 145\n--- Страница 147 ---\nПервая строка обновляет ячейку, находящуюся в строке 0 и столб­ це 0, заменяя все, что в ней до этого хранилось, значением 1. В осталь­ ных строках другие ячейки аналогичным образом обновляются, а по­ следняя строка выводит массив на экран с помощью инструкции p r i n t ( а ) . На приведенной ниже иллюстрации показано, что собой представляет массив после всех изменений. Теперь, когда вам известно, как присваивать значения элемен­ там массива, вас, вероятно, интересует, каким образом можно уз­ нать значение отдельного элемента, не выводя на экран весь массив? Это делается очень просто. Чтобы сослаться на содержимое ячейки массива, которое мы хотим вывести на экран или присвоить другой переменной, достаточно воспользоваться выражением наподобие а [ 0 ,1 ] или а [ 1 ,0 ] . Именно это демонстрирует приведенный ниже фрагмент кода. print(а[0,1]) v = а[1,0] print(v) Запустив этот пример, вы увидите, что первая инструкция p r in t выводит значение 2,0, т.е. содержимое ячейки [0,1]. Следующая ин­ струкция присваивает значение элемента массива а [ 1 ,0 ] перемен­ ной v и выводит значение этой переменной. Как и ожидалось, выво­ дится значение 9,0. 146 Глава 2. Создаем нейронную сеть на Python\n--- Страница 148 ---\nНумерация столбцов и строк начинается с 0, а не с 1. Верхний ле­ вый элемент обозначается как [0,0], а не как [1,1]. Отсюда следует, что правому нижнему элементу соответствует обозначение [2,1], а не [3,2]. Иногда я сам попадаю впросак на этом, потому что забываю о том, что в компьютерном мире многие вещи начинаются с 0, а не с 1. Если мы попытаемся, к примеру, обратиться к элементу массива а[0,2], то получим сообщение об ошибке. Массивы, или матрицы, пригодятся нам для нейронных сетей, поскольку позволят упростить инструкции при выполнении интен­ сивных вычислений, связанных с распространением сигналов и об­ ратным распространением ошибок в сети, что обсуждалось в главе 1. Графическое представление массивов Как и в случае больших числовых таблиц и списков, понять смысл чисел, содержащихся в элементах массива большой размерности, довольно трудно. В то же время их визуализация позволяет быстро получить общее представление о том, что они означают. Одним из способов графического отображения двухмерных числовых масси­ вов является их представление в виде двухмерных поверхностей, Простое введение в Python 147\n--- Страница 149 ---\nокраска которых в каждой точке зависит от значения соответству­ ющего элемента массива. Способ установления соответствия между цветом поверхности и значением элемента массива вы выбираете по своему усмотрению. Например, можно преобразовывать значения в цвет, используя какую-либо цветовую шкалу, или закрасить всю поверхность белым цветом за исключением черных точек, которым соответствуют значения, превышающие определенный порог. Давайте представим в графическом виде созданный ранее неболь­ шой массив размерностью 3 x 2 . Но сначала мы должны расширить возможности Python для рабо­ ты с графикой. Для этого необходимо импортировать дополнитель­ ный код Python, написанный другими людьми. Это все равно что взять у товарища книгу рецептов, поставить ее на свою книжную полку и пользоваться ею для приготовления блюд, которые раньше не умели готовить. Ниже приведена инструкция, с помощью которой мы импортиру­ ем нужный нам пакет для работы с графикой: import matplotlib.pyplot Здесь m a t p l o t l i b .p y p l o t — это имя новой “книги рецептов” , кото­ рую мы на время одалживаем. Во всех подобных случаях имя модуля или библиотеки, предоставляющей в ваше распоряжение дополни­ тельный код, указывается после ключевого слова im p o r t. В процессе работы с Python часто приходится импортировать дополнительные средства, облегчающие жизнь программиста за счет повторного ис­ пользования полезного кода, предложенного сторонними разработ­ чиками. Возможно, и вы разработаете когда-нибудь код, которым поделитесь с коллегами! Кроме того, мы должны дополнительно сообщить IPython о том, что любую графику следует отображать в блокноте, а не в отдельном окне. Это делается с помощью следующей директивы: %matplotlib inline Теперь мы полностью готовы к тому, чтобы представить массив в графическом виде. Введите и выполните следующий код: matplotlib.pyplot.imshow(a, interpolation=\"nearest\") 148 Глава 2. Создаем нейронную сеть на Python\n--- Страница 150 ---\nПотрясающе! Нам удалось представить содержимое массива в виде цветной диаграммы. Вы видите, что ячейки, содержащие одинако­ вые значения, закрашены одинаковыми цветами. Позже мы исполь­ зуем ту же функцию imshow() для визуализации значений, которые будем получать из нашей нейронной сети. В состав пакета IPython входит богатый набор инструментов, пред­ назначенных для визуализации данных. Вам следует изучить их само­ стоятельно, чтобы оценить диапазон их возможностей. Даже функция imshow () предлагает множество опций графического представления данных, таких как использование различных цветовых палитр. Объекты Вам следует познакомиться с еще одним фундаментальным поня­ тием, которое используется в Python, — понятием объекта. Объекты в чем-то схожи с повторно используемыми функциями, поскольку, однажды определив их, вы сможете впоследствии обращаться к ним множество раз. Но по сравнению с функциями объекты способны на гораздо большее. Простое введение в Python 149\n--- Страница 151 ---\nНаилучший способ знакомства с объектами — это не обсужде­ ние абстрактных понятий, а рассмотрение конкретного примера. Взгляните на следующий код. # класс объектов Dog (собака) class Dog: # собаки могут лаять def bark(self): print(\"Гав!\") pass pass Начнем с того, с чем мы уже знакомы. Прежде всего, код вклю­ чает функцию b a r k ( ) . Как нетрудно заметить, при вызове данной функции она выведет слово “Гав!” Это довольно просто. А теперь рассмотрим код в целом. Вы видите ключевое слово c l a s s , за которым следуют имя Dog (собака) и структура, напоми­ нающая функцию. Вы сразу же можете провести параллели между этой структурой и определением функции, которое также снабжает­ ся именем. Отличаются же они тем, что для определения функций используется ключевое слово def, тогда как для определения объек­ тов используется ключевое слово c l a s s . Прежде чем углубиться в обсуждение того, какое отношение эта структура, называемая к л а с с о м, имеет к объектам, вновь обратимся к простому, но реальному коду, который оживляет эти понятия. sizzles = Dog() sizzles.bark() В первой строке создается переменная sizzles, источником ко­ торой является, судя по всему, вызов функции. В действительности Dog () — это особая функция, которая создает экземпляр класса Dog. Теперь вы увидели, как создавать различные сущности из определе­ ний классов. Эти сущности называются объектами. В данном случае мы создали из определения класса Dog объект sizzles и можем счи­ тать, что этот объект является собакой! В следующей строке для объекта sizzles вызывается функция bark (). С этим вы уже немного знакомы, поскольку ранее успели поработать с функциями. Но вам нужно еще привыкнуть к тому, 150 Глава 2. Создаем нейронную сеть на Python\n--- Страница 152 ---\nчто функция bark () вызывается так, как если бы она была частью объекта sizzles. Это возможно, потому что данную функцию имеют все объекты, созданные на основе класса Dog, ведь именно в нем она и определена. Опишем все это простыми словами. Мы создали переменную sizzles, разновидность класса Dog. Переменная sizzles — это объект, созданный по шаблону класса Dog. Объекты — это экземпляры класса. Следующий пример показывает, что мы к этому времени успели сделать, и подтверждает, что функция sizzles .bark () действитель­ но выводит слово “Гав!” Возможно, вы обратили внимание на непонятный элемент self в определении функции — bark (self). Он здесь для того, чтобы указывать Python, к какому объекту приписывается функция при ее создании. Я считаю, что это должно быть очевидным, поскольку определение функции bark () включено в определение класса, а зна­ чит, Python и без того известно, к какому объекту ее следует прикре­ пить, но это мое личное мнение. Рассмотрим примеры более полезного использования объектов и классов. Взгляните на следующий код. sizzles = Dog () mutley = Dog() sizzles.bark() mutley.bark() Простое введение в Python 151\n--- Страница 153 ---\nЭто уже интересно! Мы создали два объекта: sizzles и mutley. Важно понимать, что оба они были созданы на основе одного и того же определения класса Dog. Замечательно! Сначала мы определяем, как объекты должны выглядеть и как должны себя вести, а затем создаем их реальные экземпляры. В этом и состоит суть различия между классами и объектами: первые представляют собой описания объектов, а вторые — реаль­ ные экземпляры классов, созданные в соответствии с этими описани­ ями. Класс — это рецепт приготовления пирога, а объект — сам пи­ рог, изготовленный по данному рецепту. Процесс создания объектов на основе описания класса можно пояснить с помощью следующей наглядной иллюстрации. 152 Глава 2. Создаем нейронную сеть на Python\n--- Страница 154 ---\nА что нам дает создание объектов на основе класса? К чему все эти хлопоты? Не лучше ли было просто вывести фразу “Гав!” без какого- либо дополнительного кода? Прежде всего, это имеет смысл делать тогда, когда возникает не­ обходимость в создании множества однотипных объектов. Создавая эти объекты по единому образцу на основе класса, а не описывая полностью каждый из них по отдельности, вы экономите массу вре­ мени. Но реальное преимущество объектов заключается в том, что они обеспечивают компактное объединение данных и функциональ­ ности в одном месте. Централизованная организация фрагментов кода в виде объектов, которым они естественным образом принад­ лежат, значительно облегчает понимание структуры программы, особенно в случае сложных задач, что является большим плюсом для программистов. Собаки лают. Кнопки реагируют на щелчки. Динамики издают звуки. Принтеры печатают или жалуются, если закончилась бумага. Во многих компьютерных системах кнопки, динамики и принтеры действительно являются объектами, функции которых вы активизируете. Функции, принадлежащие объектам, называют методами. С вклю­ чением функций в состав объектов вы уже сталкивались, когда мы до­ бавляли функцию bark () в определение класса Dog, и созданные на ос­ нове этого класса объекты s i z z l e s и m u tle y включали в себя данный метод. Вы видели, что оба они “лаяли” в рассмотренном примере! Нейронные сети принимают некоторые входные данные (вход­ ной сигнал), выполняют некоторые вычисления и выдают выходные данные (выходной сигнал). Вы также знаете, что их можно трениро­ вать. Вы уже видели, что эти действия — тренировка и выдача от­ вета — являются естественными функциями нейронной сети, т.е. их можно рассматривать в качестве функций объекта нейронной сети. Вы также помните, что с нейронными сетями естественным образом связаны относящиеся к ним внутренние данные — весовые коэффи­ циенты связей между узлами. Вот почему мы будем создавать нашу нейронную сеть в виде объекта. Чтобы вы получили более полное представление о возможностях объектов, давайте добавим в класс переменные, предназначенные для хранения специфических данных конкретных объектов, а так­ же методы, позволяющие просматривать и изменять эти данные. Простое введение в Python 153\n--- Страница 155 ---\nВзгляните на приведенное ниже обновленное определение класса Dog. Оно включает ряд новых элементов, которые мы рассмотрим по отдельности. # определение класса объектов Dog cla ss Dog: # метод для инициализации объекта внутренними данными def _ _i n i t _ _( s e l f , petname, temp) : self.name = petname; self.temperature = temp; # получить состояние def s t a t u s ( s e l f ) : print(\"имя собаки: \", self.name) print(\"температура собаки: \", self.temperature) pass # задать температуру def setT em peratu re(self, temp): self.temperature = temp; pass # собаки могут лаять def b a r k (s e lf): print(\"Гав!\") pass pass Прежде всего, хочу обратить ваше внимание на то, что мы добави­ ли в класс Dog три новые функции. У нас уже была функция bark (), а теперь мы дополнительно включили в класс функции __i n i t ___(), s t a t u s () и s e tT e m p e r a tu r e (). Процедура добавления новых функ­ ций достаточно очевидна. Чтобы собака могла не только лаять с по­ мощью функции b a rk (), мы при желании могли бы дополнительно предоставить ей возможность чихать с помощью функции s n e e z e (). Но что это за переменные, указанные в круглых скобках после имен новых функций? Например, функция s e t T e m p e r a t u r e фак­ тически определена как s e tT e m p e r a t u r e ( s e l f , temp). Функция со странным названием __i n i t__фактически определена к а к ___ i n i t _ _ ( s e l f , petname, temp). Эти переменные, получения значений кото­ рых функции ожидают во время вызова, называются параметрами. Помните функцию вычисления среднего avg ( х , у ) , с которой вы уже 154 Глава 2. Создаем нейронную сеть на Python\n--- Страница 156 ---\nсталкивались? Определение функции a v g () явно указывало на то, что функция ожидает получения двух параметров. Следовательно, функция __i n i t__() нуждается в параметрах petname и temp, а функ­ ция s e tT e m p e r a tu r e () — только в параметре temp. Заглянем внутрь этих функций. Начнем с функции с необычным названием __i n i t__(). Зачем ей присвоено такое замысловатое имя? Это специальное имя, и Python будет вызывать функцию __init__() каждый раз при создании нового объекта данного класса. Это очень удобно для выполнения любой подготовительной работы до фактичес­ кого использования объекта. Так что же именно происходит в этой ма­ гической функции инициализации? Мы создаем две новые перемен­ ные: s e l f .паше и s e l f . temperature. Вы можете узнать их значения из переменных petname и temp, передаваемых функции. Часть s e l f , в именах означает, что эти переменные являются собственностью объекта, т.е. принадлежат данному конкретному объекту и не зависят от других объектов Dog или общих переменных Python. Мы не хотим смешивать имя данной собаки с именем другой! Если это кажется вам слишком сложным, не беспокойтесь, все значительно упростится, ког­ да мы приступим к рассмотрению конкретного примера. Следующая на очереди — функция s t a t u s ( ) , которая действи­ тельно проста. Она не принимает никаких параметров и просто вы­ водит значения переменных паше и te m p e ra tu r e объекта Dog. Наконец, функция s e tT e m p e r a tu r e () принимает параметр tem p, значение которого при ее вызове присваивается внутренней перемен­ ной s e l f . te m p e r a tu r e . Это означает, что даже после того, как объект создан, вы можете в любой момент изменить его температуру, при­ чем это можно сделать столько раз, сколько потребуется. Мы не будем тратить время на обсуждение того, почему все эти функции, включая b a r k (), принимают атрибут s e l f в качестве первого пара­ метра. Это особенность Python, которая лично меня немного раз­ дражает, но таков ход эволюции Python. По замыслу разработчиков это должно напоминать Python, что функция, которую вы собирае­ тесь определить, принадлежит объекту, ссылкой на который слу­ жит s e l f . Но ведь, по сути, это и так очевидно, ведь код функции находится внутри класса. Таким образом, вас не должно удивлять то, что горячие дискуссии по этому поводу разгорелись даже в среде Простое введение в Python 155\n--- Страница 157 ---\nпрофессиональных программистов на языке Python, так что вы не одиноки в компании тех, у кого такой подход вызывает недоумение. Чтобы прояснить все, о чем мы говорили, рассмотрим конкретный пример. В приведенном ниже коде вы видите обновленный класс Dog, определенный с новыми функциями, и новый объект la s s ie , созда­ ваемый с параметрами, один из которых задает его имя как “Lassie”, а другой устанавливает его температуру равной 37. Как видите, вызов функции s t a t u s () для объекта l a s s i e класса Dog обеспечивает вывод его имени и текущего значения температу­ ры. С момента создания объекта эта температура не изменялась. Попытаемся изменить температуру объекта и проверим, действи­ тельно ли она изменилась, введя следующий код. lassie.SetTemperature(40) lassie.status() 156 Глава 2. Создаем нейронную сеть на Python\n--- Страница 158 ---\nРезультат представлен ниже. Как видите, вызов функции s e tT e m p e r a tu r e (40) действительно изменил внутреннее значение температуры объекта. Мы должны быть довольны собой, поскольку узнали доволь­ но много об объектах, которые многие считают сложной темой, но для нас она оказалась не таким уж трудным орешком! Сейчас нам известно достаточно много о Python, чтобы мы могли самостоятельно создать собственную нейронную сеть. Проект нейронной сети на Python Теперь мы можем приступить к созданию собственной нейронной сети с помощью языка Python, знакомиться с которым вы только что закончили. Мы будем двигаться постепенно, отрабатывая каждый шаг, и создадим свою программу на Python по частям. Начинать с малого, а затем постепенно наращивать — весьма муд­ рый подход при создании компьютерного кода даже средней слож­ ности. С учетом того опыта, который мы к этому моменту накопили, ка­ жется вполне естественным начать с построения скелета класса ней­ ронной сети. Не будем терять времени! Скелет кода Кратко обрисуем, что должен собой представлять класс нейрон­ ной сети. Мы знаем, что он должен содержать по крайней мере три функции: Проект нейронной сети на Python 157\n--- Страница 159 ---\n• инициализация — задание количества входных, скрытых и вы­ ходных узлов; • тренировка — уточнение весовых коэффициентов в процессе обработки предоставленных для обучения сети тренировочных примеров; • опрос — получение значений сигналов с выходных узлов после предоставления значений входящих сигналов. Возможно, в данный момент мы не сможем предложить идеальное определение класса, и впоследствии понадобится включить в него новые функции, но давайте начнем с этого минимального набора. Наш начальный код может иметь примерно следующий вид. # определение класса нейронной сети class neuralNetwork: # инициализировать нейронную сеть def __init__() : pass # тренировка нейронной сети def train(): pass # опрос нейронной сети def query(): pass Для начала довольно неплохо. В действительности это достаточно надежный скелет, который в процессе нашей работы будет постепен­ но обрастать плотью в виде работающего кода. Инициализация сети Начнем с инициализации. Мы знаем, что нам необходимо задать количество узлов входного, скрытого и выходного слоев. Эти данные определяют конфигурацию и размер нейронной сети. Вместо того чтобы жестко задавать их в коде, мы предусмотрим установку соот­ ветствующих значений в виде параметров во время создания объекта нейронной сети. Благодаря этому можно будет без труда создавать новые нейронные сети различного размера. 158 Глава 2. Создаем нейронную сеть на Python\n--- Страница 160 ---\nВ основе нашего решения лежит одно важное соображение. Хорошие программисты, ученые-компьютерщики и математики при всяком удобном случае стараются писать обобщенный код, не зави­ сящий от конкретных числовых значений. Это хорошая привычка, поскольку она вынуждает нас более глубоко продумывать решения, расширяющие применимость программы. Следуя ей, мы сможем использовать наши программы в самых разных сценариях. В дан­ ном случае это означает, что мы будем пытаться разрабатывать код для нейронной сети, поддерживающий как можно больше открытых опций и использующий как можно меньше предположений, чтобы его можно было легко применять в различных ситуациях. Мы хо­ тим, чтобы один и тот же класс мог создавать как небольшие ней­ ронные сети, так и очень большие, требуя лишь задания желаемых размеров сети в качестве параметров. Кроме того, нам нельзя забывать о коэффициенте обучения. Этот параметр также можно устанавливать при создании новой нейрон­ ной сети. Посмотрите, как может выглядеть функция инициализа­ ции __init__() в подобном случае. # инициализировать нейронную сеть def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate): # задать количество узлов во входном, скрытом и выходном слое self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes # коэффициент обучения self.lr = learningrate pass Добавим этот код в наше определение класса нейронной сети и по­ пытаемся создать объект небольшой сети с тремя узлами в каждом слое и коэффициентом обучения, равным 0,3. # количество входных, скрытых и выходных узлов input_nodes = 3 hidden_nodes = 3 output_nodes = 3 # коэффициент обучения равен 0,3 learning_rate = 0.3 Проект нейронной сети на Python 159\n--- Страница 161 ---\n# создать экземпляр нейронной сети n = neuralNetwork(input_nodes,hidden_nodes,output_nodes,learning_rate) Конечно же, данный код позволяет получить объект сети, но та­ кой объект пока что не будет особенно полезным, потому что не со­ держит ни одной функции, способной выполнять полезную работу. Впрочем, тут нет ничего плохого, это нормальная практика — начи­ нать с малого и постепенно наращивать код, попутно находя и устра­ няя ошибки. Исключительно для проверки того, что мы ничего не упустили, ниже показано, как выглядит блокнот IPython с определением клас­ са нейронной сети и кодом для создания объекта. Что дальше? Мы сообщили объекту нейронной сети, сколько уз­ лов разных типов нам необходимо иметь, но для фактического созда­ ния узлов пока что ничего не сделали. 160 Глава 2. Создаем нейронную сеть на Python\n--- Страница 162 ---\nВесовые коэффициенты — сердце сети Итак, нашим следующим шагом будет создание сети, состоящей из узлов и связей. Наиболее важная часть этой сети — весовые ко­ эффициенты связей (веса). Они используются для расчета распро­ странения сигналов в прямом направлении, а также обратного рас­ пространения ошибок, и именно весовые коэффициенты уточняются в попытке улучшить характеристики сети. Ранее вы уже видели, насколько удобна компактная запись весов в виде матриц. Следовательно, мы можем создать следующие матрицы: • матрицу весов для связей между входным и скрытым слоями, К входной_скрытый> размерностью hidden_nodes х input_nodes; • другую матрицу для связей между скрытым и выходным сло­ ями, И с к р ы т ы й _в ы ж о д н о й , размерностью output_nodes х hidden_nodes. При необходимости вернитесь к главе 1, чтобы понять, почему первая матрица имеет размерность hidden_nodes х input_nodes, а не input_nodes х hidden_nodes. Вспомните из главы 1, что начальные значения весовых коэффи­ циентов должны быть небольшими и выбираться случайным обра­ зом. Следующая функция из пакета numpy генерирует массив случай­ ных чисел в диапазоне от 0 до 1, где размерность массива равна rows х х columns: numpy.random.rand(rows, columns) Все хорошие программисты ищут в Интернете онлайновую доку­ ментацию по функциям Python и даже находят полезные функции, о существовании которых и не подозревали. Для поиска любой ин­ формации, касающейся программирования, лучше всего использо­ вать Google. Выполните такой поиск для функции numpy.random, rand () , если хотите узнать о ней больше. Если мы собираемся использовать расширения пакета numpy, мы должны импортировать эту библиотеку в самом начале кода. Прежде всего удостоверимся, что нужная нам функция работает. В приве­ денном ниже примере используется матрица размерностью 3x3. Как видите, матрица заполнилась случайными значениями в диапазоне от 0 до 1. Проект нейронной сети на Python 161\n--- Страница 163 ---\nДанный подход можно улучшить, поскольку весовые коэффици­ енты могут иметь не только положительные, но и отрицательные значения и изменяться в пределах от -1 ,0 до +1,0. Для простоты мы вычтем 0,5 из этих граничных значений, перейдя к диапазону зна­ чений от -0,5 до +0,5. Ниже представлены результаты применения этого изящного подхода, которые демонстрируют, что некоторые ве­ совые коэффициенты теперь имеют отрицательные значения. Мы готовы создать матрицу начальных весов в нашей программе на Python. Эти весовые коэффициенты составляют неотъемлемую часть нейронной сети и служат ее характеристиками на протяжении всей ее жизни, а не временным набором данных, которые исчезают сразу же после того, как функция отработала. Это означает, что они должны быть частью процесса инициализации и быть доступными для других методов, таких как функции тренировки и опроса сети. Ниже приведен код, включая комментарии, который создает две матрицы весовых коэффициентов, используя значения переменных s e lf .inodes, s e lf .hnodes и s e lf .onodes для задания соответствую­ щих размеров каждой из них. # Матрицы весовых коэффициентов связей wih (между входным и скрытым # слоями) и who (между скрытым и выходным слоями). # Весовые коэффициенты связей между узлом i и узлом j следующего слоя # обозначены как w_i_j: # wll w21 # wl2 w22 и т.д. 162 Глава 2, Создаем нейронную сеть на Python\n--- Страница 164 ---\nself.wih = (numpy.random.rand(self.hnodes, self.inodes) - 0.5) self.who = (numpy.random.rand(self.onodes, self.hnodes) - 0.5) Великолепная работа! Мы реализовали то, что составляет саму сердцевину нейронной сети, — матрицы связей между ее узлами! По желанию: улучшенный вариант инициализации весовых коэффициентов Описанное в этом разделе обновление кода не является обязатель­ ным, поскольку это всего лишь простое, но популярное усовершен­ ствование процесса инициализации весовых коэффициентов. В конце главы 1 мы обсуждали различные способы подготовки данных и инициализации коэффициентов. Так вот, некоторые пред­ почитают несколько усовершенствованный подход к созданию слу­ чайных начальных значений весов. Для этого весовые коэффициен­ ты выбираются из нормального распределения с центром в нуле и со стандартным отклонением, величина которого обратно пропорцио­ нальна корню квадратному из количества входящих связей на узел. Это легко делается с помощью библиотеки numpy. Опять-таки, в отношении поиска онлайновой документации Google незаменим. Функция numpy. random.normal () описана по такому адресу: https://docs.scipy.org/doc/numpy-1.10.1/reference/ generated/numpy.random.normal.html Она поможет нам с извлечением выборки из нормального распре­ деления. Ее параметрами являются центр распределения, стандарт­ ное отклонение и размер массива numpy, если нам нужна матрица случайных чисел, а не одиночное число. Обновленный код инициализации весовых коэффициентов будет выглядеть примерно так. self.wih = numpy.random.normal (0.0, pow(self.hnodes, -0.5), ^(self.hnodes, self.inodes)) self.who = numpy.random.normal (0.0, pow(self.onodes, -0.5), ^(self.onodes, self.hnodes)) Как видите, центр нормального распределения установлен здесь в 0,0. Стандартное отклонение вычисляется по количеству узлов Проект нейронной сети на Python 163\n--- Страница 165 ---\nв следующем слое с помощью функции p o w (s e lf .h n odes, - 0 . 5 ) , ко­ торая просто возводит количество узлов в степень -0 ,5 . Последний параметр определяет конфигурацию массива numpy. Опрос сети Казалось бы, логично начать с разработки кода, предназначенного для тренировки нейронной сети, заполнив инструкциями функцию tr a in ( ) , которая на данном этапе пуста, но мы отложим ее на время и займемся более простой функцией query ( ) . Благодаря этому мы постепенно приобретем уверенность в своих силах и получим опыт в использовании как языка Python, так и матриц весовых коэффи­ циентов в объекте нейронной сети. Функция query () принимает в качестве аргумента входные дан­ ные нейронной сети и возвращает ее выходные данные. Все доволь­ но просто, но вспомните, что для этого нам нужно передать сигналы от узлов входного слоя через скрытый слой к узлам выходного слоя для получения выходных данных. При этом, как вы помните, по мере распространения сигналов мы должны сглаживать их, используя ве­ совые коэффициенты связей между соответствующими узлами, а так­ же применять сигмоиду для уменьшения выходных сигналов узлов. В случае большого количества узлов написание для каждого из них кода на Python, осуществляющего сглаживание весовых коэф­ фициентов, суммирование сигналов и применение к ним сигмоиды, превратилось бы в сплошной кошмар. К счастью, нам не нужно писать детальный код для каждого узла, поскольку мы уже знаем, как записать подобные инструкции в прос­ той и компактной матричной форме. Ниже показано, как можно по­ лучить входящие сигналы для узлов скрытого слоя путем сочетания матрицы весовых коэффициентов связей между входным и скрытым слоями с матрицей входных сигналов: X = W • Iскрытый входной_скрытый В этом выражении замечательно не только то, что в силу его крат­ кости нам легче его записать, но и то, что такие компьютерные язы­ ки, как Python, распознают матрицы и эффективно выполняют все 164 Глава 2, Создаем нейронную сеть на Python\n--- Страница 166 ---\nрасчеты, поскольку им известно об однотипности всех стоящих за этим вычислений. Вы будете удивлены простотой соответствующего кода на языке Python. Ниже представлена инструкция, которая показывает, как применить функцию скалярного произведения библиотеки numpy к матрицам весов и входных сигналов: hidden_inputs = numpy.dot(self.wih, inputs) Вот и все! Эта короткая строка кода Python выполняет всю работу по объеди­ нению всех входных сигналов с соответствующими весами для полу­ чения матрицы сглаженных комбинированных сигналов в каждом узле скрытого слоя. Более того, нам не придется ее переписывать, если в следующий раз мы решим использовать входной или скрытый слой с другим количеством узлов. Этот код все равно будет работать! Именно эта мощь и элегантность матричного подхода являют­ ся причиной того, что перед этим мы не пожалели потратить время и усилия на его рассмотрение. Для получения выходных сигналов скрытого слоя мы просто при­ меняем к каждому из них сигмоиду: О = сигмоида (X _ )скрытый скрытый 7 Это не должно вызвать никаких затруднений, особенно если сигмоида уже определена в какой-нибудь библиотеке Python. Оказывается, так оно и есть! Библиотека scipy в Python содержит набор специальных функций, в том числе сигмоиду, которая назы­ вается expit (). Не спрашивайте меня, почему ей присвоили такое дурацкое имя. Библиотека scipy импортируется точно так же, как и библиотека numpy. # библиотека scipy.special содержит сигмоиду expit() import scipy.special Поскольку в будущем мы можем захотеть поэкспериментировать с функцией активации, настроив ее параметры или полностью заме­ нив другой функцией, лучше определить ее один раз в объекте ней­ ронной сети во время его инициализации. После этого мы сможем Проект нейронной сети на Python 165\n--- Страница 167 ---\nнеоднократно ссылаться на нее, точно так же, как на функцию query (). Такая организация программы означает, что в случае внесе­ ния изменений нам придется сделать это только в одном месте, а не везде в коде, где используется функция активации. Ниже приведен код, определяющий функцию активации, кото­ рый мы используем в разделе инициализации нейронной сети. # использование сигмоиды в качестве функции активации self.activation_function = lam bda x: scipy.special.expit(x) Что делает этот код? Он не похож ни на что, с чем мы прежде сталкивались. Что это за lambda? Не стоит пугаться, здесь нет ничего страшного. Все, что мы сделали, — это создали функцию наподобие любой другой, только с использованием более короткого способа за­ писи, называемого лямбда-выражением. Вместо привычного опреде­ ления функции в форме def им я() мы использовали волшебное слово lambda, которое позволяет создавать функции быстрым и удобным способом, что называется, “на лету” . В данном случае функция при­ нимает аргумент х и возвращает s cip y .sp e cia l.e x p it (), а это есть не что иное, как сигмоида. Функции, создаваемые с помощью лямб­ да-выражений, являются безымянными или, как предпочитают го­ ворить опытные программисты, анонимными, но данной функции мы присвоили имя s e lf .activation _fu n ction (). Это означает, что всякий раз, когда потребуется использовать функцию активации, ее нужно будет вызвать как s e l f . activation_function (). Итак, возвращаясь к нашей задаче, мы применим функцию акти­ вации к сглаженным комбинированным входящим сигналам, посту­ пающим на скрытые узлы. Соответствующий код совсем не сложен. # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) Таким образом, сигналы, исходящие из скрытого слоя, описыва­ ются матрицей hidden_outputs. Мы прошли промежуточный скрытый слой, а как быть с послед­ ним, выходным слоем? В действительности распространение сигнала от скрытого слоя до выходного ничем принципиально не отличает­ ся от предыдущего случая, поэтому способ расчета остается тем же, а значит, и код будет аналогичен предыдущему. 166 Глава 2. Создаем нейронную сеть на Python\n--- Страница 168 ---\nНиже приведен итоговый фрагмент кода, объединяющий расчеты сигналов скрытого и выходного слоев. # рассчитать входящие сигналы для скрытого слоя hidden_inputs = nuxnpy.dot(self.wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) # рассчитать входящие сигналы для выходного слоя final_inputs = numpy. dot (self. who, hidcLen_outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.асtivation_function(final_inputs) Если отбросить комментарии, здесь всего четыре строки кода, вы­ деленные полужирным шрифтом, которые выполняют все необходи­ мые расчеты: две — для скрытого слоя и две — для выходного слоя. Текущее состояние кода Сделаем паузу и переведем дыхание, чтобы посмотреть, как вы­ глядит в целом код, который мы к этому времени создали. А выгля­ дит он так. # определение класса нейронной сети class neuralNetwork: # инициализировать нейронную сеть def __init__(self, inputnodes, hiddennodes, outputnodes, b learningrate): # задать количество узлов во входном, скрытом и выходном слое self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes # Матрицы весовых коэффициентов связей wih и who. # Весовые коэффициенты связей между узлом i и узлом j # следующего слоя обозначены как w__i__j: # wll w21 # wl2 w22 и т.д. self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), ^(self.hnodes, self.inodes)) self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), b (self.onodes, self.hnodes)) # коэффициент обучения Проект нейронной сети на Python 167\n--- Страница 169 ---\nself.lr = learningrate # использование сигмоиды в качестве функции активации self.activation_function = lambda x: scipy.special.expit(x) pass # тренировка нейронной сети def train() : pass # опрос нейронной сети def query(self, inputsJList): # преобразовать список входных значений # в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2).T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy.dot(self.wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) # рассчитать входящие сигналы для выходного слоя final_inputs = numpy.dot(self.who, hidden__outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation_function(final_inputs) return final_outputs Но это только определение класса, перед которым в первой ячей­ ке блокнота IPython следует поместить код, импортирующий модули numpy и s c ip y . s p e c ia l. import numpy # библиотека scipy.special с сигмоидой expit () import scipy.special Попутно отмечу, что функции query () в качестве входных данных потребуются только входные сигналы i n p u t _ l i s t . Ни в каких дру­ гих входных данных она не нуждается. Мы достигли значительного прогресса и теперь можем вернуться к недостающему фрагменту — функции tr a in (). Вспомните, что тре­ нировка включает две фазы: первая — это расчет выходного сигнала, что и делает функция query (), а вторая — обратное распространение 168 Глава 2. Создаем нейронную сеть на Python\n--- Страница 170 ---\nошибок, информирующее вас о том, каковы должны быть поправки к весовым коэффициентам. Прежде чем переходить к написанию кода функции train (), осуществляющей тренировку сети на примерах, протестируем, как работает уже имеющийся код. Для этого создадим небольшую сеть и предоставим ей некоторые входные данные. Очевидно, что никако­ го реального смысла результаты содержать не будут, но нам важно лишь проверить работоспособность всех созданных функций. В следующем примере создается небольшая сеть с входным, скры­ тым и выходным слоями, содержащими по три узла, которая опра­ шивается с использованием случайно выбранных входных сигналов (1.0, 0.5 и -1.5). Нетрудно заметить, что при создании объекта нейронной сети не­ обходимо задавать значение коэффициента обучения, даже если он не используется. Это объясняется тем, что определение класса ней­ ронной сети включает функцию инициализации _in it__(), кото­ рая требует предоставления данного аргумента. Если его не указать, программа не сможет быть выполнена, и отобразится сообщение об ошибке. Вы также могли заметить, что входные данные передаются в виде списка, который в Python обозначается квадратными скобками. Вывод также представлен в виде числового списка. Эти значения не имеют никакого реального смысла, поскольку мы не тренировали Проект нейронной сети на Python 169\n--- Страница 171 ---\nсеть, но тот факт, что во время выполнения программы не возникли ошибки, должен нас радовать. Тренировка сети Приступим к решению несколько более сложной задачи трениров­ ки сети. Ее можно разделить на две части. • Первая часть — расчет выходных сигналов для заданного тре­ нировочного примера. Это ничем не отличается от того, что мы уже можем делать с помощью функции query (). • Вторая часть — сравнение рассчитанных выходных сигналов с желаемым ответом и обновление весовых коэффициентов свя­ зей между узлами на основе найденных различий. Сначала запишем готовую первую часть. # тренировка нейронной сети def train (self, inputs_list, targets__list) : # преобразовать список входных значений в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2).T targets = numpy.array(targets_list, ndmin=2),T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy.dot(self.wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) # рассчитать входящие сигналы для выходного слоя final_inputs = numpy.dot(self.who, hidden joutputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation_function(final_inputs) pass Этот код почти совпадает с кодом функции query (), поскольку процесс передачи сигнала от входного слоя к выходному остается од­ ним и тем же. Единственным отличием является введение дополнительного па­ раметра targets_list, передаваемого при вызове функции, посколь­ ку невозможно тренировать сеть без предоставления ей тренировоч­ ных примеров, которые включают желаемые или целевые значения: def train (self, inputs_list, targets_list) 170 Глава 2, Создаем нейронную сеть на Python\n--- Страница 172 ---\nСписок ta r g e ts _ lis t преобразуется в массив точно так же, как список in pu t_list: targets = numpy.array(targets_list, ndmin=2).T Теперь мы очень близки к решению основной задачи тренировки сети — уточнению весов на основе расхождения между расчетными и целевыми значениями. Будем решать эту задачу поэтапно. Прежде всего, мы должны вычислить ошибку, являющуюся разнос­ тью между желаемым целевым выходным значением, предоставлен­ ным тренировочным примером, и фактическим выходным значением. Она представляет собой разность между матрицами (targets - final_ outputs), рассчитываемую поэлементно. Соответствующий код выгля­ дит очень просто, что еще раз подтверждает мощь и красоту матрич­ ного подхода. I ошибка = целевое значение - фактическое значение output_errors = targets - final_outputs Далее мы должны рассчитать обратное распространение ошибок для узлов скрытого слоя. Вспомните, как мы распределяли ошибки между узлами пропорционально весовым коэффициентам связей, а затем рекомбинировали их на каждом узле скрытого слоя. Эти вы­ числения можно представить в следующей матричной форме: ошибки = веса1 - ош ибкискрытый скрытый_выходной выходной Код, реализующий эту формулу, также прост в силу способности Python вычислять скалярные произведения матриц с помощью мо­ дуля numpy. # ошибки скрытого слоя - это ошибки output_errors, # распределенные пропорционально весовым коэффициентам связей # и рекомбинированные на скрытых узлах hidden_errors = numpy.dot(self.who.T, output_errors) Итак, мы получили то, что нам необходимо для уточнения весо­ вых коэффициентов в каждом слое. Для весов связей между скры­ тым и выходным слоями мы используем переменную output_errors. Проект нейронной сети на Python 171\n--- Страница 173 ---\nДля весов связей между входным и скрытым слоями мы используем только что рассчитанную переменную hidden e r r o r s . Ранее нами было получено выражение для обновления веса связи между узлом j и узлом к следующего слоя в матричной форме. Величина а — это коэффициент обучения, а сигмоида — это функ­ ция активации, с которой вы уже знакомы. Вспомните, что символ \"*\" означает обычное поэлементное умножение, а символ \" — ска­ лярное произведение матриц. Последний член выражения — это транспонированная (т) матрица исходящих сигналов предыдущего слоя. В данном случае транспонирование означает преобразование столбца выходных сигналов в строку. Это выражение легко транслируется в код на языке Python. Сначала запишем код для обновления весов связей между скрытым и выходным слоями. # обновить весовые коэффициенты связей между скрытым и выходным слоями self.who += self.lr * numpy.dot( (output_errors * final_outputs * Ъ (1.0 - final_outputs)), numpy.transpose(hidden_outputs)) Это довольно длинная строка кода, но цветовое выделение помо­ жет вам разобраться в том, как она связана с приведенным выше ма­ тематическим выражением. Коэффициент обучения s e l f . l r просто умножается на остальную часть выражения. Есть еще матричное ум­ ножение, выполняемое с помощью функции numpy. dot (), и два эле­ мента, выделенных синим и красным цветами, которые отобража­ ют части, относящиеся к ошибке и сигмоидам из следующего слоя, а также транспонированная матрица исходящих сигналов предыду­ щего слоя. 172 Глава 2. Создаем нейронную сеть на Python\n--- Страница 174 ---\nОперация += означает увеличение переменной, указанной слева от знака равенства, на значение, указанное справа от него. Поэтому х+=3 означает, что х увеличивается на 3. Это просто сокращенная запись инструкции х=х+3. Аналогичный способ записи допускается и для других арифметических операций. Например, х/=3 означает деление х на 3. Код для уточнения весовых коэффициентов связей между вход­ ным и скрытым слоями будет очень похож на этот. Мы воспользуем­ ся симметрией выражений и просто перепишем код, заменяя в нем имена переменных таким образом, чтобы они относились к предыду­ щим слоям. Ниже приведен суммарный код для двух наборов весо­ вых коэффициентов, отдельные элементы которого выделены цветом таким образом, чтобы сходные и различающиеся участки кода мож­ но было легко заметить. # обновить весовые коэффициенты связей между скрытым и выходным слоями self.w ho += self.lr * mmpy.dot( (output_errors * final_outputs * ^(1.0 - final_outputs)), num py.transpose(hidden_outputs)) I обновить весовые коэффициенты связей между входным и скрытым слоями self.wih += self.lr * numpy.dot( (hidden_errors * hidden_outputs * ■0(1.0 - hidden_outputs)), numpy.transpose(inputs)) Вот и все! Даже не верится, что вся та работа, для выполнения которой нам потребовалось множество вычислений, и все те усилия, которые мы вложили в разработку матричного подхода и способа минимизации ошибок сети методом градиентного спуска, свелись к паре строк кода! Отчасти мы обязаны этим языку Python, но фактически это за­ кономерный результат нашего упорного труда, вложенного в упро­ щение того, что легко могло стать сложным и приобрести устраша­ ющий вид. Полный код нейронной сети Мы завершили разработку класса нейронной сети. Он приве­ ден ниже для справки, и вы можете получить его в любой момент, воспользовавшись следующей ссылкой на GitHub — крупнейшем Проект нейронной сети на Python 173\n--- Страница 175 ---\nвеб-ресурсе для совместной разработки проектов, на котором люди бесплатно делятся своим кодом: • https: //g ith u b . com/makeyourownneuralnetwork/ makeyourownneuralnetwork/blob/master/part2__neural__ network.ipynb # определение класса нейронной сети class neuralNetwork: # инициализировать нейронную сеть def __init__(self, inputnodes, hiddennodes, outputnodes, ^learningrate): # задать количество узлов во входном, скрытом и выходном слое self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes # Матрицы весовых коэффициентов связей wih и who. # Весовые коэффициенты связей между узлом i и узлом j # следующего слоя обозначены как w__i: # wll w21 # wl2 w22 и т.д. self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), b (self.hnodes, self.inodes)) self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), b (self.onodes, self.hnodes)) # коэффициент обучения self.lr = learningrate # использование сигмоиды в качестве функции активации self.activation_function = lambda x: scipy.special.expit(x) pass # тренировка нейронной сети def train (self, inputs_list, targets__list) : # преобразование списка входных значений # в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2).T targets = numpy.array(targets_list, ndmin=2).T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy.dot(self.wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) 174 Глава 2. Создаем нейронную сеть на Python\n--- Страница 176 ---\n# рассчитать входящие сигналы для выходного слоя final_inputs = numpy.dot(self.who, hidden_outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation_function(final_inputs) # ошибки выходного слоя = # (целевое значение - фактическое значение) output_errors = targets - final__outputs # ошибки скрытого слоя - это ошибки output_errors, # распределенные пропорционально весовым коэффициентам связей # и рекомбинированные на скрытых узлах hidden_errors = numpy.dot(self.who.T, output_errors) # обновить весовые коэффициенты для связей между # скрытым и выходным слоями self.who += self.lr * numpy .dot ((output__errors * ^>final_outputs * (1.0 - final_outputs)), ^>numpy.transpose (hidden_outputs)) # обновить весовые коэффициенты для связей между # входным и скрытым слоями self.wih += self.lr * numpy.dot((hidden_errors * Q>hidden_outputs * (1.0 - hidden__outputs)), numpy.transpose(inputs)) pass # опрос нейронной сети def query(self, inputs_list): # преобразовать список входных значений # в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2),T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy.dot(self.wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) # рассчитать входящие сигналы для выходного слоя final__inputs = numpy.dot(self.who, hidden_outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation__function(final_inputs) return final_outputs Здесь не так много кода, особенно если принять во внимание, что он может быть использован с целью создания, тренировки и опроса трехслойной нейронной сети практически для любой задачи. Проект нейронной сети на Python 175\n--- Страница 177 ---\nДалее мы займемся решением одной конкретной задачи: обучение нейронной сети распознаванию рукописных цифр. Набор рукописных цифр MNIST Распознавание текста, написанного от руки, — это настоящий вы­ зов для испытания возможностей искусственного интеллекта, по­ скольку эта проблема действительно трудна и размыта. Она не столь ясная и четко определенная, как перемножение одного множества чисел на другое. Корректная классификация содержимого изображений с помо­ щью компьютера, которую часто называют распознаванием обра­ зов, десятилетиями выдерживала атаки, направленные на ее разре­ шение. В последнее время в этой области наблюдается значительный прогресс, и решающую роль в наметившемся прорыве сыграли тех­ нологии нейронных сетей. О трудности проблемы можно судить хотя бы по тому, что даже мы, люди, иногда не можем договориться между собой о том, какое именно изображение мы видим. В частности, предметом спора может послужить и написанная неразборчивым почерком буква. Взгляните на следующую цифру, написанную от руки. Что вы видите: 4 или 9? Существует коллекция изображений рукописных цифр, используе­ мых исследователями искусственного интеллекта в качестве популяр­ ного набора для тестирования идей и алгоритмов. То, что коллекция из­ вестна и пользуется популярностью, означает, что никому не составит труда проверить, как выглядит самая последняя из его безумных идей по сравнению с идеями других людей (т.е. различные идеи и алгорит­ мы тестируются с использованием одного и того же тестового набора). 176 Глава 2. Создаем нейронную сеть на Python\n--- Страница 178 ---\nЭтим тестовым набором является база данных рукописных цифр под названием “MNIST” , предоставляемая авторитетным исследо­ вателем нейронных сетей Яном Лекуном для бесплатного всеобщего доступа по адресу h t t p ://y a n n .le c u n .c o m /e x d b /m n i s t / . Там же вы найдете сведения относительно успешности прежних и нынешних попыток корректного распознавания этих рукописных символов. Мы будем неоднократно обращаться к этому списку, чтобы прове­ рить, в какой степени наши собственные идеи конкурентоспособны по сравнению с идеями, разрабатываемыми профессионалами! Формат базы данных MNIST не относится к числу тех, с которыми легко работать, но, к счастью, другие специалисты создали соответ­ ствующие файлы в более простом формате (см., например, h t t p : / / p jr e d d i e .c o m /p r o j e c t s /m n i s t -i n -c s v /) . Это так называемые CSV- файлы, в которых отдельные значения представляют собой обычный текст и разделены запятыми. Их содержимое можно легко просмат­ ривать в любом текстовом редакторе, и большинство электронных таблиц или программ, предназначенных для анализа данных, могут работать с CSV-файлами. Это довольно универсальный формат. На указанном сайте предоставлены следующие два файла: • тренировочный набор (h t tp ://w w w .p jr e d d ie .c o m /m e d ia /file s / m n is t _ t r a in . csv); • тестовый набор (h t tp ://w w w .p jr e d d ie .c o m /m e d ia /file s /m n is t _ t e s t . csv). Тренировочный набор содержит 60 000 промаркированных экзем­ пляров, используемых для тренировки нейронной сети. Слово “про­ маркированные” означает, что для каждого экземпляра указан соот­ ветствующий правильный ответ. Меньший тестовый набор, включающий 10 000 экземпляров, ис­ пользуется для проверки правильности работы идей или алгоритмов. Он также содержит корректные маркеры, позволяющие увидеть, способна ли наша нейронная сеть дать правильный ответ. Использование независимых друг от друга наборов тренировоч­ ных и тестовых данных гарантирует, что с тестовыми данными ней­ ронная сеть ранее не сталкивалась. В противном случае можно было бы схитрить и просто запомнить тренировочные данные, чтобы по­ лучить наибольшие, хотя и заработанные обманным путем, баллы. Набор рукописных цифр MNIST 177\n--- Страница 179 ---\nИдея разделения тренировочных и тестовых данных распространена среди специалистов по машинному обучению. Присмотримся к этим файлам. Ниже показана часть тестового на­ бора MNIST, загруженного в текстовый редактор. Ого! Создается впечатление, будто здесь что-то не так. Напоминает кадры из кинофильмов 1980-х годов, содержащих сцены взлома компьютерных систем хакерами. На самом деле все хорошо. В окне текстового редактора отобража­ ются длинные строки текста, которые содержат числа, разделенные запятыми. Это легко можно увидеть. Текстовые строки такие длин­ ные, потому что каждая из них занимает несколько строк на экране. Очень удобно то, что текстовый редактор отображает на полях реаль­ ные номера строк, и мы видим четыре целые строки и часть пятой. Содержимое этих записей, т.е. строк текста, легко понять. • Первое значение — это маркер, т.е. фактическая цифра, напри­ мер “ 7” или “ 9” , которую должен представлять данный руко­ писный экземпляр. Это ответ, правильному получению которо­ го должна обучиться нейронная сеть. • Последующие значения, разделенные запятыми, — это значе­ ния пикселей рукописной цифры. Пиксельный массив имеет размерность 28x28, поэтому за каждым маркером следуют 784 пикселя. Если у вас есть такое желание, можете пересчитать! 178 Глава 2. Создаем нейронную сеть на Python\n--- Страница 180 ---\nТаким образом, первая запись представляет цифру “ 5” , о чем го­ ворит первое значение, тогда как остальная часть текста в этой стро­ ке — это пиксельные значения написанной кем-то от руки цифры “5” . Вторая строка представляет рукописную цифру “0” , третья — цифру “4” , четвертая — цифру “ 1” и пятая — цифру “9” . Можете выбрать любую строку из файлов данных MNIST, и ее первое число укажет вам маркер для последующих данных изображения. Однако увидеть, каким образом длинный список из 784 значений формирует изображение рукописной цифры “5” , не так-то просто. Мы должны вывести в графическом виде эти цифры и убедиться в том, что они действительно представляют цвета пикселей рукописной цифры. Прежде чем углубиться в рассмотрение деталей и приступить к на­ писанию кода, загрузим небольшое подмножество набора данных, содержащихся в базе MNIST. Файлы данных MNIST имеют очень большой размер, тогда как работать с небольшими наборами значи­ тельно удобнее, поскольку это позволит нам экспериментировать, разрабатывать и испытывать свой код, что было бы затруднительно в случае длительных расчетов из-за большого объема обрабатывае­ мых данных. Когда бы отработаем алгоритм и будем удовлетворены созданным кодом, можно будет вернуться к полному набору данных. Ниже приведены ссылки на меньшие наборы MNIST, также под­ готовленные в формате CSV. • 10 записей из тестового набора данных MNIST: https://raw.githubusercontent.com/makeyourownneuralnetwork/ makeyourownneuralnetwork/master/mnist_dataset/mnist_test_10.csv • • 100 записей из тренировочного набора данных MNIST: https://raw.githubusercontent.com/makeyourownneuralnetwork/ makeyourownneuralnetwork/master/mnist_dataset/mnist_train_l00.csv Если ваш браузер отображает данные вместо того, чтобы загрузить их автоматически, можете сохранить файл, выполнив команду меню ФайлоСохранить к а к или эквивалентную ей. Сохраните файл в локальной папке, выбрав ее по своему усмотре­ нию. Я храню свои данные в папке m n is t_ d a ta s e t вместе со своими блокнотами IPython, как показано на приведенном ниже снимке экрана. Сохранение блокнотов IPython и файлов данных в случайно выбираемых местах вносит в работу беспорядок. Набор рукописных цифр MNIST 179\n--- Страница 181 ---\nПрежде чем с этими данными можно будет что-либо сделать, на­ пример построить график или обучить с их помощью нейронную сеть, необходимо обеспечить доступ к ним из кода на языке Python. Открытие файлов и получение их содержимого в Python не со­ ставляет большого труда. Лучше всего показать, как это делается, на конкретном примере. Взгляните на следующий код. data_file = open(\"mnist_dataset/mnist_train_100.csv\", 'г ') data_list = data_file.readlines() data_file.close() Здесь всего три строки кода. Обсудим каждую из них по отдель­ ности. Первая строка открывает файл с помощью функции open (). Вы ви­ дите, что в качестве первого из параметров ей передается имя файла. На самом деле это не просто имя файла m n is t_ t r a in _ 1 0 0 .c s v , а весь путь доступа к нему, включая каталог (папку), в котором он находится. Второй параметр необязательный и сообщает Python, как мы хотим ра­ ботать с файлом. Буква “г” означает, что мы хотим открыть файл толь­ ко для чтения, а не для записи. Тем самым мы предотвращаем любое непреднамеренное изменение или удаление файла. Если мы попытаем­ ся осуществить запись в этот файл или изменить его, Python не позво­ лит этого сделать и выдаст ошибку. А что это за переменная data_file? Функция open () создает дескриптор (указатель), играющий роль ссыл­ ки на открываемый файл, и мы присваиваем его переменной d a ta _f Не. Когда файл открыт, любые последующие действия с ним, например чтение, осуществляются через этот дескриптор. 180 Глава 2. Создаем нейронную сеть на Python\n--- Страница 182 ---\nСледующая строка проще. Мы используем функцию readlines (), ассоциированную с дескриптором файла data fi le , для чтения всех строк содержимого файла в переменную d ata_list. Эта переменная содержит список, каждый элемент которого является строкой, пред­ ставляющей строку файла. Это очень удобно, поскольку мы можем переходить к любой строке файла так же, как к конкретным запи­ сям в списке. Таким образом, d a ta _list[0 ] — это первая запись, a data_list [9] — десятая и т.п. Кстати, вполне возможно, что некоторые люди не рекомендовали вам использовать функцию readlines (), поскольку она считывает весь файл в память. Наверное, они советовали вам считывать по од­ ной строке за раз, выполнять всю необходимую обработку для этой строки и лишь затем переходить к следующей. Нельзя сказать, что они неправы. Действительно, гораздо эффективнее работать пооче­ редно с каждой строкой, а не считывать в память весь файл целиком. Однако наши файлы невелики, и использование функции readlines () значительно упрощает код, а для нас простота и ясность очень важны, поскольку мы изучаем Python. Последняя строка закрывает файл. Считается хорошей практикой закрывать файлы и другие ресурсы после их использования. Если же оставлять их открытыми, то это может приводить к возникно­ вению проблем. Что за проблемы? Некоторые программы могут от­ казываться осуществлять запись в файл, открытый в другом месте, если это приводит к несогласованности. В противном случае это на­ поминало бы ситуацию, когда два человека пытаются одновременно записывать разные тексты на одном и том же листе бумаги. Иногда компьютер может заблокировать файл во избежание такого рода конфликтов. Если не оставить за собой порядок после того, как не­ обходимость в использовании файла уже отпала, у вас может нако­ питься много заблокированных файлов. По крайней мере, закрыв файл, вы предоставите компьютеру возможность освободить память, занимаемую уже ненужными данными. Создайте новый пустой блокнот, выполните представленный ниже код и посмотрите, что произойдет, если попытаться вывести элемен­ ты списка. Набор рукописных цифр MNIST 181\n--- Страница 183 ---\nВы видите, что длина списка равна 100. Функция Python 1еп() сообщает о размере списка. Вы также можете видеть содержимое первой записи, d a ta _ list[0 ]. Первое число, 5, — это маркер, тогда как остальные 784 числа — это цветовые коды пикселей, из которых состоит изображение. Если вы внимательно присмотритесь, то заме­ тите, что их значения не выходят за пределы диапазона 0 до 255. Вы можете взглянуть на другие записи, чтобы проверить, выполняется ли это условие и для них. Вы убедитесь в том, что так оно и есть: значения кодов всех цветов попадают в диапазон чисел от 0 до 255. Ранее приводился пример графического отображения прямоуголь­ ного массива чисел с использованием функции im show (). То же са­ мое мы хотим сделать и в данном случае, но для этого нам нужно преобразовать список чисел, разделенных запятыми, в подходящий массив. Это можно сделать в соответствии со следующей процедурой: • разбить длинную текстовую строку значений, разделенных за­ пятыми, на отдельные значения, используя символ запятой в качестве разделителя; 182 Глава 2. Создаем нейронную сеть на Python\n--- Страница 184 ---\n• проигнорировать первое значение, являющееся маркером, из­ влечь оставшиеся 28*28=784 значения и преобразовать их в массив, состоящий из 28 строк и 28 столбцов; • отобразить массив! И вновь, проще всего показать соответствующий простой код на Python и уже после этого подробно рассмотреть, что в нем проис­ ходит. Прежде всего, мы не должны забывать о необходимости импор­ тировать библиотеки расширений Python для работы с массивами и графикой. import numpy import matplotlib.pyplot %matplotlib inline А теперь взгляните на следующие три строки кода. Переменные окрашены различными цветами таким образом, чтобы было понят­ но, где и какие данные используются. all_values = data_list[ 0].split(',') image_array = numpy.asfarray(all_yalues[l:]).reshape((28,28)) matplotlib.pyplot.imshow(image_array, cmap='Greys', ^interpolation»'None') В первой строке длинная первая запись d a ta _list[0 ], которую мы только что выводили, разбивается на отдельные значения с исполь­ зованием запятой в качестве разделителя. Это делается с помощью функции sp lit (), параметр которой определяет символ-разделитель. Результат помещается в переменную all_values. Можете вывести эти значения на экран и убедиться в том, что эта переменная действитель­ но содержит нужные значения в виде длинного списка Python. Следующая строка кода выглядит чуть более сложной, посколь­ ку в ней происходит сразу несколько вещей. Начнем с середины. Запись списка в виде all_values [1: ] указывает на то, что берутся все элементы списка за исключением первого. Тем самым мы иг­ норируем первое значение, играющее роль маркера, и берем лишь остальные 784 элемента, numpy.asfarray() — это функция библио­ теки numpy, преобразующая текстовые строки в реальные числа и создающая массив этих чисел. Постойте-ка, но почему текстовые Набор рукописных цифр MNIST 183\n--- Страница 185 ---\nстроки преобразуются в числа? Если файл был прочитан как тек­ стовый, то каждая строка или запись все еще остается текстом. Извлечение из них отдельных элементов, разделенных запятыми, также дает текстовые элементы. Например, этим текстом могли бы быть слова “ apple” , “orangel23” или “ 567” . Текстовая строка “ 567” — это не то же самое, что число 567. Именно поэтому мы должны преобразовывать текстовые строки в числа, даже если эти строки выглядят как числа. Последний фрагмент инструкции — .reshape ((28,28)) — гарантирует, что список будет сформирован в виде квадратной матрицы размером 28x28. Результирующий мас­ сив такой же размерности получает название image_array. Ух! Как много интересного всего лишь в одной строке кода! Третья строка просто выводит на экран массив image_array с по­ мощью функции imshow (), аналогично тому, с чем вы уже сталки­ вались. На этот раз мы выбрали цветовую палитру оттенков серого с помощью параметра cmap='Greys ' для лучшей различимости руко­ писных символов. Результат работы кода представлен ниже. Вы видите графическое изображение цифры “ 5” , на что и ука­ зывал маркер. Если мы выберем следующую запись, data_list [1] с маркером 0, то получим показанное ниже изображение. 184 Глава 2. Создаем нейронную сеть на Python\n--- Страница 186 ---\nГлядя на это изображение, вы с уверенностью можете сказать, что этой рукописной цифре действительно соответствует цифра 0. Подготовка тренировочных данных MNIST Теперь, когда вы уже знаете, как получить данные из файлов MNIST и извлечь из них нужные записи, мы можем воспользоваться этим для визуализации данных. Мы хотим использовать эти данные для обучения нашей нейронной сети, но сначала мы должны проду­ мать, как их следует подготовить, прежде чем предоставлять сети. Вы уже видели, что нейронные сети работают лучше, если как входные, так и выходные данные конфигурируются таким образом, чтобы они оставались в диапазоне значений, оптимальном для функ­ ций активации узлов нейронной сети. Первое, что мы должны сделать, — это перевести значения цветовых кодов из большего диапазона значений 0-255 в намного меньший, ох­ ватывающий значения от 0,01 до 1,0. Мы намеренно выбрали значение 0,01 в качестве нижней границы диапазона, чтобы избежать упомяну­ тых ранее проблем с нулевыми входными значениями, поскольку они могут искусственно блокировать обновление весов. Нам необязательно выбирать значение 0,99 в качестве верхней границы допустимого диа­ пазона, поскольку нет нужды избегать значений 1,0 для входных сиг­ налов. Лишь выходные сигналы не могут превышать значение 1,0. Деление исходных входных значений, изменяющихся в диапа­ зоне 0-255, на 255 приведет их к диапазону 0-1,0. Последующее Набор рукописных цифр MNIST 185\n--- Страница 187 ---\nумножение этих значений на коэффициент 0,99 приведет их к диа­ пазону 0,0-0,99. Далее мы инкрементируем их на 0,01, чтобы вмес­ тить их в желаемый диапазон 0,01-1,0. Все эти действия реализует следующий код на языке Python. scaled_input = (numpy.asfarray(all_values [1:]) / 255.0 * 0.99) + 0.01 print(scaled_input) Результирующий вывод данных подтверждает, что они действи­ тельно принадлежат к диапазону значений от 0,01 до 1,00. Итак, мы осуществили подготовку данных MNIST путем их мас­ штабирования и сдвига и теперь можем подавать их на вход нашей нейронной сети как с целью ее тренировки, так и с целью опроса. На этом этапе нам также нужно продумать, что делать с выходны­ ми значениями нейронной сети. Ранее вы видели, что выходные зна­ чения должны укладываться в диапазон значений, обеспечиваемый функцией активации. Используемая нами логистическая функция не может выдавать такие значения, как -2 ,0 или 255. Ее значения охватывают диапазон чисел от 0,0 до 1,0, а фактически вы никогда не получите значений 0,0 или 1,0, поскольку логистическая функ­ ция не может их достигать и лишь асимптотически приближается к ним. Таким образом, по-видимому, нам придется масштабировать выходные значения в процессе тренировки сети. 186 Глава 2. Создаем нейронную сеть на Python\n--- Страница 188 ---\nНо вообще-то, мы должны задать самим себе вопрос более глубо­ кого содержания. Что именно мы должны получить на выходе ней­ ронной сети? Должно ли это быть изображение ответа? В таком слу­ чае нам нужно иметь 28x28=784 выходных узла. Если мы вернемся на шаг назад и задумаемся над тем, чего имен­ но мы хотим от нейронной сети, то поймем, что мы просим ее клас­ сифицировать изображение и присвоить ему корректный маркер. Таким маркером может быть одно из десяти чисел в диапазоне от О до 9. Это означает, что выходной слой сети должен иметь 10 узлов, по одному на каждый возможный ответ, или маркер. Если ответом является “0” , то активизироваться должен первый узел, тогда как остальные узлы должны оставаться пассивными. Если ответом яв­ ляется “9” , то активизироваться должен последний узел выходного слоя при пассивных остальных узлах. Следующая иллюстрация по­ ясняет эту схему на нескольких примерах выходных значений. Первый пример соответствует случаю, когда сеть распознала вход­ ные данные как цифру “ 5” . Вы видите, что наибольший из исходя­ щих сигналов выходного слоя принадлежит узлу с меткой “ 5” . Не Набор рукописных цифр MNIST 187\n--- Страница 189 ---\nзабывайте о том, что это шестой по счету узел, потому что нумерация узлов начинается с нуля. Все довольно просто. Остальные узлы про­ изводят сигналы небольшой величины, близкие к нулю. Вывод ну­ лей мог оказаться следствием ошибок округления, но в действитель­ ности, как вы помните, функция активации никогда не допустит фактическое нулевое значение. Следующий пример соответствует рукописному “0” . Наибольшую величину здесь имеет сигнал первого выходного узла, ассоциируе­ мый с меткой “О ” . Последний пример более интересен. Здесь самый большой сиг­ нал генерирует последний узел, соответствующий метке “9” . Однако и узел с меткой “4” дает сигнал средней величины. Обычно нейрон­ ная сеть должна принимать решение, основываясь на наибольшем сигнале, но, как видите, в данном случае она отчасти считает, что правильным ответом могло бы быть и “4” . Возможно, рукописное на­ чертание символа затруднило его надежное распознавание? Такого рода неопределенности встречаются в нейронных сетях, и вместо того, чтобы считать их неудачей, мы должны рассматривать их как полезную подсказку о существовании другого возможного ответа. Отлично! Теперь нам нужно превратить эти идеи в целевые мас­ сивы для тренировки нейронной сети. Как вы могли убедиться, если тренировочный пример помечен маркером “ 5” , то для выходного узла следует создать такой целевой массив, в котором малы все элементы, кроме одного, соответствующего маркеру “ 5” . В данном случае этот массив мог бы выглядеть примерно так: [0,0,0,0,0,1,0,0,0,0]. В действительности эти числа нуждаются в дополнительном масшта­ бировании, поскольку мы уже видели, что попытки создания на выхо­ де нейронной сети значений 0 и 1, недостижимых в силу использования функции активации, приводят к большим весам и насыщению сети. Следовательно, вместо этого мы будем использовать значения 0,01 и 0,99, и потому целевым массивом для маркера “ 5” должен быть мас­ сив [0.01, 0.01, 0.01, 0.01, 0.01, 0.99, 0.01, 0.01, 0.01, 0.01]. А вот как выглядит код на языке Python, создающий целевую матрицу. # количество выходных узлов - 10 (пример) onodes = 10 targets = numpy.zeros(onodes) + 0.01 targets[int(all_values[0])] =0.99 188 Глава 2. Создаем нейронную сеть на Python\n--- Страница 190 ---\nПервая строка после комментария просто устанавливает количе­ ство выходных узлов равным 10, что соответствует нашему примеру с десятью маркерами. Во второй строке с помощью удобной функции numpy. zeros () соз­ дается массив, заполненный нулями. Желаемые размер и конфигу­ рация массива задаются параметром при вызове функции. В данном случае создается одномерный массив, размер onodes которого равен количеству узлов в конечном выходном слое. Проблема нулей, кото­ рую мы только что обсуждали, устраняется путем добавления 0,01 к каждому элементу массива. Следующая строка выбирает первый элемент записи из набора дан­ ных MNIST, являющийся целевым маркером тренировочного набора, и преобразует его в целое число. Вспомните о том, что запись читается из исходного файла в виде текстовой строки, а не числа. Как только преобразование выполнено, полученный целевой маркер использует­ ся для того, чтобы установить значение соответствующего элемента массива равным 0,99. Здесь все будет нормально работать, поскольку маркер “0” будет преобразован в целое число 0, являющееся коррект­ ным индексом данного маркера в массиве targets [ ]. Точно так же маркер “9” будет преобразован в целое число 9, и элемент targets [9] действительно является последним элементом этого массива. Вот пример работы этого кода. Великолепно! Теперь мы знаем, как подготовить входные значе­ ния для тренировки и опроса нейронной сети, а выходные значения — для тренировки. Обновим наш код с учетом проделанной работы. Ниже представле­ но состояние кода на данном этапе, включая последнее обновление. Вы также можете в любой момент получить его на сайте GitHub, ис­ пользуя следующую ссылку, в то время как мы продолжим его даль­ нейшую разработку: Набор рукописных цифр MNIST 189\n--- Страница 191 ---\n• https: //g ith u b . com/makeyourownneuralnetwork/ makeyourownneuralnetwork/blob/master/part2_neural__ network_mnist_data. ipynb Вы также можете ознакомиться с тем, как постепенно улучшался этот код, воспользовавшись следующей ссылкой: • https: //g ith u b . com/makeyourownneuralnetwork/ makeyourownneuralnetwork/commits/master/part2_neural__ network_mnist_data. ipynb # Блокнот Python для книги \"Создаем нейронную сеть”. # Код для создания 3-слойной нейронной сети вместе с # кодом для ее обучения с помощью набора данных MNIST. # (с) Tariq Rashid, 2016 # лицензия GPLv2 import numpy # библиотека scipy.special содержит сигмоиду expit() import scipy.special # библиотека для графического отображения массивов import matplotlib.pyplot # гарантировать размещение графики в данном блокноте, # а не в отдельном окне %matplotlib inline # определение класса нейронной сети class neuralNetwork: # инициализировать нейронную сеть def __init__(self, inputnodes, hiddennodes, outputnodes, ^learningrate): # задать количество узлов во входном, скрытом и выходном слое self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes # Матрицы весовых коэффициентов связей, wih и who. # Весовые коэффициенты связей между узлом i и узлом j # следующего слоя обозначены как w_i_j: # wll w21 # wl2 w22 и т.д. self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), b (self.hnodes, self.inodes)) self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), b (self.onodes, self.hnodes)) # коэффициент обучения self.lr = learningrate 190 Глава 2, Создаем нейронную сеть на Python\n--- Страница 192 ---\n# использование сигмоиды в качестве функции активации self.activation_function = lambda x: scipy.special.expit(x) pass # тренировка нейронной сети def train (self, inputs_list, targets__list) : # преобразование списка входных значений # в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2).T targets = numpy.array(targets_list, ndmin=2).T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy .dot (self .wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) # рассчитать входящие сигналы для выходного слоя final_inputs = numpy.dot(self.who, hidden_outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation_function(final_inputs) # ошибки выходного слоя = # (целевое значение - фактическое значение) output_errors = targets - final_outputs # ошибки скрытого слоя - это ошибки output_errors, # распределенные пропорционально весовым коэффициентам связей # и рекомбинированные на скрытых узлах hidden_errors = numpy.dot(self.who.T, output_errors) # обновить весовые коэффициенты для связей между # скрытым и выходным слоями self.who += self.lr * numpy.dot((output_errors * ^final_outputs * (1.0 - final_outputs)), ^>numpy.transpose(hidden_outputs)) # обновить весовые коэффициенты для связей между # входным и скрытым слоями self.wih += self.lr * numpy.dot((hidden_errors * ^>hidden_outputs * (1.0 - hidden_outputs)), numpy.transpose(inputs)) pass # опрос нейронной сети def query(self, inputs_list): # преобразовать список входных значений # в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2).T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy.dot(self.wih, inputs) Набор рукописных цифр MNIST 191\n--- Страница 193 ---\n# рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self,activation_function(hidden__inputs) # рассчитать входящие сигналы для выходного слоя final_inputs = numpy.dot (self .who, hidden_outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation_function(final_inputs) return final_outputs # количество входных, скрытых и выходных узлов input_nodes = 784 hidden_nodes = 100 output_nodes =10 # коэффициент обучения равен 0,3 learning_rate =0.3 # создать экземпляр нейронной сети n = neuralNetwork(input_nodes,hidden_nodes,output_nodes,learning_rate) # загрузить в список тестовый набор данных CSV-файла набора MNIST training_data_file = open(, , mnist_dataset/mnist_train_100.csv,,, 'г1) training_data_list = training_data_file.readlines () training_data_file.close() # тренировка нейронной сети # перебрать все записи в тренировочном наборе данных for record in training_data_list: # получить список значений, используя символы запятой (1,1) # в качестве разделителей all_values = record.split(',') # масштабировать и сместить входные значения inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 # создать целевые выходные значения (все равны 0,01, за исключением # желаемого маркерного значения, равного 0,99) targets = numpy.zeros(output_nodes) + 0.01 # all_values[0] - целевое маркерное значение для данной записи targets[int(all_values[0])] =0.99 n.train(inputs, targets) pass В самом начале этого кода мы импортируем графическую биб­ лиотеку, добавляем код для задания размеров входного, скрытого и выходного слоев, считываем малый тренировочный набор данных MNIST, а затем тренируем нейронную сеть с использованием этих за­ писей. 192 Глава 2. Создаем нейронную сеть на Python\n--- Страница 194 ---\nПочему мы выбрали 784 входных узла? Вспомните о том, что это число равно произведению 28x28, представляющему количество пикселей, из которых состоит изображение рукописной цифры. Выбор ста скрытых узлов не имеет столь же строгого научного обос­ нования. Мы не выбрали это число большим, чем 784, из тех соображе­ ний, что нейронная сеть должна находить во входных значениях такие особенности или шаблоны, которые можно выразить в более короткой форме, чем сами эти значения. Поэтому, выбирая количество узлов меньшим, чем количество входных значений, мы заставляем сеть пы­ таться находить ключевые особенности путем обобщения информации. В то же время, если выбрать количество скрытых узлов слишком ма­ лым, будут ограничены возможности сети в отношении определения достаточного количества отличительных признаков или шаблонов в изображении. Тем самым мы лишили бы сеть возможности выносить собственные суждения относительно данных MNIST. С учетом того, что выходной слой должен обеспечивать вывод 10 маркеров, а значит, дол­ жен иметь десять узлов, выбор промежуточного значения 100 для ко­ личества узлов скрытого слоя представляется вполне разумным. В связи с этим следует сделать одно важное замечание: идеального общего метода для выбора количества скрытых узлов не существует. В действительности не существует и идеального метода выбора коли­ чества скрытых слоев. В настоящее время наилучшим подходом яв­ ляется проведение экспериментов до тех пор, пока не будет получена конфигурация сети, оптимальная для задачи, которую вы пытаетесь решить. Тестирование нейронной сети Справившись с тренировкой сети, по крайней мере на небольшом подмножестве из ста записей, мы должны проверить, как она работа­ ет, и сделаем это, используя тестовый набор данных. Прежде всего, необходимо получить тестовые записи. Соответс­ твующий код очень похож на тот, который мы использовали для по­ лучения тренировочных данных. # загрузить в список тестовый набор данных CSV-файла набора MNIST test_data_file = open(\"mnist_dataset/mnist_test_10.csv\", 'г') test_data_list = test_data_file.readlines() test data file.closed Набор рукописных цифр MNIST 193\n--- Страница 195 ---\nМы распакуем эти данные точно так же, как и предыдущие, по­ скольку они имеют аналогичную структуру. Прежде чем создавать цикл для перебора всех тестовых записей, посмотрим, что произойдет, если мы вручную выполним одиночный тест. Ниже представлены результаты опроса уже обученной нейрон­ ной сети, выполненного с использованием первой записи тестового набора данных. Как видите, в качестве маркера первой записи тестового набора сеть определила символ “ 7” . Именно этого ответа мы ожидали, опра­ шивая ее. 194 Глава 2, Создаем нейронную сеть на Python\n--- Страница 196 ---\nГрафическое отображение пиксельных значений подтверждает, что рукописной цифрой действительно является цифра “ 7” . В результате опроса обученной сети мы получаем список чисел, являющихся выходными значениями каждого из выходных узлов. Сразу же бросается в глаза, что одно из выходных значений намного превышает остальные, и этому значению соответствует маркер “ 7” . Это восьмой элемент списка, поскольку первому элементу соответ­ ствует маркер “О ” . У нас все сработало! Этот момент заслуживает того, чтобы мы им насладились, и пол­ ностью окупает все затраченные нами до сих пор усилия! Мы обучили нашу нейронную сеть и добились того, что она смог­ ла определить цифру, предоставленную ей в виде изображения. Вспомните, что до этого сеть не сталкивалась с данным изображе­ нием, поскольку оно не входило в тренировочный набор данных. Следовательно, нейронная сеть оказалась в состоянии корректно классифицировать незнакомый ей цифровой символ. Это поистине впечатляющий результат! С помощью всего лишь нескольких строк кода на языке Python мы создали нейронную сеть, способную делать то, что многие люди сочли бы проявлением искусственного интеллекта, — распознавать изображения цифр, написанных рукой человека. Этот результат впечатляет еще больше, если учесть, что для обу­ чения сети была использована ничтожно малая часть полного набора тренировочных данных. Вспомните, что этот набор включает 60 ты­ сяч записей, а мы использовали только 100 из них. У меня даже были сомнения относительно того, что у нас вообще что-либо получится! Продолжим в том же духе и напишем код, позволяющий прове­ рить, насколько хорошо нейронная сеть справляется с остальной частью набора данных, и провести подсчет правильных результатов, чтобы впоследствии мы могли оценивать плодотворность своих буду­ щих идей по совершенствованию способности сети обучаться, а так­ же сравнивать наши результаты с результатами, полученными дру­ гими людьми. Сначала ознакомьтесь с приведенным ниже кодом, а затем мы его обсудим. Набор рукописных цифр MNIST 195\n--- Страница 197 ---\n# тестирование нейронной сети # журнал оценок работы сети, первоначально пустой scorecard = [] # перебрать все записи в тестовом наборе данных for record in test_data_list: # получить список значений из записи, используя символы # запятой (*,1) в качестве разделителей all_values = record.split(',') # правильный ответ - первое значение correct_label = int(all_values[0]) print(correct_label, \"истинный маркер\") # масштабировать и сместить входные значения inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 # опрос сети outputs = n.query(inputs) # индекс наибольшего значения является маркерным значением label = numpy.argmax(outputs) print(label, \"ответ сети\") # присоединить оценку ответа сети к концу списка if (label == correct_JLabel) : # в случае правильного ответа сети присоединить # к списку значение 1 scorecard.append(1) else: # в случае неправильного ответа сети присоединить # к списку значение 0 scorecard.append(0) pass pass Прежде чем войти в цикл, обрабатывающий все записи тестового набора данных, мы создаем пустой список scorecard, который будет служить нам журналом оценок работы сети, обновляемым после об- работки каждой записи. В цикле мы делаем то, что уже делали раньше: извлекаем значения из текстовой записи, в которой они разделены запятыми. Первое зна­ чение, указывающее правильный ответ, сохраняется в отдельной пере­ менной. Остальные значения масштабируются, чтобы их можно было использовать в качестве входных данных для передачи запроса нейрон­ ной сети. Ответ нейронной сети сохраняется в переменной outputs. Далее следует довольно интересная часть кода. Мы знаем, что наибольшее из значений выходных узлов рассматривается сетью 196 Глава 2. Создаем нейронную сеть на Python\n--- Страница 198 ---\nв качестве правильного ответа. Индекс этого узла, т.е. его позиция, со­ ответствует маркеру. Эта фраза просто означает, что первый элемент соответствует маркеру “0” , пятый — маркеру “4” и т.д. К счастью, су­ ществует удобная функция библиотеки numpy, которая находит среди элементов массива максимальное значение и сообщает его индекс. Это функция numpy.argmax (). Для получения более подробных сведений о ней можете посетить веб-страницу по следующему адресу: https: / /docs.scipy.org/doc/numpy-1.10.1/reference/ generated/numpy.argmax.html Возврат этой функцией значения 0 означает, что правильным от­ ветом сеть считает “0” и т.д. В последнем фрагменте кода полученный маркер сравнивается с известным корректным маркером. Если оба маркера одинаковы, в журнал записывается “ 1” , в противном случае — “О ” . Кроме того, я включил в некоторых местах кода полезную команду print (), чтобы мы сами могли отслеживать правильные и предсказы­ ваемые значения. Ниже представлены результаты выполнения этого кода вместе с выведенными записями нашего рабочего журнала. На этот раз не все у нас хорошо! Вы видите, что имеется несколько несовпадений. Последняя выведенная строка результатов показывает, Набор рукописных цифр MNIST 197\n--- Страница 199 ---\nчто из десяти тестовых записей правильно были распознаны 6. Таким образом, доля правильных результатов составила 60%. На самом деле это не так уж и плохо, если принять во внимание небольшой размер тренировочного набора, который мы использовали. Дополним код фрагментом, который будет выводить относитель­ ную долю правильных ответов в виде дроби. # рассчитать показатель эффективности в виде # доли правильных ответов scorecard_array = numpy.asarray(scorecard) print (\"эффективность = \", scorecard_array.sum() / ^ scorecard_array.size) Эта доля рассчитывается как количество всех записей в журна­ ле, содержащих “ 1” , деленное на общее количество записей (размер журнала). Вот каким получается результат. Как и ожидалось, мы получили показатель эффективности сети, равный 0,6, или 60%. Тренировка и тестирование нейронной сети с использованием полной базы данных Далее мы добавим в нашу основную программу новый код, разра­ ботанный для тестирования эффективности сети. При этом потребуется изменить имена файлов, поскольку теперь они должны указывать на полный набор тренировочных данных, на­ считывающий 60 тысяч записей, и набор тестовых данных, насчиты­ вающий 10 тысяч записей. Ранее мы сохранили эти наборы в файлах с именами m nist_dataset/m nist_train.csv и mnist_dataset/mnist_ test.csv. Нам предстоит серьезная работа! 198 Глава 2* Создаем нейронную сеть на Python\n--- Страница 200 ---\nНе забывайте о том, что блокнот с этим кодом можно получить на сайте GitHub по следующему адресу: https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/ blob/master/part2_neural_network_mnist_data.ipynb Вы также можете ознакомиться с тем, как постепенно улучшался этот код, воспользовавшись следующей ссылкой: https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/ commits/master/part2_neural_network_mnist_data.ipynb В соответствии с результатами обучения нашей простой трехслой­ ной нейронной сети с использованием полного набора, включающего 60 тысяч примеров, и последующего тестирования на 10 тысячах за­ писей показатель общей эффективности сети составляет 0,9473. Это очень неплохо. Точность распознавания составила почти 95%! Этот показатель, равный почти 95%, можно сравнить с аналогич­ ными результатами эталонных тестов, которые можно найти по адре­ су http://yann.lecun.com /exdb/m nist/ . Вы увидите, что в некоторых случаях наши результаты даже лучше эталонных и почти сравнимы с приведенными на указанном сайте результатами для простейшей нейронной сети, эффективность которой составила 95,3%. Это вовсе не так плохо. Мы должны быть довольны тем, что наша первая попытка продемонстрировала эффективность на уровне ней­ ронной сети профессиональных исследователей. Кстати, вас не должно удивлять, что даже в случае современных быстродействующих домашних компьютеров обработка всех 60 ты­ сяч тренировочных примеров, для каждого из которых необходимо вычислить распространение сигналов от 784 входных узлов через сто скрытых узлов в прямом направлении, а также обратное распро­ странение ошибок и обновление весов, занимает ощутимое время. Набор рукописных цифр MNIST 199\n--- Страница 201 ---\nНа моем ноутбуке прохождение всего тренировочного цикла заняло около двух минут. Для вашего компьютера длительность вычисле­ ний может быть иной. Улучшение результатов: настройка коэффициента обучения Получение 95%-го показателя эффективности при тестировании набора данных MNIST нашей нейронной сетью, созданной на ос­ нове простейших идей и с использованием простого кода на языке Python, — это совсем неплохо, и ваше желание остановиться на этом можно было бы считать вполне оправданным. Однако мы попытаемся улучшить разработанный к этому моменту код, внеся в него некоторые усовершенствования. Прежде всего, мы можем попытаться настроить коэффициент об­ учения. Перед этим мы задали его равным 0,3, даже не тестируя дру­ гие значения. Давайте удвоим это значение до величины 0,6 и посмотрим, как это скажется на способности нейронной сети обучаться. Выполнение кода с таким значением коэффициента обучения дает показатель эф­ фективности 0,9047. Этот результат хуже прежнего. По-видимому, увеличение коэффициента обучения нарушает монотонность процес­ са минимизации ошибок методом градиентного спуска и сопровож­ дается перескоками через минимум. Повторим вычисления, установив коэффициент обучения равным ОД. На этот раз показатель эффективности улучшился до 0,9523, что почти совпадает с результатом ранее упомянутого эталонного теста, который проводился с использованием тысячи скрытых узлов. Но ведь наш результат был получен с использованием намного меньше­ го количества узлов! Что произойдет, если мы пойдем еще дальше и уменьшим коэффи­ циент обучения до 0,01? Оказывается, это также приводит к умень­ шению показателя эффективности сети до 0,9241. По-видимому, слишком малые значения коэффициента обучения снижают эффек­ тивность. Это представляется логичным, поскольку малые шаги уменьшают скорость градиентного спуска. Описанные результаты представлены ниже в виде графика. Это не совсем научный подход, поскольку нам следовало бы провести такие 200 Глава 2. Создаем нейронную сеть на Python\n--- Страница 202 ---\nэксперименты множество раз, чтобы исключить фактор случайности и влияние неудачного выбора маршрутов градиентного спуска, но в целом он позволяет проиллюстрировать общую идею о существова­ нии некоего оптимального значения коэффициента обучения. Вид графика подсказывает нам, что оптимальным может быть значение в интервале от 0,1 до 0,3, поэтому испытаем значение 0,2. Показатель эффективности получится равным 0,9537. Мы видим, что этот результат немного лучше тех, которые мы имели при значе­ ниях коэффициента обучения, равных 0,1 или 0,3. Идею построения графиков вы должны взять на вооружение и в других сценариях, по­ скольку графики способствуют пониманию общих тенденций лучше, чем длинные числовые списки. Итак, мы остановимся на значении коэффициента обучения 0,2, которое проявило себя как оптимальное для набора данных MNIST и нашей нейронной сети. Кстати, если вы самостоятельно выполните этот код, то ваши оцен­ ки будут немного отличаться от приведенных здесь, поскольку процесс Набор рукописных цифр MNIST 201\n--- Страница 203 ---\nв целом содержит элементы случайности. Ваш случайный выбор на­ чальных значений весовых коэффициентов не будет совпадать с моим, а потому маршрут градиентного спуска для вашего кода будет другим. Улучшение результатов: многократное повторение тренировочных циклов Нашим следующим усовершенствованием будет многократное по­ вторение циклов тренировки с одним и тем же набором данных. В от­ ношении одного тренировочного цикла иногда используют термин эпо­ ха. Поэтому сеанс тренировки из десяти эпох означает десятикратный прогон всего тренировочного набора данных. А зачем нам это делать? Особенно если для этого компьютеру потребуется 10, 20 или даже 30 минут? Причина заключается в том, что тем самым мы обеспечиваем большее число маршрутов градиентного спуска, оптимизирующих ве­ совые коэффициенты. Посмотрим, что нам дадут две тренировочные эпохи. Для этого мы должны немного изменить код, предусмотрев в нем дополнительный цикл выполнения кода тренировки. В приведенном ниже коде внеш­ ний цикл выделен цветом, чтобы сделать его более заметным. # тренировка нейронной сети # переменная epochs указывает, сколько раз тренировочный # набор данных используется для тренировки сети epochs = 2 for е in range(epochs): # перебрать все записи в тренировочном наборе данных for record in training_data_list: # получить список значений из записи, используя символы # запятой (', 1) в качестве разделителей all_values = record.split(1,1) # масштабировать и сместить входные значения inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 # создать целевые выходные значения (все равны 0,01, за # исключением желаемого маркерного значения, равного 0,99) targets = numpy.zeros(output_nodes) + 0.01 # all_values[0] - целевое маркерное значение для # данной записи targets[int(all_values[0])] =0.99 n.train(inputs, targets) pass pass 202 Глава 2. Создаем нейронную сеть на Python\n--- Страница 204 ---\nРезультирующий показатель эффективности для двух эпох со­ ставляет 0,9579, что несколько лучше показателя для одной эпохи. Подобно тому, как мы настраивали коэффициент обучения, про­ ведем эксперимент с использованием различного количества эпох и построим график зависимости показателя эффективности от этого фактора. Интуиция подсказывает нам, что чем больше тренировок, тем выше эффективность. Но можно предположить, что слишком большое количество тренировок чревато ухудшением эффективности из-за так называемого переобучения сети на тренировочных данных, снижающего эффективность при работе с незнакомыми данными. Фактора переобучения следует опасаться в любых видах машинного обучения, а не только в нейронных сетях. В данном случае мы имеем следующие результаты. Теперь пиковое значение эффективности составляет 0,9628, или 96,28%, при семи эпохах. Как видите, результаты оказались не столь предсказуемыми, как ожидалось. Оптимальное количество эпох — 5 или 7. При боль­ ших значениях эффективность падает, что может быть следствием Набор рукописных цифр MNIST 203\n--- Страница 205 ---\nпереобучения. Провал при 6 эпохах, по всей вероятности, обуслов­ лен неудачными параметрами цикла, которые привели градиентный спуск к ложному минимуму. На самом деле можно было ожидать большей вариации результатов, поскольку мы не проводили множе­ ства экспериментов для каждой точки данных, чтобы уменьшить ва­ риацию, вызванную случайными факторами. Именно поэтому я оста­ вил эту странную точку, соответствующую шести эпохам, чтобы на­ помнить вам, что по самой своей сути обучение нейронной сети — это случайный процесс, который иногда может работать не очень хорошо, а иногда и очень плохо. Другое возможное объяснение — это то, что коэффициент обуче­ ния оказался слишком большим для большего количества эпох. Повторим эксперимент, уменьшив коэффициент обучения с 0,2 до 0,1, и посмотрим, что произойдет. На следующем графике новые значения эффективности при коэф­ фициенте обучения 0,1 представлены вместе с предыдущими резуль­ татами, чтобы их было легче сравнить между собой. 204 Глава 2, Создаем нейронную сеть на Python\n--- Страница 206 ---\nКак нетрудно заметить, уменьшение коэффициента обучения действительно привело к улучшению эффективности при большом количестве эпох. Пиковому значению 0,9689 соответствует вероят­ ность ошибок, равная 3% , что сравнимо с эталонными результата­ ми, указанными на сайте Яна Лекуна по адресу http://yann .lecun . com/exdb/mnist/. Интуиция подсказывает нам, что если мы планируем использо­ вать метод градиентного спуска при значительно большем количе­ стве эпох, то уменьшение коэффициента обучения (более короткие шаги) в целом приведет к выбору лучших маршрутов минимизации ошибок. Вероятно, 5 эпох — это оптимальное количество для тести­ рования нашей нейронной сети с набором данных MNIST. Вновь об­ ращу ваше внимание на то, что мы сделали это довольно ненаучным способом. Правильно было бы выполнить эксперимент по нескольку раз для каждого сочетания значений коэффициента обучения и ко­ личества эпох с целью минимизации влияния фактора случайности, присущего методу градиентного спуска. Изменение конфигурации сети Один из факторов, влияние которых мы еще не исследовали, хотя, возможно, и должны были сделать это раньше, — конфигурация нейронной сети. Необходимо попробовать изменить количество уз­ лов скрытого промежуточного слоя. Давным-давно мы установили его равным 100. Прежде чем приступить к экспериментам с различными количе­ ствами скрытых узлов, давайте подумаем, что при этом может слу­ читься. Скрытый слой как раз и является тем слоем, в котором про­ исходит обучение. Вспомните, что узлы входного слоя принимают входные сигналы, а узлы выходного выдают ответ сети. Собственно, скрытый слой (или слои) должен научить сеть превращать входные сигналы в ответ. Именно в нем происходит обучение. На самом деле все обучение основано на значениях весовых коэффициентов до и после скрытого слоя, но вы понимаете, что я имею в виду. Согласитесь, что если бы у нас было слишком мало скрытых узлов, скажем, три, то мы не имели бы никаких шансов обучить сеть чему- либо, научить ее преобразовывать все входные сигналы в коррект­ ные выходные сигналы. Это все равно что пытаться перевезти десять Набор рукописных цифр MNIST 205\n--- Страница 207 ---\nчеловек в автомобиле, рассчитанном на пятерых. Вы просто не смог­ ли бы втиснуть всю входную информацию в эти узлы. Ограничения такого рода называют способностью к обучению. Невозможно об­ учить большему, чем позволяет способность к обучению, но можно увеличить способность к обучению, изменив конфигурацию сети. Что, если бы у нас было 10 тысяч скрытых узлов? Ну да, в таком случае способности к обучению вполне хватило бы, но мы могли бы столкнуться с трудностями обучения сети, поскольку число мар­ шрутов обучения было бы непомерно большим. Не исключено, что для тренировки такой сети понадобилось бы 10 тысяч эпох. Выполним эксперименты и посмотрим, что получится. Как видите, при небольшом количестве узлов результаты хуже, чем при больших количествах. Это совпадает с нашими ожидания­ ми. Однако даже для всего лишь пяти скрытых узлов показатель эф­ фективности составил 0,7001. Это удивительно, поскольку при столь малом количестве узлов, в которых происходит собственно обуче­ ние сети, она все равно дает 70% правильных ответов. Вспомните, что до этого мы выполняли тесты, используя сто скрытых узлов. Но 206 Глава 2. Создаем нейронную сеть на Python\n--- Страница 208 ---\nдаже десять скрытых узлов обеспечивают точность 0,8998, или 90%, что тоже впечатляет. Зафиксируйте в памяти этот факт. Нейронная сеть способна да­ вать хорошие результаты даже при небольшом количестве скрытых узлов, в которых и происходит обучение, что свидетельствует о ее мощных возможностях. По мере дальнейшего увеличения количества скрытых узлов ре­ зультаты продолжают улучшаться, однако уже не так резко. При этом значительно растет время, затрачиваемое на тренировку сети, поскольку добавление каждого дополнительного скрытого узла при­ водит к увеличению количества связей узлов скрытого слоя с узлами предыдущего и следующего слоев, а вместе с этим и объема вычис­ лений! Поэтому необходимо достигать компромисса между количе­ ством скрытых узлов и допустимыми затратами времени. Для моего компьютера оптимальное количество узлов составляет двести. Ваш компьютер может работать быстрее или медленнее. Мы также установили новый рекорд точности: 0,9751 при 200 скрытых узлах. Длительный расчет с 500 узлами обеспечил точность 0,9762. Это действительно неплохо по сравнению с результатами эта­ лонных тестов, опубликованными на сайте Лекуна по адресу http: yann.lecun.com/exdb/mnist/. Возвращаясь к графикам, можно заметить, что неподдающийся ранее предел точности 97% был преодолен за счет изменения конфи­ гурации сети. Подведем итоги Давая общую оценку проделанной нами работы, хочу подчер­ кнуть, что при создании нейронной сети с помощью Python мы ис­ пользовали лишь самые простые концепции. И тем не менее с помощью нашей нейронной сети нам, даже без использования каких-либо дополнительных математических ухищ­ рений, удалось получить вполне достойные результаты, сравнимые с теми, которые были достигнуты учеными и профессиональными исследователями. Дополнительный интересный материал вы найдете в главе 3, но даже если вы не будете применять изложенные там идеи, можете безо всяких колебаний продолжить эксперименты с уже созданной Набор рукописных цифр MNIST 207\n--- Страница 209 ---\nнами нейронной сетью — используйте другое количество скрытых узлов, задавайте другие коэффициенты масштабирования или даже задействуйте другую функцию активации и анализируйте, что при этом происходит. Окончательный вариант кода Для удобства читателей ниже приведен окончательный вариант кода, также доступный на сайте GitHub. # Блокнот Python для книги \"Создаем нейронную сеть\". # Код для создания 3-слойной нейронной сети вместе с # кодом для ее обучения с помощью набора данных MNIST. # (с) Tariq Rashid, 2016 # лицензия GPLv2 import numpy # библиотека scipy.special содержит сигмоиду expit () import scipy.special # библиотека для графического отображения массивов import matplotlib.pyplot # гарантировать размещение графики в данном блокноте, # а не в отдельном окне %matplotlib inline # определение класса нейронной сети class neuralNetwork: # инициализировать нейронную сеть def __init__(self, inputnodes, hiddennodes, outputnodes, ^learningrate): # задать количество узлов во входном, скрытом и выходном слое self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes # Матрицы весовых коэффициентов связей wih (между входным # и скрытым слоями)и who (между скрытым и выходным слоями). # Весовые коэффициенты связей между узлом i и узлом j # следующего слоя обозначены как w__i_j : # wll w21 # wl2 w22 и т.д. self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), (self.hnodes, self.inodes)) self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), % (self.onodes, self.hnodes)) 208 Глава 2. Создаем нейронную сеть на Python\n--- Страница 210 ---\n# коэффициент обучения self.lr = learningrate # использование сигмоиды в качестве функции активации self.activation_function = lambda x: scipy.special.expit(x) pass # тренировка нейронной сети def train(self, inputs_list, targets_list): # преобразование списка входных значений # в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2).T targets = numpy.array(targets_list, ndmin=2).T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy.dot(self.wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) # рассчитать входящие сигналы для выходного слоя final_inputs = numpy.dot(self.who, hidden_outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation_function(final__inputs) # ошибки выходного слоя = # (целевое значение - фактическое значение) output_errors = targets - final_outputs # ошибки скрытого слоя - это ошибки output_errors, # распределенные пропорционально весовым коэффициентам связей # и рекомбинированные на скрытых узлах hidden_errors = numpy.dot(self.who.T, output_errors) # обновить веса для связей между скрытым и выходным слоями self, who += self.lr * numpy .dot ((output__errors * ^>final_outputs * (1.0 - final_outputs)), ^>numpy.transpose(hidden_outputs)) # обновить весовые коэффициенты для связей между # входным и скрытым слоями self.wih += self.lr * numpy.dot((hidden__errors * ^>hidden_outputs * (1.0 - hidden_outputs )) , numpy.transpose(inputs)) pass # опрос нейронной сети def query(self, inputs_list): # преобразовать список входных значений Набор рукописных цифр MNIST 209\n--- Страница 211 ---\n# в двухмерный массив inputs = numpy.array(inputs_list, ndmin=2).T # рассчитать входящие сигналы для скрытого слоя hidden_inputs = numpy.dot(self.wih, inputs) # рассчитать исходящие сигналы для скрытого слоя hidden_outputs = self.activation_function(hidden_inputs) # рассчитать входящие сигналы для выходного слоя final_inputs = numpy.dot(self.who, hidden_outputs) # рассчитать исходящие сигналы для выходного слоя final_outputs = self.activation_function(final_inputs) return final_outputs # количество входных, скрытых и выходных узлов input_nodes = 784 hidden_nodes = 200 output_nodes =10 # коэффициент обучения learning_rate =0.1 # создать экземпляр нейронной сети n = neuralNetwork(input_nodes,hidden_nodes,output_nodes,learning_rate) # загрузить в список тренировочный набор данных # CSV-файла набора MNIST training_data_file = open(, f mnist_dataset/mnist_train.csvn, f гf) training_data_list = training_data_file.readlines () training_data_file.close () # тренировка нейронной сети # переменная epochs указывает, сколько раз тренировочный # набор данных используется для тренировки сети epochs = 5 for е in range(epochs): # перебрать все записи в тренировочном наборе данных for record in training_data_list: # получить список значений из записи, используя символы # запятой (',f) в качестве разделителей all_values = record.split(1,') # масштабировать и сместить входные значения inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 # создать целевые выходные значения (все равны 0,01, за # исключением желаемого маркерного значения, равного 0,99) targets = numpy.zeros(output_nodes) +0.01 210 Глава 2. Создаем нейронную сеть на Python\n--- Страница 212 ---\n# all_values[0] - целевое маркерное значение # для данной записи targets[int(all_values[0])] =0.99 n.train(inputs/ targets) pass pass # загрузить в список тестовый набор данных # CSV-файла набора MNIST test_data_file = open(\"mnist__dataset/mnist_test.csv\", f г') test_data_list = test_data_file.readlines() test_data_file.close() # тестирование нейронной сети # журнал оценок работы сети, первоначально пустой scorecard = [] # перебрать все записи в тестовом наборе данных for record in test_data_list: # получить список значений из записи, используя символы # запятой (',*) в качестве разделителей all_values = record, split (',') # правильный ответ - первое значение correct_label = int(all_values[0]) # масштабировать и сместить входные значения inputs = (numpy.asfarray(all_values[l:]) / 255.0 * 0.99) + 0.01 # опрос сети outputs = n.query(inputs) # индекс наибольшего значения является маркерным значением label = numpy.argmax(outputs) # присоединить оценку ответа сети к концу списка if (label == correct_label): # в случае правильного ответа сети присоединить # к списку значение 1 scorecard.append(1) else: # в случае неправильного ответа сети присоединить # к списку значение 0 scorecard.append(0) pass pass # рассчитать показатель эффективности в виде # доли правильных ответов scorecard_array = numpy.asarray(scorecard) print (\"эффективность = \", scorecard_array.sum() / b scorecard array.size) Набор рукописных цифр MNIST 211",
      "debug": {
        "start_page": 130,
        "end_page": 213
      }
    },
    {
      "name": "Глава 3. Несколько интересных проектов 213",
      "content": "--- Страница 214 --- (продолжение)\nГЛАВА 3 Несколько интересных проектов Н е играя, не научишься. В этой главе мы исследуем ряд оригинальных идей. Они не свя­ заны с пониманием основ нейронных сетей, поэтому не смущайтесь, если кое-что будет вам непонятно. Поскольку глава предназначена больше для развлечения, мы ускорим темп, хотя там, где это потребуется, будут даваться простые пояснения. Собственный рукописный текст В главе 2 мы распознавали изображения рукописных цифр из базы данных MNIST. А почему бы не использовать собственный ру­ кописный текст? В этом эксперименте мы создадим свою тестовую базу данных, используя собственноручно написанные цифры. Кроме того, мы по­ пытаемся сымитировать различные виды почерка, а также зашум­ ленные и прерывистые изображения, чтобы посмотреть, насколько хорошо с ними справится наша нейронная сеть. Для создания изображений можно использовать любой графичес­ кий редактор. Вы не обязаны делать это с помощью дорогостоящей программы Photoshop. Вполне подойдет альтернативный вариант в виде бесплатной программы с открытым исходным кодом GIMP (www.gimp.org ), доступной для компьютеров с операционными си­ стемами Windows, Mac и Linux. Вы даже можете написать цифры карандашом на листе бумаги, а затем отсканировать или сфотогра­ фировать их с помощью смартфона или фотокамеры. Единственным требованием является то, что изображение цифры должно быть\nГЛАВА 3 Несколько интересных проектов Н е играя, не научишься. В этой главе мы исследуем ряд оригинальных идей. Они не свя­ заны с пониманием основ нейронных сетей, поэтому не смущайтесь, если кое-что будет вам непонятно. Поскольку глава предназначена больше для развлечения, мы ускорим темп, хотя там, где это потребуется, будут даваться простые пояснения. Собственный рукописный текст В главе 2 мы распознавали изображения рукописных цифр из базы данных MNIST. А почему бы не использовать собственный ру­ кописный текст? В этом эксперименте мы создадим свою тестовую базу данных, используя собственноручно написанные цифры. Кроме того, мы по­ пытаемся сымитировать различные виды почерка, а также зашум­ ленные и прерывистые изображения, чтобы посмотреть, насколько хорошо с ними справится наша нейронная сеть. Для создания изображений можно использовать любой графичес­ кий редактор. Вы не обязаны делать это с помощью дорогостоящей программы Photoshop. Вполне подойдет альтернативный вариант в виде бесплатной программы с открытым исходным кодом GIMP (www.gimp.org ), доступной для компьютеров с операционными си­ стемами Windows, Mac и Linux. Вы даже можете написать цифры карандашом на листе бумаги, а затем отсканировать или сфотогра­ фировать их с помощью смартфона или фотокамеры. Единственным требованием является то, что изображение цифры должно быть\n--- Страница 215 ---\nквадратным (длина равна ширине) и представленным в формате PNG. Этот формат можно выбрать в списке допустимых форматов большинства графических редакторов при выполнении команды меню Файл^Сохранить как или ФайлоЭкспорт. Вот как выглядят некоторые из подготовленных мною изображе­ ний. Цифру “ 5” я написал маркером. Цифра “ 4” написана мелом. Цифру “3” я написал маркером, но намеренно сделал линию пре­ рывистой. Цифра “ 2” взята из типичного газетного или книжного шрифта, но немного размыта. Цифра “ 6” как бы покрыта рябью, словно мы видим ее как отражение на поверхности воды. Последнее изображение совпадает с предыдущим, но в него добавлен шум, что­ бы намеренно затруднить распознавание цифры нейронной сетью. Все это забавно, но здесь есть и серьезный момент. Ученых из­ умляет поразительная способность человеческого мозга сохранять функциональность даже после того, как он испытал повреждения. Предполагают, что в нейронной сети приобретенные знания рас­ пределяются между несколькими связями, а потому даже в услови­ ях повреждения некоторых связей остальные связи могут успешно 214 Глава 3. Несколько интересных проектов\n--- Страница 216 ---\nфункционировать. Это также означает, что они могут достаточно хорошо функционировать и в случае повреждения или неполноты входного изображения. Таковы возможности нашего мозга, и имен­ но это мы хотим протестировать с посеченной цифрой “3” , изобра­ женной на приведенной выше иллюстрации. Прежде всего, мы должны создать уменьшенные версии PNG- изображений, масштабировав их до размера 28x28 пикселей, что­ бы привести в соответствие с использовавшимися ранее данными MNIST. Для этого можете использовать свой графический редактор. Для чтения и декодирования данных из распространенных форма­ тов изображений, включая PNG, мы вновь используем библиотеки Python. Взгляните на следующий простой код. import scipy.misc img_array = scipy.misc. imread(image_file_name, flatten=True) img_data = 255.0 - img_array.reshape(784) img_data = (img_data / 255.0 * 0.99) + 0.01 Функция scipy.misc.imreadO поможет нам в получении данных из файлов изображений, таких как PNG- или JPG-файлы. Чтобы ис­ пользовать библиотеку scipy.misc, ее необходимо импортировать. Параметр flatten=True превращает изображение в простой массив чисел с плавающей запятой и, если изображение цветное, переводит цветовые коды в шкалу оттенков серого, что нам и надо. Следующая строка преобразует квадратный массив размерностью 28x28 в длинный список значений, который нужен для передачи данных нейронной сети. Ранее мы делали это не раз. Новым здесь является вычитание значений массива из 255,0. Это необходимо сде­ лать, поскольку обычно коду 0 соответствует черный цвет, а коду 255 — белый, но в наборе данных MNIST используется обратная схе­ ма, в связи с чем мы должны инвертировать цвета для приведения их в соответствие с соглашениями, принятыми в MNIST. Последняя строка выполняет уже знакомое вам масштабирование данных, переводя их в диапазон значений от 0,01 до 1,0. Образец кода, демонстрирующего чтение PNG-файлов, доступен на сайте GitHub по следующему адресу: Собственный рукописный текст 215\n--- Страница 217 ---\nhttps: //github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/ blob/master/part3_load_own_images.ipynb Нам нужно создать версию программы, использовавшейся ранее для создания базовой нейронной сети и ее обучения с помощью набора данных MNIST, но теперь мы будем тестировать программу с исполь­ зованием набора данных, созданного на основе наших изображений. Новая программа доступна на сайте GitHub по следующему адресу: https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/ blob/master/part3_neural_network_mnist_and_own_data.ipynb Работает ли она? Конечно, работает! Следующая иллюстрация де­ монстрирует результаты опроса сети с использованием наших изоб­ ражений. Как видите, нейронной сети удалось распознать все изображения, включая намеренно поврежденную цифру “ 3” . Не удалось распоз­ нать лишь зашумленную цифру “6” . 216 Глава 3. Несколько интересных проектов\n--- Страница 218 ---\nПроведите эксперименты с подготовленными вами изображения­ ми, включая изображения рукописных цифр, и убедитесь в том, что нейронная сеть действительно работает. Также проверьте, как далеко можно зайти с испорченными или искаженными цифрами. Вы будете поражены гибкостью нашей ней­ ронной сети. Проникнем в “мозг” нейронной сети Нейронные сети полезны при решении тех задач, для которых трудно придумать простой и четкий алгоритм решения с фиксиро­ ванными правилами. Представьте себе только, каким должен быть набор правил, регламентирующих процедуру определения рукопис­ ной цифры, представленной изображением! Вы согласитесь, что соз­ дать такие правила довольно нелегко, а вероятность того, что наши попытки окажутся успешными, весьма мала. Загадочный черный ящик Завершив обучение нейронной сети и проверив ее работоспособ­ ность на тестовых данных, вы, по сути, получаете черный ящик. Фактически вы не знаете, как вырабатывается ответ, но все же он вырабатывается! Незнание внутреннего механизма не всегда является проблемой, если главное для вас — ответы и вас не интересует, каким образом они получены. Но именно этим недостатком страдают рассматрива­ емые методы машинного обучения: обучение не всегда означает по­ нимание сути задачи, которую черный ящик научился решать. Давайте разберемся, можем ли мы заглянуть внутрь нашей про­ стой нейронной сети и увидеть, чему она научилась, чтобы визуали­ зировать знания, приобретенные ею в процессе тренировки. Мы могли бы проанализировать весовые коэффициенты, в кото­ рых, в конце концов, и сосредоточено все, чему учится сеть. Но вряд ли эти данные будут нести в себе полезную для нас информацию, особенно если учесть, что нейронная сеть работает таким образом, чтобы распределить то, чему она учится, по различным связям. Это обеспечивает устойчивость сети к повреждениям, как это свойствен­ но биологическому мозгу. Маловероятно, что удаление одного или Проникнем в “мозг” нейронной сети 217\n--- Страница 219 ---\nдаже большего количества узлов полностью лишит сеть возможно­ сти нормально работать. Рассмотрим одну безумную идею. Обратные запросы Обычно мы задаем тренированной сети вопрос, и она выдает нам ответ. В нашем примере вопросом является изображение рукописной цифры. Ответом является маркер, представляющий число из диапа­ зона значений от 0 до 9. А что, если развернуть этот процесс наоборот? Что, если мы по­ дадим маркер на выходные узлы и проследим за распространением сигнала по уже натренированной сети в обратном направлении, пока не получим на входных узлах исходное изображение? Следующая диаграмма иллюстрирует процесс распространения обычного запроса и описанный только что процесс распространения обратного запроса. Мы уже знаем, как распространять сигналы по сети, сглаживая их весовыми коэффициентами и рекомбинируя на узлах, прежде чем применять к ним функцию активации. Весь этот механизм работает также для сигналов, распространяющихся в обратном направлении, 218 Глава 3. Несколько интересных проектов\n--- Страница 220 ---\nза исключением того, что в этом случае используется обратная функ­ ция активации. Если у = f (х) — функция активации для прямых сигналов, то ее обратная функция — х = g ( у ). Для логистической функции нахождение обратной функции сводится к простой алгебре: у = 1/(1 +е-х) 1 + е\"х = 1 /у е'х = (1 /у )-1 = (1 у) / у -х = 1п[ (1-у) /у] х = 1п[у/ (1-у) ] Эта функция называется lo g it , и библиотека Python scip y. special предоставляет ее как s c ip y .s p e c ia l.lo g it(), точно так же, как и логистическую функцию scip y .sp ecia l.ex p it(). Прежде чем использовать обратную функцию активации lo g it (), мы должны убедиться в допустимости сигналов. Что это означает? Вы помните, что сигмоида принимает любое значение и возвраща­ ет значение из диапазона от 0 до 1, исключая граничные значения. Обратная функция должна принимать значения из того же самого диапазона — от 0 до 1, исключая сами значения 0 и 1, — и возвра­ щать значение, которое может быть любым положительным или отрицательным числом. Для этого мы просто берем все значения в слое, к которым собираемся применить функцию lo g it (), и при­ водим их к допустимому диапазону. В качестве такового я выбрал диапазон чисел от 0,01 до 0,99. Соответствующий код доступен на сайте GitHub по следующему адресу: https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/ blob/master/part3_neural_network_mnist_backquery.ipynb Маркер \"О\" Посмотрим, что произойдет, если выполнить обратный запрос для маркера “0” , т.е. мы предоставляем выходным узлам значения, равные 0,01, за исключением первого узла, соответствующего марке­ ру “0” , которому мы предоставляем значение 0,99. Иными словами, Проникнем в “мозг” нейронной сети 219\n--- Страница 221 ---\nмы передаем на выходные узлы массив чисел [0.99, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01]. Ниже показано изображение, полученное на входных узлах. Это уже интересно! Так “видит” картинку “мозг” нашей нейрон­ ной сети. Как расценивать полученное изображение? Как его следует интер­ претировать? Основное, что сразу же бросается в глаза, — округлая форма изоб­ ражения. Это соответствует истине, поскольку мы интересовались у нейронной сети, каков тот идеальный вопрос, ответом на который будет “О ” . Кроме того, на изображении можно выделить темные, светлые и серые области. • Темные области — это те части искомого изображения, кото­ рые, если обвести их маркером, свидетельствуют в пользу того, что ответом следует считать “0” . Форма их контура действи­ тельно напоминает цифру “О ” . • Светлые области — это те участки искомого изображения, ко­ торые следует считать не закрашенными, если остановиться на версии, что ответом является “0” . Это предположение пред­ ставляется разумным, поскольку эти участки располагаются внутри контура цифры “О ” . • Серые области в основном не несут никакой информации для нейронной сети. 220 Глава 3. Несколько интересных проектов\n--- Страница 222 ---\nИтак, в общих чертах нам удалось достигнуть некоторого понима­ ния того, как именно сформировалось умение сети классифициро­ вать изображения с маркером “О ” . Нам выпала редкостная удача заглянуть внутрь нейронной сети, поскольку в случае сетей с более сложной структурой и большим количеством слоев, а также в случае более сложных задач вряд ли можно рассчитывать на столь же легкую интерпретацию результа­ тов. Остальные изображения Ниже представлены результаты обратного запроса для остальных случаев. Вот это да! Мы вновь получили довольно-таки интересные изоб­ ражения. Они словно представляют собой снимки мозга нейронной сети, полученные с помощью компьютерной томографии. По поводу этих изображений можно сделать некоторые замечания. • Маркер “ 7” довольно отчетливо распознается как цифра “ 7” . Если вы обведете карандашом темные пиксели изображения, то получите достаточно наглядное подтверждение этого. Также заметно выделяется “белая” область, где не должно быть закра­ шенных элементов. Оба этих фактора вместе указывают на то, что в данном случае мы имеем дело с цифрой “ 7” . Проникнем в “мозг” нейронной сети 221\n--- Страница 223 ---\n• То же самое справедливо для маркера “ 3” , поскольку здесь на­ лицо те же два фактора: схожесть контура темных пикселей, если обвести его карандашом, с цифрой “ 3” и наличие белых об­ ластей в тех местах, где они и должны быть в цифре “ 3” . • Маркеры “ 2” и “ 5” интерпретируются аналогичным образом. • Случай маркера “4” интересен наличием фигуры, напоминаю­ щей четыре квадранта, и белых областей. • Изображение, полученное для маркера “ 8” , очень напоминает снеговика, “голова и туловище” которого сформированы двумя белыми областями, что в целом соответствует цифре “8” . • Изображение для маркера “ 1” ставит нас в тупик. Создается впе­ чатление, что сеть уделила больше внимания тем областям, кото­ рые должны оставаться белыми, чем тем, которые должны быть закрашены. Ну что ж, это то, чему научилась сеть на примерах. • Изображение для маркера “9” вообще неразборчиво. В нем нет четко выделенных темных областей и каких-либо фигур, обра­ зованных белыми областями. Это результат того, чему сеть на­ училась на предоставленных ей примерах, обеспечивая в целом точность на уровне 97,5% . Глядя на данное изображение, на­ прашивается вывод, что, возможно, сеть нуждается в дополни­ тельных тренировочных примерах, которые помогли бы ей луч­ ше распознавать образцы цифры “9” . Итак, вам была предоставлена увлекательная возможность загля­ нуть во внутренний мир нейронной сети и, что называется, увидеть, как работает ее мозг. Создание новых тренировочных данных: вращения Оценивая тренировочные данные MNIST, следует сказать, что они содержат довольно богатый набор рукописных начертаний цифр. В нем встречается множество видов почерка и стилей, причем как хороших, так и плохих. Нейронная сеть должна учиться на как можно большем количес­ тве всевозможных вариантов написания цифр. Удачно то, что в этот 222 Глава 3, Несколько интересных проектов\n--- Страница 224 ---\nнабор входит также множество форм написания цифры “4” . Одни из них искусственно сжаты, другие растянуты, некоторые повернуты, в одних верхушка цифры разомкнута, в других сомкнута. Разве не будет полезно создать дополнительные варианты написа­ ния и использовать их в качестве тренировочных примеров? Как это сделать? Нам трудно собрать коллекцию из тысячи дополнительных примеров рукописного написания той или иной цифры. Вернее, мы могли бы попытаться, но это стоило бы нам огромных усилий. Но ведь ничто не мешает нам взять существующие примеры и соз­ дать на их основе новые, повернув цифры по часовой стрелке или против, скажем, на 10 градусов. В этом случае мы могли бы создать по два дополнительных примера для каждого из уже имеющихся. Мы могли бы создать гораздо больше примеров, вращая образцы на разные углы, но мы ограничимся углами +10 и -10 градусов, что­ бы посмотреть, как работает эта идея. И вновь большую помощь в этом нам окажут расширения и биб­ лиотеки Python. Функция scipy. ndimage. interpolation. rotate () поворачивает изображение, представленное массивом, на заданный угол, а это именно то, что нам нужно. Описание функции можно найти здесь: https://docs.scipy.org/doc/scipy-0.16.0/reference/ generated/scipy.ndimage.interpolation.rotate.html Вспомните, что наши входные значения представляют собой одно­ мерный список длиной 784 элемента, поскольку мы спроектировали нашу нейронную сеть таким образом, чтобы она принимала длинный список входных сигналов. Мы должны реорганизовать этот список в массив размерностью 28x28, чтобы повернуть изображение, а затем проделать обратную операцию по преобразованию массива в список из 784 входных сигналов, которые мы подадим на вход нейронной сети. В приведенном ниже коде показан пример использования функ­ ции scipy.ndimage.interpolation.rotate () в предположении, что у нас уже имеется массив scaled_input, о котором шла речь ранее. # создание повернутых на некоторый угол вариантов изображений # повернуть на 10 градусов против часовой стрелки inputs_pluslO_img = Создание новых тренировочных данных: вращения 223\n--- Страница 225 ---\n^scipy.ndimage.interpolation.rotate(scaled_input.reshape(28,28), 4>10, cval=0.01, reshape=False) # повернуть на 10 градусов по часовой стрелке inputs_minuslO_img = 'bscipy.ndimage.interpolation.rotate(scaled_input.reshape (28,28), ^>-10, cval=0.01, reshape=False) В этом коде первоначальный массив scaled input преобразуется в массив размерностью 28x28. Параметр reshape=False сдерживает излишнюю рьяность библиотеки в ее желании быть как можно более полезной и сжать изображение таким образом, чтобы после враще­ ния все оно уместилось в массиве и ни один его пиксель не был от­ сечен. Параметр cval — это значение, используемое для заполнения элементов массива, которые не существовали в исходном массиве, но теперь появились. Мы откажемся от используемого по умолчанию значения 0,0 и заменим его значением 0,01, поскольку во избежание подачи на вход нейронной сети нулей мы используем смещенный ди­ апазон входных значений. Запись 6 (седьмая по счету) малого тренировочного набора MNIST содержит рукописное начертание цифры “ 1” . Вот как выглядят ее исходное изображение и две его повернутые вариации, полученные с помощью нашего кода. Результаты очевидны. Версия исходного изображения, повер­ нутая на +10 градусов, является примером почерка человека, “за­ валивающего” текст влево. Еще более интересна версия оригина­ ла, повернутая на -1 0 градусов, т.е. по часовой стрелке. Эта версия 224 Глава 3. Несколько интересных проектов\n--- Страница 226 ---\nрасполагается даже ровнее по сравнению с оригиналом и в некото­ ром смысле более представительна в качестве изображения для об­ учения. Создадим новый блокнот Python с имеющимся кодом нейронной сети, но с дополнительными тренировочными примерами, созданны­ ми путем поворота исходных изображений на 10 градусов в обе сто­ роны. Этот код доступен на сайте GitHub по следующему адресу: https://github.com/makeyourownneuralnetwork/makeyourownneuralnetwork/ blob/master/part3_neural_network_mnist_data_with_rotations.ipynb Запуск этого кода с использованием коэффициента обучения 0,1 и всего лишь одной тренировочной эпохи дает показатель эффектив­ ности, равный 0,9669. Это значительное улучшение по сравнению со значением 0,954, полученным без дополнительных повернутых изо­ бражений. Такой показатель уже попадает в число лучших из тех, которые опубликованы на сайте Яна Лекуна (http://yann . lecun. com/exdb/mnist/). Запустим серию экспериментов, изменяя количество эпох, чтобы проверить, можно ли еще больше улучшить полученный показатель эффективности обучения. Кроме того, уменьшим коэффициент обу­ чения до 0,01, поскольку, предоставив гораздо больше тренировоч­ ных данных и тем самым увеличив общее время обучения, мы мо­ жем позволить себе более осторожные шаги обучения меньшей вели­ чины. Не забывайте о том, что мы не ожидаем получить точность распоз­ навания 100%, поскольку, вероятно, существует естественный пре­ дел точности, обусловленный спецификой архитектуры нейронной сети или полнотой тренировочных данных, в связи с чем мы вряд ли можем получить точность выше примерно 98%. Под “спецификой архитектуры нейронной сети” здесь подразумевается выбор количес­ тва узлов в каждом слое, количества скрытых слоев, функции акти­ вации и т.п. Ниже представлены графики, отражающие зависимость эффек­ тивности нейронной сети от угла поворота дополнительных трениро­ вочных изображений. Для сравнения показана также точка данных, соответствующая отсутствию дополнительных примеров. Создание новых тренировочных данных: вращения 225\n--- Страница 227 ---\nКак видите, для пяти эпох наилучший результат равен 0,9745, или 97,5% точности. Это явное улучшение по сравнению с предыду­ щим примером. Также следует отметить, что с увеличением угла поворота изобра­ жения точность падает. Это вполне объяснимо, поскольку при боль­ ших углах поворота результирующие изображения фактически во­ обще не представляют цифры. Представьте цифру “3” , повернутую на 90 градусов, т.е. положенную на бок. Это будет вовсе не тройка. Поэтому, добавляя тренировочные примеры с чрезмерно большими углами поворота, мы снижаем качество тренировки, потому что до­ бавляемые примеры являются ложными. Пожалуй, оптимальным углом поворота для дополнительных тренировочных изображений является угол 10 градусов. Для десяти эпох рекордное пиковое значение точности составля­ ет 0,9787, или почти 9 8 % ! Это поистине ошеломляющий результат для простой нейронной сети такого рода. Не забывайте о том, что мы не использовали никаких изощренных математических трюков в отношении нейронной сети или данных, как это делают некоторые 226 Глава 3. Несколько интересных проектов\n--- Страница 228 ---\nлюди. Мы придерживались предельной простоты и тем не менее до­ стигли результатов, которыми по праву можем гордиться. Отличная работа! Создание новых тренировочных данных: вращения 227\n--- Страница 230 ---\nЭпилог Надеюсь, мне удалось продемонстрировать, что в случае использо­ вания традиционных подходов задачи, которые легко решает чело­ век, для компьютеров оказываются крепким орешком. Одним из вы­ зовов, брошенных так называемому “искусственному интеллекту” , является задача распознавания образов (изображений). Значительный прогресс в области распознавания изображений, как, впрочем, и в ряде других проблемных областей, был достигнут благодаря использованию нейронных сетей. Толчком к развитию теории нейронных сетей послужило стремление разгадать тайну биологического мозга, который, обладая, на первый взгляд, мень­ шими быстродействием и ресурсами по сравнению с современными суперкомпьютерами, даже в случае таких живых существ, как по­ пугаи или насекомые, способен решать сложные задачи, например управление полетом, прием пищи или строительство жилья. Кроме того, биологический мозг необычайно устойчив к повреждениям и способен различать даже несовершенные сигналы. Цифровым компьютерам и традиционным вычислительным подходам до этого пока что далеко. На сегодняшний день нейронные сети — ключевой фактор успешности самых фантастических проектов в области искусствен­ ного интеллекта. Не ослабевает интерес к применению нейронных сетей в области машинного обучения, особенно глубокого обучения, предполагающего наличие иерархии обучающих методов. В начале 2016 года компьютерная система компании DeepMind, ныне при­ надлежащей компании Google, победила профессионального игрока в го. Это был поворотный момент в развитии искусственного интел­ лекта, поскольку игра го требует гораздо более глубокого продумы­ вания стратегии по сравнению с шахматами, и исследователи по­ лагали, что наступления столь знаменательного события придется ожидать еще долгие годы. Ключевую роль в этом успехе сыграли нейронные сети.\n--- Страница 231 ---\nХочется верить, что мне удалось продемонстрировать вам, насколь­ ко простые идеи лежат в основе нейронных сетей. Я также надеюсь, что эксперименты с нейронными сетями доставили вам удовольствие. Возможно, это пробудит в вас интерес к изучению других разновиднос­ тей машинного обучения и искусственного интеллекта. Если хотя бы одно из моих предположений оказалось верным, моя цель достигнута. 230 Эпилог\n--- Страница 232 ---\nПРИЛОЖЕНИЕ А Краткое введение в дифференциальное исчисление Представьте, что вы движетесь в автомобиле с постоянной ско­ ростью 30 миль в час. Затем вы нажимаете на педаль акселератора. Если вы будете держать ее постоянно нажатой, скорость движения постепенно увеличится до 35, 40, 50, 60 миль в час и т.д. Скорость движения автомобиля изменяется. В этом разделе мы исследуем природу изменения различных вели­ чин и обсудим способы математического описания этих изменений. А что подразумевается под “математическим описанием”? Это озна­ чает установление соотношений между различными величинами, что позволит нам точно определить степень изменения одной величины при изменении другой. Например, речь может идти об изменении ско­ рости автомобиля с течением времени, отслеживаемого по наручным часам. Другими возможными примерами могут служить зависимость высоты растений от уровня выпавших осадков или изменение длины пружины в зависимости от приложенного к ее концам усилия. Математики называют это дифференциальным исчислением. Я дол­ го сомневался, прежде чем решился вынести этот термин в название приложения. Мне казалось, что многих людей он отпугнет, посколь­ ку они посчитают изложенный ниже материал слишком сложным для того, чтобы на него тратить время. Однако такое отношение к дан­ ному предмету обсуждения могли привить только плохие учителя или плохие школьные учебники. Прочитав все приложение до конца, вы убедитесь в том, что мате­ матическое описание изменений — а именно для этого и предназначе­ но дифференциальное исчисление — оказывается совсем не сложным во многих полезных сценариях.\n--- Страница 233 ---\nДаже если вы уже знакомы с дифференциальным исчислением, возможно, еще со школы, вам все равно стоит прочитать это прило­ жение, поскольку вы узнаете много интересного об истории матема­ тики. Вам будет полезно взять на вооружение идеи и инструменты математического анализа, чтобы использовать их в будущем при ре­ шении различных задач. Если вам нравятся исторические эссе, почитайте книгу “Великие противостояния в науке” (ИД “Вильямс” , 2007), где рассказывается о драме, разыгравшейся между Лейбницем и Ньютоном, каждый из которых приписывал открытие дифференциального исчисления себе! Прямая линия Чтобы настроиться на работу, начнем для разминки с очень прос­ того сценария. Вновь представьте себе автомобиль, движущийся с постоянной ско­ ростью 30 миль в час. Не больше и не меньше, а ровно 30 миль в час. В приведенной ниже таблице указана скорость автомобиля в раз­ личные моменты времени с интервалом в полминуты. 232 Приложение А, Краткое введение в дифференциальное исчисление\n--- Страница 234 ---\nВремя (мин.) Скорость (миль/ч) 0,0 3 0 0,5 3 0 1 ,0 3 0 1 ,5 3 0 2,0 3 0 2,5 3 0 3,0 3 0 Следующий график представляет значения скорости в соответ­ ствующие моменты времени. Как видите, скорость не изменяется с течением времени, и по­ этому точки выстраиваются в прямую линию. Эта линия не идет ни вверх (увеличение скорости), ни вниз (уменьшение скорости), а оста­ ется на уровне 30 миль в час. В данном случае математическое выражение для скорости, кото­ рую мы обозначим как s, имеет следующий вид: Прямая линия 233\n--- Страница 235 ---\nЕсли бы кто-то спросил нас о том, как изменяется скорость со вре­ менем, мы бы ответили, что она не изменяется. Скорость ее измене­ ния равна нулю. Иными словами, скорость не зависит от времени. Зависимость в данном случае нулевая. Мы только что выполнили одну из операций дифференциального исчисления! Я не шучу! Дифференциальное исчисление сводится к нахождению измене­ ния одной величины в результате изменения другой. В данном слу­ чае нас интересует, как скорость изменяется со временем. Вышеизложенное можно записать в следующей математической форме: Что собой представляют эти символы? Считайте, что они означают “как скорость изменяется с изменением времени” , или “как s зави­ сит от t”. Таким образом, это выражение является компактной математи­ ческой записью утверждения о том, что скорость не изменяется со временем. Другими словами, изменение времени не влияет на ско­ рость. Зависимость скорости от времени нулевая. Именно это означа­ ет нуль в выражении. Обе величины полностью независимы. Ладно, ладно — мы все уже поняли! В действительности эту независимость можно легко заметить, если вновь взглянуть на выражение для скорости s = 30. В нем во­ обще нет даже намека на время, т.е. в нем отсутствует любое про­ явление символа t. Поэтому, чтобы сказать, что = 0, нам не по­ требуется никакое дифференциальное исчисление. Говоря языком математиков, “это следует из самого вида выражения” . Выражения вида d s / d t, определяющие степень изменения одной величины при изменении другой, называют производными. Для на­ ших целей знание этого термина не является обязательным, но он вам может встретиться где-нибудь еще. А теперь посмотрим, что произойдет, если надавить на педаль ак­ селератора. Поехали! 234 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 236 ---\nНаклонная прямая линия Представьте себе все тот же автомобиль, движущийся со скорос­ тью 30 миль в час. Вы надавили на педаль акселератора, и автомо­ биль набирает скорость. Вы удерживаете педаль нажатой, смотрите на показания спидометра и записываете их через каждые 30 секунд. По прошествии 30 секунд скорость автомобиля составила 35 миль в час. Через минуту она возрастает до 40 миль в час. Через 90 секунд автомобиль ускоряется до 45 миль в час, а после двух минут автомо­ биль разгоняется до 50 миль в час. С каждой минутой скорость авто­ мобиля увеличивается на 10 миль в час. Эта информация сведена в представленной ниже таблице. Время (мин.) Скорость (миль/ч) 0,0 30 0,5 35 1,0 40 1,5 45 2,0 50 2,5 55 3,0 60 Визуализируем эти данные. Наклонная прямая линия 235\n--- Страница 237 ---\nКак видите, увеличение скорости движения автомобиля с 30 до 60 миль в час происходит с постоянной скоростью изменения. Она действительно постоянна, поскольку приращение скорости за каждые полминуты остается одним и тем же, что приводит к прямо­ линейному графику скорости. А что собой представляет выражение для скорости? В нулевой момент времени скорость равна 30 миль в час. Далее мы добавляем по 10 миль в час за каждую минуту. Таким образом, искомое выра­ жение должно иметь следующий вид: Это выражение говорит о том, что между скоростью движения ав­ томобиля и временем существует зависимость. На это указывает тот факт, что 3s/3t не равно нулю. Вспомните, что для прямой линии, описываемой уравнением = = ах + Ь ,наклон равен а, и поэтому наклон для прямой линии s = 30 + + 10t должен быть равным 10. 236 Приложение А. Краткое введение в дифференциальное исчислениеПерепишем его, используя символьные обозначения: В этом выражении имеется константа 30. В нем также есть член ( 1 0* время), который каждую минуту увеличивает скорость на 10 миль в час. Вы быстро сообразите, что 10 — это угловой ко­ эффициент линии, график которой мы построили. Вспомните, что общая форма уравнения прямой линии имеет вид = где а — угловой коэффициент, или наклон, линии. А как будет выглядеть выражение, описывающее изменение ско­ рости во времени? Мы уже говорили, что с каждой минутой скорость увеличивается на 10 миль в час.\n--- Страница 238 ---\nОтличная работа! Мы уже успели охватить довольно много базо­ вых элементов дифференциального исчисления, и это оказалось со­ всем несложно. А теперь надавим на акселератор еще сильнее! Кривая линия Представьте, что я начинаю поездку в автомобиле, нажав педаль акселератора почти до упора и удерживая ее в этом положении. Совершенно очевидно, что начальная скорость равна нулю, посколь­ ку в первый момент автомобиль вообще не двигался. Поскольку педаль акселератора нажата почти до упора, скорость движения будет увеличиваться не равномерно, а быстрее. Это оз­ начает, что скорость автомобиля уже не будет возрастать только на 10 миль в час каждую минуту. Само ежеминутное приращение скорости будет с каждой минутой увеличиваться, если педаль аксе­ лератора по-прежнему удерживается нажатой. Предположим, что скорость автомобиля принимает в каждую ми­ нуту значения, приведенные в следующей таблице. Время (мин.) Скорость (миль/ч) 0 0 1 1 2 4 3 9 4 16 5 25 6 36 7 49 8 64 Внимательно присмотревшись к этим данным, вы заметите, что выбранные мною значения скорости представляют собой время в ми­ нутах, возведенное в квадрат, т.е. скорость в момент времени 2 равна 22 =4, в момент времени 3 - 32 =9, в момент времени 4 - 42 =16 и т.д. Записать соответствующее математическое выражение не состав­ ляет труда: Кривая линия 237\n--- Страница 239 ---\nДа, я отдаю себе отчет в том, что пример со скоростью автомобиля довольно искусственный, но он позволяет наглядно продемонстриро­ вать, как мы можем использовать дифференциальное исчисление. Представим табличные данные в виде графика, который позволит нам лучше понять характер изменения скорости автомобиля во вре­ мени. Как видите, со временем скорость автомобиля растет все интенсив­ нее. График уже не является прямой линией. Нетрудно сделать вы­ вод, что вскоре скорость должна достигнуть очень больших значений. На 20-й минуте она должна была бы составить 400 миль в час, а на 100-й — целых 10000 миль в час! Возникает интересный вопрос: как быстро изменяется скорость с течением времени? Другими словами, каково приращение скорости в каждый момент времени? Это не то же самое, что спросить: а какова фактическая скорость в каждый момент времени? Ответ на этот вопрос нам уже известен, поскольку для него у нас есть соответствующее выражение: s = t2 . Мы же спрашиваем следующее: какова скорость изменения скорос­ ти автомобиля в каждый момент времени? Но что вообще это означает в нашем примере, в котором график оказался криволинейным? 238 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 240 ---\nЕсли вновь обратиться к двум предыдущим примерам, то в них ско­ рость изменения скорости определялась наклоном графика зависимости скорости от времени. Когда автомобиль двигался с постоянной скоро­ стью 30 миль в час, его скорость не изменялась, и поэтому скорость ее из­ менения была равна 0. Когда автомобиль равномерно набирал скорость, скорость ее изменения составляла 10 миль в час за минуту. Данный по­ казатель имел одно и то же значение в любой момент времени. Он был равен 10 миль в час на второй, четвертой и даже на сотой минуте. Можем ли мы применить те же рассуждения к криволинейному гра­ фику? Можем, но с этого момента нам следует немного сбавить темп, чтобы не спеша обсудить этот вопрос. Применение дифференциального исчисления вручную Присмотримся повнимательнее к тому, что происходит в конце тре­ тьей минуты движения. По прошествии трех минут с момента начала движения (t=3) ско­ рость (s) составит 9 миль в час. Сравним это с тем, что будет в конце шес­ той минуты движения. В этот момент скорость составит 36 миль в час, но мы знаем, что после этого автомобиль будет двигаться еще быстрее. Мы также знаем, что в любой момент времени вслед за шестой ми­ нутой скорость будет увеличиваться быстрее, чем в эквивалентный мо­ мент времени, следующий за третьей минутой. Существует реальное различие в том, что происходит в моменты времени, соответствующие трем и шести минутам движения. Представим все это в наглядной форме с помощью графика. Применение дифференциального исчисления вручную 239\n--- Страница 241 ---\nВы видите, что в момент времени 6 минут наклон кривой круче, чем в момент времени 3 минуты. Оба наклона представляют иско­ мую скорость изменения скорости движения. Очень важно, чтобы вы это поняли, потому повторим мысль в следующей формулировке: скорость изменения кривой в любой точке определяется ее наклоном в этой точке. Но как измерить наклон линии, которая искривлена? С прямыми линиями все просто, а вот как быть с кривыми? Мы можем попы­ таться оценить наклон, прочертив прямую линию, так называемую касательную, которая лишь касается кривой (имеет с ней только одну общую точку) таким образом, чтобы иметь тот же наклон, что и кривая в данной точке. Именно так в действительности люди и по­ ступали, пока не были изобретены другие способы. Давайте испытаем этот приближенный простой способ хотя бы для того, чтобы лучше понять, к чему он приводит. На следующей иллюстрации представлен график скорости с касательной к кри­ вой в точке, соответствующей шести минутам движения. 240 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 242 ---\nИз школьного курса математики нам известно, что для определе­ ния наклона, или углового коэффициента, следует разделить при­ ращение вертикальной координаты на приращение горизонтальной координаты. На диаграмме приращение по вертикали (скорость) обозначено как Да, а приращение по горизонтали (время) — как At. Символ Д (читается “дельта”) просто означает небольшое изменение. Поэтому At — это небольшое изменение t. Наклон определяется отношением A s/A t. Мы можем выбрать для определения наклона любой треугольник и измерить длину его катетов с помощью линейки. В выбранном мною треугольнике при­ ращение As оказалось равным 9,6, а приращение At — 0,8. Это дает следующую величину наклона. Мы получили очень важный результат! Скорость изменения скоро­ сти в момент времени 6 минут составляет 12,0 миль в час за минуту. Нетрудно заметить, что от способа, основанного на проведении ка­ сательной вручную и выполнении измерений с помощью линейки, вряд ли можно ожидать высокой точности. Поэтому мы должны об­ ратиться к более совершенным методам. Усовершенствованный способ применения дифференциального исчисления, допускающий автоматизацию Взгляните на следующий график, на котором проведена другая прямая линия. Она не является касательной, поскольку имеет более одной общей точки с кривой. Но видно, что она в некотором смысле центрирована на моменте времени, соответствующем трем минутам. Усовершенствованный способ применения дифференциального исчисления 241\n--- Страница 243 ---\nСвязь этой прямой с моментом времени 3 минуты действитель­ но существует. Для ее проведения были выбраны моменты времени до и после интересующего нас момента времени t=3. В данном случае были выбраны точки, отстоящие от точки t=3 на две минуты в боль­ шую и меньшую стороны, т.е. этим моментам времени соответствуют точки t=l и t=5. Используя математические обозначения, можно сказать, что Ах равно 2 минуты. Тогда выбранным нам точкам соответствуют коор­ динаты х - А х и х + А х . Вспомните, что символ А означает “небольшое изменение” , поэтому А х — это небольшое изменение х . Зачем мы это делаем? Потерпите минутку — очень скоро все про­ яснится. Если мы возьмем значения скорости в моменты времени х - А х и х + А х и проведем через соответствующие две точки прямую линию, то ее наклон будет примерно равен наклону касательной в средней точке х . 242 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 244 ---\nВернитесь к предыдущей иллюстрации и взгляните на эту прямую ли­ нию. Несомненно, ее наклон не совпадает в точности с наклоном истин­ ной касательной в точке х , но мы исправим этот недостаток. Вычислим наклон этой прямой. Мы используем прежний подход и рассчитаем наклон как отношение смещения точки по вертикали к смещению по горизонтали. Следующая иллюстрация проясняет, что в данном случае представляют собой эти смещения. Смещение по вертикали — это разность между значениями ско­ рости в точках х + Д х и х - Д х , соответствующих пяти минутам и од­ ной минуте движения. Эти скорости нам известны: 52 = 25 и I2 = 1, поэтому разность составляет 24. Смещение по горизонтали — это просто расстояние между точками х + Д х и х - Д х . , т.е. 5 - 1=4. Следовательно, имеем: Усовершенствованный способ применения дифференциального исчисления 243\n--- Страница 245 ---\nТаким образом, наклон прямой линии, являющейся приближением к касательной в точке t=3 минуты, составляет 6 миль в час за минуту. Сделаем паузу и осмыслим полученные результаты. Сначала мы попытались определить наклон кривой, вручную проведя касатель­ ную к ней. Такой подход никогда не бывает точным, и мы не можем повторять его многократно, поскольку человеку свойственно уста­ вать, терять концентрацию внимания и совершать ошибки. Второй подход не требует проведения касательной вручную и вместо этого предлагает рецепт построения другой линии, наклон которой, по- видимому, может служить приближением к истинному наклону кривой. Этот подход допускает автоматизированную реализацию с помощью компьютера и может выполняться многократно с огром­ ной скоростью, недоступной человеку. Конечно, это неплохо, но и этого еще недостаточно! Второй подход также является всего лишь приближенным. Можно ли его усовершенствовать так, чтобы сделать точным? В конце кон­ цов, нашей целью является точное математическое описание скорос­ ти изменения величин. Вот здесь и начинается магия! Я познакомлю вас с одним из самых элегантных инструментов, разработанных математиками. Что случится, если мы уменьшим величину смещения. Иными словами, что произойдет, если уменьшить Д х ? Следующая иллюстра­ ция демонстрирует несколько приближений в виде наклонных пря­ мых, соответствующих уменьшению Д х. 244 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 246 ---\nМы провели линии для Д х = 2 , 0 , Д х = 1 , 0 , Д х = 0 , 5 и Л х = 0 , 1 . Вы видите, что эти линии постепенно приближаются к интересующей нас точке х = 3 . Нетрудно сообразить, что по мере уменьшения А х прямые линии будут все более и более приближаться к истинной касательной. При бесконечно малой величине А х линия приблизится к истин­ ной касательной на бесконечно малое расстояние. Это очень круто! Идея постепенного улучшения первоначального приближенного решения путем уменьшения отклонений необычайно плодотворна. Она позволяет математикам решать задачи, непосредственное реше­ ние которых наталкивается на значительные трудности. При таком подходе к решению приближаются постепенно, словно крадучись, вместо того чтобы атаковать его прямо в лоб! Усовершенствованный способ применения дифференциального исчисления 245\n--- Страница 247 ---\nДифференциальное исчисление без использования графиков Как уже отмечалось, целью дифференциального исчисления явля­ ется описание изменения величин математически точным способом. Посмотрим, можем ли мы добиться этого, применяя идею последо­ вательного уменьшения Д х к математическим выражениям, опре­ деляющим эти величины, такие, например, как скорость движения автомобиля. Напомню, что в нашем примере скорость движения является функцией времени вида s = t 2 . Нас интересует скорость изменения скорости движения как функция времени. Вы видели, что эта вели­ чина определяется наклоном графика зависимости s от t. Интересующая нас скорость изменения ds/dt определяется вели­ чиной отношения смещения по вертикали к смещению по горизонта­ ли, где последнее бесконечно мало и стремится к нулю. Что такое смещение по вертикали? Как было показано раньше, это (t + Д х ) 2 - (t - Д х )2 . Здесь использована функция s = t2 , где t при­ нимает значения, немного меньшие и немного большие, чем в инте­ ресующей нас точке. Это “немного” равно Д х. Что такое смещение по горизонтали? Как вы видели раньше, это просто расстояние между точками (t + Д х) и (t - Д х ), которое равно 2Дх. Мы уже почти у цели: Раскроем и упростим это выражение: 246 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 248 ---\nВ данном случае нам крупно повезло, поскольку алгебра необы­ чайно все упростила. Итак, мы это сделали! Математически точная скорость изменения ds/dt = 2 t . Это означает, что для любого момента времени t мы мо­ жем вычислить скорость изменения скорости движения по формуле da/dt = 2t. При t = 3 мы получаем ds/dt = 2t = 6. Фактически мы подтвердили этот результат еще раньше с помощью приближенного метода. Для t = 6 получаем 3 s / 3 t = 2 t = 1 2 , что также согласуется с найденным ра­ нее результатом. А что насчет ста минут? В этом случае 3 s / 3 t = 2 t = 2 0 0 миль в час за минуту. Это означает, что спустя сто минут от начала движения машина будет ускоряться со скоростью 200 миль в час за минуту. Сделаем небольшую паузу и немного поразмышляем над величи­ ем и красотой того, что нам удалось сделать. Мы получили матема­ тическое выражение, с помощью которого можем точно определить скорость изменения скорости движения автомобиля в любой момент времени. При этом, в полном соответствии с нашими рассуждениями в начале приложения, мы видим, что эти изменения s действительно зависят от времени. Нам повезло, что алгебра все упростила, но в силу простоты выра­ жения s = t 2 нам не представилась возможность проверить на практи­ ке идею устремления Дх к нулю. В связи с этим полезно рассмотреть другой пример, в котором скорость движения автомобиля описыва­ ется несколько более сложной формулой: Дифференциальное исчисление без использования графиков 247\n--- Страница 249 ---\nА что теперь означает вертикальное смещение? Это разность меж­ ду скоростью s , рассчитанной в момент времени t + Д х , и скоростью s , рассчитанной в момент времени t - Д х . Найдем эту разность путем несложных вычислений: ( t + Д х ) 2 + 2 ( t + Д х ) - ( t - Д х ) 2 — 2 ( t — Д х ) . А что насчет горизонтального смещения? Это просто расстояние между точками ( t + Д х ) и ( t - Д х ) , которое по-прежнему равно 2Д х: Раскроем и упростим это выражение: Это замечательный результат! К сожалению, алгебра и в этот раз немного перестаралась, упростив нам работу. Но этот пример не был напрасным, поскольку здесь уже вырисовывается закономерность, к которой мы еще вернемся. Попробуем рассмотреть еще один, чуть более сложный, пример. Предположим, что скорость движения автомобиля описывается ку­ бической функцией времени: 248 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 250 ---\nРаскроем и упростим это выражение: Это уже намного интереснее! Мы получили результат, содержа­ щий Д х , тогда как раньше эти члены взаимно сокращались. Вспомните, что корректное значение наклона получается лишь в том случае, если величина Д х уменьшается, становясь бесконечно малой. А сейчас смотрите! Что произойдет с величиной Д х в выражении d s / d t = 3 t 2 + A x 2, если она становится все меньшей и меньшей? Она исчезнет! Если для вас это неожиданность, то представьте, что вели­ чина Д х очень мала. Напрягитесь и представьте, что она еще мень­ ше. Потом представьте, что на самом деле она еще меньше И этот процесс мысленного уменьшения Д х вы могли бы продолжать до бес­ конечности, устремляя ее к нулю. Поэтому давайте проявим реши­ мость и сразу же перейдем к нулю без лишней суеты. В результате мы получаем искомый математически точный ответ: Дифференциальное исчисление без использования графиков 249\n--- Страница 251 ---\nЭто фантастический результат, и на этот раз он был получен с ис­ пользованием мощного математического инструмента, что оказалось совсем несложным. Закономерности Конечно, это весьма интересное занятие — находить производные, используя приращения наподобие Дх, и смотреть, что произойдет, если делать их все меньшими и меньшими. Но зачастую можно по­ лучить результат, не выполняя всю эту работу. Посмотрите на приведенные ниже формулы и постарайтесь уви­ деть в них закономерность. Вы видите, что производная функции t представляет собой ту же функцию, но с понижением на единицу каждой степени t. Поэтому t4 превращается в t3 , a t7 превратилось бы в t* и т.д. Это очень просто! А если вы вспомните, что t — это t\\ то в производной это превраща­ ется в t°, т.е. в 1. Свободные постоянные члены, такие как 3, 4 или 5, просто исчеза­ ют. Постоянные переменные, не являющиеся коэффициентами, такие как а, b или с, также исчезают, поскольку скорость их изменения так­ же нулевая. Именно поэтому их называют константами. Но погодите, ведь t2 превращается в 2t, а не просто в t, a t8 превра­ щается в 3t2 , а не просто в t2 . Это общее правило: степень переменной, прежде чем уменьшиться на единицу, становится коэффициентом. 250 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 252 ---\nПоэтому 5 в 2 t 5 используется в качестве дополнительного коэффици­ ента перед уменьшением степени на единицу: 5 * 2 t 4 = 1 0 t 4. Приведенная ниже формула суммирует все, что было сказано о дифференцировании степеней, в виде следующего правила: Испытаем эту формулу на дополнительных примерах только ради того, чтобы набить руку в использовании этого нового приема: Это правило пригодится вам во многих случаях, а зачастую ниче­ го другого вам и не потребуется. Верно и то, что правило применимо только к полиномам, т.е. к выражениям, состоящим из переменных в различных степенях, как, например, выражение у = а х 3 + b x 2 + с х + d , но не к функциям вида sin (x) или cos(x). Это не является сущес­ твенным недостатком, поскольку в огромном количестве случаев вам вполне хватит правила дифференцирования степеней. Однако для нейронных сетей нам понадобится еще один инстру­ мент, о котором сейчас пойдет речь. Закономерности 251\n--- Страница 253 ---\nФункции функций Представьте, что в функции переменная у сама является функцией: При желании можно переписать эту формулу в виде f = (х8 + х)2 . Как f изменяется с изменением у? То есть что собой представля­ ет производная df/Эу? Получить ответ на этот вопрос не составляет труда, поскольку для этого достаточно применить только что полу­ ченное нами правило дифференцирования степенных выражений, поэтому d f/ Эу = 2у. Но возникает более интересный вопрос: как изменяется f при из­ менении х? Ну хорошо, мы могли бы раскрыть выражение f = (х3 + х)2 и применить уже знакомый подход. Только ни в коем случае не счи­ тайте наивно, что производная от (ха + х)2 — это 2 (х3 + х). Если бы мы проделали множество подобных вычислений преж­ ним трудоемким способом, предполагающим устремление прираще­ ний к нулю в результирующих выражениях, то рано или поздно мы подметили бы еще одну закономерность. Я сразу же дам вам готовый рецепт. Вот как выглядит новая закономерность. Это очень мощный результат, который называется цепным пра видом. 252 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 254 ---\nВ соответствии с этим правилом нахождение производной в по­ добных случаях осуществляется поэтапно. Может оказаться так, что для нахождения производной dt/dx проще найти производные d f /Э у и эу/ах. Если последние две производные действительно вычисляют­ ся очень просто, то с помощью этого приема удается находить произ­ водные, определить которые другими способами практически невоз­ можно. Цепное правило позволяет разбивать трудные задачи на бо­ лее легкие. Рассмотрим следующий пример и применим к нему цепное правило: Мы разбили задачу на две простые части. Первая часть дает ( a f / Э у ) = 2 у , вторая — ( Э у /Э х ) = З х 2 + 1. Объединяя эти части с помо­ щью цепного правила, получаем Мы знаем, что у = х 3 + х , поэтому можем получить выражение, со­ держащее только х : Магия! Функции функций 253\n--- Страница 255 ---\nВозможно, вас так и подмывает спросить: а почему бы не предста­ вить f в виде функции, зависящей только от х , и применить простое правило дифференцирования степеней к результирующему полино­ му? Мы могли бы это сделать, но тогда я не продемонстрировал бы вам, как работает цепное правило, которое позволяет разгрызать бо­ лее твердые орешки. Рассмотрим еще один пример, на этот раз последний, который демонстрирует, как обращаться с переменными, не зависящими от других переменных. Предположим, имеется функция f - 2-Ху + 3 + 4Z В ней переменные х , у и г н е зависят одна от другой. Что мы под­ разумеваем под независимостью переменных? Под этим подразуме­ вается, что каждая из переменных х , у и z может принимать любые значения, какими бы ни были значения остальных переменных — их изменения на нее не влияют. В предыдущем примере это было не так, поскольку значение у определялось значением выражения х 3 + х , а значит, переменная у зависела от х . Что такое S f / Э х ? Рассмотрим каждый член длинного полинома по отдельности. Первый член — это 2 х у , поэтому его производная равна 2 у . Почему так просто? Да потому, что у не зависит от х . Когда мы интересуемся величиной д£/дх, нас интересует, как изменяется f при изменении х . Если переменная у не зависит от х , то с ней можно обращаться как с константой. На ее месте могло бы быть любое дру­ гое число, например 2, 3 или 10. Идем дальше. Следующий член выражения — 3 x 2z . Применяя правило понижения степеней, получаем 2 * 3 x z или 6 x z . Мы рассмат­ риваем z как обычную константу, значением которой может быть 2, 4 или 100, поскольку х и г н е зависят друг от друга. Изменение г не влияет на х . Последний член, 4 z , вообще не содержит х . Поэтому он полностью исчезает, так как мы рассматриваем его как постоянное число, кото­ рым, например, могло бы быть 2 или 4. Вот как выглядит окончательный ответ: 254 Приложение А. Краткое введение в дифференциальное исчисление\n--- Страница 256 ---\nВ этом примере была важна возможность уверенно игнорировать переменные, о которых известно, что они являются независимыми. Это значительно упрощает дифференцирование довольно сложных выражений, в чем часто возникает необходимость в ходе анализа нейронных сетей. Вы освоили дифференциальное исчисление! Если вам удалось одолеть материал, изложенный в этом приложе­ нии, примите мои поздравления! Я постарался донести до вас, в чем состоит суть дифференциаль­ ного исчисления и как оно возникло на основе постепенного улуч­ шения приближенных решений. Всегда пытайтесь применять опи­ санные в данном приложении методы, если другие способы решения задачи не приводят к успеху. Используя метод дифференцирования выражений путем пониже­ ния степеней переменных и применения цепного правила для на­ хождения производных сложных функций, вы сможете многое уз­ нать о природе и механизмах функционирования нейронных сетей. Желаю вам максимально эффективно использовать этот мощный инструмент, которым вы теперь владеете! Вы освоили дифференциальное исчисление! 255\n--- Страница 258 ---\nПРИЛОЖЕНИЕ Б Нейронная сеть на Raspberry Pi В этом приложении вы узнаете, как установить IPython на устрой­ стве Raspberry Pi. Необходимость в этом может возникнуть по нескольким причинам. • Компьютеры Raspberry Pi очень дешевые и доступные по срав­ нению с более дорогими ноутбуками. • Компьютер Raspberry Pi работает под управлением бесплатной операционной системы Linux с открытым исходным кодом, для которой доступно множество всевозможных бесплатных программ, включая Python. Открытость исходного кода чрез­ вычайно важна, поскольку это позволяет разобраться в том, как функционирует та или иная программа, и поделиться ре­ зультатами своей работы с другими людьми, которые смогут воспользоваться ими в своих проектах. Это важно и для образо­ вательных целей, ведь, в отличие от коммерческого программ­ ного обеспечения, открытый исходный код свободно доступен для изучения. • В силу описанных, а также множества других причин устрой­ ства Raspberry Pi получили широкую популярность в качестве школьных и домашних компьютеров для детей, увлекающихся созданием компьютерных программ или программно-аппарат­ ных систем. • Компьютеры Raspberry Pi не такие мощные, как более до­ рогие компьютеры и ноутбуки. Поэтому интересно проде­ монстрировать, что даже этот фактор не мешает реализовать на Raspberry Pi нейронную сеть с помощью Python.\n--- Страница 259 ---\nЯ буду использовать модель Raspberry Pi Zero, поскольку она еще дешевле и миниатюрнее, чем обычные устройства Raspberry Pi, и это делает задачу развертывания на ней нейронной сети еще более инте­ ресной. Стоит эта модель около 5 долларов. Это не опечатка! Ниже представлена фотография моего устройства с двухпенсовой монетой для сравнения. Установка IPython Далее предполагается, что питание вашего Raspberry Pi включе­ но, а клавиатура, мышь, дисплей и подключение к Интернету рабо­ тают нормально. Существует несколько дистрибутивов операционных систем для Raspberry Pi, но мы будем ориентироваться на Raspbian — вер­ сию популярного дистрибутива Debian Linux, оптимизированную для аппаратных возможностей Raspberry Pi и доступную для загруз­ ки по следующему адресу: https://www.raspberrypi.org/downloads/raspbian/ 258 Приложение Б. Нейронная сеть на Raspberry Pi\n--- Страница 260 ---\nНиже показан вид рабочего стола после запуска Raspberry Pi. Я убрал фоновое изображение, чтобы оно не отвлекало внимание. В левом верхнем углу видны кнопки меню, а также другие значки. Мы собираемся установить IPython, чтобы иметь возможность ра­ ботать с помощью дружественного интерфейса блокнотов через веб­ браузер, а не в режиме командной строки. Для установки IPython нам все-таки придется использовать ко­ мандную строку, но сама эта процедура очень простая, и ее придется выполнить только один раз. Откройте приложение Terminal, представленное в верхней час­ ти окна значком с изображением черного экрана. При наведении на него указателя мыши появляется подсказка “Terminal” . Когда вы запустите это приложение, откроется окно для ввода команд. Установка IPython 259\n--- Страница 261 ---\nRaspberry Pi очень хорош тем, что не позволяет рядовым поль­ зователям вводить команды, приводящие к глубоким изменениям в системе. Для этого необходимо иметь специальные привилегии. Введите в окне терминала следующую команду: sudo SU “ Вместо символа доллара ($), которым до этого заканчивалась под­ сказка для ввода команд, должен появиться символ решетки (#). Это свидетельствует о том, что теперь вы обладаете административными привилегиями и должны внимательно относиться к выбору вводи­ мых команд. Следующие команды актуализируют список текущего программ­ ного обеспечения Raspberry Pi, а затем обновляют установленные вами программы, загружая дополнительные программные компо­ ненты. apt-get update apt-get dist-upgrade 260 Приложение Б. Нейронная сеть на Raspberry Pi\n--- Страница 262 ---\nЕсли ваше программное обеспечение в последнее время не обнов­ лялось, то, вероятно, эта процедура потребуется некоторым про­ граммам. В таком случае вы увидите, как на экране промелькнет множество текстовых строк. На них можно не обращать внимания. От вас может потребоваться подтвердить обновление нажатием кла­ виши <Y>. Обновив состояние системы, введите команду для получения IPython. Имейте в виду, что на момент написания книги программ­ ные пакеты Raspbian не содержали версий IPython, позволяю­ щих работать с размещенными на сайте GitHub для всеобщего до­ ступа блокнотами, которые мы ранее создали. Если бы они их со­ держали, то достаточно было бы просто ввести команду apt-get install ipython3 ipython3-notebook или аналогичную ей. Если вы не хотите запускать блокноты из GitHub, можете спокой­ но использовать более старые версии IPython и блокнота из репози­ тория программного обеспечения Raspberry Pi. Если же вы хотите работать с более свежими версиями IPython и блокнота, то для того, чтобы получить их из каталога PyPi (Python Package Index — каталог пакетов Python), вам придется использо­ вать некоторые команды “pip” в дополнение к командам apt-get. В этом случае программное обеспечение будет управляться Python, а не менеджером программного обеспечения операционной системы. Следующие команды обеспечат вас всем необходимым. apt-get install python3-matplotlib apt-get install python3-scipy pip3 install jupyter Работа будет выполнена, как только на экране промелькнут по­ следние строки текста. Скорость выполнения зависит от конкретной модели Raspberry Pi и скорости вашего интернет-соединения. Вот как выглядел мой экран после выполнения этих команд. Установка IPython 261\n--- Страница 263 ---\nКак правило, в Raspberry Pi используются карты памяти, так на­ зываемые SD-карты, наподобие тех, которые вы, возможно, исполь­ зуете в своей цифровой камере. Они обеспечивают меньший объем памяти, чем обычные компьютеры. Удалите программные пакеты, которые были загружены для обновления вашего Raspberry Pi, ис­ пользовав для этого следующую команду: apt-get clean В последних версиях Raspbian браузер Epiphany заменен бра­ узером Chromium (версия с открытым исходным кодом популяр­ ного браузера Chrome). Но Epiphany гораздо легче тяжеловесного Chromium и работает лучше с крохотным Raspberry Pi Zero. Чтобы установить его в качестве браузера по умолчанию для блокнотов IPython, используйте следующую команду: update-alternatives — config x-www-browser Команда уведомит вас о текущей установленной версии браузера, используемой по умолчанию, и запросит разрешение на установку 262 Приложение Б, Нейронная сеть на Raspberry Pi\n--- Страница 264 ---\nновой версии. Выберите номер, соответствующий Epiphany, и от вас больше ничего не потребуется. Теперь все готово. Перезапустите Raspberry Pi в том случае, если обновление повлекло за собой некие глубокие изменения, такие как обновление ядра. Для этого выберите пункт Shutdown основного меню в левом верхнем углу, а затем пункт Reboot, как показано ниже. Shutdown Options - Shutdown Reboot Logout После повторного запуска Raspberry Pi запустите Python, выпол­ нив в окне терминала следующую команду: jupyter-notebook Это приведет к автоматическому запуску веб-браузера с откры­ той основной страницей IPython, на которой можно создавать новые блокноты IPython. Jupyter Notebook — это новое программное обес­ печение для выполнения блокнотов. Ранее приходилось выполнять команду ipython3 notebook, которая будет еще работать в течение переходного периода. Ниже показана основная начальная страница IPython. Установка IPython 263\n--- Страница 265 ---\nЗамечательно! Мы получили IPython и запустили оболочку на Raspberry Pi. С этого момента можно приступать к работе и создавать собствен­ ные блокноты IPython, но мы продемонстрируем, что способны вы­ полнить на Raspberry Pi код, который разработали ранее. Мы по­ лучим блокноты и базу данных рукописных цифр MNIST на сайте GitHub. Откройте в браузере новую вкладку и перейдите по следую­ щей ссылке: https: //github.com/makeyourownneuralnetwork/makeyourownneuralnetwork Вы увидите страницу проекта GitHub (см. ниже). Загрузите фай­ лы, щелкнув на кнопке Clone or Download и выбрав вариант Download Z IP . 264 Приложение Б. Нейронная сеть на Raspberry Pi\n--- Страница 266 ---\nЕсли GitHub не воспримет Epiphany, введите в адресной строке браузера следующую ссылку для загрузки файлов: https://github.com/makeyourownneuralnetwork/ makeyourownneuralnetwork/archive/master.zip Браузер сообщит вам об окончании загрузки. Откройте новое окно терминала и введите следующие команды, чтобы распаковать фай­ лы, а затем освободить место, удалив zip-файл. unzip Downloads/makeyourownneuralnetwork-master.zip rm -f Downloads/makeyourownneuralnetwork-master.zip Файлы будут распакованы в каталог makeyourownneuralnetwork- master. При желании можете присвоить ему более короткое имя, но делать это вовсе необязательно. На сайте GitHub содержатся лишь сокращенные версии наборов данных MNIST, поскольку сайт не позволил бы мне разместить фай­ лы большего размера. Чтобы получить полный набор данных, введи­ те в том же окне терминала следующие команды для перехода в ка­ талог mnist_dataset и получения тренировочного и тестового набо­ ров данных в CSV-формате. Установка IPython 265\n--- Страница 267 ---\ncd makeyourownneuralnetwork-master/mnist_dataset wget -c http://pjreddie.com/media/files/mnist_train.csv wget -c http://pjreddie.com/media/files/mnist_test.csv Загрузка файлов может занять некоторое время, которое зави­ сит от скорости вашего интернет-соединения и конкретной модели Raspberry Pi. Теперь вы располагаете всеми необходимыми блокнотами и дан­ ными MNIST. Закройте это окно терминала, но не то, из которого запускали IPython. Вернувшись в окно браузера с начальной страницей IPython, вы увидите в списке новую папку makeyourownneuralnetwork-master. Откройте эту папку, щелкнув на ней. Теперь вы сможете открыть любой блокнот, как смогли бы это сделать на любом другом компью­ тере. Ниже показаны блокноты, хранящиеся в указанной папке. 266 Приложение Б. Нейронная сеть на Raspberry Pi\n--- Страница 268 ---\nПроверка работоспособности программ Прежде чем приступить к тренировке и тестированию нейронной сети, убедимся в работоспособности кода, выполняющего такие опе­ рации, как чтение файлов и вывод изображений. Откройте блокнот part3_mnist_data_set_with_rotations. ipynb, реализующий эти опе­ рации. Открывшийся и готовый к выполнению блокнот должен вы­ глядеть так. Выполните содержащиеся в блокноте инструкции, выбрав в меню C ell пункт R un А Н . Спустя некоторое время, превышающее то, которое потребовалось бы в случае современного ноутбука, вы должны уви­ деть изображения повернутых цифр. Проверка работоспособности программ 267\n--- Страница 269 ---\nТаким образом, мы убедились в работоспособности на Raspberry Pi таких средств, как загрузка данных из файла, импорт модулей рас­ ширения Python для работы с массивами и изображениями, а также графический вывод изображений. Выберите в меню F ile этого блокнота пункт Close and H alt. Именно так, а не простым закрытием вкладки браузера, вы должны закры­ вать свои блокноты. Тренировка и тестирование нейронной сети Приступим к тренировке нейронной сети. Откройте блокнот part2_neural_network_mnist_data. ipynb. В нем представлена упро­ щенная версия нашей программы, лишенная таких возможностей, как вращение изображений. Поскольку наш Raspberry Pi работает гораздо медленнее типичного ноутбука, мы уменьшим некоторые па­ раметры для снижения объема вычислений, чтобы можно было сра­ зу же убедиться в работоспособности кода, а не потратить несколько часов лишь для того, чтобы обнаружить, что он не работает. Я уменьшил количество скрытых узлов до 10, а количество эпох — до 1. Я по-прежнему использовал полные тренировочные и тестовые 268 Приложение Б. Нейронная сеть на Raspberry Pi\n--- Страница 270 ---\nнаборы данных MNIST, а не ранее созданные уменьшенные подмно­ жества. Чтобы запустить программу, выберите в меню C ell пункт R u n А Н . Теперь вам остается только ждать. Обычно на выполнение подобных вычислений на моем ноутбуке уходит около минуты, но в данном случае для завершения работы программе потребовалось около 25 минут. В целом это не так уж и плохо, если учесть, что Raspberry Pi Zero стоит примерно в 400 раз дешевле, чем мой ноутбук. Я был готов к тому, что программа завер­ шится только к утру. Успех Raspberry Pi Только что мы продемонстрировали, что функциональных воз­ можностей даже такого миниатюрного компьютера, как Raspberry Pi Zero стоимостью всего 5 долларов, достаточно для полноценной работы с блокнотами IPython и создания кода, позволяющего тре­ нировать и тестировать нейронные сети. Просто все выполняется не­ много медленнее! Успех Raspberry Pi 269\n--- Страница 271 ---\nПредметный указатель А Anaconda, 130 С Chromium, 262 CSV-файл, 177 Е Epiphany, 262 I IPython, 130 установка, 258 J Jupyter Notebook, 130; 263 M MNIST, 176; 215; 222; 264 тренировочный набор, 185 Р Python, 129 R Raspberry Pi, 130; 257 Raspbian, 258 A Аксон, 58 Алгоритм, 21; 36 Анонимная функция, 166 Асимптота, 124 Б Библиотека matplotlib.pyplot, 148 numpy, 145 scipy, 165 scipy.misc, 215Блокнот, 132 Булева функция, 45 В Векторизация, 96 Весовой коэффициент, 60; 64; 78; 100;161 инициализация, 125; 163 Внутреннее произведение, 73 Входной порог, 55 Вызов функции, 142 Г Гиперболический тангенс, 126 Глубокое обучение, 229 Градиентный спуск, 103 д Дендрит, 52; 58 Дескриптор, 180 Дифференциальное исчисление, 110;231 И Импорт, 148 Итеративный процесс, 27 К Касательная, 240 Класс, 150 Классификатор, 28 линейный, 44 тренировка, 33 Комментарий, 140 Константа, 250 Коэффициент обучения, 119; 205;225 настройка, 200\n--- Страница 272 ---\nл Линейная зависимость, 23 Линейный классификатор, 44 Логистическая функция, 56 Лямбда-выражение, 166 М Маркер, 178 Массив, 144 графическое представление, 147 нумерация элементов, 147 Матрица, 68 Машинное обучение, 41 Метод, 153 градиентного спуска, 103 грубой силы, 101 Н Наклон, 236; 241 Насыщение нейронной сети, 123 Нейрон,51 Нейронная сеть, 153; 157 инициализация, 158 опрос, 164 способность к обучению, 206 тестирование, 193; 198 тренировка, 170; 198; 202; 268 О Обратное распространение ошибок, 88; 91; 117 Обратный запрос, 218 Объект, 149 Ошибка, 24; 36; 86 П Переменная,136 Переобучение, 203 Предиктор, 21; 44 Приращение, 241 Производная, 234; 250Р Распознавание образов, 176 Рукописные цифры, 176; 213 вращение, 222 С Сглаживание, 41; 66 Сигмоида, 55; 65; 81; 117; 165 Скалярное произведение, 73 Скорость обучения, 42 Скрытый слой, 77; 205 Способность к обучению, 206 Ступенчатая функция, 54 Т Терминаль, 52; 58 Тестовый набор, 177 Точечное произведение, 73 Точка разрыва, 106 Транспонирование, 98 Трансцендентные числа, 56 Тренировка классификатора, 33 нейронной сети,170; 198; 202;268 Тренировочный набор, 177 У Угловой коэффициент, 236 Ф Функция, 140; 252 1еп(), 182 list(), 137 matplotlib.pyplot.imshow(), 148 numpy.argmax(), 197 numpy.asfarrayO, 183 numpy.dot(), 165 numpy.random.normal(), 163 numpy.random.randO, 161 numpy.zeros(), 145; 189 open(), 180 Предметный указатель 271\n--- Страница 273 ---\npow(), 164 print(), 133 readlines(), 181 reshape(), 184 scipy.misc.imread(), 215 scipy.ndimage.interpolation. rotate(), 223 scipy.special.expit(), 165 scipy.special.logit(), 219 spit(), 183 активации,54; 66 анонимная, 166 вызов, 142 параметры, 154ц Цепное правило, 252 Цикл, 138 Ч Черный ящик, 217 Э Эпоха, 202; 225 Эффективность, 199; 225 Я Ячейка, 132 272 Предметный указатель",
      "debug": {
        "start_page": 214,
        "end_page": 274
      }
    }
  ]
}