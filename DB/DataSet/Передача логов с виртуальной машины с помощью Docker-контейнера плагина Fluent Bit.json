{
  "title": "Передача логов с виртуальной машины с помощью Docker-контейнера плагина Fluent Bit",
  "chapters": [
    {
      "name": "Передача логов с виртуальной машины с помощью Docker-контейнера плагина Fluent Bit",
      "content": "Практические руководства Evolution    \n\n # Передача логов с виртуальной машины с помощью Docker-контейнера плагина Fluent Bit   Эта статья полезна?          \nПередача логов в сервис «Клиентское логирование» с помощью Docker-контейнера доступна для разных операционных систем.\nВ этой инструкции мы приводим пример настройки отправки логов на созданной виртуальной машине.\n\n## Перед началом работы\n1. Создайте и настройте лог-группу.\n2. Создайте сервисный аккаунт.\nВ блоке Доступы и роли выберите роли:\n- в блоке Проект — «Пользователь сервисов»;\n- в блоке Сервисы — «logaas.writer».\n3. Для сервисного аккаунта создайте ключи доступа.\n4. Создайте виртуальную машину Ubuntu 22.04.\n5. Подключитесь к созданной виртуальной машине по SSH.\n\n## Шаг 1. Установка Docker\n1. Установите необходимые зависимости:\n```\nsudo apt updatesudo apt install ca-certificates curl gnupg software-properties-common\n```\n2. Установите ключ GPG:\n```\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n```\n3. Добавьте Docker-репозиторий:\n```\necho \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n```\n4. Установите Docker:\n```\nsudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n```\n5. Запустите Docker как службу:\n```\nsudo systemctl enable docker  # Enable auto-start on bootsudo systemctl start docker   # Start Docker immediately\n```\n6. Проверьте, что Docker запущен:\n```\nsudo docker run hello-world\n```\n\nПри проверке появится сообщение c подтверждением успешного запуска.\n\n## Шаг 2. Определение структуры проекта\nДля записи логов через Docker-образ создайте простой проект, который будет включать в себя:\n- генератор логов,\n- настройки программы логирования fluent-bit,\n- файл docker-compose, который все объединит.\nКорневая рабочая директория проекта — /usr/local/bin/myproject:\n```\n.├── app│   ├── Dockerfile│   └── log_generator.py├── docker-compose.yml└── fluent-bit-settings    ├── fluent-bit.conf    ├── logaas.so    ├── parsers.conf    └── plugins.conf\n```\n\n## Шаг 3. Создание приложения — тестового источника логов\n1. Создайте рабочую директорию /usr/local/bin/myproject/app, в которой нужно описать структуру приложения и файлы с настройками:\n```\n.├── app│   ├── Dockerfile│   └── log_generator.py\n```\n2. Создайте скрипт-генератор логов log_generator.py:\n```\nimport randomimport jsonimport socketimport osfrom datetime import datetime, timezoneimport time\nLOG_LEVELS = ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL']MESSAGE_TEMPLATES = [    \"Data received [ID: {id}]\",    \"Processing request from user {user}\",    \"Failed to connect to database {db}\",    \"Connection timeout after {sec} seconds\",    \"File {file} not found\",    \"Authentication failed for {service}\",    \"Received {size} bytes from {ip}\",    \"Task {task} completed in {ms}ms\",    \"Cache miss for key {key}\",    \"Starting backup process {job_id}\"]\n\ndef generate_message():    template = random.choice(MESSAGE_TEMPLATES)    replacements = {        'id': lambda: random.randint(1000, 9999),        'user': lambda: f\"user_{random.randint(100, 999)}\",        'db': lambda: random.choice([\"primary\", \"replica\", \"archive\"]),        'sec': lambda: random.randint(1, 30),        'file': lambda: f\"/var/log/{random.choice(['app', 'system', 'auth'])}.log\",        'service': lambda: random.choice([\"API\", \"SSH\", \"Database\"]),        'size': lambda: random.randint(512, 4096),        'ip': lambda: \".\".join(map(str, [random.randint(1, 255) for _ in range(4)])),        'task': lambda: random.choice([\"cleanup\", \"backup\", \"sync\"]),        'ms': lambda: random.randint(100, 5000),        'key': lambda: hex(random.getrandbits(128))[2:10],        'job_id': lambda: f\"JOB-{random.randint(10000, 99999)}\"    }\n    return template.format(**{k: v() for k, v in replacements.items() if k in template})\n\ndef generate_log():    return {        \"timestamp\": datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),        \"level\": random.choice(LOG_LEVELS),        \"labels\": {            \"app\": \"logger\",            \"host\": socket.gethostname(),            \"pid\": os.getpid(),            \"random\": random.randint(1, 1000)        },        \"message\": generate_message()    }\n\nif __name__ == \"__main__\":    while True:        log_entry = generate_log()        print(json.dumps(log_entry))        time.sleep(random.uniform(0.1, 2.0))\n```\n3. Для запуска этого приложения создайте файл Dockerfile:\n```\nFROM python:3.13-alpineWORKDIR /appCOPY log_generator.py .CMD [\"python\", \"./log_generator.py\"]\n```\n4. Соберите образ:\n```\nsudo docker build -t my-app:1.0 .\n```\n5. Запустите контейнер на основе собранного образа:\n```\nsudo docker run -d --name my_running_app1 my-app:1.0\n```\n\nБудет выдан ID запущенного контейнера — например, 41f8a276da1dc3b6f03bd98f55e13786c33937a453c40a07701c94fd10d0433b.\nПо этому ID вы сможете посмотреть логи.\n6. Запросите логи одним из способов:\n- по имени контейнера:\n```\nsudo docker logs -f my_running_app1\n```\n- по ID контейнера:\n```\nsudo docker logs -f 41f8a276da1dc3b6f03bd98f55e13786c33937a453c40a07701c94fd10d0433b\n```\nЧтобы остановить запущенный контейнер:\n1. Выведите список контейнеров:\n```\nsudo docker ps\n```\n\nСписок запущенных контейнеров отображается в виде:\n```\nCONTAINER ID   IMAGE        COMMAND                  CREATED         STATUS         PORTS     NAMESe75bb4ff0ca0   my-app:1.0   \"python ./log_genera…\"   5 seconds ago   Up 5 seconds             my_running_app1\n```\n2. Остановите запущенный контейнер одним из способов:\n- по имени контейнера:\n```\nsudo docker stop my_running_app1\n```\n- по ID контейнера:\n```\nsudo docker stop e75bb4ff0ca0\n```\nЗапущенный контейнер можно удалить по его ID:\n```\nsudo docker rm e75bb4ff0ca0\n```\n\n## Шаг 4. Настройка Fluent Bit для передачи логов\nСодержимое директории с настройками fluent-bit будет иметь следующий вид:\n```\n└── fluent-bit-settings    ├── fluent-bit.conf     - файл с общими настройками    ├── logaas.so           - бинарная библиотека для записи логов в сервис \"Клиентское логирование\"    ├── parsers.conf        - файл с настройками парсеров    └── plugins.conf        - пути к используемым плагинам\n```\n\n1. Создайте директорию /usr/local/bin/myproject/fluent-bit-settings:\n```\nsudo mkdir /usr/local/bin/myproject/fluent-bit-settings\n```\n2. Скачайте плагин logaas.so, который вместе с fluent-bit будет отвечать за отправку логов в сервис «Клиентское логирование»:\n```\nsudo wget https://github.com/CLOUDdotRu/fluent-bit-plugins/raw/main/logaas.so -O /usr/local/bin/myproject/fluent-bit-settings/logaas.so\n```\n3. Создайте файлы настроек:\n```\nsudo touch /usr/local/bin/myproject/fluent-bit-settings/{fluent-bit,parsers,plugins}.conf\n```\n4. Откройте файл с настройками плагинов plugins.conf с помощью редактора nano:\n```\nsudo nano /usr/local/bin/myproject/fluent-bit-settings/plugins.conf\n```\n\nВ файл добавьте путь до плагина logaas.so:\n```\n[PLUGINS]      Path /etc/fluent-bit/logaas.so\n```\n5. Откройте файл fluent-bit.conf:\n```\nsudo nano /usr/local/bin/myproject/fluent-bit-settings/fluent-bit.conf\n```\n\nДобавьте в него данные в виде:\n```\n[SERVICE]    Daemon Off    Flush 1    Log_Level info    Plugins_File plugins.conf    Parsers_File parsers.conf\n[INPUT]    Name tail    Path <path-to-log/logfile.log>    Parser docker\n[OUTPUT]    Name                    logaas    Match                   *    address                 https://console.cloud.ru/    iam_address             https://auth.iam.sbercloud.ru/    iam_client_id           REPLACE_TO_LOGGING_SA_KEY_ID    iam_client_secret       REPLACE_TO_LOGGING_SA_SECRET    default_project_id      REPLACE_TO_PROJECT_ID    default_group_id        REPLACE_TO_LOG_GROUP_ID    default_labels          {\"some_label\":\"default_value\"}\n```\n\nСекция [INPUT] указывает на источник логов, а [OUTPUT] — на сервис, в который отправятся логи.\nВ режиме tail сбор логов в fluent-bit работает по принципу отслеживания новых записей в логах.\nПри перезапуске сервиса данные, обработанные ранее, не отправляются в систему повторно.\nИзмените файл, подставив в него свои данные:\n\n- <path-to-log/logfile.log> — путь к файлу-источнику логов: fluent-bit будет сканировать этот файл и отслеживать в нем новые строки.\n- REPLACE_TO_LOGGING_SA_KEY_ID и REPLACE_TO_LOGGING_SA_SECRET — Key ID (логин) и Key Secret (пароль) сервисного аккаунта с ролью «logaas.writer» для получения токена и отправки логов.\nПроверьте, что у вас есть доступ к проекту, а для вашего сервисного аккаунта выбраны проект «Пользователь сервисов» и роль «logaas.writer».\n- REPLACE_TO_PROJECT_ID и REPLACE_TO_LOG_GROUP_ID — ID проекта и ID лог-группы, в которую будут отправлены логи.\n- default_labels — необязательный раздел. В нем вы можете указать метки, которые будут добавлены ко всем логам.\n\nПример для настройки отправки логов, собираемых из приложения — тестового источника логов:\n```\n[SERVICE]    Daemon Off    Flush 1    Log_Level info    Plugins_File plugins.conf    Parsers_File parsers.conf\n[INPUT]    Name tail    Path /var/log/myapp.log    Parser docker\n[OUTPUT]    Name                    logaas    Match                   *    address                 https://console.cloud.ru/    iam_address             https://auth.iam.sbercloud.ru/    iam_client_id           30dce000000000000000000000f6b8e0    iam_client_secret       18a4f000000000000000000000098414    default_project_id      00000000-1111-2222-3333-444444444444    default_group_id        aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee    default_labels          {\"source\":\"docker-image\", \"logger\":\"fluentbit\"}\n```\n6. Откройте файл parsers.conf:\n```\nsudo nano /usr/local/bin/myproject/fluent-bit-settings/parsers.conf\n```\n\nДобавьте в файл данные:\n```\n[PARSER]    Name         docker    Format       json    Time_Key     time    Time_Format  %Y-%m-%dT%H:%M:%S.%L    Time_Keep    On    Time_System_Timezone true\n```\n\n## Шаг 5. Создание файла Doсker Compose\n1. Создайте файл docker-compose.yml в корне проекта:\n```\n.├── app│   ├── Dockerfile│   └── log_generator.py├── docker-compose.yml└── fluent-bit-settings    ├── fluent-bit.conf    ├── logaas.so    ├── parsers.conf    └── plugins.conf\n```\n\nФайл docker-compose.yml — это YAML-файл, в котором описываются сервисы, сети, тома и настройки для запуска многоконтейнерного приложения через Docker.\nОн позволяет управлять всеми компонентами приложения одной командой (docker compose up), автоматизируя развертывание и связывание контейнеров.\n2. Добавьте в файл docker-compose.yml данные в виде:\n```\nversion: '3.8'\nservices:        app:          build:                  context: ./app                  dockerfile: Dockerfile          volumes:                  - logs:/var/log          entrypoint: sh -c \"python log_generator.py > /var/log/myapp.log 2>&1\"\n  fluent-bit:          image: fluent/fluent-bit          volumes:                  - logs:/var/log                  - ./fluent-bit-settings/:/etc/fluent-bit/          command: [ \"fluent-bit\", \"-c\", \"/etc/fluent-bit/fluent-bit.conf\",  \"-e\", \"/etc/fluent-bit/logaas-client.so\" ]\nvolumes:        logs:\n```\n\nВ docker-compose.yml мы используем готовый образ fluent/fluent-bit.\nПо желанию вы можете использовать свой образ с настроенным fluent-bit.\nУстановка модуля fluent-bit в систему не требуется.\n3. Запустите полученный Doсker Compose.\nЧтобы запустить его в фоновом режиме, добавьте к команде флаг -d:\n```\nsudo docker compose up -d\n```\n\nDocker загрузит недостающие образы и запустит контейнеры:\n```\n[+] Running 2/2 ✔ Container myproject-fluent-bit-1  Started                                                                                              0.5s ✔ Container myproject-app-1         Start\n```\n4. Если запущенные контейнеры больше не нужны, остановите их:\n```\nsudo docker compose stop\n```\n5. Удалите неиспользованные контейнеры:\n```\nsudo docker compose down\n```\n\nDocker удалит неиспользованные контейнеры:\n```\n[+] Running 3/3 ✔ Container myproject-app-1         Removed                                                                                             10.3s ✔ Container myproject-fluent-bit-1  Removed                                                                                              0.5s ✔ Network myproject_default         Removed\n```\n6. Кроме контейнеров и сетей вы можете удалить volumes:\n```\nsudo docker compose down -v\n```\n\n## Шаг 6. Просмотр логов\nВ случае успешного старта Docker-образов логи появятся в сервисе «Клиентское логирование» вскоре после старта приложения.\nВы можете посмотреть логи в лог-группах.\nЛоги можно отфильтровать с помощью языка фильтрующих выражений и выгрузить как файл.\nВ режиме tail сбор логов в fluent-bit работает по принципу отслеживания новых записей в логах.\nПри перезапуске сервиса данные, обработанные ранее, не отправляются в систему повторно.\nЧтобы данные непрерывно поступали в сервис, выберите подходящий сценарий:\n\n- запустите генератор логов в бесконечном цикле, чтобы поддерживать постоянное поступление данных;\n- выполняйте генерацию логов пакетами — запускайте скрипт многократно с необходимым интервалом.\n\nЭто позволяет исключить дублирование записей и поддерживать актуальность передаваемых данных.\nДополнительно рекомендуется настроить ротацию логов, чтобы избежать переполнения диска при длительной работе.\n\n## После окончания работы\nЕсли виртуальная машина и ее логи стали неактуальными, вы можете удалить их:\n- Удалить лог-группу\n- Удалить проект\n- Удалить виртуальную машину\n\n  [© 2025 Cloud.ru](https://cloud.ru)",
      "debug": {
        "start_page": 1,
        "end_page": 1
      }
    }
  ]
}