{
  "title": "Вайб-кодинг с помощью Foundation Models и подключение MCP-сервера для деплоя приложения в Container Apps",
  "chapters": [
    {
      "name": "Вайб-кодинг с помощью Foundation Models и подключение MCP-сервера для деплоя приложения в Container Apps",
      "content": "Практические руководства Evolution    \n\n # Вайб-кодинг с помощью Foundation Models и подключение MCP-сервера для деплоя приложения в Container Apps   Эта статья полезна?          \nС помощью этого руководства вы научитесь:\n- вайб-кодить бэкенд-приложение на Python (фреймворк Django) с использованием VS Code и Foundation Models;\n- создавать фронтенд с помощью готовых промптов к Foundation Models в VS Code;\n- подключать кастомный AI-агент для работы с MCP-сервером в VS Code;\n- автоматизировать деплой приложения в Container Apps, используя промпты к MCP-серверу.\nВы будете использовать набор готовых промптов для всех шагов создания и деплоя приложения.\nНа примере этих промптов вы сможете не только с нуля создать работающее приложение и разместить его в Container Apps, но и полностью автоматизировать процесс обновления и публикации новой версии приложения.\nВы будете использовать следующие сервисы:\n- Artifact Registry для хранения, совместного использования и управления Docker-образами и Helm-чартами.\n- Container Apps — сервис для запуска контейнерных приложений в облаке. Не требует знания Kubernetes и создания виртуальных машин.\n- Object Storage — объектное S3-хранилище с бесплатным хранением файлов, объемом до 15 ГБ.\n- Foundation Models — сервис для доступа к API популярных фундаментальных моделей машинного обучения с открытым исходным кодом.\n- Систему контроля версий GitVerse.\n- VS Code — редактор кода, который поддерживает множество языков программирования, включая Python, Java, C++, JavaScript и многие другие.\n- Roo Code или Kilo Code — плагин для анализа, написания, рефакторинга и отладки кода.\nПоддерживает различные API и локальные модели.\nПозволяет создавать собственных AI-ассистентов для определенных задач и ролей, переключать режимы и настраивать промпты.\nШаги:\n1. Подготовьте среду.\n2. Подготовьте окружение и создайте приложение для основных настроек Django и для работы с моделями с помощью промпта.\n3. Создайте модель RecordEntry и зарегистрируйте ее в Django-админке с помощью промпта.\n4. Создайте пользователя admin с помощью промпта.\n5. Сохраните версии Python-библиотек в requirements и создайте документацию по проекту c помощью промпта.\n6. Проверьте работоспособность Django-приложения.\n7. Создайте фронтенд-приложение с помощью промпта.\n8. Проверьте работоспособность фронтенд-приложения.\n9. Заполните админку записями с помощью промпта.\n10. Создайте Docker-файл с помощью промпта.\n11. Зарегистрируйте MCP-сервер в плагине для передачи промптов в Container Apps и Artifact Registry.\n12. Выполните деплой приложения с помощью промпта.\n13. Проверьте работоспособность приложения в Container Apps.\n14. Создайте бакеты в Object Storage для хранения данных.\n15. (Опционально) Синхронизируйте файлы из БД с папкой, смонтированной для контейнера, с помощью промпта.\n\n## Перед началом работы\nЗарегистрируйтесь в личном кабинете Cloud.ru.\nЕсли вы уже зарегистрированы, войдите под своей учетной записью.\n\n## 1. Подготовьте среду\n1. Убедитесь, что у вас есть доступ к Foundation Models.\n2. Убедитесь, что баланс в личном кабинете положительный.\nЕсли он нулевой или отрицательный — пополните баланс.\nНебольшое количество запросов в Foundation Models будет стоить не больше рубля, подробнее — .\n3. Подключите Foundation Models в VS Code.\nИспользуйте следующие параметры:\n- При создании сервисного аккаунта  выберите роль внутри проекта — «Администратор пользователей» для создания контейнеров Container Apps от лица этого сервисного аккаунта в дальнейшем.\n- При создании API-ключа укажите в поле Сервисы значение Foundation Models.\n- В поле Модель в плагине VS Code выберите одну из следующих моделей:\n- zai-org/GLM-4.6\n- Qwen/Qwen3-Coder-480B-A35B-Instruct\n- openai/gpt-oss-120b\n\nДля решения задач этого руководства рекомендуется использовать модель zai-org/GLM-4.6.\n\nЧтобы увидеть полное описание моделей и стоимость токенов:\n1. Перейдите в личный кабинет.\n2. Перейдите в раздел AI Factory –> Foundation Models.\n3. В разделе Модели найдите описание, параметры и стоимость токенов для нужной модели.\nВы можете использовать бесплатные модели, доступные в режиме Public Preview.\n\n## 2. Подготовьте окружение и создайте приложения с помощью промпта\nПримечание Если вы хотите не писать Django-приложение с нуля, обращаясь к AI-модели с помощью промптов, а попробовать развернуть уже готовое приложение из репозитория GitVerse, перейдите к практическому руководству по развертыванию django-приложения.\nВ этом проекте используются:\n\n- Django 5.2.7\n- Python 3.13\n- База данных SQL Lite\n\nВнимание Пример с использованием SQLite предназначен исключительно для демонстрационных целей и быстрого запуска приложения.Для production-среды настоятельно рекомендуется использовать полноценную СУБД, например PostgreSQL — она обеспечит надежность, масштабируемость и поддержку конкурентного доступа.\nС помощью промптов создается приложение для добавления рекордов (как в «Книге рекордов Гиннеса»). В приложении должна быть возможность модерировать рекорды (подтверждать добавленную запись) в административной панели. В приложении должны храниться изображения с текстом описания.\nФронтенд приложения должен быть опубликован в сети с фиксированным адресом и заданным дизайном.\nЧтобы создать проект и приложения с помощью выбранной модели ИИ, используйте промпт:\n```\nСоздай проект под названием «Рекордасьон» (по-английски — Recordacion) с использованием следующих технологий:- Django 5.2.7- Python 3.13- База данных: SQLite\nСоздай новое виртуальное окружение и размести его в папке .venv\nВнутри проекта создай два приложения:\n  - recordacion — для основных настроек Django (settings, urls и т.д.) создан через startproject;  - records — для работы с моделями создан через startapp.\nФункционал: Любой пользователь может добавить свой рекорд и просматривать рекорды других.В приложении records создай модель RecordEntry со следующими полями:\n  - название  - описание  - картинка для preview  - картинки (картинок может быть несколько, должна быть связь ManyToMany)  - поля \"Дата создания\" и \"Дата обновления\" (должны заполняться автоматически)  - модель принята администратором или нет, поле is_approved  - связь с тем, кто принял рекорд approved_by на django user\n```\n\nВ процессе создания приложения AI-модель предлагает использовать стандартные команды фреймворка Django.\nAI-модель периодически запрашивает подтверждение действий.\n\nПосле завершения работы AI-модели в папке проекта появляются папки:\n\n- ./recordacion — для хранения основных настроек Django (settings, urls).\n- ../records — для хранения модели рекорда.\n\nВнимание Чтобы ускорить работу AI-модели по созданию окружения, рекомендуется добавить все промпты из Шагов 2–5 в виде сплошного текста.\nПромпт целиком для создания проекта, окружения, приложения Django, модели и базы данных (Шаги 2–5):\n```\n### Создай проект под названием «Рекордасьон»(по-английски — Recordacion) с использованием следующих технологий:- Django 5.2.7- Python 3.13- База данных: SQLite\n1. Создай новое виртуальное окружение и размести его в папке .venv2. Внутри проекта создай два приложения:    recordacion — для основных настроек Django (settings, urls и т.д.) создан через startproject;    records — для работы с моделями создан через startapp.    Функционал:    Любой пользователь может добавить свой рекорд и просматривать рекорды других.    В приложении records создай модель RecordEntry со следующими полями:    - название    - описание    - картинка для preview    - картинки (картинок может быть несколько, должна быть связь ManyToMany)    - поля дата создания и дата обновления (должны заполняться автоматически)    - модель принята администратором или нет is_approved    - связь с тем кто принял рекорд approved_by на django user3. Зарегистрируй модель RecordEntry в админке Django, чтобы можно было управлять записями через интерфейс администратора.4. Добавь кастомную Django-команду create_admin_user, которая создаёт суперпользователя с логином admin и паролем admin. Если такой пользователь уже существует — команда должна пропустить создание.5. Версии Python библиотек сохрани в requirements.txt.6. Создай файл README.md с кратким описанием проекта и пошаговой инструкцией по его запуску (включая активацию виртуального окружения, миграции и запуск сервера).\n```\n\nПри использовании промпта целиком после того, как AI-модель закончит работу, перейдите к проверке работоспособности Django-приложения.\n\n## 3. Создайте модель RecordEntry и зарегистрируйте ее в Django-админке с помощью промпта\nИспользуйте промпт:\n```\nЗарегистрируй модель RecordEntry в админке Django, чтобы можно было управлять записями через интерфейс администратора.\n```\n\nAI-модель добавила в ../records/models.py модель с заданными параметрами.\nAI-модель добавила в настройки admin.py новую модель для работы с приложением.\nТакже AI-модель самостоятельно накатила миграции для работы с Django и создала базу данных db.sqlite3.\n\n## 4. Создайте пользователя admin с помощью промпта\nИспользуйте промпт:\n```\nДобавь кастомную Django-команду create_admin_user, которая создаёт суперпользователя с логином admin и паролем admin.Если такой пользователь уже существует, команда должна пропустить создание.\n```\n\nAI-модель запускает команду create-admin-user.\n\n## 5. Сохраните версии Python-библиотек и создайте документацию по проекту c помощью промпта\nВ процессе разработки AI-модель самостоятельно загружает недостающие библиотеки Python.\nНа этом шаге попросите модель сохранить версии скачанных библиотек в отдельном файле requirements.txt.\nИспользуйте промпт:\n```\nВерсии Python библиотек сохрани в requirements.txt\n```\n\nПопросите модель создать инструкцию по работе с проектом.\nИспользуйте промпт:\n```\nСоздай файл README.md с кратким описанием проекта и пошаговой инструкцией по его запуску (включая активацию виртуального окружения, миграции и запуск сервера).\n```\n\nAI-модель создает файлы requirements.txt и README.md в корне проекта.\n\n## 6. Проверьте работоспособность Django-приложения\nДля запуска и проверки работоспособности приложения воспользуйтесь автоматически созданной инструкцией в файле README.md в корне проекта.\n1. Запустите сервер с помощью команды:\n```\npython manage.py runserver\n```\n2. Используйте адрес 127.0.0.1:8000/admin для проверки работоспособности приложения.\nОтобразится окно входа в панель администратора.\n\n## 7. Создайте фронтенд-приложение с помощью промпта\nСоздайте фронтенд-приложение с заданным дизайном для просмотра добавленных рекордов, добавления рекордов и просмотра отдельного рекорда.\nИспользуйте новое контекстное окно модели.\nИспользуйте промпт:\n```\n### Реализуй три страницы в records.views\n1. Главная страница Маршрут: GET /\nОтображает только одобренные (is_approved=True) пользовательские рекорды.Рекорды упорядочены по возрастанию даты создания — самый новый должен находиться в начале списка.Для каждого рекорда показывай:- Название- Картинку из Preview (если есть)- Дату создания Рекорды отображай по 3 на одной строчке.\nДобавь фильтр:- по названию- выбор сортировки по дате- добавь пагинацию по 10 рекордов- кнопку сброса фильтрафии\n\n2. Страница добавления рекорда Маршрут: GET /records и POST /records\nФорма для создания нового RecordEntry с полями:- Название- Описание- Картинка для preview- Несколько картинок для поста После успешной отправки формы отобрази сообщение:«Ваш рекорд успешно добавлен и будет рассмотрен администратором в ближайшее время.»Не перенаправляй пользователя — просто покажи это сообщение на той же странице.\n3. Страница отдельного рекорда Маршрут: GET /records/<record_id>\nОтображает все данные конкретного рекорда:- Название- Описание- Все прикрепленные изображения (без изображения с preview)- Дату создания\nТребования к оформлению всех страниц:Используй наследование шаблонов (base.html → дочерние шаблоны).Все стили должны находиться в одном CSS-файле (например, static/css/style.css).\nИспользуй формулу цветов:60% основной цвет, 30% акцентный цвет, 10% яркий цвет Цветовая палитра:Основной акцент - персик/терракота #FFF9F5Фон - очень светлый кремовый #4B3F72Текст - мягкий тёмно-фиолетовый #FF6F61Дополнительно (для UI-состояний):Hover на кнопке: #FF5C4D (чуть темнее акцента)Disabled-состояние: #E0D9D0 (светло-бежевый, на фоне кремового)Тени / разделители: rgba(75, 63, 114, 0.1) — полупрозрачный оттенок основного текстового цвета Кнопки должны быть одинаковыми по высоте.Стиль должен быть чистым, современным и напоминать немного сайт Книги рекордов Гиннеса.\n```\n\nAI-модель самостоятельно находит модель данных в проекте и создает HTML-страницы.\nAI-модель периодически запрашивает подтверждение действий. Модель самостоятельно тестирует полученный код и решает проблемы, например, отсутствие таблицы стилей CSS.\nЗаписи добавлены в файл ../records/views.py.\n\n## 8. Проверьте работоспособность фронтенд-приложения\n1. Используйте адрес localhost:8000 для проверки работоспособности приложения.\nОтобразится домашняя страница со строкой поиска рекордов и кнопкой Добавить рекорд.\n2. Добавьте запись о рекорде через сайт.\n3. Перейдите по адресу 127.0.0.1:8000/admin, войдите с логином и паролем admin/admin и подтвердите добавленную запись.\n4. Проверьте по адресу localhost:8000, что запись отобразилась в списке рекордов.\n\n## 9. Заполните админку записями с помощью промпта\n1. Скопируйте в репозиторий с проектом папку init-data.\nИспользуйте новое контекстное окно модели.\n2. Используйте промпт:\n```\nЗаполни рекорды (EntryRecords)\nСоздай django manage.py команду fill_records, которая добавит первые записи Используя данные из prompts/init-data/data.json Если рекорд с таким именем уже существует, его можно пропустить.\n```\n3. Запустите итоговую команду.\n4. Откройте адрес localhost:8000 и проверьте, что рекорды отображаются.\n5. При ошибках, например, если не отображаются изображения, в том же контекстном окне AI-модель введите промпт:\n```\nНе работает отображение картинок, поправь\n```\n6. После отработки команды повторно откройте адрес localhost:8000 и проверьте, что рекорды отображаются корректно.\n\n## 10. Создайте Docker-файл с приложением с помощью промпта\nВ промпте предусмотрены параметры для деплоя проекта в Container Apps, в том числе:\n\n- .dockerignore — чтобы исключить из сборки статичные папки для хранения данных.\n- Переменные окружения: ALLOWED_HOSTS, CONTAINER_APP_NAME (заполняется сервисом Container Apps), CSRF_TRUSTED_ORIGINS (необходимо для отправки формы).\n- FILE_UPLOAD_PERMISSIONS — настройка, необходимая для подключения в дальнейшем Object Storage.\n- Непривилегированный пользователь с UID 1000 для работы в непривилегированном режиме. По умолчанию контейнеры в Container Apps запускаются от имени пользователя с идентификатором (UID) 1000.\n- Точка входа, в которой указаны команды при запуске контейнера.\n\nИспользуйте промпт:\n\n```\n### Создай Docker-образна основе официального образа python:3.13.9-bookworm (Debian Bookworm) со следующими требованиями:\n1. Зависимости и игнорирование файлов Добавь файл requirements.txt с необходимыми Python-зависимостями (включая Django 5.2.7).Создай файл .dockerignore и исключи из сборки:```db/media/staticfiles/.venv/```\n2. Расположение базы данных Настрой проект так, чтобы файл SQLite (db.sqlite3) сохранялся в папке ./db (в корне проекта).Обнови settings.py, указав путь к базе данных:DATABASES = {    'default': {        'ENGINE': 'django.db.backends.sqlite3',        'NAME': BASE_DIR / 'db' / 'db.sqlite3',    }}\n3. Настройки для запуска в Cloud.ru Container Apps Добавь в settings.py следующие параметры:\n```pythonimport os\nCONTAINER_APP_NAME = os.environ.get(\"CONTAINER_NAME\", \"-\")  # будет установлен средой Cloud.ru Container Apps\nALLOWED_HOSTS = [    f'{CONTAINER_APP_NAME}.containerapps.ru',    f'{CONTAINER_APP_NAME}.internal.containers.cloud.ru',    'localhost',    '127.0.0.1',]\nCSRF_TRUSTED_ORIGINS = [    f'https://{CONTAINER_APP_NAME}.containerapps.ru',    f'https://{CONTAINER_APP_NAME}.internal.containers.cloud.ru',]\n# Django пытается изменить права доступа к загруженным файлам — отключаем это поведениеFILE_UPLOAD_PERMISSIONS = None```\n4. Пользователь и права доступаВ Dockerfile создай непривилегированного пользователя с UID 1000.Предоставь этому пользователю права на запись в папки:./db (для базы данных)./media (для загружаемых изображений)\n5. В Dockerfile добавьRUN python manage.py collectstatic --noinputENTRYPOINT entrypoint.shв котором:- запусти миграции- запусти django команду для создания admin пользователя create_admin_user- запусти django команду fill_recordsCMD добавь запуск runserver\n6. Добавь в Readme.md способ запуска приложения через Docker\n```\n\nВ корне проекта создан образ Dockerfile.\nНа следующих шагах добавьте в плагин MCP-сервер и задеплойте приложение с помощью промптов.\n\n## 11. Зарегистрируйте в плагине MCP-сервер для передачи промптов в Container Apps и Artifact Registry\nИспользуйте кастомный AI-агент для взаимодействия с MCP-сервером.\nMCP-сервер работает совместно с VSCode-плагинами, например Kilo Code, Roo Code, Claude, и использует MCP-протокол для обращения к внешним системам (Container Apps и Artifact Registry).\n1. Перед началом работы с AI-агентом для взаимодействия с MCP-сервером установите последнюю версию Golang с официального сайта.\n2. Выполните команду по установке AI-агента по работе с MCP-сервером:\n```\ngo install github.com/Nick1994209/cloudru-containerapps-mcp/cmd/cloudru-containerapps-mcp@latest\n```\n3. Перейдите в сервисный аккаунт, созданный на этапе подготовки среды.\n4. Перейдите в раздел Ключи доступа.\n5. Нажмите Создать ключ.\n6. Скопируйте в надежное место KeyID (логин) и Key Secret (пароль).\n7. Скопируйте значения KeyID (логин) и Key Secret (пароль), а также project ID своего проекта в json-файл.\nВы можете узнать projectId своего проекта, открыв cloud.console.ru:\n```\nhttps://console.cloud.ru/spa/svp?customerId=&projectId=<***********>\n```\n\nИспользуйте следующий JSON-файл, дополнив своими значениями:\n```\n{  \"mcpServers\": {    \"cloudru-containerapps-mcp\": {      \"command\": \"cloudru-containerapps-mcp\",      \"args\": [],      \"env\": {        \"CLOUDRU_KEY_ID\": \"********\",        \"CLOUDRU_KEY_SECRET\": \"********\",        \"CLOUDRU_PROJECT_ID\": \"********\",      },      \"alwaysAllow\": [        \"cloudru_containerapps_description\",        \"cloudru_get_containerapp\",        \"cloudru_get_list_containerapps\",        \"cloudru_start_containerapp\",        \"cloudru_get_list_docker_registries\"      ],      \"timeout\": 900,      \"disabledTools\": []    }  }}\n```\n8. В плагине, который вы добавили в VS Code на этапе подготовки среды, перейдите в раздел MCP Servers и добавьте json-файл по кнопке Edit Global MCP.\n\nВ разделе MCP Servers отобразится добавленный MCP-агент и набор команд.\n9. Запустите AI-агент:\n```\ncloudru-containerapps-mcp\n```\n\n## 12. Выполните деплой приложения с помощью промпта\nНа этом шаге выполняется создание реестра в Artifact Registry, сборка и отправка в созданный реестр Docker-образа приложения и создание контейнерного приложения в Container Apps на основе Docker-образа.\nMCP-сервер обращается к Public API Artifact Registry и Public API Container Apps для выполнения команд.\n1. Последовательно выполните промпты, заменив название реестра на свое значение:\n```\n### Деплой приложения в Cloud.ru Evolution Container Apps\nВыполни MCP команду и создай в Cloud.ru реестр, где будет храниться Docker image с приложением recordacionреестр называется = <ваше_название_реестра>\n```\n\n```\nСделай docker build and push в Cloud.ru Artifact Registry используяназвание реестра = <ваше_название_реестра>название репозитория = recordacionназвание тэга = v0.0.1\n```\n\nУбедитесь, что в личном кабинете в сервисе Artifact Registry отображается реестр с указанным именем и в нем содержится репозиторий recordacion.\n2. Выполните промпт для создания контейнерного приложения:\n```\nСоздай ContainerApps используяназвание контейнер аппа = recordacionдокер образ возьми из предыдущего шагавключи автодеплой, тэг паттерн \"*\"установи время простоя в 30 минутвключи автодеплой, тэг паттерн \"*\"cpu = 0.5\n```\n\nЕсли название recordacion уже занято, укажите ваше название.\nУбедитесь, что в личном кабинете в сервисе Container Apps отображается контейнерное приложение <ваше_название_контейнерного_приложения> и статус ревизии изменился на «Выполняется».\n3. Не меняя контекстное окно, используйте промпт:\n```\nПолучи публичный адрес приложения\n```\n\n```\nПолучи логи приложения\n```\n\nЕсли команда не вернула логи или публичный URL-адрес приложения, попробуйте ещё раз спустя 10–15 секунд.\nТак как включена опция Автоматическое развертывание, при каждой загрузке в Artifact Registry новой версии образа (например, с помощью промпта) на стороне Container Apps будет автоматически создаваться новая ревизия контейнера на базе обновленной версии образа.\n\n## 13. Проверьте работоспособность приложения в Container Apps\nВставьте публичный адрес контейнерного приложения в адресную строку браузера.\nОткроется страница приложения.\n\nВаше приложение запущено и работает. Но оно может потерять недавно добавленные рекорды при развертывании новой версии приложения или при масштабировании до нуля.\nНа следующем шаге подключите постоянное хранилище для базы данных и медиафайлов.\n\n## 14. Создайте бакеты в Object Storage для хранения данных\n1. Создайте бакеты в Object Storage, как описано в Шаге 7 практического руководства по развертыванию django-приложения.\nИспользуйте следующие пути для монтирования\n- /app/db — для тома базы данных;\n- /app/media — для тома загружаемых изображений.\n2. Примонтируйте созданные бакеты, как указано в Шаге 8 практического руководства по развертыванию django-приложения.\n\nТеперь при каждом новом деплое Django-приложения данные не будут теряться, сохраняясь в постоянных томах Object Storage.\nПримечание Монтирование папки с базой данных SQLite уместно только в демонстрационных или тестовых целях. Если вы не планируете в ближайшее время переходить на другую СУБД и ожидаете, что у вашего приложения будет много пользователей, рекомендуется выполнить следующий шаг.\n\n## 15. (Опционально) Синхронизируйте файлы из БД с папкой, смонтированной для контейнера, с помощью промпта\nЕсли вы планируете продолжать использовать SQL Lite, с помощью этого скрипта синхронизируйте файлы базы данных SQL Lite с папкой, примонтированной для контейнера Object Storage.\nПри запуске приложения этот скрипт будет скачивать БД из смонтированной папки во временную, а затем синхронизировать содержимое временной БД с постоянной примонтированной.\n1. Используйте промпт:\n```\n### Добавь синхронизацию db файлов из одной папки в другую\n1. добавь скрипт background-sync-folders.sh```bash#!/bin/bash\n# === Проверка аргументов ===if [ \"$#\" -ne 2 ]; then    echo \"Передан только 1 или меньше аргументов, скрипт не будет синхронизировать данные\"    echo \"Использование: $0 <SOURCE_DIR> <TARGET_DIR>\"    exit 0fi\nSOURCE_DIR=\"$1\"TARGET_DIR=\"$2\"\n# === Вспомогательная функция: есть ли обычные файлы в директории? ===has_files() {    local dir=\"$1\"    [ -d \"$dir\" ] || return 1    for f in \"$dir\"/*; do        [ -e \"$f\" ] && [ -f \"$f\" ] && return 0    done    return 1}\n# === Функция однократной синхронизации: SOURCE → TARGET ===sync_once() {    local src=\"$1\"    local tgt=\"$2\"    for f in \"$src\"/*; do        [ -e \"$f\" ] || continue        if [ -f \"$f\" ]; then            cp \"$f\" \"$tgt/\"        fi    done}\n# === Инициализация ===mkdir -p \"$SOURCE_DIR\" \"$TARGET_DIR\"\nif ! has_files \"$SOURCE_DIR\"; then    if has_files \"$TARGET_DIR\"; then        echo \"SOURCE_DIR=$SOURCE_DIR пуста — копирую из TARGET_DIR=$TARGET_DIR...\"        sync_once \"$TARGET_DIR\" \"$SOURCE_DIR\"        echo \"Данные в SOURCE_DIR=$SOURCE_DIR восстановлены.\"    else        echo \"Обе директории пусты.\"    fielse    echo \"SOURCE_DIR=$SOURCE_DIR содержит данные — используем как источник.\"fi\n# === Запуск бесконечной синхронизации в фоне ===(    while true; do        sync_once \"$SOURCE_DIR\" \"$TARGET_DIR\"        sleep 5    done) &\necho \"Скрипт завершил инициализацию. Синхронизация запущена в фоновом режиме: файлы копируются каждые 5 секунд из SOURCE_DIR=$SOURCE_DIR в TARGET_DIR=$TARGET_DIR.\"```Добавьте этот скрипт в ./entrypoint.sh и запустите его до выполнения миграций: `./entrypoint.sh /app/db \"$MOUNTED_DB_FOLDER\"`\nТакже включите в ./entrypoint.sh проверку: если директория /app/db/ пуста или не содержит файлов, автоматически выполните следующие Django-команды:- migrate- create_admin_user- fill_records\nПосле создания скрипта background-sync-folders.sh и правок в ./entrypoint.sh Выполни docker build and push в Cloud.ru Artifact Registry используяназвание реестра = <ваше_название_реестра>название репозитория = recordacionназвание тэга = v0.0.2\n```\n\nГде <ваше_название_реестра> — название реестра, заданное на Шаге 12.\n2. Создайте новую ревизию контейнера, изменив следующие параметры:\n- добавьте переменную MOUNTED_DB_FOLDER=/synced/db;\n- в подключенном бакете замените путь до бакета с базой данных с /app/db на /synced/db.\n\n## Результат\nВы научились:\n- подключать MCP-сервер для автоматизации сборки и публикации Docker-образа приложения в Artifact Registry\n- с помощью AI-агента обращаться к MCP-серверу, чтобы деплоить контейнерное приложение в Container Apps одной командой;\n- добавлять постоянный том Object Storage, который позволяет сохранить ваши данные, когда запросы к приложению не поступают;\n- синхронизировать временную базу данных с томом Object Storage при работе контейнерного приложения.\nСмотрите обучающее видео по вайб-кодингу с помощью Foundation Models и деплою приложения в Container Apps и узнайте о том, как автоматизировать деплой приложения с помощью MCP-сервера.\n\n  [© 2025 Cloud.ru](https://cloud.ru)",
      "debug": {
        "start_page": 1,
        "end_page": 1
      }
    }
  ]
}