{
  "title": "Решение задач с помощью квантового симулятора",
  "chapters": [
    {
      "name": "Решение задач с помощью квантового симулятора",
      "content": "Практические руководства Evolution    \n\n # Решение задач с помощью квантового симулятора   Эта статья полезна?          \nС помощью этого руководства вы научитесь решать задачу с применением алгоритма имитации отжига, получите результаты решений и интерпретируете их.\nДля решения используется образ виртуальной машины «Квантовый симулятор» на мощностях CPU и предустановленный в образе сэмплер D-Wave.\n«Квантовый симулятор» — это усовершенствованная реализация алгоритма имитации отжига.\nСимулятор предназначен для решения задач в постановке матрицы Quadratic Unconstrained Binary Optimization (QUBO).\nС его помощью вы можете решать сложные оптимизационные задачи, например: оптимизировать маршруты, логистические процессы, энергопотребление, планирование производственных процессов.\nВы будете использовать следующие сервисы:\n- Виртуальные машины — сервис, в рамках которого предоставляется виртуальная машина для развертывания симулятора.\n- Публичный IP-адрес для доступа к виртуальной машине через интернет.\n- Jupyter Server — серверное приложение, позволяющее запускать командные графические оболочки для интерактивных вычислений Jupyter Notebook и JupyterLab.\nШаги:\n1. Разверните ресурсы в облаке.\n2. Подключитесь к Jupyter Server.\n3. Создайте матрицу.\n4. Запустите сэмплер.\n5. Выберите решение.\n\n## Перед началом работы\n1. Зарегистрируйтесь в личном кабинете Cloud.ru.\nЕсли вы уже зарегистрированы, войдите под своей учетной записью.\n2. Убедитесь, что для вашей учетной записи достаточно прав на проект.\nПри необходимости настройте права или запросите их у администратора.\n3. Запросите в технической поддержке пароль для квантового симулятора.\n\n## 1. Разверните ресурсы в облаке\n1. Создайте виртуальную машину со следующими параметрами:\n- Название — quantum-server.\n- Зона доступности — ru.AZ-1.\n- Образ — на вкладке Маркетплейс выберите «Квантовый симулятор».\n- Гарантированная доля vCPU — 30%.\n- vCPU, шт — 2.\n- RAM, ГБ: — 4.\n- Сетевой интерфейс — выберите тип Подсеть с публичным IP.\n- Публичный IP — оставьте Арендовать новый или выберите IP-адрес из списка арендованных.\n- Имя пользователя — cloud-user.\n- Метод аутентификации — Пароль.\n- Пароль — задайте пароль пользователя.\nНа виртуальной машине будет развернут Jupyter Server для работы с jupyter-ноутбуками.\n2. В строке созданной ВМ скопируйте и сохраните адрес из столбца Публичный IP: он потребуется для дальнейшей настройки.\n3. Добавьте правило входящего трафика в группу безопасности SSH-access_ru.AZ-1:\n Протокол Порт Тип источника ИсточникTCP8888IP-адрес0.0.0.0/0\n\n## 2. Подключитесь к Jupyter Server\nJupyter Server станет доступен через 5–7 минут после запуска виртуальной машины.\n1. В браузере перейдите по адресу https://<public_ip>:8888, где <public_ip> — публичный IP-адрес ВМ quantum-server.\nЕсли появится предупреждение о том, что подключение не защищено, добавьте сертификат сайта в доверенные по инструкции для вашего браузера.\n2. В поле Password введите пароль, полученный в технической поддержке Cloud.ru.\n3. Нажмите Log in.\nОткроется страница с файлами симулятора.\n4. Смените пароль Jupyter Server:\n1. Откройте терминал: на верхней панели нажмите File → New → Terminal.\n2. В терминале введите команду:\n```\njupyter notebook password\n```\n3. Дважды введите новый пароль.\n5. Создайте новый ноутбук:\n1. На верхней панели нажмите File → New → Notebook.\n2. В открывшемся окне выберите ядро Python 3.\n\n## 3. Создайте матрицу\n1. Импортируйте в проект библиотеки.\nВставьте в ячейку ноутбука указанный ниже код и нажмите Shift + Enter.\n```\nimport numpy as npfrom dwave.samplers import SimulatedAnnealingSamplerimport matplotlib.pyplot as plt\n```\n\nГде:\n- numpy — библиотека для работы с массивами данных.\n- dwave.samplers — пакет с сэмплером D-Wave, в котором доступно несколько алгоритмов решения.\n- SimulatedAnnealingSampler — алгоритм имитации отжига из пакета D-Wave.\n- matplotlib — библиотека для визуализации.\n2. Создайте матрицу со случайными значениями:\n```\nN = 10M = 10Q = np.random.uniform(low=-M, high=M, size=(N, N))\n```\n\nГде:\n- N — размер матрицы;\n- M — диапазон значений;\n- Q — объект матрицы.\n3. Чтобы убедиться, что матрица случайная, получите ее изображение:\n```\nplt.matshow(Q)\n```\n\n## 4. Запустите сэмплер\n1. Запустите сэмплер D-Wave:\n```\nsampler = SimulatedAnnealingSampler()\nnum_reads = 10\nnum_sweeps = 10**3\nbeta_range = [0.1, 4.2]\nbeta_schedule_type = 'geometric'\nsample_set = sampler.sample_qubo(Q, num_reads=num_reads, num_sweeps=num_sweeps, beta_range=beta_range, beta_schedule_type=beta_schedule_type)\n```\n\nГде:\n- sampler — объект решателя.\n- num_reads — количество запусков алгоритма.\n- num_sweeps — максимальное количество итераций алгоритма.\n- beta_range — расписание отжига, последовательность обратных температуре величин.\n- beta_schedule_type — тип интерполяции между точками.\n2. Получите результаты:\n```\nprint(sample_set)\n```\n\nВ результате отобразится таблица:\n```\n   0  1  2  3  4  5  6  7  8  9     energy num_oc.0  1  1  1  0  1  0  0  0  0  1 -50.046614       11  1  1  1  0  1  0  0  0  0  1 -50.046614       12  1  1  1  0  1  0  0  0  0  1 -50.046614       13  1  1  1  0  1  0  0  0  0  1 -50.046614       14  1  1  1  0  1  0  0  0  0  1 -50.046614       16  1  1  1  0  1  0  0  0  0  1 -50.046614       18  1  1  1  0  1  0  0  0  0  1 -50.046614       19  1  1  1  0  1  0  0  0  0  1 -50.046614       15  0  1  0  0  1  1  0  0  1  1 -46.860889       17  0  1  0  0  0  1  0  0  1  1 -46.729231       1['BINARY', 10 rows, 10 samples, 10 variables]\n```\n\nГде:\n- Столбцы от 0 до 9 показывают полученные решения.\nКаждое число в строке, 0 или 1, соответствует одной из переменных в векторе решения.\n- Столбец energy показывает значение функции \\(E(x)\\).\nЭто число указывает, насколько эффективно решение с точки зрения достижения минимального значения функции — чем меньше число, тем лучше.\n- Столбец num_oc показывает, сколько раз конкретное решение было найдено.\nКаждая строка в таблице представляет одну попытку решения задачи.\n\n## 5. Выберите решение\nВыберите решение одним из двух методов:\n- Чтобы получить конкретное решение, используйте метод record, отправив команду:\n```\nn = 9E = sample_set.record[n][1]x = sample_set.record[n][0]print(\"Energy is \",E)print(\"Solution is \",x)\n```\n\nГде:\n\n- n — номер решения.\n- E — значение энергии, связанное с решением.\n- x — бинарный вектор, представляющий решение.\n\nВ результате отобразятся значения выбранного решения:\n```\nEnergy is  -50.046614387554584Solution is  [1 1 1 0 1 0 0 0 0 1]\n```\n- Чтобы получить эффективное решение, используйте метод first, отправив команду:\n```\nx = sample_set.first[0]print(\"Energy is \",E)print(\"Solution is \",x)\n```\n\nВ результате отобразятся значения эффективного решения с точки зрения достижения минимального значения функции:\n```\nEnergy is  -50.046614387554584Solution is  {0: 1, 1: 1, 2: 1, 3: 0, 4: 1, 5: 0, 6: 0, 7: 0, 8: 0, 9: 1}\n```\n\n## Результат\nВы научились применять алгоритм имитации отжига для решения задач в постановке матрицы QUBO.\n\n  [© 2025 Cloud.ru](https://cloud.ru)",
      "debug": {
        "start_page": 1,
        "end_page": 1
      }
    }
  ]
}