{
  "title": "Введение в рекурсивное программирование [2019] Рубио-Санчес",
  "chapters": [
    {
      "name": "Глава 1. Основные понятия рекурсивного программирования 19",
      "content": "--- Страница 19 ---\n18  Предисловие полезные замечания по содержанию книги. Ещё хотел бы выразить бла- годарность Луису Фернандесу (Luís Fernández), профессору информати-ки Политехнического университета Мадрида, за его советы и опыт по обучению рекурсии. Особая благодарность – Джерту Лэнкриту и сотруд-никам Лаборатории компьютерного слуха в Университете Калифорнии, Сан-Диего. Мануэль Рубио-Санчес, июль 2017\n--- Страница 20 ---\nГлава 1 Основные понятия рекурсивного программирования Итерация – от человека, рекурсия – от Бога. – Лоуренс Питер Дейч Рекурсия – широкое понятие, которое используется в таких разных дисциплинах, как математика, биоинформатика или лингвистика, и присутствует даже в искусстве и в природе. В программировании ре-курсия понимается как мощная стратегия, позволяющая разрабатывать простые, компактные и изящные алгоритмы решения вычислительных задач. В данной главе вводятся терминология, обозначения и фунда-ментальные понятия рекурсии, которые в дальнейшем будут раскрыты в этой книге. 1.1. Распознание рекурсии Говорят, что объект или понятие рекурсивны, когда в его состав вхо-дят более простые или меньшие подобные ему элементы. Природа даёт множество примеров этого свойства (см. рис. 1.1). Например, ветку де-рева можно считать основой для меньших веток, которые отходят от неё и, в свою очередь, состоят из других, меньших, веток, и так далее до почки, листа или цветка. Строение кровеносных сосудов или рек тоже подобно структуре ветвления деревьев, когда бóльшая структура содер-жит подобные ей элементы, но в меньших масштабах. Другой родствен-ный рекурсивный пример – капуста романеско (Romanesco broccoli), где отдельные маленькие цветки явно напоминают всё растение. Другие примеры включают горные цепи, облака или рисунок кожи животных.\n--- Страница 21 ---\n20  Глава 1. Основные понятия рекурсивного программирования Ветви дерева Реки с притоками Брокколи Romanesco Спиральный эффект Дросте Треугольник Серпиньского Кукла-матрёшка Рис. 1.1. Примеры рекурсивных объектов Рекурсия также появляется в искусстве. Известный пример – эффект Дросте (Droste-effect), который представляет собой картинку, повторяю-\n--- Страница 22 ---\n1.1. Распознание рекурсии  21 щуюся внутри себя. Теоретически такой процесс бесконечен, но на прак - тике он, конечно же, заканчивается, когда наименьшая картинка стано- вится настолько малой, что занимает всего один пиксель в цифровом изображении. Создаваемый компьютером фрактал – ещё один тип ре-курсивного изображения. Например, треугольник Серпиньского состо-ит из трёх меньших идентичных треугольников, которые затем делятся ещё на три меньших. Бесконечно повторяя этот процесс, мы обнаружим, что каждый маленький треугольник имеет ту же структуру, что и ориги-нал. И последний, классический пример иллюстрации рекурсии – набор кукол-матрёшек. В этом ремесле каждая кукла имеет такой размер, что-бы уместиться внутри большей куклы. Отметим, что рекурсивный объ-ект – это не одна полая кукла, а вся вложенная коллекция кукол. Таким образом, рекурсивное мышление предполагает, что вся коллекция кукол может быть описана как одна-единственная (наибольшая) кукла, кото-рая содержит внутри себя меньшую коллекцию кукол. Хотя в приведённых примерах рекурсивные объекты – явно матери- альные, рекурсия встречается и в огромном числе абстрактных поня-тий. В этом отношении рекурсию можно понимать как процесс опре-деления понятий через их собственные определения. Таким способом можно выразить многие математические формулы и определения. Са-мые очевидные примеры – последовательности, n-й член которых за- даётся некоторой формулой или процедурой, использующей предыду - щие члены. Рассмотрим следующее рекурсивное определение: s n = sn–1 + sn–2. (1.1) Формула говорит о том, что член последовательности sn – это прос то сумма двух предыдущих членов sn–1 и sn–2. Сразу видно, что формула ре- курсивна, так как определяемый ею объект s появляется в обеих частях уравнения. Таким образом, элементы последовательности явно опреде- ляются через самих себя. Кроме того, заметьте, что рекурсивная формула (1.1) описывает не конкретную последовательность, а целое семейство последовательностей, где каждый её член есть сумма двух предыдущих членов. Чтобы задать конкретную последовательность, мы должны пре-доставить дополнительную информацию. В данном случае достаточно задать любые два члена последовательности. Как правило, чтобы опре-делить такую последовательность, достаточно задать два первых её чле-на. Например, если s 1 = s2 = 1, то мы получим последовательность 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …, которая является известной последовательностью чисел Фибоначчи.\n--- Страница 23 ---\n22  Глава 1. Основные понятия рекурсивного программирования Последовательности могут начинаться и с члена s0. Последовательность s можно считать функцией, которая в качестве аргумента получает положительное целое число n, а возвращает n-й член этой последовательности. В этом случае функция Фибоначчи, обо- значенная просто как F, может быть определена как: 1, 1, ( ) 1, 2, ( 1) ( 2), 2.n Fn n Fn Fn n=  == −+ − >  (1.2) Всюду в этой книге мы будем использовать для описания функции такие обозначения, когда определения включают два типа выражений или случаев. Начальные условия (base cases) соответствуют случаю, когда результат функции может быть получен тривиально без привлечения значений функции от дополнительных параметров. По определению, начальные условия для чисел Фибоначчи – это F(1) = 1 и F(2) = 1. Рекур- сивные условия (recursive cases) представляют собой более сложные ре-курсивные выражения, включающие обычно определённую функцию от предыдущих значений входных параметров. Функция Фибоначчи имеет одно рекурсивное условие: F(n) = F(n – 1) + F(n – 2), если n > 2. На - чальные условия необходимы для получения из рекурсивных условий конкретных значений членов последовательности. В заключение сле-дует сказать, что рекурсивное определение может содержать несколько начальных и рекурсивных условий. Ещё одна функция, которая может быть выражена рекурсивно, – это факториал некоторого неотрицательного целого числа n: n! = 1 × 2 × … × (n – 1) × n. В этом случае рекурсивность функции не столь очевидна из-за явно- го отсутствия в правой части определения факториала. Но поскольку (n – 1)! = 1 × 2 × … × (n – 1), можно переписать формулу рекурсивно: n! = ( n – 1)! × n. Наконец, по определению 0! = 1, что следует из рекур- сивной формулы для n = 1. Таким образом, функция факториала может быть определена рекурсивно как 1, 0,!( 1)! , 0.nnnn n= =−× > (1.3) Рассмотрим также задачу вычисления суммы первых n положитель- ных целых чисел. Соответствующая функция S(n) может быть, очевид- но, определена как:если если если если если\n--- Страница 24 ---\n1.1. Распознание рекурсии  23 S(n) = 1 + 2 + … + (n – 1) + n. (1.4) И снова мы пока не видим в правой части определения слагаемого, содержащего функцию S. Однако первые n – 1 членов можно сгруппи- ровать так, чтобы получить S(n – 1) = 1 + 2 + … + ( n – 1), что приводит к следующему рекурсивному определению:  > +−==.1 åñëè , )1(,1 åñëè ,1)(n n nSnnS (1.5) Отметим, что S(n – 1) – подзадача, подобная S(n), но более простая, так как для получения её результата требуется меньшее количество опе- раций. Таким образом, говорят, что подзадача имеет меньший размер (размерность). Кроме того, мы говорим, что выполнена декомпозиция (разложение) исходной задачи (S(n)) на меньшие для формирования ре- курсивного определения. Таким образом, S(n – 1) – меньший экземпляр исходной задачи. Другой математический объект, рекурсивность которого не вполне очевидна, – неотрицательные целые числа. Эти числа можно разло- жить и определить рекурсивно через меньшие числа разными способа- ми. Например, неотрицательное целое число n можно представить как предшествующее ему число плюс один: 0, 0, ( ) 1, 0.nnpredesessor n n= =+>  Заметим, что в рекурсивном условии n находится по обе стороны от знака равенства. Кроме того, если мы считаем, что функция predecessor обязательно возвращает неотрицательное целое число, то она непри-менима к 0. Поэтому определение становится законченным только вместе с тривиальным начальным условием для n = 0. Ещё один способ определения (неотрицательных) целых чисел – счи- тать их упорядоченной последовательностью цифр. Например, число 5342 может быть конкатенацией следующих пар меньших чисел: (5, 342), (53, 42), (534, 2). На практике простейший способ декомпозиции целого числа – это представление его в виде соединения наименьшей его значащей циф-ры с остальной его частью. Поэтому целое число можно определить сле-дующим образом:если если если если\n--- Страница 25 ---\n24  Глава 1. Основные понятия рекурсивного программирования , 10, ( //10) 10 ( %10), 10,nnnnn n< =×+ ≥  где // и % – операции вычисления частного и остатка целочисленного деления соответственно, в обозначениях языка Python. Например, если n = 5342, то частное (n // 10) = 534, а остаток (n % 10) = 2 – наименьшая значащая цифра n. Понятно, что само число n можно восстановить, ум- ножив частное на 10 и добавив к полученному результату остаток. На-чальное условие имеет дело только с однозначными числами, которые, конечно же, не могут быть подвержены разложению. Математика просто изобилует рекурсивными выражениями. Так, на- пример, они часто используются для описания свойств функций. Сле-дующее рекурсивное выражение говорит о том, что производная сум-мы функций есть сумма её производных: [f(x) + g(x)]' = [f(x)]' + [g(x)]'. В этом случае рекурсивный объект – это производная функции, обо- значаемая как [-]', но не сами функции f(x) и g(x). Заметьте, что фор- мула явно указывает на имеющую место декомпозицию, где некоторая первичная функция (являющаяся входным параметром производной функции) разложена на сумму функций f(x) и g(x). Структуры данных тоже можно считать рекурсивными объектами. На рис. 1.2 показано, как могут быть подвергнуты рекурсивной декомпо-зиции структуры данных список и дерево. Списки Деревья Рис. 1.2. Рекурсивная декомпозиция списков и деревьев Список может состоять из одного элемента плюс ещё список (это обычное определение списка как абстрактного типа данных). Или же он может быть поделён на несколько списков (в этом, более широком контексте список – это любая коллекция элементов данных, которые линейно упорядочены в определённой последовательности, как в спис -если если\n--- Страница 26 ---\n1.2. Декомпозиция задачи  25 ках, массивах, кортежах и т. д.). Дерево же состоит из родительской вершины и множества (или списка) поддеревьев, корневой узел кото-рых – прямой потомок исходной родительской вершины. Рекурсивные определения структур данных заканчиваются пустыми (начальными) значениями. Например, список из одного элемента мог бы состоять из этого элемента плюс пустой список. Наконец, обратите внимание, что в этих схемах более темные поля представляют рекурсивный объект в целом, тогда как светлые обозначают меньшие и подобные ему экземп-ляры. Рекурсия может также использоваться для определения слов в слова- рях. Это может показаться невозможным, так как нас учат в школе, что толкование слова в словаре не может содержать внутри себя это же сло-во. Однако многие понятия могут быть определены правильно именно так. Рассмотрим термин «потомок» определенного предка. Обратите внимание, что он может быть определён так: некто, являющийся либо ребёнком своего предка, либо потомком любого из детей своего предка. В этом случае мы можем определить рекурсивную конструкцию, в ко-торой множество потомков можно представить (генеалогическим) дре-вом, как на рис. 1.3, где тёмные блоки содержат всех потомков общего предка (корня дерева), а светлые – потомков детей предка. Рис. 1.3. Генеалогическое древо потомков человека – его детей и потомков их детей 1.2. Декомпозиция задачи Вообще говоря, основная задача рекурсивного мышления и програм-мирования – дать наши собственные рекурсивные определения объек - там, понятиям, функциям, задачам и т. д. И если первый шаг обычно сводится к выявлению начальных условий, то главная задача состоит в определении рекурсивных условий. В связи с этим важно усвоить по-нятия (a) декомпозиции задачи и (b) индукции, которые мы вкратце рассмотрим в этой главе.\n--- Страница 27 ---\n26  Глава 1. Основные понятия рекурсивного программирования Цель книги будет заключаться в разработке рекурсивных алгорит - мов решения вычислительных задач. Их следует понимать как вопро- сы, на которые могут ответить компьютеры и которые задаются в виде высказываний, описывающих отношения между заданным набором входных значений или параметров и множеством выходных значений, результатов или решений. Например: «Дано некое положительное це-лое число n. Найти сумму первых n положительных целых чисел» – это формулировка вычислительной задачи с одним входным парамет - ром (n) и одним выходным значением, определяемым как 1 + 2 + … + (n – 1) + n. Экземпляр задачи – это определённый набор допустимых входных значений, которые позволяют нам получить решение задачи. Тогда как алгоритм – это логическая процедура, определяющая поша- говый процесс вычислений для получения по заданным входным зна-чениям выходных значений. Таким образом, алгоритм определяет, как решить задачу. Заслуживает внимания то, что вычислительные задачи могут решаться различными алгоритмами. Цель этой книги состоит в том, чтобы объяснить, как разработать и реализовать рекурсивные ал-горитмы и программы, где основным этапом является декомпозиция вычислительной задачи. Декомпозиция – важное понятие в информатике, играющее главную роль не только в рекурсивном программировании, но и в решении за-дач вообще. Суть её состоит в разложении сложной задачи на меньшие и более простые подзадачи, которые проще выразить, вычислить, за-кодировать и решить. После чего решения подзадач используются для получения решения более сложной исходной задачи. В контексте рекурсивного решения задач и программирования де- композиция подразумевает разложение вычислительной задачи на не-сколько подзадач, некоторые из которых подобны исходной, как пока-зано на рис. 1.4. Отметим, что для решения задачи может потребоваться решение других, дополнительных задач, которые не являются подобными ис - ходной. В книге будет несколько таких задач, но в этой вводной главе мы приведём только такие примеры, где исходные задачи разбиваются только на себе подобные. В качестве первого примера снова рассмотрим задачу вычисления суммы первых n положительных целых чисел, обозначаемой как S(n) и выраженной формулой (1.4). Есть несколько способов разбить задачу на меньшие подзадачи и сформировать рекурсивное определение S(n). Во-первых, она зависит только от входного параметра n, который опре-\n--- Страница 28 ---\n1.2. Декомпозиция задачи  27 деляет также размер задачи. В этом примере начальное условие связа- но с наименьшим целым положительным числом n = 1, и очевидно, что S(1) = 1 – наименьший экземпляр задачи. В дальнейшем при рассмот - рении подзадач нам, возможно, придётся уточнить начальное условие задачи. Поэтому мы должны подумать, каким образом мы будем умень-шать размер задачи – входной параметр n. Декомпозиция РешениеРешить и объединитьПодобные задачи Другие задачиЗадача Рис. 1.4. Рекурсивное решение задачи Первый вариант – уменьшать n на единицу. В этом случае наша цель – определить S(n), используя подзадачу S(n – 1). Соответствующее рекур-сивное решение, полученное алгебраически в разделе 1.1, приведено в (1.5). Рекурсивное условие можно также вывести из графического пред-ставления задачи. Например, можно подсчитать общее число блоков в «треугольной» пирамиде, которая содержит n блоков в первом (нижнем) своём ряду, n – 1 – во втором и т. д. (верхний n-й ряд состоит только из одного блока), как показано на рис. 1.5(a) для n = 8. Для рекурсивной декомпозиции задачи нам нужно найти подоб- ные ей задачи. В этом случае нетрудно найти в исходном треугольни-ке меньшие подобные треугольники. Например, на рис. 1.5(b) показан треугольник высотой n – 1, включающий все блоки исходного треуголь- ника, за исключением n блоков первого ряда. Поскольку этот мень- ший треугольник содержит ровно S(n – 1) блоков, из этого следует, что S(n) = S(n – 1) + n.\n--- Страница 29 ---\n28  Глава 1. Основные понятия рекурсивного программирования Другой вариант декомпозиции с подзадачей суммирования n – 1 членов заключается в рассмотрении суммы 2 + … + (n – 1) + n. Однако тут важно отметить, что эта задача не подобна S(n). Очевидно, что это не сумма первых положительных целых чисел, а частный случай более общей задачи суммирования всех целых чисел от некоторого началь-ного значения m до некоторого большего значения n: m + ( m + 1) + … + (n – 1) + n, где m ≤ n. Различие между обеими задачами можно также пояснить графически. На рис. 1.5 этой общей задаче соответствовал бы прямой трапециоид треугольника. В итоге можно вычислить сум-му первых n положительных целых чисел, используя эту, более общую задачу, если задать m = 1. Однако её рекурсивное определение сложнее, так как требует вместо одного два входных параметра m и n. Исходная задача: S(n) S(n) = 3S((n – 1)/2) + S((n + 1)/2) для нечётных nS(n) = 3S(n/2) + S(n/2 – 1) для чётных n (n – 1)/2n – 1nS(n) = S(n – 1) + 1 n/2(a) (b) (c) (d) Рис. 1.5. Декомпозиции суммы первых положительных целых чисел Другие варианты декомпозиции этой задачи состоят в том, чтобы уменьшать n с шагом, большим 1. Например, все входные значения n можно разбить на чётные и нечётные, чтобы получить декомпозицию,\n--- Страница 30 ---\n1.2. Декомпозиция задачи  29 приведённую на рис. 1.5(c) и 1.5(d). Если n – чётное, то внутри большого треугольника, соответствующего S(n), можно разместить три треуголь- ника высотой n/2. И поскольку оставшийся блок – тоже треугольник вы- сотой n/2 – 1, рекурсивную формулу можно записать как S(n) = 3 S(n/2) + S(n/2 – 1). С другой стороны, если n – нечётное, то внутри треугольника можно разместить три треугольника высотой (n – 1)/2 и один высотой (n + 1)/2. Так что в этом случае рекурсивная формула примет вид S(n) = 3S((n – 1)/2) + S((n + 1)/2). Окончательная рекурсивная функция: 1, 1, 2, 2,()3 ( /2) ( /2 1), 2 3 (( 1)/2) (( 1)/2), 2n nSnSn Sn n Sn Sn n=  = =+− >  −++ >  (1.6) Важно отметить, что определение нуждается в дополнительном на- чальном условии для n = 2. Иначе в рекурсивном условии для чётных n мы получили бы S(2) = 3S(1) + S(0). Но по условию задачи S(0) не опре- делена, поскольку входными значениями для S должны быть только положительные целые числа. Таким образом, новое начальное условие исключает применение рекурсивной формулы для n = 2. За счёт уменьшения размера задачи её подзадачи становятся значи- тельно меньше исходной и потому могут решаться намного быстрее. Грубо говоря, если число подзадач, которые должны быть решены, мало и существует возможность разумного объединения их решений, то та-кая стратегия может привести к существенно более быстрым алгорит - мам решения исходной задачи. Однако в этом частном примере код для (1.6) не обязательно эффективнее кода для (1.5). Интуитивно потому, что (1.6) требует решения двух подзадач (с различными параметрами), тогда как (1.5) содержит только одну подзадачу. Оценке стоимости вы-полнения рекурсивных алгоритмов посвящена глава 3. В последнем способе суммирования первых n положительных целых чисел исходная задача делилась на две подзадачи меньшего размера, где новые входные параметры удовлетворяют заданным начальным условиям. В самом общем случае можно разбивать задачи на любое ко-личество более простых подзадач до тех пор, пока новые параметры тесно связаны со значениями, заданными в начальных условиях. На-пример, рассмотрим следующее альтернативное рекурсивное опреде-ление функции Фибоначчи (эквивалент (1.2)):если если еслиеслии n – чётное,и n – нечётное.\n--- Страница 31 ---\n30  Глава 1. Основные понятия рекурсивного программирования 2 11, 1, ( ) 1, 2, 1 ( ), 2,n in Fn n Fi n− = ===  +> ∑ (1.7) где )(2 1iFn i∑− = есть сумма F(1) + F(2) + … + F(n – 2) (см. раздел 3.1.4). В этом примере для некоторого значения n размера исходной задачи рекур- сивное условие использует результаты всех меньших подзадач разме- ром от 1 до n – 2. В последнем примере декомпозиции задачи мы будем использовать списки, которые позволят нам обращаться к отдельным его элементам посредством числовых индексов (во многих языках программирования такую структуру данных называют «массивом», тогда как в Python это просто «список»). Задача заключается в суммировании значений эле- ментов списка, обозначаемого как a и содержащего n чисел. Формально задача может быть записана как: s(a) = ∑− =1 0][n iia = a[0] + a[1] + … + a[n – 1], (1.8) где a[i] – ( i + 1)-й элемент списка, поскольку 1-й элемент списка имеет индекс 0. На рис. 1.6(a) изображён частный случай списка из 9 элементов. Что касается обозначений, то в этой книге мы будем считать, что подсписок некоторого списка a – это коллекция смежных элементов a, если явно не оговаривается иное. Напротив, в подпоследовательности некоторой последовательности s её элементы появляются в том же по- рядке, что и в s, но они не обязаны быть смежными. Другими словами, подпоследовательность может быть получена из исходной последова-тельности s удалением некоторых элементов s без изменения порядка следования оставшихся элементов. Декомпозиция задачи заключается в уменьшении её размера на еди- ницу. С одной стороны, список можно разбить на подсписок из первых n – 1 элементов (a[0: n – 2], где a[i : j] – подсписок от a[i] до a[j – 1] в обозначениях языка Python) и единственный элемент (a[n – 1]), соот - ветствующий последнему числу в списке (см. рис.1.6(b)). В этом случае задачу можно определить рекурсивно таким образом:если если если\n--- Страница 32 ---\n1.2. Декомпозиция задачи  31 0, 0,()( [0: 2]) [ 1], 0.nssn n n= =−+− > aaa (1.9) Исходная задача: s(a) = a[0] + a[1] + + a[n – 1] (a) (b) (c)s(a) = s(a[0 : n – 1]) + a[n – 1] s(a) = a[0] + s(a[1 : n]) s(a) = s(a[0 : n//2]) + s(a[n//2 : n]) (d) Рис. 1.6. Декомпозиции суммы элементов списка a из n = 9 чисел В рекурсивном условии подзадача решается, естественно, для под- списка размером n – 1. Начальное условие рассматривает тривиаль- ную ситуацию, когда список пуст и совсем не требует суммирования. если если 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 0 1 2 3 4 5 6 7 8 0 8 5 7 5 3 5 1 12 4 2 6 5 7 5 3 1 12 4 2 6 5 7 5 3 1 12 4 2 6 5 7 5 3 1 12 4 2 6\n--- Страница 33 ---\n32  Глава 1. Основные понятия рекурсивного программирования Вторым возможным начальным условием может быть s(a) = a[0] для n = 1. Однако оно было бы избыточным при такой декомпозиции и поэтому не обязательно. Обратите внимание, что при n = 1 функция добавляет a[0] к нулевому результату применения функции к пустому списку. Таким образом, второе начальное условие можно опустить для краткости. С другой стороны, исходный список можно также представить как его первый элемент a[0] и меньший список a[1: n] (см. рис. 1.6(c)). В этом случае задача может быть записана рекурсивно как: 0, 0,()[0] ( [1: ]), 0.nssn n= =+> aaa (1.10) Хотя обе декомпозиции очень похожи, код для каждой из них может весьма отличаться в разных языках программирования. В разделе 1.3 мы приведём несколько способов кодирования алгоритма решения за-дачи для каждой из этих декомпозиций. Ещё один способ декомпозиции задачи – деление списка пополам, как на рис. 1.6(d). Это приводит к двум подзадачам размером пример- но в половину исходной. Декомпозиция даёт следующее рекурсивное определение: 0, 0, ( ) [0], 1, ( [0: //2]) ( [ //2: ]), 1. n sn s n sn n n=  == +> aa aa (1.11) В отличие от предыдущих определений такая декомпозиция требует начального условия для n = 1. Без него функция никогда бы не верну - ла конкретного значения для непустого списка. Обратите внимание, что такое определение не складывало бы и не возвращало ни одного элемента списка. Для непустого списка рекурсивное условие применя-лось бы многократно, и этот процесс никогда бы не закончился. Такая ситуация называется бесконечной рекурсией. Например, если бы спи- сок содержал только один элемент, то рекурсивное условие добавило бы значение 0, соответствующее пустому списку, к результату такой же исходной задачи. Иными словами, мы пытались бы бесконечно вычис - лить s(a) = 0 + s(a) = 0 + s(a) = 0 + s(a) + … . Очевидная проблема такого сценария – в том, что при n = 1 исходная задача s(a) уже не может быть разбита на меньшие и более простые.если если если еслиесли\n--- Страница 34 ---\n1.3. Рекурсивный код  33 1.3. Рекурсивный код Для использования рекурсии при разработке алгоритмов крайне важно знать, как разбить задачу на меньшие себе подобные и определить ре- курсивные методы, опираясь на индукцию (см. раздел 1.4). Как только это сделано, дальше уже не составит труда преобразовать определения в код, особенно для таких базовых типов данных, как целые и веществен-ные числа, символы или логические (булевы) значения. Рассмотрим функцию (1.5), которая суммирует первые n целых положительных (на- туральных) чисел. В языке Python такая функция может быть закоди-рована, как показано в листинге 1.1. Аналогия между (1.5) и функцией Python очевидна. Как и во многих примерах данной книги, обычный условный оператор – единственная управляющая конструкция, необ-ходимая для реализации рекурсивной функции. Кроме того, внутри его тела обязательно должно быть имя функции, означающее рекурсивный вызов. Таким образом, мы говорим, что функция вызывает саму себя, или обращается к самой себе, и потому рекурсивна (существуют рекур- сивные функции, которые не вызывают себя непосредственно в теле условного оператора, о чём говорится в главе 9). Листинг 1.1. Суммирование первых n натуральных чисел 1 2345def sum_first_naturals(n): if n == 1: return 1 # Base case else: return sum_first_naturals(n – 1) + n # Recursive case Код функции в других языках программирования так же прост. На рис. 1.7 показаны эквивалентные коды на нескольких языках програм- мирования. И здесь сходство кода и определения функции вполне оче-видно. Хотя весь код книги написан на языке Python, перевести его на другие языки программирования будет довольно просто. Важно, что в функции (1.5) и в соответствующем ей коде не проверяет - ся условие n > 0. Для входного параметра такой тип условия, задаваемого в постановке задачи или в определении функции, известен как предусло- вие. Программисты могут считать, что предусловия соблюдаются всегда и потому не должны создавать код для их поиска или обработки. Листинг 1.2 соответствует рекурсивному определению (1.6). Рекур- сивная функция использует каскадный условный оператор для выбора одного из двух начальных (строки 2–5) и рекурсивных условий (стро-\n--- Страница 35 ---\n34  Глава 1. Основные понятия рекурсивного программирования ки 6–11), где два последних дважды вызывают саму рекурсивную функ - цию. C, Java: 1 234567int sum_first_naturals(int n) { if (n == 1) return 1; else: return sum_first_naturals(n–1) + n; } Pascal: 1 234567function sum_first_naturals(n: integer): integer; begin if n=1 then sum_first_naturals := 1 else sum_first_naturals := sum_first_naturals(n–1) + n; end; MATLAB®: 1 234567function result = sum_first_naturals(n) if n==1 result = 1; else result = sum_first_naturals(n–1) + n; end Scala: 1 23456def sum_first_naturals(n: Int): Int = { if (n==1) return 1 else return sum_first_naturals(n–1) + n } Haskell: 1 2sum_first_naturals 1 = 1 sum_first_naturals n = sum_first_naturals (n – 1) + n Рис. 1.7. Функции вычисления суммы первых n натуральных чисел в разных языках программирования\n--- Страница 36 ---\n1.3. Рекурсивный код  35 Листинг 1.2. Другой вариант суммирования первых n натуральных чисел 1 234567891011def sum_first_naturals(n): if n == 1: return 1 elif n == 2: return 3 elif n % 2: return (3 * sum_first_naturals_2((n – 1) / 2) + sum_first_naturals_2((n + 1) / 2)) else: return (3 * sum_first_naturals_2((n / 2) + sum_first_naturals_2((n / 2 – 1)) Так же просто закодировать функцию, вычисляющую n-е число Фи- боначчи согласно стандартному определению (1.2). В листинге 1.3 при- водится соответствующий код, где оба начальных условия проверяются в логическом выражении условного оператора. Листинг 1.3. Вычисление n-го числа Фибоначчи 1 2345def fibonacci(n): if n == 1 or n == 2: return 1 else: return fibonacci(n – 1) + fibonacci(n – 2) Реализация функции Фибоначчи (1.7) требует большего количества действий. Если начальные условия идентичны, суммирование в рекур- сивном условии нуждается в операторе цикла или иной функции для вычисления суммы значений F(1), F(2), , F(n – 2). В листинге 1.4 при- водится возможное решение с использованием цикла for. Листинг 1.4. Другой вариант вычисления n-го числа Фибоначчи 1 2345678def fibonacci_alt(n): if n == 1 or n == 2: return 1 else: aux = 1 for i in range(1, n – 1): aux += fibonacci_alt(i) return aux\n--- Страница 37 ---\n36  Глава 1. Основные понятия рекурсивного программирования Результат сложения можно сохранить во вспомогательной перемен- ной-сумматоре aux с начальным значением 1 (строка 5). Цикл for прос - то добавляет к вспомогательной переменной члены F(i) для i = 1, …, n – 2 (строки 6–7). В итоге функция возвращает вычисленное и сохранённое в aux число Фибоначчи. Для более сложных типов данных различий в кодах разных языков программирования может становиться ещё больше из-за низкоуровне-вых деталей. Например, при работе с такой структурой данных, как спи-сок, рекурсивным алгоритмам для вычленения подсписков нужно знать его длину. На рис. 1.8 приведены три варианта списков (или подобных им структур данных) с параметрами, необходимыми для вычленения подсписков в рекурсивных программах. длина (a) (b) (c) Рис. 1.8. Списочные структуры данных с параметрами, необходимыми для определения подсписков В случае (a) длина списка a может быть получена без использования дополнительных переменных или параметров. Например, она может быть свойством или методом списка. В языке Python длину списка мож - но получить вызовом функции len. Однако в таких языках програм- мирования, как C или Паскаль, получить длину стандартного массива невозможно. Если длину списка нельзя извлечь непосредственно из структуры данных, то для хранения и получения длины списка нужен 3 42 5 7 *a size 6 7– 1 26 5– 1 – 1 –3 –3 –32 2 23 3 5 4 94 0a a * lower upper\n--- Страница 38 ---\n1.3. Рекурсивный код  37 дополнительный параметр, например size , как в случае (b). Такой под- ход может применяться при работе с массивами – фиксированного раз- мера или частично заполненными. Правда, в подобных случаях лучше использовать начальный и конечный индексы, задающие границы под-списка, как в случае (c). Отметим, что в этом случае фиксированный раз-мер структуры данных может быть довольно большим (достаточным для нужд приложения), хотя истинная длина списков и подсписков может быть гораздо меньше. На рис. 1.8(c) изображён список, использую щий только первые 10 элементов (остальные игнорируются). Внутри него определён подсписок из шести элементов с нижней ( lower ) и верхней (upper ) индексными переменными, ограничивающими его пределы. Отметим, что элементы с этими индексами входят в подсписок. Конструкции и синтаксис языка Python поддерживают высокий уро- вень алгоритмизации задач, избегая необходимости знать механизмы нижнего уровня, такие, например, как передача параметров. Однако его гибкость допускает большое разнообразие возможностей кодиро-вания. В листинге 1.5 приводятся три решения задачи суммирования элементов списка, соответствующих трём способам декомпозиции на рис. 1.6, в которых единственным входным параметром является спи-сок, изображённый на рис. 1.8(a). Функции sum_list_length_1 , sum_list_length_2 и sum_list_ length_3 реализуют рекурсивные определения (1.9), (1.10) и (1.11) со- ответственно. Заключительные строки листинга объявляют список a и печатают сумму его элементов, используя эти три функции. Отметим, что количество элементов n списка вычисляется методом len. В за- ключение напомним, что a[lower, upper] – это подсписок a от индекса lower до upper – 1, тогда как [lower:] равносильно [lower:len(a)]. Если размер списка нельзя получить непосредственно из списка, то его мож - но передать дополнительным параметром функции, как показано на рис. 1.8(b). Соответствующий код подобен листингу 1.5 и предлагается в качестве упражнения в конце главы. В листинге 1.6 приводится другой вариант тех же функций с исполь- зованием больших списков и двух параметров ( lower и upper ), опре- деляющих подсписки внутри этого списка, как показано на рис. 1.8(c). Обратите внимание на аналогию этих функций с функциями из лис - тинга 1.5. В данном случае список пуст, когда lower больше upper . Кро- ме того, подсписок содержит единственный элемент, если значения обоих индексов совпадают (напомним, что оба параметра указывают позиции элементов, входящих в подсписок).\n--- Страница 39 ---\n38  Глава 1. Основные понятия рекурсивного программирования Листинг 1.5. Рекурсивные функции суммирования элементов списка с единственным параметром – списком a 1 23456789101112131415161718192021222324252627282930313233343536# Decomposition: s(a) => s(a[0:n–1]), a[n–1] def sum_list_length_1(a): if len(a) == 0: return 0 else: return (sum_list_length_1(a[0:len(a) – 1]) + a[len(a) – 1]) # Decomposition: s(a) => a[0], s(a[1:n]) def sum_list_length_2(a): if len(a) == 0: return 0 else: return a[0] + sum_list_length_2(a[1:len(a)]) # Decomposition: s(a) => s(a[0:n//2]), s(a[n//2:n]) def sum_list_length_3(a): if len(a) == 0: return 0 elif len(a) == 1: return a[0] else: middle len(a) // 2 return (sum_list_length_3(a[0:middle]) + sum_list_length_3(a[middle:len(a)])) # Some list: a = [5, –1, 3, 2, 4, –3] # Function calls: print (sum_list_length_1(a)) print (sum_list_length_2(a))print (sum_list_length_3(a))\n--- Страница 40 ---\n1.3. Рекурсивный код  39 Листинг 1.6. Другой вариант рекурсивных функций суммирования элементов подсписков списка a. Границы подсписков задаются двумя входными параметрами lower и upper – соответственно нижним и верхним индексами в списке a 1 234567891011121314151617181920212223242526272829303132333435# Decomposition: s(a) => s(a[0:n–1]), a[n–1] def sum_list_limits_1(a, lower, upper): if lower > upper: return 0 else: return a[upper] + sum_list_limits_1(a, lower, upper – 1) # Decomposition: s(a) => a[0], s(a[1:n]) def sum_list_limits_2(a, lower, upper): if lower > upper: return 0 else: return a[lower] + sum_list_limits_2(a, lower + 1, upper) # Decomposition: s(a) => s(a[0:n//2]), s(a[n//2:n]) def sum_list_limits_3(a, lower, upper): if lower > upper: return 0 elif lower == upper: return a[lower] # or a[upper] else: middle len(upper + lower) // 2 return (sum_list_limits_3(a, lower, upper) + sum_list_limits_3(a, middle + 1, upper)) # Some list: a = [5, –1, 3, 2, 4, –3] # Function calls: print (sum_list_limits_1(a, 0, len(a) – 1))print (sum_list_limits_2(a, 0, len(a) – 1)) print (sum_list_limits_3(a, 0, len(a) – 1))\n--- Страница 41 ---\n40  Глава 1. Основные понятия рекурсивного программирования 1.4. Индукция Индукция – ещё одно понятие, которое играет существенную роль при разработке рекурсивного кода. Термин имеет разные значения в зави- симости от области и предмета его применения. В контексте рекурсив- ного программирования он связан с математическим доказательством методом индукции. Его ключевая идея состоит в том, что программис - ты должны предположить, что рекурсивный код, который они пытают - ся реализовать, правильно работает для простых и малых задач, даже если они ещё не написали ни одной строчки программы! Это понятие также называют иногда рекурсивной «убеждённостью» (leap of faith). В данном разделе рассматриваются эти чрезвычайно важные понятия. 1.4.1. Математические доказательства методом индукции В математике доказательства методом индукции – это важный ин- струмент обоснования истинности некоторого утверждения. Простей-шие доказательства касаются формул, зависящих от некоторого поло-жительного (или неотрицательного) целого числа n. В таких случаях доказательства проверяют истинность формул для любого допустимого значения n. Метод индукции предполагает два шага: a) начальное условие (основание). Проверяется, что формула верна для наименьшего значения n, скажем, n = 0; b) шаг индукции. Сначала предполагается, что формула верна для некоторого произвольного значения n. Это предположение назы- вается гипотезой индукции. Затем на основании этого предполо-жения доказывается, что формула верна и для n + 1. Если можно доказать истинность обоих шагов, то согласно индукции из этого следует, что утверждение справедливо для всех n ≥ n 0. Утверж - дение должно быть истинным для n0, а затем – для n0 + 1, n0 + 2 и так далее для каждого следующего шага индукции. Рассмотрим ещё раз сумму первых n положительных чисел (1.4). По- пробуем доказать справедливость следующего равенства (гипотеза ин-дукции), содержащего квадратный полином: S(n) = ∑ =n ii 1 = n (n + 1)/2. (1.12) Начальное условие, очевидно, истинно, так как S(1) = 1(1 + 1)/2 = 1. А на шаге индукции мы должны показать, имеет ли силу\n--- Страница 42 ---\n1.4. Индукция  41 S(n + 1) = ∑+ =1 1n ii = (n + 1) (n + 2)/2 (1.13) при условии, что (1.12) верна. Для начала запишем S(n + 1) как S(n + 1) = ∑ =n ii 1 + (n + 1). Затем, считая, что имеет силу (1.12), заменим сумму полиномом: S(n + 1) = n(n + 1)/2 + (n + 1) = (n + 1)(n/2 + 1) = (n + 1)(n + 2)/2. Откуда видно, что (1.13) истинна, и на этом доказательство законче- но. 1.4.2. Рекурсивная убеждённость Для решения меньших подзадач рекурсивные функции обычно вы- зывают сами себя. И тут у начинающего программиста возникают впол- не резонные сомнения и вопросы: действительно ли написанная таким образом рекурсивная функция будет работать и допустимо ли в теле функции вызывать её саму, если она ещё не завершилась? И даже не-смотря на то, что в языках программирования с поддержкой рекурсии функции могут вызывать сами себя, крайне важно поверить, что они работают правильно для подзадач меньшего размера. Эту уверенность, играющую ту же роль, что и гипотеза в доказательствах методом ин-дукции, называют рекурсивной «убеждённостью». Она – один из крае-угольных камней рекурсивного мышления и в то же время «крепкий орешек», о который программисты-новички рискуют сломать себе зубы. И конечно же, это не догма, принимаемая безраздумно. Следую-щий мысленный эксперимент поясняет её роль в рекурсивном мышле-нии. Представьте, что вы находитесь в огромной классной комнате, и учи- тель просит вас найти сумму целых чисел от 1 до 100. Если вы не знаете формулы (1.12), вам пришлось бы выполнить 99 сложений. Но предпо-ложим, что вам разрешено переговариваться с одноклассниками, и сре-ди них есть один «умный», который убеждён, что может сложить первые n положительных целых чисел, когда n ≤ 99. В этом случае ваша задача стала бы гораздо проще: вы могли бы просто попросить его вычислить сумму первых 99 положительных целых чисел (она равна 4950), а вам бы осталось только добавить к ней 100, чтобы получить 5050. Несмот - ря на то что вы якобы пытаетесь схитрить или воспользоваться некой\n--- Страница 43 ---\n42  Глава 1. Основные понятия рекурсивного программирования уловкой, такая стратегия, приведённая на рис. 1.9(a), – правильный спо- соб (рекурсивного) мышления и решения задачи. При этом вы должны быть уверены лишь в том, что умный одноклассник действительно даст вам правильный ответ на ваш вопрос. Эта уверенность как раз и соот - ветствует рекурсивной убеждённости. Одноклассник Ученик Учитель (a) (b)S(100) = ? S(100) = ?S(99) = ? S(99) = ? S(98) = ? S(2) = ? S(1) = ? 5050 4950 4851 3 15050 4950+100 +100 +99 +3 +2 - - - - - Рис. 1.9. Задача на устный счёт в классе. Учитель просит учеников сложить первые 100 положительных целых чисел. S(n) – сумма первых n положительных целых чисел Для ответа на ваш вопрос у вашего одноклассника есть два пути. Если он действительно очень умён, то способен ответить на ваш вопрос без посторонней помощи, например применив формулу (1.12). Но это маловероятно ввиду сложности задачи. Поэтому, осознавая, что он не столь умён, как ему кажется, для получения ответа на заданный ему во-прос он, скорее всего, выберет другой путь и задаст аналогичный во-прос ещё одному «умному» однокласснику, то есть воспользуется вашей же стратегией. Иными словами, вы можете считать, что ваш друг – это просто ваш клон. Фактически при таком сценарии, представленном на рис. 1.9(b), все ученики в классе применили бы ваш подход. Отметим, что этот процесс явно рекурсивен: каждый ученик просит другого, что-бы тот решил более простую задачу (размер которой на каждом шаге уменьшается на 1), пока самый последний в этой цепочке ученик не даст ответ «1» для тривиального начального условия. Таким образом, каждый ученик может дать ответ всякому, кто попросит его вычис - лить полную сумму целых чисел, выполнив только одно-единственное сложение. Этот процесс продолжается до тех пор, пока вы не получите сумму первых 99 положительных целых чисел. После чего вы сможете - - - - -\n--- Страница 44 ---\n1.4. Индукция  43 правильно ответить на вопрос учителя, добавив к этой сумме 100. Сто- ит отметить, что процесс не заканчивается по достижении начального условия (это одна из главных ошибок в понимании студентами началь-ного условия). Кроме первого этапа, когда ученики последовательно задают вопросы другим одноклассникам, пока один из них не даст три-виальный ответ «1», есть и второй – когда они вычисляют сумму и пере-дают результат однокласснику. Этот подход можно формализовать, как в (1.5), и закодировать, как в листинге 1.1, где S(n – 1) или sum_first_naturals(n – 1) равносильны вашему обращению к однокласснику с просьбой решить подзадачу. Ре-курсивная убеждённость заключается в вашей уверенности в том, что S(n – 1) в определении или sum_first_naturals(n – 1) в коде действи- тельно дают правильный ответ. Аналогично, при доказательстве методом индукции мы можем пред- положить, что процедура в целом должна быть правильной. Во-первых, ваш ответ будет верным, пока ваш одноклассник даёт вам правильный ответ. Но то же самое относится и к ученику, которого ваш одноклассник просит решить подзадачу. Это рассуждение может многократно при-меняться к каждому ученику до тех пор, пока, наконец, некий ученик не попросит другого сложить целые числа от 1 до 1. Так как последний ученик возвращает 1, что, конечно же, верно, все предыдущие ответы студентов должны быть по той же причине верными. Всё это подразумевает, что программисты могут – и должны – выстра- ивать правильные рекурсивные условия, предполагая, что рекурсивные вызовы функции, включающие подобные им подзадачи меньшего раз-мера, работают правильно. Неформально мы должны считать, что мо-жем получить решения подзадач «бесплатно». Таким образом, если нам нужно решать различные задачи, то согласно декомпозиции на рис. 1.4 нам нет нужды решать подобные исходной подзадачи, так как можно считать, что эти решения уже найдены. Конечно, нам нужно будет так или иначе переработать их (изменить, расширить, объединить и т. д.), чтобы создать рекурсивные условия. Наконец, рекурсивные алгоритмы завершаются благодаря начальным условиям, которые не только ис - тинны, но и позволяют алгоритмам завершаться. 1.4.3. Императивное и декларативное программирование Парадигма программирования – это общая стратегия разработки программного обеспечения. Парадигма императивного программи-рования фокусируется на том, как работает программа, когда код явно\n--- Страница 45 ---\n44  Глава 1. Основные понятия рекурсивного программирования описывает поток управления и команды, которые изменяют значения переменных (то есть состояние программы). Из этой парадигмы следу - ет итерационный код. Напротив, рекурсивный код опирается на декла-ративную парадигму программирования, которая фокусируется на том, что должны делать программы без явного описания потока управле-ния, и может считаться противоположностью императивного програм-мирования. Функциональное программирование следует декларатив-ной парадигме, которая исключает побочные эффекты, а все действия сводятся к вычислению математических функций. Таким образом, при разработке рекурсивного кода программисты нацелены думать о том, что должны делать функции, а не как они долж - ны это делать. Отметим, что это имеет прямое отношение к функцио-нальной абстракции и использованию программных библиотек, когда программисты, не беспокоясь о деталях реализации, могут сосредо-точиться исключительно на функциональных возможностях, считая методы правильно работающими «черными ящиками». По этой при-чине с позиций высокоуровневого программирования программисты могут – и должны – рассматривать вызовы рекурсивных функций как обращения к «черным ящикам», дающим правильные результаты (как на рис. 1.9(a), а не думать обо всех рекурсивных шагах вплоть до на-чального условия (как на рис. 1.9(b)). Зачастую фиксация внимания на деталях низкого уровня, касающихся цепочки вызовов функций, только запутывает дело. 1.5. Рекурсия против итерации Вычислительная мощь компьютеров заключается главным образом в их способности выполнять задачи многократно – итерационно или ре-курсивно. Первые для многократного повторения действий использу - ют такие конструкции, как циклы while или for, тогда как рекурсивные функции раз за разом вызывают самих себя, при каждом вызове вплоть до достижения начального условия решая одну и ту же задачу. Итера-ция и рекурсия эквивалентны в том смысле, что они решают одни и те же виды задач. Всякая итеративная программа может быть преобразо-вана в рекурсивную, и наоборот. Выбор может зависеть от нескольких факторов, таких как вычислительная задача, эффективность, язык или парадигма программирования. Например, итерация предпочтитель-на в императивных языках, тогда как рекурсия широко используется в функциональном программировании, которое следует декларативной парадигме программирования.\n--- Страница 46 ---\n1.5. Рекурсия против итерации  45 Уже приведённые в книге примеры могут быть легко закодированы с помощью циклов. Поэтому выгода от применения рекурсии ещё не вполне ясна. На практике основное преимущество использования ре- курсивных алгоритмов вместо итерационных заключается в том, что для многих вычислительных задач рекурсивный алгоритм гораздо про- ще проектировать и понимать. Рекурсивный алгоритм больше похож на логический подход к решению задач. Следовательно, он должен быть более понятным, изящным и коротким. Кроме того, рекурсивные алгоритмы неявно используют для хра- нения информации программный стек, операции с которым (скажем, втолкнуть и вытолкнуть) прозрачны для программиста. Поэтому они предоставляют ясные альтернативы итерационным алгоритмам, где ответственность за явное управление стековой (или подобной ей) структурой данных ложится на программиста. Например, если условие задачи или структура данных предполагает дерево, рекурсивные алго-ритмы будут гораздо проще и понятнее итерационных, поскольку для последних нужно реализовывать поиски в ширину или в глубину с ис - пользованием очередей и стеков соответственно. С другой стороны, в самом общем случае рекурсивные алгоритмы не столь эффективны, как итерационные, и используют больше памяти. Эти недостатки связаны с использованием программного стека. Во-обще, каждый вызов функции, рекурсивный он или нет, выделяет па- мять в программном стеке и хранит в нём информацию, требующую дополнительных вычислительных затрат. Таким образом, рекурсивная программа может быть не только медленнее итерационной – большое количество вызовов при выполнении программы может привести к переполнению стека. Более того, некоторые рекурсивные определения сами по себе могут быть довольно медленными. Например, коды для чисел Фибоначчи в листингах 1.3 и 1.4 требуют экспоненциального вре-мени выполнения, тогда как числа Фибоначчи могут быть вычислены (гораздо быстрее) за логарифмическое время. Помимо этого, рекурсив- ные алгоритмы сложнее для отладки (то есть для пошагового анали-за программы с целью поиска и локализации ошибок), особенно если функции вызывают себя многократно, как в листингах 1.3 и 1.4. Наконец, если в некоторых функциональных языках программирова- ния циклы вообще не допускаются, то многие иные языки поддержи- вают как итерацию, так и рекурсию. Поэтому в них можно объединять оба этих стиля программирования так, чтобы создавать алгоритмы не только мощные, но и ясные для понимания (например, перебор с воз-\n--- Страница 47 ---\n46  Глава 1. Основные понятия рекурсивного программирования вратами). В листинге 1.4 приведён простой пример рекурсивной функ - ции с применением цикла. 1.6. Типы рекурсии Рекурсивные алгоритмы можно классифицировать по нескольким критериям. В этом последнем разделе кратко описываются типы ре-курсивных функций и процедур, которые будут рассматриваться на протяжении всей книги. Каждый тип рекурсии мы проиллюстрируем на примере рекурсивных функций для вычисления чисел Фибоначчи (F(n)) с определёнными для каждого типа рекурсии параметрами. В за-ключение отметим, что рекурсивные алгоритмы могут относиться к не-скольким типам рекурсии. 1.6.1. Линейная рекурсия Линейный тип рекурсии появляется, когда методы вызывают себя только однажды. Есть два типа линейно-рекурсивных методов, однако мы будем применять термин «линейная рекурсия», когда имеем дело с методами, которые так или иначе обрабатывают результат рекурсивно-го вызова до выдачи или возврата своего собственного результата. На-пример, функция вычисления факториала в (1.3) относится к этой кате-гории, так как выполняет только один рекурсивный вызов, а результат подзадачи умножается на n, чтобы получить результат функции. Функ - ции в (1.5), (1.9) и (1.10) тоже являются очевидными примерами линей-ной рекурсии. Следующая функция представляет собой другой пример функции Фибоначчи: f(n) = 1, 1 2, ( 1) 1/2 , 2,nn fn n==  Φ⋅ − + >  (1.14) где Φ = (1 + √ 5)/2 ≈ 1.618 – константа, известная под названием «золотое сечение», а ⌊ · ⌋ обозначает нижнюю границу. В этом случае F(n) = f(n)– n-е число Фибоначчи. Такой тип линейно-рекурсивных алгоритмов подробно рассматривается в главе 4. 1.6.2. Хвостовая рекурсия Второй тип линейной рекурсии называют «хвостовой рекурсией». Методы, относящиеся к этой категории, также вызывают себя лишь од-нажды, но рекурсивный вызов – это последнее действие в рекурсивном условии. Следовательно, оно никак не влияет на результат рекурсивно-если или если\n--- Страница 48 ---\n1.6. Типы рекурсии  47 го вызова. Для примера рассмотрим следующую хвостовую рекурсив- ную функцию: f(n, a, b) =, 1, ( 1, , ), 1.bn fn a ba n=  −+ >  (1.15) Обратите внимание, что в рекурсивном условии метод просто воз- вращает результат рекурсивного вызова, который не входит в мате-матическое или логическое выражение. Поэтому рекурсивное условие определяет лишь отношение между наборами параметров, для которых функция возвращает одно и то же значение. Выполняя рекурсивные вызовы, алгоритм лишь изменяет параметры, пока нет возможности получить решение из начального условия. В этом случае числа Фибо-наччи F(n) могут быть получены из f(n, 1, 1). Этому типу рекурсивных алгоритмов будет посвящена глава 5. 1.6.3. Множественная рекурсия Рекурсия множественного типа возникает, когда в каком-то рекур- сивном условии метод вызывает себя несколько раз (см. главу 7). Если метод вызывает себя дважды, то такой тип рекурсии называют «двой-ной рекурсией» («binary recursion»). Из приведённых ранее примеров к данному типу рекурсии относятся (1.2), (1.6), (1.7) и (1.11). Следующая функция использует множественную рекурсию для альтернативного определения чисел Фибоначчи, где F(n) = f(n): f (n) = 22 221, 1 2, ( / 2 1) ( / 2 1) , 2 (( 1)/2) (( 1)/2) , 2nn fn fn n fn fn n==  +− − >  + +− >  (1.16) Такой тип рекурсии обычно возникает в алгоритмах, разработанных согласно стратегии «разделяй и властвуй», которой посвящена глава 6. 1.6.4. Взаимная рекурсия Говорят, что несколько методов относится к типу взаимно-рекурсив- ных, если они могут вызывать друг друга циклически. Например, функ - ция f может вызывать другую функцию g, которая, в свою очередь, может вызвать третью функцию h, которая может завершаться вызовом пер- вой функции f. Такую рекурсию называют ещё «косвенной», поскольку метод вызывает себя не непосредственно внутри своего тела, а через если если если или если еслии n – чётное, и n – нечётное.\n--- Страница 49 ---\n48  Глава 1. Основные понятия рекурсивного программирования циклическую цепочку вызовов. Например, рассмотрим две следую щие функции Фибоначчи: 0, 1,()( 1) ( 1), 1,nAnAn Bn n= =−+ − >  (1.17) 1, 1,()( 1), 1.nBnAn n= =−>  (1.18) Ясно, что A рекурсивна, так как вызывает саму себя, но рекурсия в B – косвенная, так как вызывает A, которая, в свою очередь, вызывает B. Таким образом, рекурсия возникает из-за того, что вызов B может поро- дить другие вызовы B (в более простых экземплярах задачи). Эти функ - ции также могут применяться для генерации чисел Фибоначчи. В част - ности, F(n) = B(n) + A(n). Взаимной рекурсии будет посвящена глава 9. 1.6.5. Вложенная рекурсия Вложенный тип рекурсии возникает, когда аргумент рекурсивной функции содержит другой рекурсивный вызов. Рассмотрим следующую функцию Фибоначчи:  > − + −= = +=.2 åñëè )),0 ,2( ,1(,2 èëè 1 åñëè ,1)(n nfs nfn n ss,nf (1.19) Второй параметр рекурсивного вызова – выражение, включающее в себя еще один рекурсивный вызов функции. В этом случае числа Фибо-наччи F(n) могут быть получены из f(n, 0). Такой тип рекурсии редок, но появляется в некоторых задачах и контекстах, связанных с хвостовой рекурсией. Краткий обзор вложенной рекурсии даётся в главе 11. 1.7. Упражнения Упражнение 1.1. Что вычисляет следующая функция? 1, 0,()( 1) , 0.nfnfn n n= =−⋅ >  Упражнение 1.2. Рассмотрим последовательность, заданную следую- щим рекурсивным определением: sn = sn–1 + 3. Вычислите первые её че- тыре члена, полагая, что (a) s0 = 0 и (b) s0 = 4. Приведите нерекурсивное определение sn для обоих случаев.если еслиилиесли если если если если если\n--- Страница 50 ---\n1.7. Упражнения  49 Упражнение 1.3. Рассмотрим последовательность, заданную следу - ющим рекурсивным определением: sn = sn–1 + sn–2. Если заданы началь- ные значения s1 и s2, то этой информации достаточно, чтобы определить всю последовательность. Покажите, что всю последовательность можно определить также, если заданы два произвольных её члена si и sj, где i < j. Наконец, найдите элементы последовательности между s1 = 1 и s5 = 17. Упражнение 1.4. Множество «потомков человека» можно опреде- лить рекурсивно, как детей этого человека вместе с их потомками. Дай-те математическое описание данного понятия в обозначениях теории множеств. В частности, определите функцию D(p), где D обозначает потомков, а параметр p ссылается на отдельного человека. Кроме того, считайте, что можно пользоваться функцией C(p), возвращающей мно- жество детей человека p. Упражнение 1.5. Пусть F(n) = F(n – 1) + F(n – 2) представляет собой рекурсивную функцию, где n – положительное целое число, а F(1) и F(2) имеют произвольные начальные значения. Покажите, что для n ≥ 2 её можно записать как F(n) = F(2) + ∑− =2 1)(n iiF . Упражнение 1.6. Реализуйте функцию вычисления факториала (1.3). Упражнение 1.7. Как абстрактный тип данных список может быть либо пустым списком, либо списком из двух частей – элемента, на- зываемого «головой», и списка (возможно, пустого), называемого «хвостом». Пусть a – список в языке Python. Существует несколько способов проверить, пуст ли он. Например, условие a == [] возвращает True, если список пуст, и False в противном случае. Кроме того, голова списка – это просто a[0], тогда как хвост определяется как a[1:]. На- пишите альтернативную версию функции sum_list_length_2 из лис - тинга 1.5, которая, используя предыдущие элементы, избегает приме-нения функции len. Упражнение 1.8. Реализуйте три функции, вычисляющие сумму элементов списка чисел для каждой из трёх декомпозиций на рис. 1.6. Функции должны получать два входных параметра: список и его размер (длину) согласно сценарию на рис. 1.12(b). Кроме того, реализуйте вы-зов этих функций и вывод их результатов. Упражнение 1.9. Докажите методом математической индукции сле- дующее тождество для геометрических прогрессий, где n – положитель- ное целое число, а x ≠ 1 – некоторое вещественное число:\n--- Страница 51 ---\n50  Глава 1. Основные понятия рекурсивного программирования ∑− =− − =1 0)1 )/(1 (n in ix x x . Упражнение 1.10. Реализуйте пять рекурсивных функций из разде- ла 1.6 для вычисления чисел Фибоначчи F(n). Поскольку некоторые из них, помимо n, требуют ещё нескольких параметров или не вычисляют само число Фибоначчи, реализуйте дополнительные функции-оболоч- ки с параметром n, возвращающие сами числа Фибоначчи. Убедитесь, что они дают правильные результаты для n = 1, …, 10.",
      "debug": {
        "start_page": 19,
        "end_page": 51
      }
    },
    {
      "name": "Глава 2. Методика рекурсивного мышления 51",
      "content": "--- Страница 52 --- (продолжение)\nГлава 2 Методика рекурсивного мышления Наука гораздо больше совокупности знаний. Это – способ мышления. – Карл Сэгэн Декларативный подход – это возможность проектировать рекурсивные алгоритмы решения широкого спектра вычислительных задач, следуя систематическому подходу. Эта глава описывает обобщённый шаблон вывода рекурсивных решений из декларативной перспективы, которая раскладывает процесс рекурсивного мышления в последовательность шагов. Кроме того, глава предлагает несколько полезных схем, которые программисты могут использовать при проектировании рекурсивных условий. Они полезны, так как заставляют думать о декомпозиции за-дачи и об индукции – двух важнейших понятиях, лежащих в основе ре-курсивного (декларативного) мышления. Конечно, в некоторых случаях (например, при отладке) или для до- вольно сложных задач было бы полезно думать о деталях нижнего уровня, имея в виду последовательность действий, выполняемых ре-курсивными процедурами. Но, несмотря на это, мы отложим пока рас - смотрение этих низкоуровневых аспектов и сосредоточимся в этой гла-ве на высокоуровневом декларативном мышлении. 2.1. Шаблон проектирования рекурсивных алгоритмов Введённые в главе 1 рекурсивные функции, как и большинство алго- ритмов из последующих глав книги, могут быть спроектированы по\nГлава 2 Методика рекурсивного мышления Наука гораздо больше совокупности знаний. Это – способ мышления. – Карл Сэгэн Декларативный подход – это возможность проектировать рекурсивные алгоритмы решения широкого спектра вычислительных задач, следуя систематическому подходу. Эта глава описывает обобщённый шаблон вывода рекурсивных решений из декларативной перспективы, которая раскладывает процесс рекурсивного мышления в последовательность шагов. Кроме того, глава предлагает несколько полезных схем, которые программисты могут использовать при проектировании рекурсивных условий. Они полезны, так как заставляют думать о декомпозиции за-дачи и об индукции – двух важнейших понятиях, лежащих в основе ре-курсивного (декларативного) мышления. Конечно, в некоторых случаях (например, при отладке) или для до- вольно сложных задач было бы полезно думать о деталях нижнего уровня, имея в виду последовательность действий, выполняемых ре-курсивными процедурами. Но, несмотря на это, мы отложим пока рас - смотрение этих низкоуровневых аспектов и сосредоточимся в этой гла-ве на высокоуровневом декларативном мышлении. 2.1. Шаблон проектирования рекурсивных алгоритмов Введённые в главе 1 рекурсивные функции, как и большинство алго- ритмов из последующих глав книги, могут быть спроектированы по\n--- Страница 53 ---\n52  Глава 2. Методика рекурсивного мышления шаблону методики, изображённой на рис. 2.1. В этом шаблоне упор на декларативное мышление делается на шаге 4, поскольку метод индук - ции заставляет сосредоточиться на том, что делает алгоритм, а не как он это делает. Последующие разделы объясняют каждый шаг шаблона и предостерегают от распространённых ловушек и недоразумений. 1.Определить размер задачи. 2.Определить начальные условия. 3.Разложить вычислительную задачу на подобные ей подзадачи меньшего размера и, возможно, на другие дополнительные задачи. 4.Определить рекурсивные условия, опираясь на индукцию и схемы. 5.Протестировать код. Рис. 2.1. Общий шаблон проектирования рекурсивных алгоритмов 2.2. Размер задачи Естественно, первый шаг решения любой вычислительной задачи – по-нять её. Для его продолжения должны быть чётко определены заданные условия задачи, её входы (исходные данные), выходы (результаты) и от - ношения между ними. Независимо от типа разрабатываемого алгорит - ма крайне важно определить размер задачи (или её входной размер). Его следует понимать как математическое выражение, включающее в себя величины, связанные с входными параметрами, которые опреде-ляют сложность задачи с точки зрения числа операций, необходимых алгоритму для её решения. При применении рекурсии это особенно важно, так как начальные и рекурсивные условия явно зависят от него. Во многих задачах размер зависит лишь от одного фактора, коим мо- жет оказаться один из входных параметров. Например, размер задач, вычисляющих n-е число Фибоначчи, факториал n или сумму первых n положительных целых чисел (см. главу 1), – это и есть входной пара-метр n. Очевидно, что для таких задач решение меньших её экземпля- ров (например, для n – 1 или n/2) требует меньшего числа операций. В других случаях размер задачи может не задаваться явно входами, однако синтаксис и конструкции языка программирования позволяют рассчитать её размер. Например, при работе со списками размер задачи часто определяется их длиной, которая может быть получена вызовом функции len.\n--- Страница 54 ---\n2.2. Размер задачи  53 В других задачах размер может быть выражен как функция входных параметров. Рассмотрим, например, задачу вычисления суммы цифр некоторого положительного целого числа n. Хотя входным параметром является n, размер задачи вовсе не n, а количество цифр n, которое определяет количество выполняемых операций. Формально эта вели-чина может быть выражена как ⌊lg n⌋ + 1. Размер задачи может также зависеть от нескольких входных пара- метров. Рассмотрим задачу добавления в список элементов подсписка (см. листинг 1.6), заданного индексами «lower» и «upper». Решение зада-чи требует добавления n – m + 1 элементов, где n и m – верхний и ниж - ний индексы соответственно. Таким образом, необходимо произвести n – m добавлений. Небольшая (на единицу) разница между обоими вы- ражениями не имеет значения. Следует отметить, что для решения за-дачи не нужно знать, сколько именно операций будет выполнено. На-против, достаточно знать, когда будет достигнуто начальное условие и каким образом сокращать размер задачи, чтобы разложить её на мень- шие подзадачи. Для этой последней задачи размер сокращается за счёт уменьшения разности между n и m. Кроме того, размер задачи не всегда определяет количество выпол- няемых алгоритмом операций. Рассмотрим задачу сложения элемен-тов квадратной матрицы размером n×n. Поскольку она содержит n 2 эле- ментов, для суммирования потребуется n2 – 1 сложений, что является функцией n. Однако в этом случае размер задачи – просто n, а не n2, так как меньшие подзадачи возникают за счёт уменьшения n, а не n2. Если бы матрица была размером n×m, то размер задачи зависел бы от обо- их параметров n и m. В частности, размер задачи мог быть nm, и тогда подзадачи меньшего размера можно было получать уменьшением n, m или обоих сразу. Вообще говоря, размер – это свойство задачи, а не конкретного ал- горитма, который её решает. Поэтому это не фактическое количество вычислений, выполненных определённым алгоритмом, так как задачи могут быть решены различными алгоритмами, время выполнения ко-торых может варьироваться в широких пределах. Рассмотрим задачу поиска некоторого числа в сортированном списке из n чисел. В худ- шем случае (когда такого числа в списке нет и результатом будет False) она может быть решена бездумно за n шагов или более эффективно за ⌊log 2(n)⌋ + 1 шагов с использованием «двоичного поиска». Но независи- мо от используемого алгоритма функция, описывающая время его вы-полнения, зависит только от n. Таким образом, размер задачи – n.\n--- Страница 55 ---\n54  Глава 2. Методика рекурсивного мышления Однако для некоторых задач их размер может быть определён не- сколькими способами. Более того, выбор размера в процессе рекурсив- ной разработки влияет на остальную часть решения и в итоге приводит к различным алгоритмам решения задачи. Рассмотрим, например, за-дачу сложения двух неотрицательных целых чисел a и b с использова- нием только операций увеличения и уменьшения на единицу (см. раз-дел 4.1.2). Размер задачи может быть a + b, a, b или min(a, b), при этом конечные алгоритмы будут разными в зависимости от выбранного раз-мера задачи. 2.3. Начальные условия Начальные условия – это такие экземпляры задачи, для решения кото-рых не нужна рекурсия, точнее не нужны рекурсивные вызовы. В самом общем случае начальное условие – это наименьший экземпляр задачи, результат которой определяется тривиально, а иногда даже не требует вычислений. Например, значение первого и второго чисел Фибоначчи – это просто 1, что прямо следует из их определения. Очевидно, что «сум-ма» первого положительного целого числа есть 1. Аналогично, «сумма» цифр неотрицательного целого числа n из одной цифры (когда n < 10), очевидно, равна самой этой цифре (n). Заметьте, что эти функции в на-чальных условиях просто возвращают значение, не выполняя ни сложе-ния, ни других математических действий. Некоторые методы могут требовать нескольких начальных условий. Например, в формуле (1.2) для чисел Фибоначчи задано два начальных условия – одно для n = 1 и другое для n = 2. Так как оба начальных ус - ловия имеют одно и то же значение (1), функция в листинге 1.3 может использовать одно логическое выражение ((n == 1) or (n == 2)), объеди- няющее оба условия. Другие методы должны использовать каскадный оператор if, чтобы проверить каждое начальное условие. Например, функция (1.6) определяет одно начальное условие для n = 1 и другое для n = 2, так как они возвращают разные значения для каждого из входов. По этой причине соответствующий код в листинге 1.2 тоже разделяет эти два условия. Одно из достоинств рекурсивного программирования – лаконич- ность кода, что способствует его пониманию. В связи с этим рассмот - рим функцию вычисления факториала (1.3). Если начальные условия представляют собой тривиальные (наименьшие) экземпляры задачи, можно было бы потребовать, чтобы определение функции включало\n--- Страница 56 ---\n2.3. Начальные условия  55 также случай 1! = 1. Но значение 1! можно получить и из рекурсивного условия, так как 1! = 0! × 1 = 1 × 1 = 1. Следовательно, хотя 1! = 1 – оче-видно, верное начальное условие, его включение в формулу было бы из-быточным и потому необязательно. Кроме того, такие необязательные условия могут вводить в заблуждение, поскольку программисты, пыта-ющиеся понять рекурсивный код, могут посчитать их необходимыми для получения правильного результата функции. Таким образом, ради краткости и ясности обычно рекомендуется включать наименьшее ко-личество начальных условий, приводящих к правильным рекурсив-ным определениям. Наконец, избыточные начальные условия обычно не оказывают существенного влияния на эффективность рекурсивной программы. В общем, если они и могут сократить количество вызовов рекурсивной функции для некоторых входных значений, то сэконом-ленное время вычисления зачастую незначительно. Например, если 1! включён в начальные условия в функцию вычисления факториала, то рекурсивный процесс выполнит лишь на один рекурсивный вызов меньше, что едва ли повлияет на время его выполнения. Кроме того, коду потребовались бы две проверки условия, и он мог бы стать даже менее эффективным, чем тот, где оба условия вычислялись бы до пере-хода к рекурсивному условию. На примере функции вычисления факториала листинг 2.1 иллюстри- рует эту и другие основные ловушки, касающиеся начальных условий. Во-первых, метод вычисления факториала обеспечивает безупречную реализацию математической функции. Метод factorial_redundant правилен, так как даёт правильный результат для любого неотрица-тельного целочисленного входного параметра. Однако он содержит до-полнительное начальное условие – совершенно ненужное. Кроме того, мы должны также добиваться общности – крайне жела- тельного свойства программ. Общие функции – это такие функции, ко- торые работают правильно в широком диапазоне входных параметров и потому более применимы и полезны. Функция вычисления факто- риала (1.3) имеет своим входным параметром неотрицательное целое число и определяется так, чтобы быть применимой не только к каждому положительному целому числу, но также и к нулю. Замена начального условия 0! = 1 на 1! = 1 привела бы к менее общей функции, так как она не была бы определена для n = 0. Метод factorial_missing_base_case реализует такую функцию. Если бы она была вызвана с входным па-раметром n = 0, она не дала бы правильного результата, погрузившись в бездну бесконечной рекурсии. А именно factorial_missing_base_\n--- Страница 57 ---\n56  Глава 2. Методика рекурсивного мышления case(0) вызвала бы factorial_missing_base_case(-1) , которая, в свою очередь, вызовет factorial_missing_base_case(-2) и т. д. На прак - тике такой процесс (после выполнения большого количества вызовов функции) обычно останавливается с сообщением об ошибке времени выполнения программы (вроде «Переполнение стека» или «Превышена предельная глубина рекурсии»). Наконец, метод factorial_no_base_ case всегда приводит к бесконечной рекурсии, так как не имеет началь- ного условия и потому никогда не остановится. Листинг 2.1. Неправильные представления начальных условий для функции вычисления факториала 1 234567891011121314151617181920212223def factorial(n): if n == 0: return 1 else: return factorial(n – 1) * n def factorial_redundant(n): if n == 0 or n == 1: return 1 else: return factorial_redundant(n – 1) * n def factorial_missing_base_case(n): if n == 1: return 1 else: return factorial_missing_base_case(n – 1) * n def factorial_no_base_case(n): return factorial_no_base_case(n – 1) * n Для многих задач существуют такие экземпляры, результат которых можно получить без использования рекурсии, даже если их размер до- статочно велик. Рассмотрим, например, задачу поиска некоторого эле-мента в списке. Размер задачи определяется множеством элементов списка. Первое начальное условие отвечает пустому списку (наимень-шему экземпляру задачи нулевого размера), когда результат – очевид-но, False. Кроме того, алгоритм может определять положение (скажем,\n--- Страница 58 ---\n2.4. Декомпозиция задачи  57 в начале, в середине или в конце) найденного элемента списка и не- медленно выдавать значение True, даже если список огромен (глава 5 посвящена этому виду поисковых задач). В обоих случаях нет никакой необходимости в дальнейшем выполнении рекурсивных вызовов. 2.4. Декомпозиция задачи Следующий шаг рекурсивной методики состоит в выявлении подзадач, подобных, но меньших исходной (и, возможно, других разнообразных задач), как показано на рис. 1.4. Эти меньшие подзадачи будут исполь-зоваться на шаге 4 шаблона проектирования для определения рекур-сивных условий. Процесс заключается в уменьшении размера задачи с целью определить её меньшие экземпляры и тем самым приблизить её к начальным условиям. Поэтому перед продолжением этого шага важно правильно установить размер задачи и ее начальные условия. Многие рекурсивные решения уменьшают размер задачи на 1 или делят его надвое, как показано на рис. 1.5 и 1.6. Представление задач в виде схем полезно и очень рекомендуется, так как они помогают на-глядно распознать подобные исходной подзадачи, то есть рекурсию, и могут также облегчить определение рекурсивных условий. На рис. 2.2 приведены дополнительные схемы, иллюстрирующие декомпозицию задачи суммирования первых положительных целых чисел, когда раз-мер задачи уменьшается на 1. Во-первых, поскольку рекурсия – это математическая функция, кото- рая может быть выражена формулой, мы можем просто развернуть вы-ражение так, чтобы идентифицировать исходную задачу и соответству - ющую подзадачу, как показано на рис. 2.2(a). На рис. 2.2(b) схема также содержит формулу, но использует вместо фигурных скобок поля, заклю-чающие формулы. В этом случае более темный внешний блок представ-ляет полную задачу, тогда как вложенный в него более светлый блок обо-значает подзадачу. Схема на рис. 2.2(c) подобна схеме на рис. 2.2(b), но задача состоит в добавлении кружочков, выстроенных треугольником. Наконец, на рис. 2.2(d), чтобы показать задачу и подзадачу, суммируе-мые числа размещены в сопоставимых друг с другом прямоугольниках. Эти довольно простые схемы целесообразны, поскольку позволяют обнаружить подзадачу внутри исходной задачи. При этом крайне важно подчеркнуть, что подзадача уже не делится на более мелкие. Например, сумма n – 2 положительных целых чисел не появляется явно как подза- дача ни в одной из схем. Иными словами, схемы не должны показывать вложенность или древовидность подзадач. В этом – одна из основных\n--- Страница 59 ---\n58  Глава 2. Методика рекурсивного мышления ловушек рекурсивного подхода, а также источник недоразумений. На рис. 2.3(a) и 2.3(c) показаны правильные декомпозиции задачи сумми-рования первых n положительных целых чисел (S(n)). Напротив, хотя вложенные подзадачи на рис. 2.3(b) или (унарное) дерево рекурсивных вызовов на рис. 2.3(d) правильно отражают задачу, они содержат допол-нительные подзадачи (S(1), S(2), , S(n – 2)), которых нет в рекурсивном определении (1.5). Поэтому такие подзадачи во избежание путаницы должны удаляться из схем и, следовательно, из самого рекурсивного процесса. Тем не менее вложенные и древовидные схемы могут быть полезными для других задач. Стремление избежать вложенных схем не означает, что необходимо рассматривать только одну подзадачу. Многие рекурсивные опреде-ления требуют разложения исходной задачи на множество подзадач. Например, на рис. 2.4 приведены две схемы декомпозиции функции Фибоначчи. В частности, вариант (a) соответствует определению (1.2), а вариант (b) – определению (1.7). Несмотря на то что в схеме (b) пока-заны все подзадачи от F(1) до F(n – 2), такое представление допустимо, так как эти подзадачи не являются вложенными. В большинстве задач этой книги размер будет зависеть только от одного параметра или фактора, но в некоторых он будет зависеть от нескольких параметров. Например, матричные задачи обычно зависят от высоты (количества строк) и ширины (количества столбцов) матри-цы. Поэтому задачи меньшего размера могут стать результатом умень-шения одного или обоих из этих параметров. В частности, многие ре-курсивные алгоритмы делят матрицы на блоки – подматрицы. Такие «блочные матрицы» можно интерпретировать как исходную матрицу с вертикальными и горизонтальными разделителями, как показано в следующем примере с матрицей размером 4×7: A =     =    0945136841235057133279430123 2,2 121,2 1,1 AAAA ,, где A1,1 =     327213 , A1,2 =     57139430 , A2,1 =     136350 , A2,2 =    09458412 .\n--- Страница 60 ---\n2.4. Декомпозиция задачи  59 Исходная задача (a) (b) (c) n – 1 (d)1 + 2 + 3 + + (n – 2) + (n – 1) + n Исходная задачаИсходная задачаПодзадача Подзадача Подзадача ПодзадачаИсходная задача1 + 2 + 3 + + (n – 2) + (n – 1) + n 1 23 (n – 2) (n – 1) n n1 2 3 n – 2 n – 1 1 2 3 n – 2 Рис. 2.2. Дополнительные схемы, иллюстрирующие декомпозицию суммы первых n положительных целых чисел с уменьшением размера задачи на единицу\n--- Страница 61 ---\n60  Глава 2. Методика рекурсивного мышления (a) (b) (c) (d)S(n – 1) S(n) S(n – 1) S(n – 1) S(n – 1) S(n) S(n) S(n)S(1) S(1)S(2) S(3) S(3) S(2) Рис. 2.3. При рекурсивном подходе обычно нет нужды представлять декомпозицию задачи всеми её экземплярами меньшего размера Здесь число строк и столбцов каждой подматрицы получено целочис - ленным делением на два исходных высоты и ширины матрицы. Что касается эффективности метода деления размера задачи попо- лам, то он может приводить к более быстрым алгоритмам, чем посте- пенное уменьшение размера на 1. Поэтому такую стратегию нужно иметь в виду вообще и в особенности тогда, когда теория показывает возможное снижение стоимости вычислений алгоритма по сравнению с уменьшением размера задачи на единицу. Однако деление размера задачи пополам не всегда приводит к приемлемому рекурсивному ал-  \n--- Страница 62 ---\n2.5. Рекурсивные условия, индукция и схемы  61 горитму. Например, трудно получить простую рекурсивную формулу для функции n! с использованием подзадачи (n/2)!. (a) (b)F(n – 1) 1 F(1) F(2) F(3)Исходная задача: F(n) Исходная задача: F(n)F(n – 2) F(n – 2) Рис. 2.4. Декомпозиции функции Фибоначчи 2.5. Рекурсивные условия, индукция и схемы Следующий шаг в шаблоне проектирования рекурсивных алгоритмов состоит из определения рекурсивных условий, одна из целей которо-го – понять, как построить полное решение исходной задачи, исполь-зуя решения подобных ей подзадач, определённых на этапе декомпо-зиции. Как сказано в разделе 1.4, согласно методу индукции мы можем считать, что эти более простые решения готовы к использованию. Та-ким образом, главная проблема рекурсивного подхода – определить, как изменить, расширить или объединить решения подзадач, чтобы на последнем шаге схемы на рис. 1.4 получить полное решение исходной задачи. 2.5.1. Рекурсивное мышление посредством схем Часто полезно представить мыслительный процесс или «мысленную модель» вывода рекурсивных условий в виде схемы. На рис. 2.5 приве-дена общая процедура рекурсивного мышления, когда декомпозиция задачи приводит к единственной, подобной ей подзадаче. Процесс начинается с рассмотрения основного экземпляра задачи некоторого размера, определяемого входными параметрами, изобра-женными в верхнем левом блоке. Применение рекурсивного метода к этим параметрам должно привести к результатам, представленным в\n--- Страница 63 ---\n62  Глава 2. Методика рекурсивного мышления верхнем правом блоке. Отметим, что этот верхний ряд блоков – просто ещё один способ определения условий задачи. Для определения рекур-сивных условий мы сначала выбираем некоторую декомпозицию, при-водящую к меньшему экземпляру задачи. Новые, более простые пара-метры для подзадачи, подобной исходной, показаны в левом нижнем блоке. Рекурсивный вызов метода с этими параметрами должен, таким образом, выдать результаты (правый нижний блок), которые получают - ся применением условий задачи к более простым входным параметрам. И наконец, поскольку согласно методу индукции эти результаты следу - ет считать правильными, мы выводим рекурсивные условия с учётом изменений или расширений, позволяющих добиться общего решения исходной задачи (верхний правый блок). ИндукцияВходные параметры ПодзадачаУпрощённые параметрыУпрощённое решениеРезультаты Вывод рекурсивных условийРешениеРекурсивный метод Задача ДекомпозицияВходы Рекурсивный метод Рис. 2.5. Общая схема обдумывания рекурсивных условий (когда декомпозиция задачи приводит к единственной, подобной ей подзадаче) Для суммы первых n положительных целых чисел (S(n)) схема может быть такой: Входы Результаты + ns1 + 2 + + (n – 1) + n = S(n) n n – 1 1 + 2 + + (n – 1) = S(n – 1)s Для начала можно выбрать декомпозицию уменьшением размера задачи на единицу. Цель такой частной декомпозиции – выяснить, как можно получить S(n), изменив или расширив решение подзада-\n--- Страница 64 ---\n2.5. Рекурсивные условия, индукция и схемы  63 чи S(n – 1). В этом случае легко видеть, что S(n) получается добав- лением n к S(n – 1). Поэтому рекурсивное условие определяется как S(n) = S (n – 1) + n . Важно понимать, что нам нужно всего лишь определить декомпози- цию и установить, как получить результат исходной задачи, используя результат подзадачи. Следовательно, нам нужно думать только о про-цессах, обозначенных на схеме толстыми стрелками. С другой стороны, тонкие стрелки обозначают лишь итог решения отдельных экземпля-ров задачи (для различных входных параметров), который полностью определен условиями задачи. Отметим, что здесь не принимается ни-каких алгоритмических проектных решений об отношении между вхо-дом и выходом, поскольку они задаются условиями задачи. Достоинство схемы на рис. 2.5 – в её общности: её можно применять к многочисленным задачам для получения рекурсивных решений. По-этому объяснения большинства примеров из этой книги опираются именно на неё. Конечно, не исключено применение и других графи-ческих представлений, таких как на рис. 1.5, 1.6 и 2.2. Такая альтер-нативная визуализация особенно полезна, поскольку она показывает не только подзадачи, но и их связь с исходной задачей, что помогает объединять, расширять или изменять решения подзадач ради решения исходной задачи. Другими словами, они дают наглядное представле-ние о том, как определить рекурсивные условия. Например, из схемы на рис. 2.2 очевидно, что решение задачи заключается в добавлении n к результату подзадачи размера n – 1. Конечно, более сложные схемы, специально приспособленные для от - дельных задач, могут помочь найти различные декомпозиции, которые могли бы в конечном счете привести к более эффективным алгорит - мам. Например, представление суммы первых n положительных целых чисел в виде блоков, выложенных треугольными пирамидами, как на рис. 1.5, позволяет легко вывести рекурсивные условия, когда размер подзадач равен примерно половине исходного. Во-первых, напомним, что задачу можно свести к подсчёту числа блоков в треугольной струк - туре. Кроме того, поскольку представление позволяет наложить поверх исходной задачи несколько подзадач (то есть меньшие треугольные структуры) одновременно, визуализация показывает, как «заполнить» бóльшую пирамиду меньшими. Поэтому схемы иллюстрируют, как по-лучить рекурсивные условия путём сложения результатов (в данном случае – количество блоков) меньших подзадач. Например, на рис. 1.5(c) для получения результата исходной задачи нужно сложить результаты трёх подзадач размера n/2 и результат подзадачи размера n/2 – 1.\n--- Страница 65 ---\n64  Глава 2. Методика рекурсивного мышления Тем не менее рекурсивное решение методом деления размера задачи S(n) пополам можно вывести и из общей схемы на рис. 2.5. В этом случае мы имеем: Входы Результаты ?s1 + 2 + + (n/2) + (n/2 + 1) + + n = S(n) n n/2s 1 + 2 + + (n/2) = S(n/2) Однако здесь возникает вопрос: как (если это возможно) получить S(n) путём изменения или расширения S(n/2). Первая очевидная идея приводит к S(n) = S(n/2) + (n/2 + 1) + … + n. И хотя она правильная, её реа- лизация потребует использования либо цикла, либо другой рекурсив-ной функции для вычисления суммы последних n/2 членов. Отметим, что на этапе построения функции (S) получить сумму (n/2 + 1) + … + n рекурсивным обращением к ней же невозможно, так как эта сумма не является экземпляром исходной задачи. Однако её можно преобразо-вать, например таким образом: ( n/2 + 1) + (n/2 + 2) + … + (n/2 + n/2) = (n/2) 2 + (1 + 2 + … + n/2) = = (n/2)2 + S(n/2). Она не только упрощает выражение, но и содержит S(n/2), чем можно воспользоваться для получения гораздо более простого рекурсивного условия: S(n) = S(n/2) + (n/2 + 1) + … + n = S(n/2) + S(n/2) + (n/2) 2 = = 2S(n/2) + (n/2)2. (2.1) Теперь общую схему можно изобразить следующим образом: Входы Результаты × 2 + (n/2)2s1 + 2 + + (n/2) + (n/2 + 1) + + n = S(n) n n/2s 1 + 2 + + (n/2) = S(n/2)\n--- Страница 66 ---\n2.5. Рекурсивные условия, индукция и схемы  65 Из неё следует, что S(n) может быть получена умножением результата S(n/2) на 2 и добавлением к нему (n/2)2. Хотя декомпозиция задачи при- водит к единственной подзадаче (S(n/2)), этот пример показывает, что для решения исходной задачи результат её подзадачи может использо-ваться несколько раз. В данном случае можно считать, что рекурсивное условие использует S(n/2) дважды. Это рекурсивное условие можно также получить из схемы на рис. 2.6, где S(n) изображается в виде треугольной пирамиды и тем самым до- казывается, что S(n) = 2 S(n/2) + (n/2) 2. Естественность такой схемы, где решение задачи сводится к сложению блоков, облегчает получение ре-курсивных условий. (a) (b)Исходная задача: S(n) n/2 n/2nS(n) = 2S(n/2) + (n/2)2 Рис. 2.6. Схема декомпозиции задачи о сумме первых n положительных целых чисел S(n), использующая две подзадачи в половину размера исходной 2.5.2. Конкретные экземпляры задачи В предыдущем примере сложения первых n положительных целых чисел результат рекурсивного метода легко выразить в виде общей функции от входного параметра n. Иными словами, выражения из пра- вой части общей схемы здесь получаются легко. Однако в других за-дачах описать результаты рекурсивных методов (скажем, некоторой формулой) гораздо сложнее, и потому труднее понять, как вывести ре-шение задачи из результатов её подзадач. В таких случаях на первых порах полезен подход, заключающийся в анализе конкретных экзем-пляров задачи. Рассмотрим задачу сложения цифр некоторого неотрицательного целого числа n и допустим, что выбрана декомпозиция, уменьшающая количество цифр на 1 за счёт отбрасывания наименьшей значащей цифры исходного числа. Эта информация представлена в левых бло-ках общей схемы. Однако определение выхода, как и функции от n, в\n--- Страница 67 ---\n66  Глава 2. Методика рекурсивного мышления правых блоках схемы может оказаться сложным. Например, его можно описать следующей суммой: 10log 0( //10 )%10n i in =∑ . (2.2) Несмотря на то что мы могли бы использовать эту формулу для вы- вода рекурсивных условий, мы продолжим анализировать конкретные экземпляры задачи. Например (ради простоты можно отказаться от использования имени метода в колонке результатов и от маркировки стрелок): + 2n = 5342Входы Результаты Входы Результатыn//10 = 53414 12 + 9n = 879 n//10 = 8724 15 Из этих схем нетрудно видеть, что результат метода – это сумма по- следней (подчеркнутой) цифры исходного числа и результата подзада-чи. 2.5.3. Альтернативные обозначения Другой подход заключается в использовании некоторых альтерна- тивных общих обозначений, которые упрощают создание схем. Пусть d m–1…d1d0 – последовательность цифр некоторого неотрицательного целого числа n по основанию 10. Иными словами, n = dm–1 · 10m–1 + … + d1 · 10 + d0, где 0 ≤ di ≤ 9 для всех i и dm–1 ≠ 0, если m > 1. В этом случае общая схема была бы такой:\n--- Страница 68 ---\n2.5. Рекурсивные условия, индукция и схемы  67 Входы Результаты + d0 n//10 = dm–1…d1n = dm–1 … d1d0dm–1 + … + d1 + d0 dm–1 + … + d1 а код функции был бы таким, как показано в листинге 2.2, где (n%10) представляет d0. Отметим, что начальное условие этой задачи выпол- няется, когда n состоит из одной цифры (то есть n < 10), а его результат, очевидно, равен n. Листинг 2.2. Вычисление суммы цифр неотрицательного целого числа 1 2345def add_digits(n): if n < 10: return n else: return add_digits(n // 10) + (n % 10) И наконец, на практике для более сложных задач может потребовать- ся анализ многих примеров и сценариев (например, разделять чётные или нечётные входные параметры), приводящих к различным рекур-сивным условиям. 2.5.4. Процедуры До сих пор нам могло показаться, что если результат определяется формулой, то методу всегда соответствует функция, возвращающая значение. И потому он может использоваться в выражениях других ме-тодов, куда возвращает определённое значение от заданных входных параметров. Однако в некоторых языках программирования (напри-мер, в Паскале) существуют методы, называемые «процедурами», кото-рые не возвращают значений. Вместо этого они могут изменять струк - туры данных, передаваемые методу в качестве аргументов, или просто отображать некоторую информацию на экране. Оказывается, что и в таких случаях также можно пользоваться общей схемой декомпозиции задачи. Рассмотрим задачу вывода на экран цифр некоторого неотрицатель- ного целого числа n – по вертикали и в обратном порядке. То есть наи-\n--- Страница 69 ---\n68  Глава 2. Методика рекурсивного мышления меньшая значащая цифра должна появиться в 1-й строке, следующая – во 2-й и т. д. Например, если n = 2743, программа должна вывести на экран следующие строки: Во-первых, размер этой задачи – количество цифр в числе n. Началь- ное условие выполняется, когда n состоит из одной цифры (n < 10), и алгоритм просто должен вывести n. Как в предыдущем примере, самая простая декомпозиция рассматривает n//10 с отбрасыванием из исход-ного числа наименьшей значащей цифры. На рис. 2.7 показана возмож - ная схема декомпозиции задачи. (a) (b) Рис. 2.7. Схема декомпозиции задачи вывода на экран цифр неотрицательного целого числа – вертикально и в обратном порядке: (a) – частный случай (n = 2743), (b) – общий случай числа из m цифр (n = dm–1 … d1d0) Кроме того, для такого типа процедур также применима общая схема: n = 2743Входы Результаты n//10 = 2743¶4¶7¶2¶ 3¶ 4¶7¶2¶ 4¶7¶2¶4¶ 7¶2¶3¶ d0¶ d1¶  dm–1¶ print(3) (перед)\n--- Страница 70 ---\n2.5. Рекурсивные условия, индукция и схемы  69 В этом примере результатом являются не столько сами числовые зна- чения, сколько последовательность команд вывода строк на экран. Для такой задачи решением будет вывод на экран наименьшей значащей цифры исходного числа с последующим рекурсивным вызовом мето-да для оставшихся цифр. При этом крайне важна последовательность выполнения этих операций. В частности, наименьшая значащая циф-ра должна быть выведена до вывода остальных. Соответствующий код приведён в листинге 2.3. Листинг 2.3. Вывод на экран цифр неотрицательного целого числа – вертикально и в обратном порядке 1 23456def print_digits_reversed_vertically(n): if n < 10: print n else: print (n % 10) print_digits_reversed_vertically(n // 10) 2.5.5. Несколько подзадач Некоторые алгоритмы требуют разбиения исходной задачи на не- сколько подобных ей подзадач, а процесс осмысления рекурсивных условий подобен изображённому на рис. 2.5. Как показано на рис. 2.8, схемы просто должны включать различные подзадачи и соответствую-щие им решения согласно выбранной декомпозиции. В таких случаях, помимо расширения и изменения решения каждой из подзадач, рекур-сивные условия обычно должны ещё и объединять их. Для заданного непустого списка из n целых чисел (n ≥ 1) рассмотрим задачу поиска в нём наибольшего значения. В этом примере мы раз-делим размер задачи пополам так, чтобы работать с одной и с другой половинами списка, как показано на рис. 1.6(d). Следующая схема ил-люстрирует процесс осмысления задачи на конкретном примере: [5, –1, 3, 2, 4, 7, 2]Входы Результаты max (5, 7) [5, –1, 3,] [2, 4, 7, 2]5 77\n--- Страница 71 ---\n70  Глава 2. Методика рекурсивного мышления ИндукцияВходные параметры Подзадача #1Упрощённые параметры #1Упрощённое решение #1Результаты Вывод рекурсивных условийРешениеРекурсивный метод Задача ДекомпозицияВходы Рекурсивный метод Рекурсивный метод Подзадача #NУпрощённые параметры #NУпрощённое решение #N Рис. 2.8. Общая схема осмысления рекурсивных условий, когда задача разбивается на несколько (N) себе подобных подзадач Толстые и тонкие стрелки обозначают решения задач и подзадач, со- ответственно. На рис. 2.9 представлена альтернативная схема декомпозиции и про- цесс рекурсивного осмысления задачи. Рис. 2.9. Альтернативная схема декомпозиции методом «разделяй и властвуй» и процесс осмысления задачи поиска наибольшего значения в списке В каждом из вариантов рекурсивный вызов возвращает наибольшее значение в каждой половине. Поэтому рекурсивное условие может воз- вращать просто максимальное значение из двух половин. Рекурсивная функция (f) определена следующим образом: [0], 1,( ) max ( ( [0 : //2]), ( [ //2 : ])), 1.nff n fn n n= => aaaa (2.3) В листинге 2.4 приводятся два способа кодирования функции. Вер- сия, использующая границы lower и upper , обычно быстрее. Конечно, эта задача допускает также рекурсивные решения на основе единствен-если если3 4 2 5 – 1 7 2\n--- Страница 72 ---\n2.6. Тестирование  71 ной подзадачи, размер которой уменьшается на 1. Этот подход столь же эффективен, как метод «разделяй и властвуй», но на практике может привести к ошибкам времени выполнения программы для больших списков. Листинг 2.4. Вычисление максимального значения в списке методом «разделяй и властвуй» 1 234567891011121314151617181920212223242526def max_list_length_DaC(a): if len(a) == 1: return a[0] else: middle len(upper + lower) // 2 m1 = max_list_length_DaC(a[0:middle) m2 = max_list_length_DaC(a[middle:len(a)) return max(m1, m2) def max_list_limits_DaC(a, lower, upper): if lower == upper: return a[lower] # or a[upper] else: middle = (upper + lower) // 2 m1 = max_list_limits_DaC(a, lower, upper) m2 = max_list_limits_DaC(a, middle + 1, upper)) return max(m1, m2) # Some list: v = [5, –1, 3, 2, 4, 7, 2] # Function calls: print (max_list_length_DaC(v)) print (max_list_limits_DaC(v, 0, len(v) – 1) 2.6. Т естирование Тестирование – основной этап в любом процессе разработки программ- ного обеспечения. В контексте данной книги его основная цель – об-наружение ошибок в коде. Таким образом, тестирование – это отладка разработанного программного обеспечения на различных экземплярах (различных входных параметрах) задачи с целью обнаружения непо-\n--- Страница 73 ---\n72  Глава 2. Методика рекурсивного мышления ладок. Начинающим программистам рекомендуется тестировать свой код, так как способность находить и исправлять ошибки (например, с помощью отладчика) является основным навыком программиста. Кро-ме того, тестирование – это ценнейший опыт по устранению ловушек и созданию более эффективного и надёжного кода. Помимо проверки правильности начальных и рекурсивных условий, при тестировании рекурсивного кода программисты должны обращать особое внимание на возможные сценарии, приводящие к бесконечным рекурсиям. Обычно они возникают из-за недостаточных начальных ус - ловий или из-за ошибочных рекурсивных условий. Рассмотрим, напри-мер, функцию из листинга 2.5. Листинг 2.5. Неправильный код для определения чётности неотрицательного целого числа n 1 2345def is_even_incorrect(n): if n == 0: return True else: return is_even_incorrect(n – 2) Её цель – определить, является ли некоторое неотрицательное целое число n чётным. И начальные, и рекурсивные условия верны. Конечно, если число n – чётное, значит, (n – 2) – тоже чётное, и функция должна вернуть для обоих целых чисел одно и то же логическое значение. Од- нако is_even_incorrect работает только для чётных чисел. Пусть f(n) обозначает is_even_incorrect(n) , тогда вызов f(7) приведёт к следую- щей цепочке рекурсивных вызовов: f(7) → f(5) → f(3) → f(1) → f(–1) → f(–3) → …, что является бесконечной рекурсией, так как процесс не останавлива-ется на начальном условии. То, что функция не имеет начального усло-вия, возвращающего False, – это сигнал о том, что её нужно исправить (однако не все логические функции требуют двух начальных условий для возвращения True или False соответственно). В данном случае ме-тод можно исправить, добавив в него ещё одно начальное условие. В листинге 2.6 приведена функция, работающая для любого допусти-мого параметра (n ≥ 0).\n--- Страница 74 ---\n2.6. Тестирование  73 Листинг 2.6. Правильный код для определения чётности неотрицательного целого числа n 1 234567def is_even_correct(n): if n == 0: return True elif n == 1: return False else: return is_even_correct(n – 2) Другой пример – функция из листинга 2.7, которая для вычисления суммы первых n положительных целых чисел (S(n)) использует рекур- сивное условие (2.1). Листинг 2.7. Ошибочное суммирование первых n положительных целых чисел, порождающее бесконечную рекурсию для большинства значений n 1 2345def sum_first_naturals_3(n): if n == 1: return 1 else: return 2 * sum_first_naturals_3(n / 2) + (n / 2)**2 Оно – неполное и генерирует бесконечную рекурсию для значений n, не являющихся степенью двух. Во-первых, поскольку язык Python счи- тает n вещественным числом, n/2 – тоже вещественное число. Поэто- му если параметр n окажется нечётным в каком-нибудь рекурсивном вызове функции, то n/2 будет иметь дробную часть, и такими же будут аргументы последующих рекурсивных вызовов. Таким образом, алго-ритм не остановится в начальном условии при n = 1 (которое является целым числом без дробной части) и продолжит вызывать функции с меньшими и меньшими аргументами. Например, пусть f(n) – это sum_ first_naturals_3(n) . Вызов f(6) порождает следующую цепочку рекур- сивных вызовов: f(6) → f(3) → f(1.5) → f(0.75) → f(0.375) → f(0.1875) → …, которая никогда не прервётся на начальном условии. Алгоритм работа-ет лишь в одном случае – когда первый параметр n является степенью двух, поскольку каждое деление на два даёт чётное число, и по дости-жении n = 2 мы получим n = 1, для которого функция может, наконец, вернуть вместо очередного вызова самой себя конкретное значение.\n--- Страница 75 ---\n74  Глава 2. Методика рекурсивного мышления Метод sum_first_naturals_3 работает неправильно, потому что его аргументы – вещественные числа. Таким образом, можно заменить ве- щественное деление целочисленным, как в листинге 2.8, что сделает ар-гументы целочисленными и предотвратит бесконечную рекурсию. Листинг 2.8. Неполный код при сложении первых n положительных чисел 1 2345def sum_first_naturals_4(n): if n == 1: return 1 else: return 2 * sum_first_naturals_4(n // 2) + (n // 2)**2 Однако и после этого функция все ещё будет работать неправильно для тех аргументов, которые не являются степенью двух. Проблема в том, что sum_first_naturals_4 – тоже неполная. В частности, несмотря на правильность рекурсивного условия, оно применимо только к чёт - ным значениям n. На рис. 2.10 показано, как в декомпозиции задачи получить рекурсивное условие S(n) = 2 S((n – 1)/2) + ((n + 1)/2)2 для нечёт - ных n. (a) (b)Исходная задача: S(n) (n–1)/2 (n+1)/2nS(n) = 2S((n–1)/2) + ((n+1)/2)2 Рис. 2.10. Схема декомпозиции суммы первых n положительных целых чисел S(n) на две подзадачи (примерно) в половину размера исходной для нечётных значений n Следовательно, окончательная функция: 2 21, 1, ( ) 2 ( /2) ( /2) , 1 2 (( 1)/2 (( 1)/2) , 1n Sn Sn n n Sn n n=  =× + >  × − ++ > а соответствующий код – в листинге 2.9.если если еслии n – чётное, и n – нечётное,\n--- Страница 76 ---\n2.7. Упражнения  75 Листинг 2.9. Сумма первых n положительных чисел с двумя подзадачами, размером (примерно) в половину исходной 1 2345678def sum_first_naturals_5(n): if n == 1: return 1 elif n % 2 == 0: return 2 * sum_first_naturals_5(n / 2) + (n / 2)**2 else: return (2 * sum_first_naturals_5(n – 1) / 2) + (n + 1) / 2)**2) При новом рекурсивном условии каждый, начиная с исходного, аргу - мент функции sum_first_naturals_5 также будет целым числом. В ито- ге замена вещественного деления (/) целочисленным (//) также приво- дит к правильному алгоритму. 2.7. Упражнения Упражнение 2.1. Пусть n – некоторое положительное целое число. Рассмотрим задачу подсчёта количества единичных разрядов в двоич-ном представлении n (то есть по основанию 2). Например, для n = 25 10 = 110012 (нижний индекс указывает основание системы счисления) ре- зультат содержит три единичных разряда. Определите размер задачи и его математическое выражение. Упражнение 2.2. Рассмотрим функцию суммирования первых n по- ложительных целых чисел (1.5). Определите обобщённую функцию, которая применима также ко всем неотрицательным целым числам. Другими словами, измените функцию с учётом того, что она может по-лучать в качестве аргумента n = 0. После этого закодируйте функцию. Упражнение 2.3. Примените схемы, подобные схемам на рис. 2.6 и 2.10, для вывода рекурсивных определений суммы первых n поло- жительных целых чисел (S (n)), когда рекурсивное условие суммирует результаты четырёх подзадач (примерно) в половину размера ис - ходной. После этого определите и закодируйте полную рекурсивную функцию. Упражнение 2.4. Рассмотрим задачу вывода на экран цифр некото- рого неотрицательного целого числа n вертикально в прямом поряд- ке, где старший разряд должен появиться в 1-й строке, следующий за\n--- Страница 77 ---\n76  Глава 2. Методика рекурсивного мышления ним – во 2-й и т. д. Например, если n = 2743, программа должна выдать на экран следующие строки: Определите размер задачи и её начальное условие. Для иллюстрации декомпозиции задачи приведите её схему для любого неотрицательно- го входа – целого числа n = dm–1 … d1d0, где m – количество цифр n, и пока- жите на схеме, как получить решение задачи по результату её подзада-чи. В заключение выведите рекурсивное условие и закодируйте метод. Упражнение 2.5. Используя принцип «разделяй и властвуй», опреде- лите общую схему задачи поиска наибольшего значения в списке из n элементов. Используйте соответствующие общие обозначения вместо конкретных примеров. Упражнение 2.6. Определите рекурсивную функцию, вычисляющую наибольшее значение в списке из n элементов, когда декомпозиция просто уменьшает размер задачи на 1.2¶7¶4¶3¶",
      "debug": {
        "start_page": 52,
        "end_page": 77
      }
    },
    {
      "name": "Глава 3. Анализ времени выполнения рекурсивных алгоритмов 77",
      "content": "--- Страница 78 --- (продолжение)\nГлава 3 Анализ времени выполнения рекурсивных алгоритмов Чем быстрее идёшь, тем меньше становишься. – Альберт Эйнштейн Анализ алгоритмов – область, изучающая теоретическую оценку ресур- сов, необходимых алгоритму для решения вычислительной задачи. Эта глава посвящена анализу времени выполнения или «временнóй вычис - лительной сложности» рекурсивных алгоритмов решения задач, размер которых зависит от единственного фактора (который присутствует в большинстве задач этой книги). Она охватывает практически весь спектр математических средств, необходимых для оценки и сравнения эффек - тивности различных алгоритмов. В частности, в главе приводятся два метода решения рекуррентных соотношений – рекурсивных матема-тических функций, описывающих стоимость вычисления рекурсивных алгоритмов. Эти методы используются для преобразования рекуррент - ных соотношений в эквивалентные нерекурсивные формулы, которые проще понять и сравнить. Кроме того, в главе приводится краткий об-зор основных математических понятий и обозначений, используемых при анализе алгоритмов. Анализу затрат памяти или пространственной сложности рекурсивных алгоритмов будет посвящена глава 6. 3.1. Предварительные математические соглашения Этот раздел представляет собой краткое введение в основные матема- тические определения и свойства, используемые при анализе вычисли-\nГлава 3 Анализ времени выполнения рекурсивных алгоритмов Чем быстрее идёшь, тем меньше становишься. – Альберт Эйнштейн Анализ алгоритмов – область, изучающая теоретическую оценку ресур- сов, необходимых алгоритму для решения вычислительной задачи. Эта глава посвящена анализу времени выполнения или «временнóй вычис - лительной сложности» рекурсивных алгоритмов решения задач, размер которых зависит от единственного фактора (который присутствует в большинстве задач этой книги). Она охватывает практически весь спектр математических средств, необходимых для оценки и сравнения эффек - тивности различных алгоритмов. В частности, в главе приводятся два метода решения рекуррентных соотношений – рекурсивных матема-тических функций, описывающих стоимость вычисления рекурсивных алгоритмов. Эти методы используются для преобразования рекуррент - ных соотношений в эквивалентные нерекурсивные формулы, которые проще понять и сравнить. Кроме того, в главе приводится краткий об-зор основных математических понятий и обозначений, используемых при анализе алгоритмов. Анализу затрат памяти или пространственной сложности рекурсивных алгоритмов будет посвящена глава 6. 3.1. Предварительные математические соглашения Этот раздел представляет собой краткое введение в основные матема- тические определения и свойства, используемые при анализе вычисли-\n--- Страница 79 ---\n78  Глава 3. Анализ времени выполнения рекурсивных алгоритмов тельной сложности алгоритмов вообще, а также ряда конкретных задач из этой книги. 3.1.1. Степени и логарифмы В следующем списке приводится обзор основных свойств степеней и логарифмов: • b1 = b • b0 = 1 • bxby = bx+y• (bx)y = bxy = (by)x • b–x = 1/bx• (ab)x = ax bx • logb b = 1 • logb 1 = 0 • logb(xy) = logb(x) + logb(y) • logb(x/y) = logb(x) – logb(y) • logb(xy) = y logb x • logb x = loga x/loga b • logb a = 1/loga b • xlogb y = ylogb x • logb(bx) = x • blogb a = a где a, b, x и y – произвольные вещественные числа, за исключением того, что: 1) основание логарифма должно быть положительным и от - личным от 1, 2) логарифм определён только для положительных чисел и 3) знаменатель при делении не может быть равным нулю. Например, logb x = loga x/loga b имеет место только при a > 0, a ≠ 1, b > 0, b ≠ 1 и x > 0. Логарифмы и степени положительных чисел – монотонно возрастаю- щие функции. Поэтому если x ≤ y, то logb x ≤ logb x и bx ≤ by (для допусти- мых значений x, y и b). 3.1.2. Биномиальные коэффициенты Биномиальный коэффициент m nC – это целое число, которое появля- ется в полиномиальном представлении биномиальной степени (1 + x)n. Его можно определить как: 1, !/( ! ( )!)m nCnmnm=−  (3.1) где n и m – целые числа, удовлетворяющие условию n ≥ m ≥ 0. Кроме того, биномиальный коэффициент может быть определён рекурсивно: 1 111, 0 , m n mm nnm nm CCC− −−== =+  (3.2)если m = 0 или n = m, иначе, если или иначе.\n--- Страница 80 ---\n3.1. Предварительные математические соглашения  79 Биномиальные коэффициенты играют важную роль в комбинатори- ке. В частности, m nC определяет количество способов выбора m различ- ных элементов из множества, состоящего из n элементов, когда поря- док выбора не имеет значения. 3.1.3. Пределы и правило Лопиталя Стоимость вычисления различных алгоритмов можно сравнить с по- мощью предела отношения функций. Прежде всего k/∞ = 0, ∞/k = ∞, где k – константа, а символ ∞ следует понимать как значение предела. Кроме того, так как функции оценки стоимости вычислений, вообще говоря, возрастают (за исключением констант), их предел стремится к бесконечности при стремлении к бесконечности их аргументов. Напри-мер: lim log lima bnnnn →∞ →∞=∞ =∞ при допустимом основании логарифма b и a > 0. Поэтому зачастую при сравнении стоимости вычислений алгоритмов может возникнуть не-определённость вида l i m () /() / nf n gn →∞=∞∞ . Обычно она разрешается упрощением дроби f(n)/g(n), пока не по- явится возможность получить отличный от неопределённости результат. Известный способ упрощения дроби – применение правила Лопиталя: l i m () /() l i m () / () , nnf n gn f n g n →∞ →∞= ′′ (3.3) где f '(n) и g'(n) – производные f(n) и g(n) соответственно. Формально правило Лопиталя верно только тогда, когда существует предел в пра-вой части (3.3), что обычно имеет место. 3.1.4. Суммы и произведения Поскольку суммы появляются не только в определениях функций и в формулах, которые приходится кодировать, но и в оценках эффек - тивности итерационных и рекурсивных алгоритмов, важно владеть ма-тематическим аппаратом суммирования. Сумма, или суммирование, – это просто сложение множества математических объектов (целых или вещественных чисел, векторов, матриц, функций и т. д.). Сумму значе-ний некоторой функции f(i) для последовательности целочисленных или\n--- Страница 81 ---\n80  Глава 3. Анализ времени выполнения рекурсивных алгоритмов значений i от начального значения m до конечного значения n можно записать коротко с использованием символа суммирования: ( ) ( ) ( 1) ( ).n imfi fm fm fn == + +++ ∑ (3.4) Таким образом, результат сложения – это просто сумма членов, кото- рые получаются при подстановке в функцию f(i) всех значений i от от m до n. Например: 2 2 2 2 24 024 3 2 1 0 ⋅+⋅+⋅+⋅+⋅=⋅∑ =k k k k kik i, где f(i) = k · i2. Важно понимать, что результат суммирования не зависит от индекс - ной переменной i. Например, сумма в (3.4) зависит от функции f и за- данных граничных значений m и n, но не от конкретных значений i. Кстати, заметьте, что i нет в правой части (3.4). Поэтому целочисленный индекс i – это просто вспомогательная переменная, позволяющая од- ним выражением задать все слагаемые суммы. Таким образом, индекс - ная переменная может иметь любое имя – скажем, j или k: ∑ ∑ ∑ = = == =n mkn mjn mikf jf if )( )( )( . Более того, с помощью замены индексной переменной одну и ту же сумму можно выразить различными способами: ∑ ∑ ∑ =− −= =+− =+ =n min min miminf if if ) ( )1( )(1 1. Во второй сумме смещены пределы (и аргумент f) суммы, а в третьей элементы суммы складываются в обратном порядке (при i = m к сумме добавляется f(n), а при i = n к сумме добавляется f(m)). Наконец, если нижний предел суммы m больше верхнего n, сумма по умолчанию счи- тается равной 0. 3.1.4.1. Основные свойства сумм Следующие основные свойства полезны для упрощения и преобразо- вания сумм и могут быть легко получены из свойств сложения и умно- жения суммируемых элементов. Во-первых: ∑ ==++++=n in n 1ðàç 11 111 .n раз\n--- Страница 82 ---\n3.1. Предварительные математические соглашения  81 Обратите внимание, что f(i) – постоянная величина (1), не зависящая от индекса i. Точно так же ∑ =⋅=++++=n in nkkk kkk 1ðàç  . Предыдущий пример показывает также, что если один и тот же мно- житель в f не зависит от индекса, его можно вынести за знак суммы: ∑ ∑ ∑ ∑ = = = =⋅= =⋅ =⋅ =n in in in ink k k k k 1 1 1 11 1 )1( . (3.5) В этом случае постоянный множитель k (считаем, умноженный на 1) не зависит от i и может быть вынесен за знак суммы, чтобы стать мно- жителем всей суммы. Из (3.5) видно, что скобки внутри суммы не нуж - ны в тех случаях, когда f не содержит внутри себя операций сложения. В общем виде это свойство выглядит так: ∑ ∑ = == ⋅n min miif kifk )( )( , что следует из дистрибутивного закона умножения суммы, где выраже- ние можно упростить, вынося общий множитель k из всех слагаемых. Множитель k может быть произведением нескольких множителей, ко- торые не зависят от индекса и могут содержать верхние и нижние пре-делы, как показано в следующем примере: ∑ ∑ = ==n min mim mi naina3 2 32 , где a – некоторая константа. Наконец, суммы, в которых функция f состоит из нескольких слагае- мых, можно разложить на несколько сумм, а именно: 12 1 2( () () ) () ()n nn im im imfi fi fi fi = ==+= + ∑ ∑∑ . 3.1.4.2. Арифметическая прогрессия Арифметическая прогрессия – это числовая последовательность si (i = 0, 1, 2, …), каждый член которой больше предыдущего на заданную константу d (которая может быть отрицательной). Иными словами, n раз\n--- Страница 83 ---\n82  Глава 3. Анализ времени выполнения рекурсивных алгоритмов si = si – 1 + d для i > 0, что является рекурсивным определением. Элементы арифметической прогрессии можно также определить нерекурсивно следующим образом: si = si – 1 + d = si – 2 + 2 · d = = s0 + i · d. (3.6) Хотя теоретически арифметическая прогрессия бесконечна, а её сум- ма равна ∑∞ =0iis, для оценки времени выполнения алгоритмов интерес представляют только конечные последовательности ∑ =n miis, называемые также частичными суммами. При анализе эффективности рекурсивных и итерационных алго- ритмов часто используется сумма первых n положительных целых чи- сел S(n), под которой подразумевается частичная сумма (n элементов) арифметической прогрессии (s0 = 1 и d = 1): 1 1 1 11 1 0 0 0 0 00 0 1( ) ( ) (1 ) 1 n n n nn n n i i i i ii i iSn s s id i i n i i− − − −− − = = = == = == = + ⋅ = + = += +=∑ ∑ ∑ ∑∑ ∑ ∑ . Как показано в разделе 1.4.1, результат этой суммы можно предста- вить в виде квадратного полинома от n (1.12). Эту формулу просто вывес ти, сложив две суммы S(n), одна из которых суммируется в воз- растающем порядке, а другая – в убывающем. Тогда из полученного результата следует, что 2S(n) = n(n + 1), поскольку в правой части ра- венства мы имеем n слагаемых, каждое из которых равно n + 1. После деления правой части на 2 получаем 1( ) ( 1)/ 2n iSn i nn == =+∑ . Графическая иллюстрация этой интересной идеи приведена на рис. 3.1, где S(n) – площадь треугольной «лесенки» из квадратиков раз- мера 1×1. Две такие «лесенки» можно соединить так, чтобы получился прямоугольник размером n×(n + 1). Из чего следует, что площадь S(n) каждой «лесенки» равна n(n + 1)/2.\n--- Страница 84 ---\n3.1. Предварительные математические соглашения  83 S(n) n + 1⇒ S(n) = (n(n+1))/2n2S(n) = n(n + 1) S(n) Рис. 3.1. Графический способ вывода формулы для суммы S(n) первых n положительных целых чисел Подобную формулу можно получить и для частичной суммы n чле- нов арифметической прогрессии (si = si–1 + d для некоторого начального значения s0) 1 01 0( )/2n in is ns s− − ==+∑ . Иными словами, эта сумма есть сред- нее арифметическое первого и последнего членов последовательности, умноженное на количество её членов. 3.1.4.3. Геометрическая прогрессия Геометрическая прогрессия – это числовая последовательность si (i = 0, 1, 2, …), каждый член которой равен предыдущему, умноженному на заданную константу r. Иными словами, s i = r · si–1 для i > 0. Нерекур- сивный вариант этой же формулы: si = r · si – 1 = r2 · si – 2 = … = ri · s0. (3.7) Частичная сумма геометрической прогрессии выражается следую- щей формулой: )1)/( (1 0 0 0 r r rs r s sr sn mn miin min mii i − − = = =+ = = =∑ ∑ ∑ , (3.8) где r ≠ 1. Последнее равенство можно легко вывести следующим обра- зом. Пусть S представляет собой значение суммы. Создадим другую сум- му, умножив S на r. А теперь вычтем из одной другую (где большинство членов сокращается) и решим полученное уравнение относительно S: ∑ =+ +− − =− − = =n mim n n m ir r r r r r r S )1 )/( ()1)/( (1 1. (3.9) В заключение отметим, что при | r | < 1 сумма бесконечной геометри- ческой прогрессии сходится к постоянному значению:\n--- Страница 85 ---\n84  Глава 3. Анализ времени выполнения рекурсивных алгоритмов ∑∞ =− = 0)1/1 iir( r . 3.1.4.4. Дифференцирование Ещё одна полезная сумма: ∑ =⋅++⋅+⋅+⋅=⋅ =n in irn r r r ri S 13 2 13 2 1 , (3.10) которую можно считать гибридом сумм арифметической и геометри- ческой прогрессий. Формулу для этой суммы можно вывести следую- щим образом. Сначала рассмотрим частичную сумму геометрической прогрессии и соответствующую ей сокращённую формулу: T = 1 + r + r 2 + … + rn = (rn + 1 – 1)/(r – 1). Затем продифференцируем её по r: 2 11 21 2 3 ( ( 1) 1)/( 1)nn n dTr r nr nr n r rdr−+=+ + + + = − + + − (3.11) и умножим на r, чтобы получить формулу для (3.10): 23 1 2 12 3 ( ( 1) 1)/( 1)n i nn n iS i r r r r nr r nr n r r+ == ⋅ =+ + + + =⋅ − + + −∑. (3.12) Эти формулы можно использовать для упрощения похожих сумм. На- пример, пусть NN iiN i S 2)1 ( 24 232211 23 21 11⋅+ ++⋅+⋅+⋅+⋅= ⋅ =∑+ =−. Эта сумма – частный случай (3.11), когда r = 2 и n = N + 1. После под- становки этих значений в общую формулу получаем: S = ((N + 1)2N + 2 – (N + 2)2N + 1 + 1)/1 = 2N + 1(2N + 2 – N – 2) + 1 = N 2N + 1 + 1. 3.1.4.5. Произведения Подобно сумме, произведение нескольких последовательных значе- ний некоторой функции f(i) для целочисленных значений i – от началь- ного m до конечного n – можно записать следующим образом: )()1( )1 ()( )( nf nf mf mf ifn mi⋅− ⋅⋅+ ⋅ = ∏ =, (3.13)\n--- Страница 86 ---\n3.1. Предварительные математические соглашения  85 что по нашему соглашению при m > n равно 1. Например, функцию вы- числения факториала можно записать как n! = n n in i⋅−⋅⋅⋅=∏ =)1( 21 1, где ради математического удобства считается, что 0! = 1. В произведениях, как и в суммах, не зависящие от индексной пере- менной множители можно выносить за знак произведения. При этом если произведение состоит из n членов, то этот множитель должен быть возведён в степень n: ∏ ∏ = == ⋅n inn iif kifk 1 1)( )( . Кроме того, в самом общем случае произведение сумм не равно сум- ме произведений: ∏ ∏ ∏ = = =+ ≠ +n min min miif if if if )( )( ))( )((2 1 2 1 . Наконец, логарифм произведения есть сумма логарифмов его мно- жителей: )( log )( log if ifn min mi∑ ∏ = == . 3.1.5. Верхняя и нижняя границы Нижняя граница ⌊x⌋ вещественного числа x – это наибольшее целое число, не превосходящее x. Аналогично, верхняя граница ⌈x⌉ веществен- ного числа x – это наименьшее целое число, не меньшее x. Формально они могут быть определены как ⌊x⌋ = max {m ∈ Z | m ≤ x}, ⌈x⌉ = min {m ∈ Z | m ≥ x}, где Z – множество целых чисел, а символ «|» читается как «такие, что». Следующий список включает несколько основных свойств нижних и верхних границ: • ⌊x⌋ ≤ x • ⌈x⌉ ≥ x • ⌊x + n⌋ = ⌊x⌋ + n • ⌈x + n⌉ = ⌈x⌉ + n • ⌊x⌋ + ⌊y⌋ ≤ ⌊x + y⌋ • ⌈x⌉ + ⌈y⌉ ≥ ⌈x + y⌉\n--- Страница 87 ---\n86  Глава 3. Анализ времени выполнения рекурсивных алгоритмов • n = ⌊n/2⌋ + ⌈n/2⌉ • n – 2 ⌊n/2⌋ = 0 ⇔ n – чётное • n//2 = ⌊n/2⌋ • n ≫ m = ⌊n/2m⌋ • ⌊log10 p⌋ + 1 = количество десятичных цифр • ⌊log2 p⌋ + 1 = количество двоичных цифр (битов) где x – вещественное число, n – целое число, m – неотрицательное целое число и p – положительное целое число. Операция // вычисляет частное от целочисленного деления, а операция ≫ сдвигает целое число вправо на один двоичный разряд. Такие операции есть в языке Python и дру - гих языках программирования. Наконец, символ ⇔ означает «тогда и только тогда». 3.1.6. Тригонометрия На рис. 3.2 изображён прямоугольный треугольник, а ниже – связан- ные с ним основные тригонометрические определения и свойства: • sin(α) = a/c • cos(α) = b/c • tan(α) = sin(α)/cos(α) = a/b • cot(α) = cos(α)/sin(α) = b/a • sin(0) = 0 • cos(0) = 1 • sin(30º) = sin(π/6) = 1/2 • cos(30º) = cos(π/6) = √3 /2 • sin(45º) = sin(π/4) = √2 /2 • cos(45º) = cos(π/4) = √2 /2 • sin(60º) = sin(π/3) = √3 /2 • cos(60º) = cos(π/3) = 1/2 • sin(90º) = sin(π/2) = 1 • cos(90º) = cos(π/2) = 0 • sin(α) = – sin(–α) • cos(α) = cos(–α) где sin, cos, tan и cot обозначают тригонометрические функции синус, косинус, тангенс и котангенс соответственно. В большинстве языков программирования параметр тригонометрических функций измеряет - ся в радианах (1 радиан = 180º/π). a bc α Рис. 3.2. Прямоугольный треугольник как иллюстрация тригонометрических определений\n--- Страница 88 ---\n3.1. Предварительные математические соглашения  87 3.1.7. Векторы и матрицы Матрица – прямоугольная таблица из чисел (или элементов других типов данных – символьных, логических и т. д.), состоящая из строк и столбцов. Формально матрица A размерности n×m содержит n строк и m столбцов чисел, где n ≥ 1 и m ≥ 1. Обычно матрицы заключаются в квадратные или круглые скобки: 1,1 1,2 1, 2,1 2,2 2, ,1 ,2 , m m n n nmaa a aa a aa a  = A   , где ai, j обозначает отдельный элемент матрицы A или вход в неё по строке i и столбцу j. Если одна из размерностей равна 1, то такой математический объ- ект называют вектором. Если же обе размерности равны 1, то объект становится скаляром, то есть числом. В этой книге мы будем придер-живаться стандартов, используя для обозначения матриц прописные буквы и жирный шрифт (A), для векторов – строчные буквы и жирный шрифт (a), для скаляров – строчные буквы или символы и курсив (a). Результатом транспонирования матрицы A размерности n×m являет - ся матрица A T размерности m×n, строками которой выступают столбцы матрицы A (а столбцами – строки A). Например, если 3 4 2 1 8 5 =A , то 3 1 4 8 2 5  = AT. Матрицы (и векторы) можно складывать и умножать. Сумма A + B – это матрица, элементы которой равны ai,j + bi,j. Иными словами, матрицы (и векторы) складываются поэлементно. Поэтому A и B должны иметь одинаковую размерность. Типичный пример суммы векторов: (4, –1, 2) + (2, 3, –7) = (6, 2, –5). Умножение матриц гораздо сложнее сложения. Пусть a и b – два n-мерных вектора (столбца). Их скалярное произведение aTb (в других обозначениях – a·b или (a,b)) – определяется как сумма их поэлемент - ных произведений: aTb = 1n ii iab =∑ . (3.14)\n--- Страница 89 ---\n88  Глава 3. Анализ времени выполнения рекурсивных алгоритмов n-мерные векторы (то есть определённые в пространстве Rn) имеют также геометрическую интерпретацию. Можно показать, что aTb = | a | · | b | · cos(α), (3.15) где α – угол между векторами a и b, а | · | обозначает модуль (евклидову норму, абсолютную величину, длину) вектора: 22 1 | | n aa= ++a . (3.16) Если A и B – матрицы размерностей n×m и m×p соответственно, то их произведение C = A · B – матрица размерности n×p, элементы которой определяются как , ,1 1, ,2 2, , , , , 1 m i j i j i j im mi ik k j kc ab ab a b a b == ⋅ + ⋅ ++ ⋅ = ⋅ ∑ . При этом число столбцов A·(m) должно совпадать с числом строк B. Элемент ci,j равен скалярному произведению i-й строки A и j-го столб- ца B (которые можно считать векторами). Например, результатом про- изведения 3 1 10 20 113 4 24 8 20 80 481 8 52 5 11 48 29     ⋅= ⋅ =     AAT является симметричная матрица, так как она не меняется при транспо- нировании. Векторы можно также считать точками. Геометрически сложение двух векторов u и v можно понимать как новый вектор, конечная точка которого – результат «соединения» u и v, как показано на рис. 3.3(a). Отсюда следует, что вектор, который начинается в конечной точке u и заканчивается в конечной точке v, есть вектор v – u, как показано на рис. 3.3(b). (a) (b)u – vu + v u uv v Рис. 3.3. Геометрическая интерпретация сложения и вычитания векторов\n--- Страница 90 ---\n3.2. Временнáя сложность вычислений  89 Наконец, двумерный вектор можно повернуть против часовой стрел- ки на α градусов (или радиан) путём умножения его на матрицу «пово- рота»: c o s () s i n () sin ( ) cos( )αα αα− =R , (3.17) как показано на рис. 3.4, где u – вектор-столбец (как обычно принима- ется в математической литературе). R = �cos(α) –sin( α)� sin( α) cos( α) uRu α Рис. 3.4. Матрица поворота (против часовой стрелки) 3.2. Временнáя сложность вычислений Временнáя сложность алгоритма – это теоретическая оценка времени или количества операций, необходимых для решения задачи. (В лис - тинге 3.1 приведён простой способ оценки времени выполнения кода с помощью модуля time языка Python.) Листинг 3.1. Вычисление времени выполнения кода с помощью модуля time 1 23456import time t = time.time() # execute some code hereelapsed_time = time.time() – t print (elapsed_time) Временнáя сложность определяется некоторой функцией T, завися- щей от исходного размера задачи и подсчитывающей количество опе- раций для выполнения конкретной задачи. В информатике эффектив-ность алгоритмов обычно определяется поведением функции T при достаточно больших размерах задачи. Более того, ключевым фактором становится скорость роста функции T при стремлении размера задачи\n--- Страница 91 ---\n90  Глава 3. Анализ времени выполнения рекурсивных алгоритмов к бесконечности. В последующих подразделах рассматриваются имен- но эти темы, а также математический аппарат, используемый обычно для оценки временнóй сложности вычислений. Несмотря на то что вре-меннáя сложность алгоритмов решения задач может зависеть от мно-гих факторов, в этой книге мы ограничимся её зависимостью лишь от одного фактора – размера задачи. 3.2.1. Порядок роста функций Функция T(n) оценки времени выполнения алгоритма может содер- жать несколько слагаемых, которые по-разному влияют на её значение для заданного размера задачи n. Пусть, например, T(n) = 0,5n 2 + 2000n + 50 000. При небольших значениях n все слагаемые почти в равной сте- пени влияют на рост T(n). Однако с увеличением n первое слагаемое (0,5n2) начинает влиять на рост функции значительно больше, чем два других (даже вместе взятых). Следовательно, порядок роста функции характеризуется её старшим членом. На рис. 3.5 приведены отдельные графики для 0,5n 2 и 2000n + 50 000. Для больших значений n очевидно, что первое слагаемое доминирует над двумя другими и, следовательно, характеризует скорость роста T(n). Коэффициенты полинома были вы- браны так, чтобы показать, что сами они не оказывают существенного влияния на скорость роста функции. 0,5n2 2000n + 50 000 n0 2000 4000 6000 8000 10 0005 4,5 4 3,5 3 2,5 2 1,5 1 0,5 0× 107 Рис. 3.5. Порядок роста функции определяется её старшим членом. Для T(n) = 0,5n2 + 2000n + 50 000 порядок роста – квадратичный, поскольку для больших значений n её старший член 0,5n2, очевидно, доминирует над младшими (даже взятыми вместе)\n--- Страница 92 ---\n3.2. Временнáя сложность вычислений  91 На рис. 3.6 приведены графики наиболее распространённых функ - ций, характеризующих порядок роста вычислительной сложности. 2n n3 n2 n log n n log n 1 nn! Рис. 3.6. Типичные порядки роста вычислительной сложности Для достаточно больших значений n их можно упорядочить следую- щим образом: 1 < log n < n < n log n < n2 < n3 < 2n < n!, где условно считается, что f(n) < g(n), если l i m () /() 0 nf n gn →∞=. Приведённые выше типичные порядки роста называются (слева на- право) константными, логарифмическими, линейными, линейно-лога- рифмическими, квадратичными, кубическими, показательными и фак - ториальными. Поскольку масштаб оси Y на рис. 3.6 – логарифмический, разница между порядками роста может показаться несколько меньше, чем есть на самом деле (каждое следующее деление означает 16-кратный рост времени выполнения алгоритма). В табл. 3.1 приведены фактические значения этих функций, где явно выделяется быстрый рост показатель-ной и факториальной функций. Задачи, которые не могут быть решены за полиномиальное время, обычно считаются трудноразрешимыми (трудными), так как время их выполнения довольно велико даже при умеренных размерах. Напротив, задачи, которые могут быть решены за полиномиальное время, счита-ются легкоразрешимыми (лёгкими). Однако граница между лёгкими и трудными задачами довольно условна. Если время выполнения алго-ритма оценивается полиномиальной функцией высокой степени, то на\n--- Страница 93 ---\n92  Глава 3. Анализ времени выполнения рекурсивных алгоритмов практике может потребоваться довольно много времени для достиже- ния её полного решения или получения промежуточных результатов. Таблица 3.1. Фактические значения типичных функций оценки вычислительной сложности 1 log2 n n n log2 n n2n32nn! 1 0 1 0 1 1 2 1 1 1 2 2 4 8 4 2 1 2 4 8 16 64 16 24 1 3 8 24 64 512 256 40 320 1 4 16 64 256 4096 65 536 2.09 · 1013 1 5 32 160 1024 32 768 4 295 967 296 2.63 · 1035 3.2.2. Асимптотические обозначения Важной особенностью порядка роста является то, что при его опре- делении обычно пренебрегают постоянными множителями. Подобно слагаемым низших порядков, они опускаются, поскольку с ростом раз-мера задачи их влияние на вычислительную эффективность становится гораздо меньше фактического порядка роста. Более того, нет смысла и в точном определении эффективности алгоритма, поскольку оно зависит от множества факторов, включая аппаратные возможности компьюте-ра, язык программирования, компилятор, интерпретатор и т. д. Таким образом, на практике достаточно предположить, что для вы- полнения элементарных машинных команд требуется постоянное вре-мя, не имеющее существенного значения. Теоретический анализ сложности алгоритмов и задач основан на так называемых «асимптотических обозначениях», которые при больших размерах задач позволяют отбрасывать слагаемые низших порядков и постоянные множители. В частности, асимптотические обозначения позволяют определить множества, которые можно использовать для определения «асимптотических границ». Обозначение «O» определяется следующим множеством: O(g(n)) = �f(n): ∃c > 0 и n 0 > 0 | 0 ≤ f(n) ≤ c · g(n), ∀n ≥ n0�. Если функция f(n) принадлежит этому множеству, то g(n) – асимпто- тическая верхняя граница f(n). Это означает, что g(n) будет больше f(n), но согласно определению это справедливо только на интервале от неко-торого n 0 > 0 до бесконечности, причём g(n) может быть умножена на до- статочно большую положительную константу c. На рис. 3.7(a) приведена\n--- Страница 94 ---\n3.2. Временнáя сложность вычислений  93 графическая иллюстрация этого определения. Если g(n) – асимптотиче- ская верхняя граница f(n), то должна существовать возможность найти такую положительную константу c, что c · g(n) ≥ f(n), но только для n, не меньшего некоторого положительного значения n0 (то, что происходит при n < n0, не имеет значения). Чтобы доказать, что функция принад- лежит O(g(n)), достаточно найти хотя бы одну пару (поскольку она не одна) констант c и n0, отвечающих данному определению. Например, если определение верно для некоторой пары c и n0, то оно также верно для бóльших значений c и n0. В связи с этим нет необходимости искать самые маленькие значения c и n0, отвечающие определению O (то же справедливо для всех обозначений, приводимых ниже). Эффективность алгоритмов чаще всего определяется так называемым худшим случаем, когда среди задач одинакового размера выбирается та, что может потребовать наибольшего количества ресурсов (времени, па-мяти и т. д.). Поскольку обозначение «O » определяет асимптотическую верхнюю границу, оно гарантирует, что конкретному алгоритму даже при больших размерах задачи потребуется в самом худшем случае не бо-лее определенного количества ресурсов. Например, время выполнения алгоритма quicksort, сортирующего список или массив из n элементов (см. раздел 6.2.2), вообще говоря, оценивается как O(n 2), поскольку в худ- шем случае он требует порядка n2 сравнений. Однако в лучших и умерен- ных случаях quicksort может работать быстрее (за время порядка n log n). Напротив, обозначение «Ω» определяет асимптотическую нижнюю границу: Ω(g(n)) = �f(n): ∃c > 0 и n0 > 0 | 0 ≤ c · g(n) ≤ f(n), ∀n ≥ n0�. На рис. 3.7(a) приведена графическая иллюстрация этого определе- ния. Обозначение «Ω» полезно для определения нижней границы ре-сурсов, необходимых для решения задачи, независимо от применяе-мого алгоритма. Например, можно теоретически доказать, что любой алгоритм сортировки списка из n вещественных чисел требует в худ- шем случае Ω(n log n) сравнений. Наконец, обозначение «Θ» определяет асимптотические жёсткие границы: Θ(g(n)) = �f(n): ∃c 1 > 0, c2 > 0 и n0 > 0 | 0 ≤ c1 · g(n) ≤ f(n) ≤ c2 · g(n), ∀n ≥ n0�. Если f(n) ∈ Θ(g(n)), то f(n) и g(n) имеют примерно одинаковый поря- док роста. Таким образом, g(n) при определённых значениях констант c1 и c2 будет для f(n) и верхней, и нижней асимптотической границей, как показано на рис. 3.7(c). Иными словами, f(n) ∈ O(g(n)) и f(n) ∈ Ω( g(n)).\n--- Страница 95 ---\n94  Глава 3. Анализ времени выполнения рекурсивных алгоритмов Например, алгоритм сортировки слиянием для списка или массива из n элементов всегда требует (в лучшем и худшем случаях) порядка n log n сравнений. Поэтому мы говорим, что его время выполнения – Θ(n log n). (a) (b)f(n) ∈ O(g(n)) n0 f(n) ∈ Ω(g(n)) (c)n0 n0f(n) ∈ Θ(g(n))c · g(n) c · g(n) c2 · g(n) c1 · g(n)f(x) f(x) f(x)xx xy y y0 0 0 Рис. 3.7. Графическая иллюстрация асимптотических обозначений вычислительной сложности\n--- Страница 96 ---\n3.3. Рекуррентные соотношения  95 При определении асимптотических границ константами и слагае- мыми низших порядков в функции g(n) пренебрегают. Например, не- смотря на очевидность того, что 3n2 + 10n ∈ O(5n2 + 20n ), достаточно сказать, что 3n2 + 10n ∈ O(n2), поскольку для асимптотических обозна- чений важен лишь порядок роста. В связи с этим читатель, видимо, обратил внимание на отсутствие основания логарифма в обозначении порядка роста функции. Причина тому – то, что логарифмы с разны-ми основаниями отличаются только постоянным множителем. Пусть ρ представляет собой некоторую асимптотическую границу, а a и b – два разных основания логарифмов. Следующие равенства показывают, что все логарифмы независимо от их основания имеют один и тот же порядок: ρ log a g(n) = ρ logb g(n)/logb a = ρ · êî í ñòàí òà 1/logba logb g(n) = ρ logb g(n). Таким образом, в обозначении порядка роста основание логарифма не нужно. Наконец, при определении порядка роста функции можно использо- вать пределы благодаря следующим равносильным утверждениям, свя-зывающим их с определениями асимптотических обозначений границ: f(n) ∈ O(g(n)) ⇔ l i m () /() nf n gn →∞<∞ (константа или ноль), f(n) ∈ Ω(g(n)) ⇔ l i m () /() 0 nf n gn →∞> (константа > 0 или ∞), f(n) ∈ Θ(g(n)) ⇔ l i m () /() nf n gn →∞ = константа > 0. 3.3. Рекуррентные соотношения Время выполнения или количество операций, выполняемых рекурсив-ным алгоритмом, определяется рекуррентными соотношениями (или просто рекуррентностью), то есть некоторой математической рекур-сивной функцией T, определяющей стоимость вычисления этого алго- ритма. Рассмотрим код из листинга 1.1, который суммирует первые n положительных целых чисел. Во-первых, число операций, которые он должен выполнить, очевидно, зависит от входного параметра n. Следо- вательно, T будет функцией n. В начальном условии (при n = 1) метод выполняет основные действия, приведённые на рис. 3.8.константа\n--- Страница 97 ---\n96  Глава 3. Анализ времени выполнения рекурсивных алгоритмов Перед их выполнением программа должна сохранить низкоуровне- вую информацию (например, параметры или адрес возврата). Считаем, что это требует a0 единиц времени, где a0 – просто константа. Следую- щее действие – проверка условия со временем выполнения a1. Посколь- ку результат – True, следующее действие – это переход к третьей строке метода, который требует a 2 единиц времени. Наконец, на последнем шаге метод возвращает значение 1, требуя a3 единиц времени. Итого при n = 1 методу нужно a = a0 + a1 + a2 + a3 единиц времени. Таким обра- зом, можно считать, что T(1) = a. Точное значение a для асимптотиче- ской сложности вычисления метода безразлично. Важно только то, что a – постоянная величина, не зависящая от n. a0 a1 a2 a3def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n Рис. 3.8. Последовательность действий, выполняемых функцией из листинга 1.1 при начальном условии Действия при выполнении рекурсивного условия (когда n > 1) приве- дены на рис. 3.9.\n--- Страница 98 ---\n3.3. Рекуррентные соотношения  97 b0 b1 b2 b3 T(n – 1) b4 b5def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + n Рис. 3.9. Последовательность действий, выполняемых функцией из листинга 1.1 при рекурсивном условии\n--- Страница 99 ---\n98  Глава 3. Анализ времени выполнения рекурсивных алгоритмов Пусть b = 5 0i ib =∑ – общее время выполнения основных действий (со- хранение низкоуровневой информации, проверка условия, переход к рекурсивному условию, вычитание единицы из n, добавление n к ре- зультату рекурсивного вызова и возвращение результата), также явля-ющееся константой, точное значение которой не важно для асимптоти- ческой сложности вычисления. Но, кроме b, необходимо оценить время на рекурсивный вызов. Поскольку он решает полную задачу размера n – 1, можно определить его как T(n – 1), а всё рекуррентное соотноше- ние T(n) можно определить следующим образом: , 1,()( 1) , 1,anTnTn b n= =−+ >  (3.18) где, например, T(3) = T(2) + b = T(1) + b + b = a + 2b. Хотя T правильно описывает стоимость вычисления алгоритма, вы- яснить порядок её роста непросто из-за её рекурсивности. Поэтому следующим шагом анализа будет преобразование рекурсивной функ - ции в эквивалентную нерекурсивную формулу. Этот процесс называют «решением» рекуррентного соотношения. В данном случае нетрудно видеть, что T(n) – линейная функция n: T(n) = b(n – 1) + a = b · n – b + a ∈ Θ(n). Следующие разделы посвящены общим методам решения рекур- рентных соотношений. Кроме того, в этом вводном курсе мы будем упрощать рекуррентные соотношения ради облегчения их анализа. Рассмотрим, например, код из листинга 2.9. Связанная с ним функция стоимости выполнения мо-жет быть определена как: , ( ) ( 2) , ( 2) , a Tn Tn / b T n/ c =+ +  (3.19) Это рекуррентное соотношение является сложным для анализа по двум причинам. С одной стороны, оно содержит более одного рекур- сивного условия. С другой – здесь не исключена работа с функцией floor, связанной с техническими особенностями её реализации и требующей более сложной математики (например, неравенств). Более того, для определения порядка роста этой функции нет нужды усложнять её про-если если если n = 1, если n > 1 и n – чётное, если n > 1 и n – нечётное.\n--- Страница 100 ---\n3.3. Рекуррентные соотношения  99 веркой чётности n и прочими лишними деталями. Поскольку алгоритм опирается на решения подзадач (примерно – в случае нечётного n) по- ловинного размера, вместо (3.19) можно работать со следующим рекур- рентным соотношением: , 1,()( /2) , 1.anTnTn b n= =+>  (3.20) Кроме того, в (3.20), используемой взамен (3.19), мы также предпо- ложим, что размер задачи (n) будет достаточно высокой степенью двух. Таким образом, в этой книге мы будем рассматривать рекуррентные соотношения только с одним рекурсивным условием, которое не содер-жит функций floor или ceiling. Это позволит нам находить точные не- рекурсивные формулы рекуррентных соотношений, чей порядок роста можно оценивать жёсткими асимптотическими границами Θ. 3.3.1. Метод расширения Метод расширения (итерации или обратной подстановки) применя- ется прежде всего для решения рекуррентных соотношений, рекурсив-ное условие которых содержит одну ссылку на рекурсивную функцию (в отдельных случаях он может быть применён к рекуррентным соотно-шениям с несколькими ссылками на рекурсивную функцию). Его идея заключается в последовательном упрощении рекуррентного соотноше-ния вплоть до выявления на некотором шаге i общей закономерности. После чего в функцию подставляются конкретные значения в предпо-ложении, что начальное условие достигнуто на этом шаге i. Приводи- мые ниже примеры иллюстрируют эту процедуру, а в разделе 10.2.1 рассматривается соответствующий визуальный подход, называемый «методом дерева». 3.3.1.1. Общие рекуррентные соотношения Рассмотрим функцию (3.18). Её рекурсивное условие T(n) = T(n – 1) + b (3.21) можно неоднократно применять (к аргументам с меньшими значения- ми) для «расширения» слагаемого T в правой части. Например, T(n – 1) = T(n – 2) + b – это результат подстановки (n – 1) вместо n в (3.21). Таким образом, мы приходим к соотношению T(n) = [T(n – 2) + b] + b = T(n – 2) + 2b,если если\n--- Страница 101 ---\n100  Глава 3. Анализ времени выполнения рекурсивных алгоритмов где выражение в квадратных скобках – это расширение T(n – 1). Этот приём можно применить снова, расширив T(n – 2) до T(n – 3) + b. Таким образом, на третьем шаге мы получим: T(n) = [T(n – 3) + b] + 2b = T(n – 3) + 3b. После нескольких таких расширений у нас должна появиться возмож - ность выявить закономерность и вывести общую формулу, соответству - ющую некоторому шагу i. Общая формула для этой функции: T(n) = T(n – i) + i · b. (3.22) В конце концов, при некотором значении i процесс достигнет началь- ного условия. Для функции (3.18) оно определяется как T(1). Следова- тельно, слагаемое T(n – i) достигнет начального условия при n – i = 1 или при i = n – 1. Подстановка этого значения в (3.22) позволяет нам избавиться от переменной i в этой формуле и получить полностью не- рекурсивное определение T(n): T(n) = T(1) + (n – 1) b = a + (n – 1) b = b · n – b + a ∈ Θ(n). Таким образом, код из листинга 1.1 выполняется за линейное от n время. На рис. 3.10 приведена справка о методе расширения, который мы теперь будем применять к другим рекуррентным соотношениям. 1.Выписать рекурсивное условие из рекуррентного соотношения. 2.Несколько раз расширить рекурсивный член в правой части, пока не удастся выявить общую формулу для произвольного шага i. 3.Определить значение i, при котором выполняется начальное условие. 4.Подставить полученное значение i в общую формулу. Рис. 3.10. Метод расширения (краткая справка) Рассмотрим процесс расширения функции (3.20): T(n) = T(n/2) + b {шаг 1} = T(n/4) + b + b = T(n/4) + 2b {шаг 2} = T(n/8) + b + 2b = T(n/8) + 3b {шаг 3} = T(n/16) + b + 3b = T(n/16) + 4b {шаг 4} Её общая формула для рекуррентного соотношения на шаге i:\n--- Страница 102 ---\n3.3. Рекуррентные соотношения  101 T(n) = T(n/2i) + i · b. (3.23) Начальное условие T(1) выполняется при n/2i = 1, то есть при n = 2i или при i = log2 n. Подставив полученное значение i в (3.23), получаем: T(n) = T(1) + b log2 n = a + b log2 n ∈ Θ(log n). Поскольку её порядок роста – логарифмический, код листинга 1.1 с линейным порядком роста асимптотически медленнее кода листин- га 2.9. Интуитивно это понятно: первый уменьшает размер задачи на 1, тогда как второй делит размер исходной задачи пополам и за счёт этого приходит к начальному условию за меньшее количество рекурсивных вызовов функции. Тонкость рекуррентных соотношений при делении размера задачи на целочисленную константу k ≥ 2 заключается в том, что в них не долж - но быть начального условия для n = 0. Математически оно никогда не достижимо, и мы не сможем получить значение i на шаге 3 метода рас - ширения. Ловушка кроется в том, что аргументом функции T(n) должно быть только целое число, поэтому дробь n/k на самом деле предполагает целочисленное деление. А это значит, что следующим за T(1) расши- рением будет не T(1/k), а T(0). Поэтому для правильного применения метода расширения в рекуррентные соотношения нужно включать до-полнительное начальное условие, чаще всего для n = 1. В предыдущих примерах было довольно просто в процессе расшире- ния обнаружить общую формулу на произвольном шаге i. Для следую- щих рекуррентных соотношений это сделать несколько сложнее, так как они содержат вычисление сумм, о которых шла речь в разделе 3.1.4. Рассмотрим следующее рекуррентное соотношение: , 0,()( 1) , 0.anTnTn bn c n= =− +⋅+ >  (3.24) Процесс его расширения: T(n) = T(n – 1) + b · n + с = [T(n – 2) + b(n – 1) + c] + b · n + c = T(n – 2) + 2b · n – n + 2с = [T(n – 3) + b(n – 2) + c] + 2b · n – b + 2c = T(n – 3) + 3 b · n – b(1 + 2) + 3c = [T(n – 4) + b(n – 3) + c] + 3b · n – b(1 + 2) + 3c = T(n – 4) + 4b · n – b(1 + 2 + 3) + 4c = T(n – i) + i · b · n – b(1 + 2 + 3 + … + (i – 1)) + i · c,если если\n--- Страница 103 ---\n102  Глава 3. Анализ времени выполнения рекурсивных алгоритмов где квадратными скобками выделены расширения тех членов, которые включают функцию T. Последний шаг содержит общую формулу, кото- рую можно записать как 1 1( )() () ( 1 ) / 2i jT n T ni i b nb ji cT ni i b nb i i i c− == − +⋅⋅ − +⋅ = − +⋅⋅ − − +⋅ ∑ . (3.25) Два распространённых заблуждения при использовании сумм в фор- мулах на шаге i: (1) использование i в качестве индексной переменной суммы и (2) выбор n в качестве её верхнего предела. Важно отметить, что верхним пределом суммы является i – 1, откуда следует, что i не мо- жет быть индексной переменной суммы. Наконец, начальное условие T(0) достигается при i = n, поэтому под- становка его значения в (3.25) даёт формулу T(n) = b · n2 – b · n(n – 1)/2 + c · n + a = b · n2 /2 + (c + b/2)/n + a ∈ Θ(n2), которая является полиномом 2-й степени. Следующее рекуррентное соотношение появляется в алгоритмах типа «разделяй и властвуй», таких, например, как сортировка слиянием (см. главу 6): , 1,()2 ( /2) , 1.anTnTn bn c n= =+⋅+ >  (3.26) Процесс его расширения: T(n) = 2T(n/2) + b · n + с = 2[2T(n/4) + b · n/2 + с] + b · n + с = 4T(n/4) + 2b · n + 2с + с = 4[2T(n/8) + b · n/4 + c] + 2b · n + 2c + c = 8T(n/8) + 3b · n + 4c + 2c + c = 8[2 T(n/16) + b · n/8 + c] + 3b · n + 4c + +2 c + c = 16T(n/16) + 4b · n + 8c + 4c + 2c + c = 2iT(n/2i) + i · b · n + c(1 + 2 + 4 + … + 2i–1). И здесь в квадратных скобках – расширения членов, содержащих T. В этом случае скобки особенно полезны, поскольку каждый из расши- ряемых членов должен умножаться на 2. Студентам всегда стоит ис - пользовать их, так как пренебрежение ими может приводить к много-численным ошибкам. В данном случае общая формула содержит частичную сумму геомет - рической прогрессииесли если\n--- Страница 104 ---\n3.3. Рекуррентные соотношения  103 T(n) = 2iT(n/2i) + i · b · n + c1 02i j j− =∑ = 2iT(n/2i) + i · b · n + c(2i – 1). (3.27) Начальное условие T(1) достигается при n/2i = 1, откуда следует, что i = log2n. Поэтому подстановка i в (3.27) даёт: T(n) = nT (1) + b · n log2 n + c(n – 1) = b · n log2 n + n(a + c) – c ∈ Θ(n log n), где старший член – b · n log2 n. 3.3.1.2. Основная теорема Основная теорема (master theorem) может использоваться в качестве быстрого способа определения временнóй сложности вычисления алго- ритмов, основанных на стратегии «разделяй и властвуй». В частности, её можно применить к рекуррентным соотношениям следующего вида: , 1,()( / ) ( ), 1,cnTnaT n b f n n= =+>  где a ≥ 1, b > 1, c ≥ 0 и f – асимптотически положительная функция. По- добные алгоритмы обычно относятся к тем задачам, исходный размер которых делится на некоторое положительное число b, не меньшее двух. Последующая обработка или объединение решений подзадач тре-буют f(n) операций. В зависимости от вклада слагаемых aT(n/b) и f(n) в стоимость выполнения алгоритма основная теорема в её самой общей форме утверждает, что можно определить асимптотическую жёсткую границу для T в следующих трех случаях: 1) если f(n) = O(n logba–ε) для некоторой константы ε > 0, то T(n) ∈ Θ(nlogba); 2) если f(n) = Θ(nlogba (log n)k), где k ≥ 0, то T(n) ∈ Θ(nlogba (log n)k+1); 3) если f(n) = Ω( nlogba+ε), где ε > 0 и f(n) удовлетворяет так называемому условию регулярности a · f(n/b) ≤ d · f(n) для некоторой константы d < 1 и для всех достаточно больших n, то T(n) ∈ Θ(f(n)). Например, для 1, 1, () ( /2) 2 , 1nn Tn Tn n= =+> если если если если ,\n--- Страница 105 ---\n104  Глава 3. Анализ времени выполнения рекурсивных алгоритмов можно найти такое ε > 0, что порядок f(n) = 2n будет больше n(log21) + ε = n ε. Действительно, в этом примере допустимо любое значение ε > 0, по- скольку порядок показательной функции 2n всегда выше порядка поли- номиальной. Таким образом, это рекуррентное соотношение относит - ся к третьему случаю основной теоремы, который подразумевает, что T(n) ∈ Θ(2n). Если f(n) – полином степени k, то можно воспользоваться следующей более простой версией основной теоремы: ( ), 1 ( ) ( log ), 1 ( log ), 1kk kk k bn ab Tn n n ab n a abΘ ⋅< ∈Θ ⋅ =  Θ ⋅> (3.28) Этот результат может быть получен методом расширения. Рассмот - рим следующее рекуррентное соотношение: , 1, () ( / ) , 1,kcn Tn aT n b d n n= =+⋅ >  (3.29) где a ≥ 1, b > 1, c ≥ 0 и d ≥ 0. Процесс его расширения: T(n) = aT (n/b) + dnk = a[aT (n/b2) + d(n/b)k] + dnk = a2T(n/b2) + dnk(1 + a/bk) = a2[aT(n/b3) + d(n/b2)k] + dnk(1 + a/bk) = a3T(n/b3) + dnk(1 + a/bk + a2/b2k) = aiT(n/bi) + dnk1 0(/ )i kj jab− =∑ . Начальное условие T(1) = c достигается при i = logb n, а подстановка этого значения в формулу даёт: log 1 log 1 log log 00() ( / ) (/ )bb bbnn na k kj k kj jjTn ca dn a b cn dn a b−− ===⋅ +⋅ =⋅ +⋅ ∑∑ , где в зависимости от значений a, b и k возможны три случая. 1. Если a < bk, то log 1 0(/ )bn kj jab− =∑ будет постоянной величиной (которая не может быть бесконечностью). Отметим, что бесконечная сум-если еслиесли , если , если ,\n--- Страница 106 ---\n3.3. Рекуррентные соотношения  105 ма 01/( 1)i irr∞ ==−∑ – константа при r < 1 (то есть не расходится). Таким образом, в этом случае T(n) = c · nlogba + dKnk для некоторой постоянной K. Кроме того, поскольку a < bk, то есть logb a < k, то nk – член высшего порядка. Следовательно: T(n) ∈ Θ(nk). 2. Если a = bk, то T(n) = cnk + dnk log 1 01bn j− =∑ = cnk + dnk logb n, из чего следует, что T(n) ∈ Θ(nk log n). 3. Если a > bk, то, вычислив сумму геометрической прогрессии, полу - чим: T(n) = c · nlogba + dnk((a/bk)logbn – 1))/(a/bk – 1) = c · nlogba + dnk(nlogba/nk – 1) K = ( c + dK) nlogba – dKnk, где K = 1/(a/bk – 1) – константа. Наконец, поскольку a > bk , то есть logb a > k, мы имеем: T(n) ∈ Θ(nlogba). 3.3.1.3. Дополнительные примеры Рекуррентное соотношение для времени выполнения кодов из лис - тингов 1.2 и 2.4 могло бы быть таким: 1, 1,()2 ( / 2) 1, 1nTnTn n= =+>  (3.30) в предположении, что постоянные множители равны 1 и размер подза- дачи равен половине размера исходной задачи. T(n/2) умножается на 2, потому что в рекурсивных условиях алгоритм вызывает себя дважды с разными аргументами. Кроме того, к этому произведению добавля- ется константа 1, так как результаты подзадач должны быть сложены перед завершением метода. Наконец, ради простоты мы пренебрежём если если ,\n--- Страница 107 ---\n106  Глава 3. Анализ времени выполнения рекурсивных алгоритмов начальным условием для n = 2. Это допущение не повлияет на порядок роста функции времени выполнения. Рекуррентное соотношение можно решить методом расширения сле- дующим образом: T(n) = 2 T(n/2) + 1 = 2 [2T(n/4) + 1] + 1 = 4 T(n/4) + 2 + 1 = 4 [2T(n/8) + 1] + 2 + 1 = 8 T(n/8) + 4 + 2 + 1 = 8[2T(n/16) + 1] + 4 + 2 + 1 = 16 T(n/16) + 8 + 4 + 2 + 1 = 2i T(n/2i) + 1 02i j j− =∑ = 2iT(n/2i) + 2i – 1. Начальное условие T(1) = 1 выполняется при n = 2i . Подстановка даёт: T(n) = n + n – 1 = 2n – 1 ∈ Θ(n), где T(n) – линейная функция n. Естественно, этот результат соответству - ет основной теореме (см. (3.28)), так как рекуррентное соотношение – особый случай (3.29), где a = 2, b = 2 и k = 0. Поэтому T(n) ∈ Θ(2 log2 n) = Θ(n). Рассмотрим функцию из листинга 1.5. Первые два метода уменьшают размер задачи на 1. Таким образом, соответствующее им рекуррентное соотношение могло бы быть таким: 1, 1,()( 1) 1, 1,nTnTn n= =−+ >  что является особым случаем (3.21), где T(n) ∈ Θ(n). Третий метод делит размер исходной задачи пополам, и решения подзадач не нуждаются в последующей обработке. Поэтому его рекуррентное соотношение со-впадает с (3.30). В заключение мы рассмотрим временную сложность вычислений ко- дов из листингов 2.2 и 2.3. Рекуррентное соотношение для них (прене-брегая постоянными множителями): 1, 10,()( /10) 1, 10.nTnTn n< =+≥  (3.31) Оно отличается от предыдущих рекуррентных соотношений тем, что начальное условие определено на интервале. Тем не менее, предполо-жив, что входным параметром метода будет степень 10, можно исполь- зовать альтернативное определение рекуррентного соотношения:если если если если\n--- Страница 108 ---\n3.3. Рекуррентные соотношения  107 1, 1,()( /10) 1, 1.nTnTn n= =+>  (3.32) Обе функции равнозначны при n = 10p и p ≥ 0. Второе рекуррентное соотношение – особый случай (3.29), когда a = 1, b = 10 и k = 0. Таким образом, согласно основной теореме, его слож - ность – логарифмическая, поскольку T(n) ∈ Θ(nk log n) = Θ(log n). Тот же результат можно получить методом расширения: T(n) = T(n/10) + 1 = T(n/100) + 1 + 1 = T(n/102) + 2 = T(n/1000) + 1 + 2 = T(n/103) + 3 = T(n/10000) + 1 + 3 = T(n/104) + 4 = T(n/10i) + i. Начальное условие выполняется при n/10i = 1, то есть при i = log10 n. Подстановка даёт: T(n) = T(1) + log10 n = 1 + log10 n ∈ Θ(log n). 3.3.2. Общий метод решения разностных уравнений Метод расширения эффективен при решении рекуррентных соотно- шений, в которых рекурсивная функция появляется только однажды. В этом разделе описывается мощный подход, называемый здесь «об-щим методом решения разностных уравнений», позволяющий решать рекуррентные соотношения, в которых рекурсивная функция встреча-ется более одного раза. В частности, метод может использоваться для решения рекуррентных соотношений следующего вида: T(n) = – a 1T(n – 1) – – akT(n – k) {«T-разности»} + P1d1(n)b1n + … + Psds(n)bsn {полином × экспонента}, (3.33) где ai и bi – константы, а Pidi(n) – полиномы от n степени di. Слагаемые правой части определения (уравнения), содержащие функцию T, мо - гут встречаться несколько раз. Кроме того, их параметром обязательно должна быть разность n и некоторой целочисленной константы. Поэто- му такие рекуррентные соотношения обычно называют «разностными уравнениями», а их T-члены – «T-разностями», чтобы подчеркнуть, что аргументы функции T не могут быть дробями вида n/b, где b – константа если если\n--- Страница 109 ---\n108  Глава 3. Анализ времени выполнения рекурсивных алгоритмов (в противном случае их следует привести к виду (3.33)). Кроме того, в правой части определения может быть несколько слагаемых, представ-ляющих собой произведения полинома на экспоненту степени n. В следующих подразделах приводится подробное описание общего метода решения разностных уравнений, начиная с простых рекуррент - ных соотношений с постепенным их усложнением за счёт добавления к ним новых элементов. 3.3.2.1. Однородные рекуррентные соотношения: характеристический полином с различными корнями Однородное рекуррентное соотношение содержит только T-разнос - ти: T(n) = – a1T(n – 1) – – akT(n – k). Первый шаг его решения состоит в переносе всех членов правой час - ти уравнения в левую: T(n) + a1T(n – 1) + + akT(n – k) = 0. После этого подстановкой T(n – z) = xk – z, где z = 0, …, k, определяется соответствующий ему характеристический полином: xk + a1 xk–1 + … + ak–1x + ak. Всё, что мы сделали, – заменили T(n) на xk, T(n – 1) на xk–1 и т. д. Коэф- фициент ak при T-разности с наименьшим аргументом становится кон- стантой полинома. Следующий шаг заключается в нахождении k кор - ней характеристического полинома. Если ri (i = 1, 2, , k) – его корни, то полином можно разложить на множители: (x – r1 )(x – r2) … ( x – rk). Если все его корни различны, то формула для T будет такой: T(n) = C1r1n + + Ckrkn. (3.34) В итоге значения констант Ci зависят от начальных условий T и мо- гут быть найдены из решения системы k линейных уравнений с k не- известными переменными. Для составления такой системы уравнений нам требуется k начальных значений T (начальных условий T для малых значений n). В следующем примере этот подход применяется к функции Фибонач- чи (1.2), приведённой в листинге 1.3. Её можно записать следующим об-разом:\n--- Страница 110 ---\n3.3. Рекуррентные соотношения  109 0, 0 , ( ) 1, 1, ( 1) ( 2), 1,n Tn n Tn Tn n=  == −+ − >  (3.35) где к начальному условию для n = 1 добавлено ещё одно – для n = 0, ко - торое, как мы вскоре увидим, окажется очень полезным и даже необхо- димым. Первый шаг заключается в переносе всех членов T-разностей в левую часть рекурсивного тождества: T(n) – T(n – 1) – T(n – 2) = 0. Это однородное рекуррентное соотношение. Его характеристический полином: x2 – x – 1, корни которого r1 = (1 + √5 )/2 и r2 = (1 – √5 )/2 различны. Следовательно, формулой этого рекуррентного соотноше-ния будет: T(n) = C 1r1n + C2r2n = C1((1 + √5 )/2)n + C2 ((1 – √5 )/2)n. (3.36) Последний шаг – это нахождение значений констант Ci решением системы линейных уравнений, которые получаются подстановкой в общую формулу (3.36) малых значений n из начальных условий рекур- сивной функции (3.35). Первое, самое простое уравнение получается из якобы избыточного начального условия для n = 0, которое было добав- лено в рекурсивное определение (3.35). Для второго уравнения исполь-зуем начальное условие для n = 1. В результате получаем следующую систему линейных уравнений: 12 120 (0) ((1 5)/2) ((1 5)/2) 1 (1).CC T C CT+ ==+ + − ==. Её решение: C1 = 1/√5 и C2 = – 1/√5 . Поэтому функцию Фибоначчи можно записать так: T(n) = F(n) = 1/√5 (((1 + √5 )/2)n – ((1 – √5 )/2)n) ∈ Θ(((1 + √5 )/2)n), (3.37) что соответствует показательной функции. Отметим, что в формуле (3.36) r1n явно доминирует над r2n, поскольку, с одной стороны, r1 > r2, а с если если если\n--- Страница 111 ---\n110  Глава 3. Анализ времени выполнения рекурсивных алгоритмов другой – |r2| < 1, из чего следует, что r2n стремится к 0 с ростом n. Наконец, несмотря на сложность и иррациональность формулы, её результатом будет, очевидно, целое число. В качестве следующего примера рассмотрим взаимно-рекурсивные функции (1.17) и (1.18). Для применения к ним нашего метода их нуж - но переопределить исключительно через самих себя. С одной стороны, B(n) = A(n – 1) подразумевает, что B(n – 1) = A(n – 2). Кроме того, A(2) = 1. Таким образом, A(n) можно переопределить как: 0, 1, ( ) 1, 2, ( 1) ( 2), 3.n An n An An n=  == −+ − ≥  (3.38) С другой стороны, поскольку A(n – 1) = B(n) и A(n) = B(n + 1), их можно подставить в (1.17), чтобы получить B(n + 1) = B(n) + B(n – 1). Кроме того, поскольку B(2) = 0, то B(n) можно определить как: 1, 1, ( ) 0, 2, ( 1) ( 2), 3.n Bn n Bn Bn n=  == −+ − ≥  (3.39) Обе эти функции имеют вид (3.36), и единственное различие между ними – в значениях констант. А именно: A(n) = (1/2 –1/2√5 ) ((1 + √5 )/2)n + (1/2 + 1/2√5 ) ((1 – √5 )/2)n, (3.40) B(n) = (– 1/2 + 3/2√5 ) ((1 + √5 )/2)n + (– 1/2 – 3/2√5 ) ((1 – √5 )/2)n, (3.41) где можно положить, что A(0) = 1 и B(0) = –1. Наконец, нетрудно видеть, что A(n) + B(n) – числа Фибоначчи F(n), так как сложение (3.40) и (3.41) даёт (3.37). 3.3.2.2. Однородные рекуррентные соотношения: характеристический полином с кратными корнями В предыдущем разделе показано, что если кратность корней ri, соот - ветствующих члену (x – ri) в разложении на множители характеристиче- ского полинома, равна 1, то формула для T(n) будет содержать член Cirin. Если же кратность m корня r больше 1, то, исходя из (x – r)m, T(n) будет содержать m членов вида «константа × полином × rn», при этом полино- мы должны иметь различные степени n в диапазоне от 0 до m – 1. На - пример, член (x – 2)4 в разложении на множители характеристического если если если если если если\n--- Страница 112 ---\n3.3. Рекуррентные соотношения  111 полинома привёл бы к четырём следующим слагаемым в формуле для T(n): C12n + C2n2n + C3n22n + C4n32n для некоторых констант Ci. Поэтому T(n) можно записать в общем виде как T(n) = C1P1(n)r1n + + CkPk(n)rkn, (3.42) где Pi(n) – полиномы вида nc для некоторого c. В качестве примера рассмотрим следующее рекуррентное соотноше- ние: T(n) = 5T(n – 1) – 9 T(n – 2) + 7T(n – 3) – 2 T(n – 4), для которого T(0) = 0, T(1) = 2, T(2) = 11 и T(3) = 28. Его можно записать как T(n) – 5 T(n – 1) + 9T(n – 2) – 7 T(n – 3) + 2T(n – 4) = 0, что приводит к характеристическому полиному: x4 – 5x3 + 9x2 – 7x + 2. Его можно разложить на множители (например, с помощью правила Руффини) следующим образом: (x – 1)3(x – 2), из чего следует, что формула рекуррентного соотношения будет иметь вид: T(n) = C 1 · 1 · 1n + C2 · n · 1n + C3 · n2 · 1n + C4 · 1 · 2n = C1 + C2n + C3n2 + C42n, в которой есть слагаемые, связанные с корнем r = 1. Константы опреде- ляются из решения следующей системы линейных уравнений: 14 123 4 1234 12340 (0) 2 2 (1) 2 4 4 11 (2) 3 9 8 28 (3).CC T CCC C T CCCC T CC CC T+ == + + + ==+ + + == + + + ==. Её решение: C1 = –1, C2 = –2, C3 = 3 и C4 = 1. (В листинге 3.2 приводится код для решения системы линейных уравнений вида Ax = b с помощью пакета NumPy.) В итоге получаем:\n--- Страница 113 ---\n112  Глава 3. Анализ времени выполнения рекурсивных алгоритмов T(n) = –1 – 2n + 3n2 + 2n ∈ Θ(2n) с экспоненциальным порядком роста. Листинг 3.2. Решение системы линейных уравнений Ax = b 1 23456import numpy as np A = np.array([[1, 0, 0, 1], [1, 1, 1, 2], [1, 2, 4, 4], [1, 3, 9, 8]])b = np.array([0, 2, 11, 28]) x = np.linalg.solve(A, b) 3.3.2.3. Неоднородные рекуррентные соотношения Неоднородные рекуррентные соотношения содержат в своей пра- вой части нерекурсивные члены. Для таких рекуррентных соотноше- ний тоже можно вывести общую формулу, если нерекурсивные члены представляют собой произведение полинома на экспоненту (см. (3.33)). Процедура решения – та же, но каждому члену P idi(n)bin в характеристи- ческом полиноме соответствует слагаемое (x – bi)di +1, где di – степень по- линома Pi(n). Рассмотрим следующее рекуррентное соотношение: T(n) = 2T(n – 1) – T(n – 2) + 3n + n3n + 3 + n + n2. Как и в предыдущих примерах, первый шаг – это перенос T-разно- стей в левую часть рекуррентного соотношения: T(n) – 2 T(n – 1) + T(n – 2) = 3n + n3n + 3 + n + n2. На следующем шаге нужно представить каждый член правой части в виде произведения полинома на экспоненту. Если этот член состоит только из экспоненты, то естественно умножить его на полином n 0 = 1. Если же он представляет собой только полином, то он умножается на экспоненту 1 n. Таким образом, рекуррентное соотношение можно за- писать в виде: T(n) – 2 T(n – 1) + T(n – 2) = 1 · 3n + n · 3n + 3 · 1n + n · 1n + n2 · 1n. Если какая-то экспонента встречается в правой части несколько раз, она должна умножаться только на один полином. Следовательно, экс - поненты правой части нужно сгруппировать: T(n) – 2 T(n – 1) + T(n – 2) = (1 + n) · 3n + (3 + n + n2) · 1n.\n--- Страница 114 ---\n3.3. Рекуррентные соотношения  113 На следующем шаге определяется характеристический полином. В левой части мы имеем (x2 – 2x + 1 ) = ( x – 1)2. В правой части члену (1 + n) · 3n соответствует (x – 3)2, где 3 – основание экспоненты, а 2 – сте- пень полинома (1) плюс 1. Аналогично члену (3 + n + n2) · 1n соответству - ет (x – 1)3. Таким образом, характеристический полином имеет вид: (x – 1)2 (x – 3)2(x – 1)3 = (x – 1)5(x – 3)2, а формула для T(n) имеет следующий вид: T(n) = C1 + C2n + C3n2 + C4n3 + C5n4 + C63n + C7n3n. Проиллюстрируем данный подход следующим примером неодно- родного рекуррентного соотношения: 1, 0, () 2 ( 1) 2 , 0. nn Tn Tn n n= =− ++ >  Сначала приводим рекурсивное условие к каноническому виду: T(n) – 2 T(n – 1) = n · 1n + 1 · 2n. Соответствующий ему разложенный на множители характеристиче- ский полином: (x – 2) {из T (n) – 2 T (n – 1)} · (x – 1)2 {из n · 1n} · (x – 2) {из 1 · 2n} = (x – 1)2(x – 2)2, из чего следует, что формулой рекуррентного соотношения будет: T(n) = C1 + C2n + C32n + C4n2n. Поскольку у нас есть четыре неизвестные константы, нам нужны зна- чения T для четырёх различных n. Это значит, что к уже имеющемуся значению из начального условия T(0) = 1 нужно добавить из рекурсив- ного условия T(n) = 2 T(n – 1) + n + 2n ещё три – T(1), T(2) и T(3), а именно: T(1) = 5, T(2) = 16 и T(3) = 43. Теперь на основании этих данных можно записать следующую систему линейных уравнений: 13 12 3 412 34123 41 (0) 2 2 5 (1) 2 4 8 16 (2) 3 8 24 43 (3).CC T CC C C T CCCC T CCC C T+ == + + + ==+ + + == + + + ==. Её решение: C1 = –2, C2 = –1, C3 = 3, C4 = 1. Поэтому формула для T(n): T(n) = –2 – n + 3 · 2n + n2n ∈ Θ(n2n).если если\n--- Страница 115 ---\n114  Глава 3. Анализ времени выполнения рекурсивных алгоритмов 3.3.2.4. Дробные аргументы рекурсивной функции Общий метод вывода формулы для рекуррентных соотношений при- меним лишь тогда, когда аргументы их T-членов представляют собой разности вида n – b, где b – некоторая целочисленная константа. Однако в отдельных случаях эту задачу можно решить, когда аргументы T-чле- нов представляют собой дроби вида n/b, где b – некоторая целочислен- ная константа. Ключевая идея здесь заключается в предположении, что n – это степень b, и последующем преобразовании дроби в разность пу - тём замены n = bk. Рассмотрим рекуррентное соотношение (3.30) с рекурсивным усло- вием T(n) = 2T(n/2) + 1, предположив, что n – степень двух. Поскольку аргумент T-члена в пра- вой части – n/2, необходимо произвести замену n = 2k, чтобы получить: T(2k) = 2T(2k/2) + 1 = 2T(2k–1) + 1. В этом новом определении T(2k) есть функция k. Поэтому её можно заменить на t(k) следующим образом: t(k) = 2t(k – 1) + 1, а такое рекуррентное соотношение можно решить общим методом для разностных уравнений. То есть сначала привести его к виду t(k) – 2 t(k – 1) = 1 · 1 n и записать его характеристический полином (x – 2)(x – 1). Тогда сама функция должна иметь следующий вид: t(k) = C1 + C22k. (3.43) Выполнив обратную замену, получаем общее решение рекуррентно- го соотношения от исходной переменной n: T(n) = C1 + C2n. (3.44) Последний шаг – определение констант C1 и C2. Их можно найти из (3.43) или из (3.44). Для T мы можем использовать начальные условия T(1) = 1 и T(2) = 3. Аналогичные начальные условия для t: t(0) = T(20) = T(1) = 1 и t(1) = T(21) = T(2) = 3. В любом случае, система линейных урав- нений будет иметь вид:\n--- Страница 116 ---\n3.3. Рекуррентные соотношения  115 12 121 (1) (0) 2 3 (2) (1).CC T t CC T t+ == = + == =. Её решение: C1 = –1 и C2 = 2, а формулой для T(n) будет: T(n) = 2n – 1 ∈ Θ(n). В следующем рекурсивном определении 21, 1,()2 ( /4) log , 1nTnTn n n= =+>  можно предположить, что аргументом рекурсивной функции T будет степень четырёх. В этом случае замена переменной n = 4k приводит к T(4k) = 2T(4k/4) + log2 4k = 2T(4k–1) + k log2 4 = 2T(4k–1) + 2k. Следующий шаг – замена t(k) = T(4k): t(k) = 2t(k – 1) + 2k. Мы назовём эту операцию «заменой функции», чтобы подчеркнуть, что замена касается только T-членов (t-членами) и не влияет на все остальные члены (в данном случае – 2k). Приводим рекуррентное соот - ношение к каноническому виду t(k) – 2 t(k – 1) = 2k · 1k, характеристический полином которого – (x – 2)(x – 1)2. Таким образом, формула для этого рекуррентного соотношения: t(k) = C12k + C2 + C3k. Чтобы вернуться к функции T, нужно произвести обратную заме- ну k = log4 n. Однако нам необходимо выражение для 2k. Заметим, что n = 4k = (2 · 2)k = (22)k = (2k)2, поэтому 2k = √n , что даёт: T(n) = C1 √n + C2 + C3 log4 n. Наконец, исходя из начального условия T(1) = 1, можно вычислить T(4) = 2T(1) + log2 4 = 4 и T(16) = 2T(4) + log2 16 = 12, что позволяет нам найти константы Ci из решения следующей системы линейных уравне- ний:если если ,\n--- Страница 117 ---\n116  Глава 3. Анализ времени выполнения рекурсивных алгоритмов 12 123 12 31 (1) 2 4 (4) 4 2 12 (16).CC T CCC T CC C T+ == + + ==  ++ == . Её решение: C1 = 5, C2 = –4 и C3 = –2, а формула для T(n): T(n) = 5√n – 4 – 2 log4 n ∈ Θ(n1/2). Если аргумент T в рекурсивном выражении – квадратный корень, можно воспользоваться заменой n = 2(2k). Рассмотрим следующее рекур- рентное соотношение: T(n) = 2T(√n ) + log2 n, (3.45) где T(2) = 1 и n = 2(2k) (заметим, что 2(2k) ≠ 4k). Это последнее ограничение для n гарантирует, что рекурсивная процедура завершится при началь- ном условии для n = 2. После замены переменной получим: T(2(2k)) = 2T(2(2k/2)) + log2 2(2k) = 2T(2(2k – 1)) + 2k, а после замены функции t(k) = T(2(2k)) рекуррентное соотношение при- нимает вид t(k) = t(k – 1) + 2k, характеристический полином которого (x – 2)(x – 2). Поэтому новое рекуррентное соотношение будет иметь вид: t(k) = C12k + C2k2k. Для отмены замены переменной нужно применить подстановку k = log2(log2 n) или 2k = log2 n. Таким образом, рекуррентное соотношение как функция n будет иметь вид: T(n) = C1 log2 n + C2(log2(log2 n)) log2 n. (3.46) Наконец, чтобы найти константы, используем начальные условия T(2) = 1 и T(4) = 4. Для этого нужно решить следующую систему линей- ных уравнений: 1 121 (2) 2 2 4 (4).CT CC T== + == . Её решение: C1 = C2 = 1. Поэтому конечная формула для T(n): T(n) = log2 n + (log2(log2 n)) log2 n ∈ Θ((log(log n)) log n). (3.47)\n--- Страница 118 ---\n3.3. Рекуррентные соотношения  117 3.3.2.5. Многократные замены переменной или функции Предыдущее рекуррентное соотношение (3.45) можно решить, при- менив две последовательные замены переменной (и функции). Во-пер- вых, замена n = 2k приводит к T(2k) = 2T(√nk) + log2 2k = T(2k/2) + k. Заменив T(2k) на t(k), получаем следующее рекуррентное соотноше- ние: t(k) = 2t(k/2) + k, которое всё ещё нельзя решить общим методом, так как оно не является разностным уравнением. Но зато можно произвести ещё одну замену переменной k = 2 m, чтобы привести его к нужному виду: t(2m) = 2t(2m – 1) + 2m, что после замены функции t(2m) = u(m) сводится к разностному уравне- нию u(m) = 2u(m – 1) + 2m. Его характеристический полином (x – 2)2, а это значит, что рекуррент - ное соотношение будет иметь вид: u(m) = C12m + C2m2m. Отмена последней замены переменной приводит к t(k) = C1k + C2(log2(k))k и в итоге к T(n) = C1 log2 n + C2(log2(log2 n))log2 n, что равносильно (3.46). Поэтому решением является (3.47). Стратегия применения нескольких замен переменных или функций может использоваться для решения более сложных рекуррентных соот - ношений, таких, например, как следующее нелинейное соотношение: 21/3, 1, () ( /2) , 1,n Tn nT n n= =>  где n – степень двух. Сначала можно применить замену переменной n = 2k, что приводит к T(2k) = 2kT(2k/2)2 = 2kT(2k – 1)2.если если\n--- Страница 119 ---\n118  Глава 3. Анализ времени выполнения рекурсивных алгоритмов После замены функции T(2k) = t(k) получаем t(k) = 2kt(k – 1)2, что всё ещё невозможно решить общим методом. Но после логарифми- рования обеих частей равенства log2 t(k) = log2 2kt(k – 1)2 = k + 2log2 t(k – 1) можно произвести более сложную замену функции log2 t(k) = u(k), кото - рая даст рекуррентное соотношение u(k) = k + 2u(k – 1), которое уже можно решить общим методом. Его характеристический полином (x – 2)(x – 1) 2, который подразумевает, что u(k) имеет следующий вид: u(k) = C12k + C2 + C3k. Отменив замены, получим сначала t(k) = 2C12k + C2 + C3k, а затем T(n) = 2C1n + C2 + C3log2 n. Последний шаг, как обычно, состоит из определения констант. Ис - пользуя начальное условие T(1) = 1/3, получаем T(2) = 2[T(1)]2 = 2/9 и T(4) = 4[T(2)]2 = 4(2/9)2 = 16/81. Воспользуемся этими значениями для составления следующей системы (нелинейных) уравнений: 12 123 12 32 422 1/3 (1) 2 2/9 (2) 2 16/81 (4),CC CC C CC CT T T+ ++++ == ==  ==, которую (после логарифмирования по основанию 2 обеих частей урав-нений) можно привести к системе линейных уравнений: 12 2 123 2 2 12 3 2 2log 3 2 1 log 9 1 2log 3 4 2 4 log 81 4 4log 3.CC CCC CC C+ =− + + =− =−  + + =− =− . Её решение: C1 = 2 – log2 3 = log2(4/3), C2 = –2, C3 = –1.\n--- Страница 120 ---\n3.4. Упражнения  119 Таким образом, T(n) можно выразить следующей формулой: T(n) = 2(log2(4/3))n –2 – log2n = 2log2(4/3)n · 2–2 · 2log2(1/n) = (4/3)n(1/4)n ∈ Θ((4/3)nn). 3.4. Упражнения Упражнение 3.1. Докажите следующее тождество: (a/bk)logbn = nlogba/nk. Упражнение 3.2. Используя пределы, покажите, что log n! ∈ Θ(n log n). Подсказка: при стремлении n к бесконечности n! можно заменить при- ближением Стирлинга n! ≈ √2πn (n/e)n. Упражнение 3.3. Покажите, что n log n ∈ O( n1+a), где a > 0. Используйте пределы и правило Лопиталя. Упражнение 3.4. Пусть m и n – произвольные целые числа. Опреде- лите 1n im=∑. Упражнение 3.5. Запишите сумму первых n нечётных целых чисел с использованием символа суммирования и упростите её (результат дол- жен быть известным полиномом). Упражнение 3.6. Воспользуйтесь следующим тождеством: 11( 1)/ 2 ( 1)nn iiii in i ==+ = −+∑∑ , чтобы получить формулу суммы квадратов первых n целых чисел (12 + 22 + … + n2). Упражнение 3.7. Покажите, что частичная сумма n членов арифме- тической прогрессии (si = si–1 + d для некоторого начального s0) равна 01 1( )/2n in is ns s− ==+∑. Упражнение 3.8. Алгоритм проверяет справа налево биты двоично- го представления чисел от 1 до 2n – 1 (где n – количество битов каждого числа), пока не находит единичный бит. Для заданного n определите, используя символы суммирования, общее количество проверенных ал-горитмом битов. Например, для n = 4 алгоритм проверит 26 затенённых битов на рис. 3.11.\n--- Страница 121 ---\n120  Глава 3. Анализ времени выполнения рекурсивных алгоритмов Рис. 3.11. Количество проверенных (затенённых) битов для чисел от 1 до 2n – 1, где n = 4 Упражнение 3.9. Определите рекуррентные соотношения для вре- мени выполнения алгоритмов, реализующих функции (1.14), (1.15), (1.16) и (1.19). Упражнение 3.10. Выведите формулы для следующих рекуррентных соотношений, не вычисляя коэффициентов Ci (начальные условия здесь не требуются). T(n) = 4T(n – 1) – 5 T(n – 2) + 2T(n – 3) + n – 3 + 5n2 · 2n T(n) = T(n – 1) + 3n – 3 + n3 · 3n T(n) = 5T(n – 1) – 8 T(n – 2) + 4T(n – 3) + 3 + n2 + n · 2n Упражнение 3.11. Определите рекуррентное соотношение для вре- мени выполнения кода из листинга 2.6, решите его методом расшире-ния и общим методом для разностных уравнений и, наконец, опреде-лите его порядок роста. Упражнение 3.12. Решите методом расширения следующее рекур- рентное соотношение: n1 01, 0, ()1 ( ), 0. jn TnTj n− ==  =+>∑если если\n--- Страница 122 ---\n3.4. Упражнения  121 Упражнение 3.13. Решите методом расширения следующее рекур- рентное соотношение: 21, 1,()2 ( /4) log , 1.nTnTn n n= =+>  Упражнение 3.14. Решите рекуррентное соотношение (3.18) общим методом для разностных уравнений. Упражнение 3.15. Определите рекуррентное соотношение для вре- мени выполнения кода из листинга 2.9, решите его с помощью основ- ной теоремы, метода расширения и общего метода для разностных уравнений, а затем определите его порядок роста. Упражнение 3.16. Решите следующее рекуррентное соотношение с помощью основной теоремы, метода расширения, общего метода для разностных уравнений и определите его порядок роста: 1, 1,()3 ( /2) , 1,nTnTn n n= =+>  где n – степень 2. Упражнение 3.17. Решите рекуррентное соотношение (3.32) общим методом для разностных уравнений. Упражнение 3.18. Решите следующие рекуррентные соотношения: 1) T(n) = 2T(n – 1) + 3n – 2, где T(0) = 0. 2) T(n) = T(n/2) + n, где T(1) = 1 и n – степень 2. 3) T(n) = T(n/α) + n, где T(1) = 0 и α ≥ 2 – целое. 4) T(n) = T(n/3) + n2, где T(1) = 1 и n – степень 3. 5) T(n) = 3T(n/3) + n2, где T(1) = 0 и n – степень 3. 6) T(n) = 2T(n/4) + n, где T(1) = 1 и n – степень 4. 7) T(n) = T(n/2) + log2 n, где T(1) = 1 и n – степень 2. 8) T(n) = 4 T(n/2) + n, где T(1) = 1 и n – степень 2. 9) T(n) = 2 T(n/2) + n log2 n, где T(1) = 1 и n – степень 2. 10) T (n) = 3/2T (n/2) – 1/2T (n/4) – 1/n , где T (1) = 1, T (2) = 3/2 и n – степень 2.если если если если",
      "debug": {
        "start_page": 78,
        "end_page": 122
      }
    },
    {
      "name": "Глава 4. Линейная рекурсия I: основные алгоритмы 122",
      "content": "--- Страница 123 --- (продолжение)\nГлава 4 Линейная рекурсия I: основные алгоритмы Трудное начинается с лёгкого, великое – с малого. Долгий путь начинается с первого шага. – Лао Цзы Рекурсивные методы можно классифицировать по количеству обраще-ний к самому себе в рекурсивных условиях. Эта глава исследует методы, которые не только вызывают себя лишь раз, но и обрабатывают резуль-тат рекурсивного вызова до того, как создать или вернуть свой соб-ственный результат. Этот общий тип рекурсии известен как линейная рекурсия, когда единственный рекурсивный вызов не является послед-ним действием метода. В данной главе будет предложено множество задач и соответствующих им линейно-рекурсивных решений, которые будут разрабатываться, опираясь на понятия и методику, введенные в главах 1 и 2. Если же единственный рекурсивный вызов является по-следним действием метода, то говорят, что имеет место хвостовая ре- курсия. Этому особому типу рекурсии будет посвящена глава 5. Линейная рекурсия – самый простой тип рекурсии, который может быть альтернативой итерации, многократно выполняющей опреде-лённую последовательность операций. Хотя обсуждаемые в этой главе задачи легко решить с помощью итерации, линейная рекурсия предла-гает очень прозрачные примеры рекурсивного мышления и програм-мирования. Поэтому в главе приводятся примеры применения рекур-сивных понятий (декомпозиции и индукции), которые читатель обязан постичь, прежде чем заняться более сложными задачами и типами ре-курсии.\nГлава 4 Линейная рекурсия I: основные алгоритмы Трудное начинается с лёгкого, великое – с малого. Долгий путь начинается с первого шага. – Лао Цзы Рекурсивные методы можно классифицировать по количеству обраще-ний к самому себе в рекурсивных условиях. Эта глава исследует методы, которые не только вызывают себя лишь раз, но и обрабатывают резуль-тат рекурсивного вызова до того, как создать или вернуть свой соб-ственный результат. Этот общий тип рекурсии известен как линейная рекурсия, когда единственный рекурсивный вызов не является послед-ним действием метода. В данной главе будет предложено множество задач и соответствующих им линейно-рекурсивных решений, которые будут разрабатываться, опираясь на понятия и методику, введенные в главах 1 и 2. Если же единственный рекурсивный вызов является по-следним действием метода, то говорят, что имеет место хвостовая ре- курсия. Этому особому типу рекурсии будет посвящена глава 5. Линейная рекурсия – самый простой тип рекурсии, который может быть альтернативой итерации, многократно выполняющей опреде-лённую последовательность операций. Хотя обсуждаемые в этой главе задачи легко решить с помощью итерации, линейная рекурсия предла-гает очень прозрачные примеры рекурсивного мышления и програм-мирования. Поэтому в главе приводятся примеры применения рекур-сивных понятий (декомпозиции и индукции), которые читатель обязан постичь, прежде чем заняться более сложными задачами и типами ре-курсии.\n--- Страница 124 ---\n4.1. Арифметические операции  123 4.1. Арифметические операции Этот раздел представляет рекурсивные решения для нескольких простей- ших арифметических вычислений. Мы изучим их в целях иллюстрации, поскольку большинство из них включает в себя простые операции, ко- торые реализуются посредством элементарных команд или выражений. 4.1.1. Степенная функция Классическая задача для иллюстрации рекурсии – степенная функ - ция. Цель состоит в том, чтобы вычислить b в степени n: 1nn inb b bb bb =×× × ∏==      , где основание степени b – вещественное число, а её показатель (экспо- нента) n – неотрицательное целое число (в Python степень вычисляется операцией **). Последующие подразделы исследуют алгоритмы вычис - ления степени за линейное и логарифмическое время. 4.1.1.1. Вычисление степени за линейное время Согласно представленной на рис. 2.1 методике первый шаг состоит из определения размера задачи, который зависит от входных параметров. В этой задаче для определения числа операций в алгоритме вычисле-ния степени важен лишь показатель степени. Ясно, что время выполне-ния растёт с ростом n, поскольку результат требует большего количества умножений. Таким образом, размер задачи – это показатель степени n. Начальное условие соответствует тривиальным экземплярам задачи минимального размера. Так как n – неотрицательное целое число, наи- меньший экземпляр класса – это b 0, равный 1. На этапе декомпозиции нужно рассмотреть наименьшую и прос - тейшую из подзадач, подобных исходной, которая получается путём уменьшения размера исходной задачи. В этом разделе мы будем умень-шать её размер на 1, что приведёт к следующей схеме: Входы Результаты × bf bn – 1 fbn(b, n) (b, n − 1)n раз\n--- Страница 125 ---\n124  Глава 4. Линейная рекурсия I: основные алгоритмы где f(b, n) = bn – функция от двух параметров b и n. Очевидно, если нам известно решение f(b, n – 1) = bn–1, то в рекурсивном условии остаёт - ся сделать лишь одно – умножить её на b, чтобы получить bn. Функцию вместе с её начальным условием можно реализовать, как показано в листинге 4.1. Листинг 4.1. Степенная функция для неотрицательных степеней с линейным временем выполнения 1 2345def power_linear(b, n): if n == 0: return 1 else: return b * power_linear(b, n – 1) Это пример линейной рекурсии, так как в рекурсивном условии есть только один вызов функции, не являющийся последней выполняемой алгоритмом операцией. Несмотря на то что вызов функции является последним элементом выражения (в строке 5), метод сначала вычисля-ет её и только потом умножает результат на b. Таким образом, функция не относится к хвостовой рекурсии. Также важно отметить, что функ - ция не нуждается в начальном условии для n = 1, так как оно было бы избыточным. Наконец, вычислительная сложность этого алгоритма ли-нейно зависит от n. В частности, время выполнения может быть опре- делено так: 1, 0,()( 1), 0,nTnTn n= =−>  (4.1) где T(n) = n + 1 ∈ Θ(n). Если условием задачи допускались бы ещё и отрицательные целочис - ленные показатели степени, то размер задачи был бы абсолютной ве-личиной n. В этом случае начальное условие также задаётся для n = 0, а рекурсивное условие идентично случаю n > 0. Когда n – отрицательное, декомпозиция должна уменьшать размер задачи таким образом, чтобы соответствующая подзадача стремилась к начальному условию. Таким образом, для этого рекурсивного условия необходимо увеличивать n. Схема процесса рассуждений была бы такой:если если\n--- Страница 126 ---\n4.1. Арифметические операции  125 Входы Результаты / bf bn + 1 fbn(b, n) (b, n + 1) Таким образом, для получения отрицательной степени bn результат подзадачи должен делиться на b. Поэтому рекурсивное условие должно быть f(b, n) = f(b, n + 1)/b, как показано в листинге 4.2. Листинг 4.2. Степенная функция с линейным временем выполнения 1 234567def power_gtntral_linear(b, n): if n == 0: return 1 elif n > 0: return b * power_gtntral_linear(b, n – 1) else: return power_gtntral_linear(b, n + 1) / b 4.1.1.2. Вычисление степени за логарифмическое время Существует возможность реализовать более эффективные алгорит - мы вычисления степени за логарифмическое время, если на этапе де- композиции разбить задачу пополам – на две подзадачи в половину размера исходной. Поскольку n – неотрицательное целое число, нам понадобятся две схемы в зависимости от четности n. Если n – чётное, то согласно рекурсивному подходу процесс можно представить следу - ющим образом: Входы Результаты ( )2f bn/2 fbn(b, n) (b, n/2)\n--- Страница 127 ---\n126  Глава 4. Линейная рекурсия I: основные алгоритмы Таким образом, чтобы получить bn, результат подзадачи нужно возвес ти в квадрат. И наоборот, если n – нечётное, следует рассмотреть подзадачу с целочисленным размером (n – 1)/2. Её схема: Входы Результаты ( )2 и × bf b(n − 1)/2fbn(b, n) (b, n − 1)/2) В этом случае результат подзадачи тоже возводится в квадрат, после чего нужно умножить его на основание b. С этими рекурсивными усло- виями и тривиальным начальным условием рекурсивная функция вы- глядит следующим образом: 2 21, 0, ( , ) ( , /2) , 0 ( ,( 1)/2) , 0n f bn f bn n fb n b n=  => −⋅ >  Правильная реализация линейно-рекурсивной функции показана в листинге 4.3. Целочисленное деление (//) вместо вещественного де- ления (/) не обязательно и применено, чтобы подчеркнуть, что вто-рой входной параметр – целое число. Кроме того, если n – нечётное, то (n – 1)//2 = n//2. Однако в коде используется первое выражение, посколь- ку оно математически точнее. Листинг 4.3. Степенная функция для неотрицательных степеней с логарифмическим временем выполнения 1 234567def power_logarithmic(b, n): if n == 0: return 1 elif n % 2 == 0: return power_logarithmic(b, n // 2)**2 else: return b * (power_logarithmic(b, (n – 1) // 2)**2)если если и n – чётное, если и n – нечётное.\n--- Страница 128 ---\n4.1. Арифметические операции  127 Время выполнения можно определить как: 1, 0,()( /2) 1, 0,nTnTn n= =+>  где T(n) = 2 + log2n для n > 0. Таким образом, T(n) ∈ Θ(log n). Высокая про- изводительность достигается за счёт деления размера задачи пополам на этапе декомпозиции. При этом функция в каждом рекурсивном ус - ловии должна выполнить только один рекурсивный вызов. Например, код в листинге 4.4 не выполняется за логарифмическое время, несмотря на то что декомпозиция делит задачу пополам. Проблема здесь в том, что он вычисляет результат одной и той же подзадачи дважды, исполь-зуя два идентичных, но совершенно ненужных рекурсивных вызова. Листинг 4.4. Неэффективная реализация степенной функции с линейным временем выполнения 1 2345678def power_alt(b, n): if n == 0: return 1 elif n % 2 == 0: return power_alt(b, n // 2) * power_alt(b, n // 2) else: return (power_alt(b, (n – 1) // 2) * power_alt(b, (n – 1) // 2) * b) Временнáя стоимость выполнения этой функции: 1, 0,()2 ( /2) 1, 0,nTnTn n= =+>  где T(n) = n + 1 ∈ Θ(n). Отметим, что она аналогична времени выполне- ния (4.1) функции в листинге 4.1. Таким образом, сверхпроизводитель- ность, которую можно было бы получить за счёт деления размера зада-чи пополам, здесь утрачивается из-за двух идентичных рекурсивных вызовов в рекурсивном условии. 4.1.2. Медленное сложение Эта задача заключается в сложении двух неотрицательных целых чи- сел a и b без использования обычных арифметических операций, таких если если если если\n--- Страница 129 ---\n128  Глава 4. Линейная рекурсия I: основные алгоритмы как сложение, вычитание, умножение или деление. Вместо этого разре- шается лишь увеличивать или уменьшать число на единицу (конечное число раз). Эта простая задача поможет показать, как выбор размера влияет на способ декомпозиции задачи, приводя к разным рекурсив-ным алгоритмам. Согласно шаблону на рис. 2.1 первый шаг – это определение размера задачи. Поскольку нам разрешено лишь добавлять или вычитать 1 из a и b, разумно считать, что эту простую операцию следует выполнять a + b раз до тех пор, пока не выполнится начальное условие (вскоре мы увидим, что это можно сделать всего лишь за a или b операций). Если мы выбираем в качестве размера задачи a + b, то начальное условие выполняется при a = b = 0, что соответствует экземпляру наименьшего размера. Кроме того, мы должны рассмотреть другие возможные на-чальные условия, когда результат может быть легко получен без выпол-нения рекурсивного вызова. Очевидно, что для этой задачи результат равен b при a = 0 и равен a при b = 0. Более того, с такими начальными условиями становится излишним начальное условие для a = 0 и b = 0. Наконец, эти начальные условия гарантируют, что в рекурсивном усло-вии a и b будут положительными. На следующем шаге декомпозиции мы можем уменьшить размер за- дачи на 1. Поскольку в качестве размера задачи выбрано a + b, можно вычитать единицу как из a, так и из b. Рекурсивная схема при уменьше- нии a была бы такой: Входы Результаты + 1f a − 1 + bfa + b (a, b) (a − 1, b) Если реализуемая функция – f, то очевидно, что f(a, b) = f(a – 1, b) + 1 определяет рекурсивное условие, и его можно выразить математически как: , 0, ( ) , 0, ( 1, ) 1, 0, 0.ba f a,b a b fa b a b=  == −+ >>  (4.2)если если если\n--- Страница 130 ---\n4.1. Арифметические операции  129 В листинге 4.5 приведена реализация функции в Python. Если бы мы выбрали в качестве размера задачи a, в определении функции появи- лись бы те же два начальных условия, а при декомпозиции задачи при- шлось бы уменьшать на единицу значение a. Поэтому получающаяся функция была бы точно такой же. С другой стороны, выбрав в качест - ве размера задачи b, пришлось бы изменить рекурсивное условие на f(a, b) = f(a, b – 1) + 1, поскольку уменьшать придётся b, а не a. Листинг 4.5. Медленное сложение двух неотрицательных целых чисел 1 234567def slow_addition(a, b): if a == 0: return b elif b == 0: return a else: return slow_addition(a – 1, b) + 1 Функция в листинге 4.5 может быть медленной для больших значе- ний a. С другой стороны, если размером задачи считать наименьший входной параметр, то есть min(a, b), то можно создать более эффектив- ный алгоритм. В этом случае два начальных условия f(0, b) = b и f(a, 0) = a соответствуют наименьшим экземплярам задачи (начальное условие f(0, 0) становится лишним). Для рекурсивных условий мы должны найти декомпозицию, гарантирующую уменьшение размера задачи. Первый подход состоит в уменьшении наименьшего входного параметра, что-бы размер подзадачи был min(a, b) – 1. Например, при a < b рекурсивное правило было бы f(a, b) = f(a – 1, b) + 1, а при a ≥ b мы применили бы правило f(a, b) = f(a, b – 1) + 1. Таким образом, математическая функция была бы следующей: , 0, , 0 ( 0),()( 1, ) 1, ( 0, 0), ( , 1) 1, ( 0, 0),ba a baf a,bfa b a b a bf ab b a a b=  =≠ =−+ < ≠≠  −+ ≤ ≠ ≠  и её можно закодировать, как в листинге 4.6.если если и если и если и\n--- Страница 131 ---\n130  Глава 4. Линейная рекурсия I: основные алгоритмы Листинг 4.6. Ускоренное медленное сложение двух неотрицательных целых чисел 1 23456789def quicker_slow_addition(a, b): if a == 0: return b elif b == 0: return a elif a < b: return quicker_slow_addition(a – 1, b) + 1 else: return quicker_slow_addition(a, b – 1) + 1 Вторая идея заключается в уменьшении обоих параметров, и она тоже гарантирует уменьшение размера задачи. В частности, отметим, что min(a – 1, b – 1) = min(a, b) – 1. Для этой декомпозиции рекурсивная схема была бы такой: Входы Результаты + 1 + 1f a − 1 + b − 1fa + b (a, b) (a − 1, b − 1) Следовательно, рекурсивным условием для a > 0 и b > 0 будет f(a, b) = f(a – 1, b – 1) + 1 + 1. По условию задачи оно справедливо, если до- пустить, что увеличение на 1 выполняется постоянное количество раз (в случае f(a – 1, b – 1) – дважды), что не зависит от входных параметров. Соответствующий этому случаю код приведён в листинге 4.7. Листинг 4.7. Ещё одно ускоренное медленное сложение двух неотрицательных целых чисел 1 234567def quicker_slow_addition_alt(a, b): if a == 0: return b elif b == 0: return a else: return quicker_slow_addition_alt(a – 1, b – 1) + 1 + 1\n--- Страница 132 ---\n4.1. Арифметические операции  131 4.1.3. Двойная сумма Следующий пример относится к вычислению двойной суммы вида: i1 1(,) ( )mn jf mn i j ===+∑∑ . (4.3) Пользуясь свойствами сумм, она может быть сведена к простому вы- ражению: f(m, n) = 11 1( ) ( ( 1)/ 2)mn m ij ii j i n nn == =+ = ⋅+ + ∑∑ ∑ = = nm(m + 1)/2 + mn(n + 1)/2 = mn(m + n + 2)/2. Однако мы решим эту задачу рекурсивно с использованием двух ре- курсивных функций (по одной на каждую сумму). Во-первых, внешняя сумма – функция параметров m и n, размер ко- торой – m. Функция возвращает 0 для её начального условия, когда m меньше наименьшего индекса (то есть когда m ≤ 0). Общая схема для рекурсивного условия в предположении, что размер подзадачи m – 1: Входы Результаты f f Очевидно, всё, что нужно сделать с результатом f(m – 1, n) для полу - чения f(m, n), – это добавить к нему внутреннюю сумму 1()n jmj =+∑ , ко- торую можно считать функцией g, зависящей от n и m. Поэтому f можно определить следующим образом: f(m, n) = 0, 0, ( 1, ) ( , ), 0.m f m n gnm m≤  −+ > (m, n) (m − 1, n) если если\n--- Страница 133 ---\n132  Глава 4. Линейная рекурсия I: основные алгоритмы g(n, m) тоже можно определить рекурсивно. Во-первых, поскольку она складывает n слагаемых, её размер равен n. Как и все суммы, она воз- вращает 0 в начальном условии, которое имеет место при n ≤ 0. Общая схема ее рекурсивного условия, также уменьшающего размер задачи на единицу: Входы Результаты Из схемы видно, что для получения g(n, m) нужно добавить (m + n) к результату подзадачи. Таким образом, функция g имеет вид: g(n, m) = 0, 0, ( 1, ) ( ), 0.n gn m m n n≤  − ++ >  В листинге 4.8 приведена реализация обеих сумм. Листинг 4.8. Рекурсивные функции вычисления двойной суммы (4.3) 1 23456789101112def inner_sum(n, m): if n <= 0: return 0 else: return inner_sum(n – 1, m) + (m + n) def outer_sum(m, n): if m <= 0: return 0 else: return outer_sum(m – 1, n) + inner_sum(n, m) 4.2. Системы счисления Числа можно представлять по-разному в зависимости от конкретной базы или основания системы счисления. Как правило, мы используем систему счисления по основанию 10, когда последовательность цифр, если еслиg(m + 1) + + (m + (n − 1)) + (m + n) (n, m) (n − 1, m) + (m + n) (m + 1) + + (m + (n − 1))g\n--- Страница 134 ---\n4.2. Системы счисления  133 скажем, 142 представляет собой число 1 · 102 + 4 · 101 + 2 · 100. В общем случае для некоторого основания b значение числа x можно предста- вить уникальной последовательностью из m цифр dm–1 … d0: 1 0m i i ix db− ==∑ , (4.4) где 0 ≤ di < b и dm–1 ≠ 0 (то есть начальные нули опускаются). Таким об- разом, различные основания приводят к различным последователь- ностям цифр, представляющим одно и то же число. Что касается обо-значений, то основание можно указывать в нижнем индексе, который обычно опускается для b = 10. Например, 142 10 = 142, но 1425 = 1 · 52 + 4 · 51 + 2 · 50 = 25 + 20 + 2 = 47. В этом разделе мы рассмотрим алгоритмы преобразования чисел из одной системы счисления в другую. 4.2.1. Двоичное представление неотрицательного целого числа Цель этого примера – разработка рекурсивной функции, которая для заданного неотрицательного целого числа n по основанию 10 возвра- щает новое целое число – его двоичное представление, состоящее из последовательности двоичных цифр (или битов). Результатом будет также десятичное число, но его цифры будут либо нулями, либо едини-цами. Таким образом, можно считать, что его цифры фактически соот - ветствуют битам. Поскольку мы должны создать последовательность «битов», размер задачи – это число битов в двоичном представлении n, или математи- чески ⌊log 2 n⌋ + 1 (для n > 0). При этом формула для разработки рекур- сивного алгоритма нам не нужна. Всё, что нам нужно, – чётко опреде-лить размер задачи, что позволит нам определить начальные условия и разбить задачу на подзадачи. В частности, наименьшие экземпляры задачи соответствуют числам, которые содержат один-единственный бит, которым могут быть 0 или 1. Таким образом, начальное условие с результатом n возникает при n < 2. Для вывода рекурсивного условия нужно решить, как уменьшать размер задачи. Самый простой способ заключается в уменьшении количест ва битов на 1, что достигается целочисленным делением n на 2 (оно сдвигает биты на одну позицию вправо, причём наименьший зна-чащий бит отбрасывается). Начнём разбор с конкретных экземпляров задачи. Например:\n--- Страница 135 ---\n134  Глава 4. Линейная рекурсия I: основные алгоритмы и Отметим, что результат f(18) = 10010 выражен по основанию 10. На схемах показано, что желаемый результат можно получить, умножая результат подзадачи на 10 и затем добавляя к нему 1, если n – нечётное. Поэтому рекурсивное условие видится таким: f(n) = 10f(n // 2) + n % 2. Более строго схему рекурсивного процесса осмысления задачи мож - но обобщить следующим образом: где bi представляет бит. В частности, f(n//2) – десятичное число, кото- рое представляет последовательность «битов» n, за исключением само- го младшего (b0), чьё значение – n%2 (или n&1, где & обозначает по- разрядную операцию AND). Чтобы добавить отброшенный бит, нужно умно жить f(n//2) на 10 (то есть сдвинуть цифры на одну позицию влево, добавив 0) и добавить его к результату. Таким образом, на самом деле рекурсивным условием действительно будет f(n) = 10f(n // 2) + n % 2, полу ченное путём на основании анализа конкретных экземпляров за- дачи. Окончательная функция:Входы Результаты n = 18f n//2 = 9f n = (bm − 1 b1b0)2Входы Результаты Входы Результатыn = 1910010 100111001 1001f f f f× 10 + 0 × 10 + 1 n//2 = 9 (bm − 1 b1b0)10 n//2 = (bm − 1 b1)2(bm − 1 b1)10× 10 + b0\n--- Страница 136 ---\n4.2. Системы счисления  135 f(n) =, 2, 10 ( //2) %2, 2.nn fn n n<  +≥  В листинге 4.9 приведён код для решения задачи. В итоге двоичное представление 142 = 14210 – это 100011102 = 128 + 8 + 4 + 2. Листинг 4.9. Двоичное представление неотрицательного целого числа 1 2345def decimal_binary(n): if n < 0: return n else: return 10 * decimal_binary(n // 2) + (n % 2) 4.2.2. Приведение десятичного числа к другому основанию Задача из раздела 4.2.1 – частный случай более общей задачи, кото- рая заключается в преобразовании десятичного числа к другому осно-ванию b, где b ≥ 2. Её можно решить аналогично с применением схем. На рис. 4.1 показаны шаги общего алгоритма решения задачи. В частности, он показывает, как привести десятичное число 142 к основанию 5, то есть 142 10 = 10325. Полное решение задачи показано на рис. 4.1(a), идея которого состоит в последовательном выполнении целочисленного деления n на b до достижения им значения 0. На каждом шаге вычис - ляются также остатки от деления b, которые образуют цифры в новом представлении числа по основанию b, чьи позиции определяются сте- пенью 10. В схеме на рис. 4.1(b) подзадача (28 10 = 1035) исходной задачи выделена более светлым фоном. Для разработки рекурсивного решения нужно определить размер за- дачи. Для этой задачи он равен количеству делений n на b до достиже- ния им значения 0. Количество делений – это, в сущности, количество цифр по основанию b. Начальное условие выполняется, когда n пред- ставляет собой единственную цифру по основанию b. Другими словами, если n < b, то результат равен n. Рекурсивное условие требует идентификации подзадачи в пределах исходной, как показано на рис. 4.1(b). Отметим, что подзадача подобна исходной задаче, начиная с 28 = 142//5. Таким образом, декомпозиция состоит из выполнения целочисленного деления n//b, которое умень-если если\n--- Страница 137 ---\n136  Глава 4. Линейная рекурсия I: основные алгоритмы шает размер задачи на 1. Впоследствии нужно будет определить, как следует изменить решение подзадачи (103), чтобы получить решение исходной задачи (1032). Решение заключается в умножении результата подзадачи на 10 и добавлении к нему n%b (равного 2 в этом примере). Таким образом, функцию можно закодировать, как показано в листин-ге 4.10. Листинг 4.10. Приведение неотрицательного целого числа n к основанию b 1 2345def decimal_to_base(n, b): if n < b: return n else: return 10 * decimal_to_base(n // b, b) + (n % b) Рис. 4.1. Приведение десятичного числа 142 к основанию 5 (1032) 4.3. Строки В этом разделе разбираются две задачи, касающиеся строк, которые представляют собой последовательности (цепочки) символов и явля-ются фундаментальным типом данных во многих языках программи-рования.(a) (b) //5 //5 //5 //5 //5 //5 //5 2 3 0 1 3 0 1142 142 228 285 5%5 %5 %5 %5 %5 %5 %5 %51 10 0//5\n--- Страница 138 ---\n4.3. Строки  137 4.3.1. Обращение строки Рассмотрим задачу обращения строки. В частности, создадим функ - цию f, которая получает на входе строку и возвращает её обращение – цепочку из тех же символов, следующих в обратном порядке. Напри- мер, f('abcd') = 'dcba'. Размер задачи – это длина входной строки. Начальное условие выпол- няется при пустой входной строке, когда результатом, очевидно, являет - ся тоже пустая строка. Для уменьшения размера задачи в рекурсивном условии следует исключать по одному символу входной строки. Явные кандидаты для этого – первый или последний символ строки. Исключе-ние первого символа приводит к следующей схеме, где входная строка s записывается в виде последовательности символов s 0 s1 … sn–2 sn–1: Таким образом, функция должна просто добавить первый символ в конец результата подзадачи, связанной с s1 … sn–2sn–1 (символ «+» обозна- чает конкатенацию строк). Эта рекурсивная функция вместе с началь-ным условием реализована в листинге 4.11. Листинг 4.11. Обращение строки s 1 2345def reverse_string(s): if s == '': return '' else: return reverse_string(s[1:]) + s[0] 4.3.2. Является ли строка палиндромом? Цель следующей задачи – выяснить, является ли строка палиндро- мом, то есть цепочкой символов, которая одинаково читается в прямом и обратном направлениях (например, 'радар'). Её размер – длина стро-ки, так как ею определяется количество операций, необходимых для s0s1 sn − 2 sn − 1Входы Результаты sn − 1 sn − 2 s1s0 + s0 s1 sn − 2 sn − 1sn − 1 sn − 2 s1\n--- Страница 139 ---\n138  Глава 4. Линейная рекурсия I: основные алгоритмы получения результата. У этой задачи два начальных условия: (a) когда строка пуста и (b) когда она состоит из одного символа. В обоих случаях результатом будет True (Истина). Как и для функции из листинга 2.6, здесь необходимо второе начальное условие, поскольку при декомпо-зиции задачи мы будем уменьшать её размер на две единицы. В данном случае подзадача исключает первый и последний символы исходной строки длиной n ≥ 2. Результатом функции для некоторой строки s = s 0 s1 sn–2sn–1 длиной n будет выражение: (s0 = sn–1) ∧ (s1 = sn–2) ∧ ∧ (s⌊n/2⌋–1 = sn–⌊n/2⌋), где ∧ – логическая операция И (конъюнкция), а si – символ строки s в позиции i (первый символ – в позиции 0). Заметим, что сумма индексов сопоставляемых символов равна n – 1. Кроме того, необходимо срав- нить только ⌊n/2⌋ пар символов. Приведённое выражение можно запи- сать короче, подобно сумме: /2 1 1 0()n i ni iss−  −− ==∧ . Соответствующая рекурсивная схема: Таким образом, логическая функция может быть определена как: f(s) = 0 1 1 2True, 2, ( ) ( ), 2,nnn s s fs n−−<  =∧ ≥ где s1…n–2 обозначает подстроку s1 sn–2. Наконец, листинг 4.12 представляет код с временной сложностью Θ(n).s0s1 sn − 2 sn − 1Входы Результаты s1 sn − 2⌊n/2⌋–1 ∧ i = 0(si = sn − i − 1) ⌊n/2⌋–1 ∧ i = 1(si = sn − i − 1)∧ (s0 = sn − 1)f f если если\n--- Страница 140 ---\n4.4. Дополнительные задачи  139 Листинг 4.12. Функция проверки строки на палиндром 1 23456def is_palindrome(s): n = len(s) if n <= 1: return True else: return (s[0] == s[n – 1]) and is_palindrome(s[1:n – 1]) 4.4. Дополнительные задачи Этот раздел содержит несколько классических задач, которые имеют изящные рекурсивные решения. 4.4.1. Сортировка выбором Сортировки выбором – один из самых простых способов сортировки элементов списка. Для заданного списка из n чисел предложить метод его сортировки в порядке возрастания. Алгоритм начинается с поиска и размещения наименьшего элемента списка в первой позиции выход-ного списка. На втором шаге метод ищет минимальный элемент среди оставшихся 1…(n – 1) элементов и помещает его во вторую позицию списка вывода. Эта процедура выполняется (n – 1) раз, пока в итоге мас - сив не отсортируется. Ясно, что в конце k-го шага наименьшие k чисел уже отсортированы, а после (n – 1) шага будет полностью отсортирован весь список. Теперь рассмотрим линейно-рекурсивную версию алгоритма. Во-первых, размер задачи – это длина списка (n). Начальное условие выполняется, когда список состоит из одного элемента и не нуждается в сортировке, являясь, очевидно, её результатом. Кроме того, если вход пуст, алгоритм может вернуть ещё и пустой список. Таким образом, для начального условия метод возвращает результат при n ≤ 1. Для вывода рекурсивного условия декомпозиция должна умень- шать размер задачи на 1, когда наименьший элемент списка исключа-ется из него. Это можно сделать двумя способами. Во-первых, элемент можно менять местами с первым элементом списка. Это, естественно, не меняет результата (сортированного списка), но позволяет после об-мена местами исключить первый элемент списка. Поэтому если вход-ной список [7 , 5, 3, 8, 4], он превращается в [3 , 5, 7, 8, 4] после обмена местами 3 и 7. В этом случае входом подзадачи размера n – 1 был бы\n--- Страница 141 ---\n140  Глава 4. Линейная рекурсия I: основные алгоритмы список [5, 7, 8, 4], а рекурсивная схема для этого частного примера мог - ла бы быть такой: Чтобы решить исходную задачу, рекурсивное правило должно до- бавить исключённый наименьший элемент ([3]) в начало выходного списка подзадачи (заметьте, что результаты – это сортированные спис - ки). В листинге 4.13 приведена реализация метода с использованием функции min для определения наименьшего значения в списке, метода index, возвращающего позицию элемента в списке, и операции + (кон-катенация) для объединения списков. Важной деталью этого алгорит - ма является то, что он должен создать новую копию входного списка (в строке 5), чтобы не изменить его при вызове метода. В частности, без этой копии метод поменял бы местами первый и наименьший элемен-ты списка. Листинг 4.13. Рекурсивный алгоритм сортировки выбором 1 234567891011def select_sort_rec(a): if len(a) <= 1: return a else: b = list(a) min_index = b.index(min(b)) aux = b[min_index] b[min_index] = b[0] b[0] = aux return [aux] + select_sort_rec(b[1:]) Другой способ уменьшения размера задачи – исключение наимень- шего элемента прямым удалением его из списка. В этом случае рекур- сивная схема была бы такой:Входы Результаты [5, 7, 8, 4]объединить с [3][7, 5, 3, 8, 4] [3, 4, 5, 7, 8] [4, 5, 7, 8]\n--- Страница 142 ---\n4.4. Дополнительные задачи  141 Её единственное отличие от предыдущей схемы – порядок следова- ния элементов во входном параметре подзадачи. Но он совершенно не влияет на рекурсивное правило, где также нужно добавлять удалённый наименьший элемент ([3]) к списку вывода подзадачи. В листинге 4.14 приведена возможная реализация функции, использующая для удале-ния наименьшего элемента метод remove. В строке 5 также создаётся копия входного списка, чтобы не изменить его очередным вызовом ме-тода. Листинг 4.14. Другой рекурсивный алгоритм сортировки выбором 1 23456789def select_sort_rec_alt(a): if len(a) <= 1: return a else: b = list(a) m = min(b) b.remove(m) return [n] + select_sort_rec_alt(b) Наконец, оценка времени выполнения этих алгоритмов задаётся формулой (3.24), так как поиск (и удаление) наименьшего элемента списка требует порядка n операций. Таким образом, алгоритмы рабо- тают за время Θ(n2). 4.4.2. Схема Горнера Цель этой задачи – вычислить полином степени n: P(x) = cn xn + cn – 1xn – 1 + … + c1 x + c0 (4.5) для некоторого вещественного значения x. Сумма состоит из степеней x, умноженных на коэффициенты ci. Простейший алгоритм, вычисляю-[7, 5, 8, 4][7, 5, 3, 8, 4] [3, 4, 5, 7, 8] [4, 5, 7, 8]Входы Результаты объединить с [3]\n--- Страница 143 ---\n142  Глава 4. Линейная рекурсия I: основные алгоритмы щий каждую степень отдельно, потребовал бы порядка n2 умножений. Тогда как схема Горнера позволяет сократить число умножений до n. Её идея – представить полином в виде: P(x) = c0 + x(c1 + x(c2 + … + x(cn–1 + cnx))). Ясно, что размер задачи – это степень n полинома. Таким образом, начальное условие выполняется при n = 0 с очевидным результатом 0. На практике коэффициенты c должны быть определяющим полином списком (или похожей структурой данных вроде массива) из n + 1 эле- ментов. Поэтому начальное условие достигается, когда длина этого списка равна 1. Чтобы воспользоваться рекурсией, нужно найти подзадачу меньшего размера, подобную исходной. Декомпозиция задачи с уменьшением ее размера на 1: P(x) = ï î ëí àÿ çàäà÷à 0 12 1 ï î äçàäà÷à( ( ( )) )nn c xc xc xc x c− + + + + +⋅     . Если пренебречь коэффициентом c0 и первым умножением на x, то получающаяся подзадача имеет точно такую же структуру, как у исход-ной задачи. Если p(c, x) – функция, вычисляющая заданный своими ко- эффициентами c полином от x, то рекурсивная формула будет такой: p(c, x) = c 0 + x · p(c1…n, x), где список c1…n – это тот же список c без первого элемента. Полная рекур- сивная функция будет такой: p(c, x) =0 0 1 , 1, ( , ), 1,ncn c x pc x n=  +⋅ >  а соответствующий ей код приведён в листинге 4.15. Листинги 4.15. Вычисление полинома по схеме Горнера 1 2345def horner(c, x): if len(c) == 1: return c[0] else: return c[0] + x * horner(c[1:], x)подзадачаполная задача если если\n--- Страница 144 ---\n4.4. Дополнительные задачи  143 Важно отметить, что уменьшение размера задачи, начиная с cn вмес - то c0, не приводит к схеме Горнера. В этом случае рекурсивная формула была бы такой: p(c, x) = p(c0…n–1, x) + cnxn, – и вычисляла бы полином, как в (4.5). Если бы степень xn вычислялась за линейное или логарифмическое время, то метод потребовал бы Θ(n2) или Θ(n log n) операций соответственно. Однако схема Горнера более эффективна, так как полином вычисляется за линейное время (Θ(n)). 4.4.3. Треугольник Паскаля Треугольник Паскаля – треугольное представление биномиальных коэффициентов �n m�1, приведённое на рис. 4.2, где треугольник (a) со- держит сами биномиальные коэффициенты, а треугольник (b) – их фактичес кие целочисленные значения. (a) (b)�0 0� �1 0� �1 1� �2 0� �2 1� �2 3� �3 0� �3 1� �3 2� �3 3� �4 0� �4 1� �4 2� �4 3� �4 4�1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 Рис. 4.2. Треугольник Паскаля Очередная наша задача – определить список биномиальных коэффи- циентов n-й строки: �n 0��n 1� �n n–1��n n�, где первые и последние элементы всегда равны 1. Задачу можно рассмо-треть с рекурсивной точки зрения, принимая во внимание определение (3.2). Графически это означает, что биномиальный коэффициент – это сумма пары коэффициентов, расположенных непосредственно над ним в предыдущей строке треугольника Паскаля. Например, � 4 3� = �3 2� + �3 3�. Поэтому строку треугольника Паскаля можно вычислить по значени- 1 �n m� – иное обозначение Cnm. – Прим. перев.\n--- Страница 145 ---\n144  Глава 4. Линейная рекурсия I: основные алгоритмы ям предыдущей строки. На рис. 4.3 показано отношение между задачей (n-й строкой) и подзадачей ((n – 1)-й строкой). Рис. 4.3. Декомпозиция и восстановление строки треугольника Паскаля Размер задачи – n. Таким образом, начальное условие соответству - ет n = 0, когда результат – это просто список, содержащий 1 ([1]). Для n = 1 нельзя применить рекурсивное правило (3.2). Поэтому поначалу кажется, что необходимо дополнительное начальное условие для n = 1 с результатом ([1,1]). Но поскольку все строки для n > 0 начинаются и заканчиваются с 1, эти элементы можно включить в рекурсивное усло-вие по умолчанию. Таким образом, особое начальное условие для n = 1 становится излишним. Листинг 4.16. Функция, генерирующая n-ю строку треугольника Паскаля 1 2345678910def pascal(n): if n == 0: return [1] else: row = [1] previous_row = pascal(n – 1) for i in range(len(previous_row) – 1): row.append(previous_row[i] + previous_row[i + 1] row.append(1) return row В частности, предполагается, что в рекурсивном условии известно решение подзадачи, вычисляющей все элементы строки, кроме край- них (их можно просто добавлять, не вычисляя). В листинге 4.16 при-ведено возможное решение задачи. Рекурсивное условие начинается с добавления 1 в итоговый список (строку). Строка 6 вычисляет результат подзадачи размера n – 1, а в строках 7 и 8 в цикле for пары целых чисел подзадачи складываются (как показано на рис. 4.3) и их сумма добав-ляется к результату. В заключение в конец строки добавляется 1, на чём �n n–1� �n 1� �n 2� �n n–2��1 n–1� �2n–1� �n–1�n–2 1 11 1… …�n–1�n–3\n--- Страница 146 ---\n4.4. Дополнительные задачи  145 и заканчивается решение. В упражнении 4.14 предлагается заменить цикл рекурсивной функцией. 4.4.4. Резистивная цепь Цель следующей задачи – упростить электрическую цепь на рис. 4.4, напоминающую многозвенную схему, содержащую несколько уровней резисторов, сопротивление которых равно r. 2 В частности, можно заме- нить всю цепь эквивалентной, состоящей из одного резистора. Рис. 4.4. Задача о резистивной цепи Таким образом, задача состоит в определении значения сопротивле- ния R (как функции сопротивления r), приводящего к эквивалентной цепи. На рис. 4.5 показано, как преобразовать цепь из двух резисторов с сопротивлениями r 1 и r2, если они соединены последовательно (a) или параллельно (b). Рис. 4.5. Эквивалентность резисторных соединений При последовательном соединении получающееся сопротивление равно r1 + r2, а при параллельном новое сопротивление r = (r1 · r2)/(r1 + r2), или иначе: 1/r = 1/r1 + 1/r2. (4.6) 2 Такое соединение называется ещё резисторной схемой лестничного типа или резисторной «лестницей». – Прим. перев.(a) (b)(r1 · r2) / (r1 + r2)(r1 + r2) r1 r2 r1 r2 r r r 1 2 3 n – 1 nrA r r r r BA BR A B A B A B A B\n--- Страница 147 ---\n146  Глава 4. Линейная рекурсия I: основные алгоритмы Рис. 4.6. Декомпозиция задачи о резистивной цепи и вывод рекурсивного условия методом индукции Эти правила можно применять последовательно к парам резисторов, пока не получится цепь из одного резистора. Однако данный процесс утомителен, и вместо него предлагается короткое и изящное рекурсив-ное решение задачи. Задача имеет два входных параметра: сопротивление r и число звень- ев n в цепи. Очевидно, размер задачи – n (r влияет на выходное зна- чение задачи (результат), но не влияет на время выполнения алгорит - ма). Пусть R(r, n) обозначает рекурсивную функцию. Начальное условие выполняется при n = 1, когда начальная цепь состоит только из одного резистора. Значит, в этом случае R(r, 1) = r. Для вывода рекурсивного условия нужно отыскать в исходной задаче подзадачу с точно такой же структурой. Рисунок 4.6(a) показывает декомпозицию задачи с умень-шением её размера на 1. Цепь, соответствующая подзадаче, может быть заменена единственным резистором с сопротивлением R(r, n – 1), как показано на рис. 4.6(b), когда на основании метода индукции можно считать её значение известным. Наконец, легко упростить получаю-щуюся цепь, состоящую всего из трёх резисторов. Во-первых, левый и верхний резисторы соединены последовательно. Значит, их можно объ-единить в один резистор с сопротивлением R(r, n – 1) + r. Наконец, этот (a) (b) r r 1 2 3 n – 1rA rrrr B A BR(r, n – 1) nr r r R(r, n)A B\n--- Страница 148 ---\n4.5. Упражнения  147 новый резистор соединён параллельно с правым резистором. Приме- няя (4.6), R(r, n) можно определить как: 1/R(r, n) = 1/r + 1/(R(r, n – 1) + r). Таким образом, рекурсивная функция: R(r, n) =, 1, 1/(1/ 1/( ( , 1) )), 1.rn r Rrn r n=  + −+ >  В листинге 4.17 приведён соответствующий код. И наконец, любо- пытное замечание: можно показать, что R(r, n) = r F(2n – 1) / F(2n), где F – функция Фибоначчи. Листинг 4.17. Функция, решающая задачу о резистивной цепи 1 2345def circuit(n, r): if n == 1: return r else: return 1 / (1 / r + 1 / (circuit(n – 1, r) + r)) 4.5. Упражнения Упражнение 4.1. Листинг 2.6 содержит линейно-рекурсивную логи- ческую функцию, определяющую, является ли неотрицательное целое число n чётным, когда декомпозиция уменьшает размер задачи (n) на два. Определите и закодируйте альтернативный метод с уменьшением размера задачи на 1. Упражнение 4.2. Реализуйте рекурсивную функцию вычисления b n за логарифмическое время для вещественного основания b и целой сте- пени n, которая может быть отрицательной. Упражнение 4.3. Реализуйте рекурсивную функцию вычисления n-й степени квадратной матрицы. Результатом вычисления будет другая квадратная матрица той же размерности. Используйте пакет NumPy и его методы: •identity : возвращает единичную матрицу; •shape : определяет размерность матрицы; •dot: умножает матрицы.если если\n--- Страница 149 ---\n148  Глава 4. Линейная рекурсия I: основные алгоритмы Наконец, вычислите матрицы: 11 10n  для n = 1, …, 10 и напечатайте элементы их первой строки и второго столбца. Каковы эти числа? Упражнение 4.4. Реализуйте рекурсивные функции вычисления «медленного» произведения двух неотрицательных целых чисел m и n. Алгоритму разрешено добавлять и вычитать числа, но запрещено использовать операцию умножения (*). Примените декомпозиции с уменьшением одного или обоих входных параметров на 1. Кроме того, изобразите схему осмысления рекурсивного процесса разработки за-дачи. В качестве примера воспользуйтесь общей схемой на рис. 2.5 или схемой вычисления произведения n и m как площади прямоугольника высотой n и шириной m, где результат – это количество единичных кле- ток внутри прямоугольника n×m, как на рис. 4.7. Рис. 4.7. Произведение двух неотрицательных целых чисел n и m как площадь прямоугольника размером n×m Упражнение 4.5. Реализуйте рекурсивную функцию более эффек - тивного «медленного» произведения, применив декомпозицию деле-нием обоих входных параметров пополам. Используйте прямоуголь-ные схемы на рис. 4.7. Упражнение 4.6. В языке Python, как и в других языках программи- рования, метод может быть параметром другого метода. Определите и закодируйте общую рекурсивную функцию вычисления суммы: g(m, n, f) = ()n imfi =∑ = f(m) + f(m + 1) + + f(n – 1) + f(n), где m и n – целые числа, а f – функция. Используйте её для вычисления и печати результата функции:n m\n--- Страница 150 ---\n4.5. Упражнения  149 3 1n ii =∑ , для n = 0, …, 4. Упражнение 4.7. Определите и закодируйте функцию вычисления количества цифр в неотрицательном целом числе n. Упражнение 4.8. Определите и закодируйте функцию, которая для заданного десятичного числа n, состоящего только из нулей и единиц, возвращает число, двоичное представление которого совпадает с деся- тичным представлением исходного числа n. Например, если n = 1011010, то функция должна вернуть 22, поскольку 101102 = 22. Упражнение 4.9. Выведите рекурсивное условие для задачи «преоб- разование десятичного числа к основанию b» из раздела 4.2.2 с приме- нением общей схемы осмысления рекурсивных условий на рис. 2.5. Упражнение 4.10. Вспомните задачу, которая обрабатывает (двоич- ные) числа n (справа налево). Выведите и закодируйте рекурсивный ал- горитм, который для конкретного числа x из n битов определяет пози- цию его младшего значащего единичного бита. В частности, учтите, что младший бит может быть в первой позиции. Например, для x = 01110100 младшая (самая правая) единица находится в позиции 3. Упражнение 4.11. Напишите рекурсивный метод решения упраж - нения 3.8, использующий в своих вычислениях функцию из упражне-ния 4.10. Напечатайте результаты для чисел из n = 1, …, 5 битов. Упражнение 4.12. Закодируйте рекурсивную функцию, возвращаю- щую количество гласных в заданной строке. Упражнение 4.13. Биномиальный коэффициент �n m� – функция двух целочисленных параметров n и m. Определите для вычисления бино- миального коэффициента три линейно-рекурсивные функции, исполь-зуя три декомпозиции: уменьшающую n, уменьшающую m и умень- шающую оба параметра. Используйте определение (3.1) для вывода рекурсивных условий. Упражнение 4.14. Замените цикл в листинге 4.16 рекурсивной функ - цией. Она должна получать строку треугольника Паскаля и возвращать строку с суммами соответствующих членов исходной строки. Напри-мер, если вход – [1, 3, 3, 1], то результат должен быть [4, 6, 4]. Упражнение 4.15. Рассмотрим неотрицательное целое число n, чьи цифры всегда расположены в неубывающем порядке слева направо, на-\n--- Страница 151 ---\n150  Глава 4. Линейная рекурсия I: основные алгоритмы пример 24667. Иными словами, если dm–1 … d1 d0 – последовательность из (m) цифр числа n, то di ≤ dj, если i < j. Пусть задана дополнительная цифра 0 ≤ x ≤ 9. Напишите функцию, которая возвращает такое целое число со вставленной в n цифрой x, что его цифры тоже расположены в неубывающем порядке слева направо. Например, если n = 24667 и x = 5, функция должна вернуть 245667. Постарайтесь избежать избыточных начальных условий. Упражнение 4.16. Это упражнение подобно упражнению 4.15. Зада- ны сортированный в порядке возрастания список чисел (a) и число x. Реализуйте функцию вставки x в список без нарушения его сортировки. отсортирован отсортированне отсортирован не отсортированШаг 5 Рис. 4.8. Шаг алгоритма сортировки вставкой Упражнение 4.17. Метод алгоритма «сортировки вставкой» сорти- рует список многократным применением процедуры на рис. 4.8. На i-м шаге элементы с индексами от 0 до i – 1 уже отсортированы, тогда как остальная часть списка не (обязательно) отсортирована. Для продол-жения процесса метод вставляет элемент с индексом i в сортирован- ный подсписок так, чтобы получающийся список (с индексами от 0 до i) оставался отсортированным. Если эта операция выполняется от индек - са (шага) 1 (или 0) до n – 1, то список останется отсортированным после последнего шага. Реализуйте рекурсивный вариант метода, который для сортировки списка использует решение упражнения 4.16. 0 1 2 3 4 5 6 7 8 9 10 11 125 3 1 2 6 7 5 9 1 4 8 8 3 4 0 1 2 3 4 5 6 7 8 9 10 11 125 3 1 6 5 2 7 9 1 8 8 3",
      "debug": {
        "start_page": 123,
        "end_page": 151
      }
    },
    {
      "name": "Глава 5. Линейная рекурсия II: хвостовая рекурсия 151",
      "content": "--- Страница 152 --- (продолжение)\nГлава 5 Линейная рекурсия II: хвостовая рекурсия Вы хороши лишь настолько, насколько хорош ваш последний поступок. – Стивен Ричардс Хвостовая линейная рекурсия, или «концевая» рекурсия, – это разно-видность линейной рекурсии, когда рекурсивные условия вызывают метод только один раз. Но в отличие от обычной линейной рекурсии хвостовой рекурсивный вызов – это последнее выполняемое методом действие. Например, функция (1.15) относится к хвостовой рекурсии, так как в рекурсивном условии она ничего не делает с результатом вы-зова функции. Это значит, что она вернёт значение, полученное непо-средственно в начальном условии. Кроме того, такие функции могут требовать большего количества параметров для сохранения промежу - точных результатов, которые будут использоваться в начальных усло-виях для получения конечного результата. Хвостовые рекурсивные ме-тоды встречались ранее в листингах 2.3, 2.5 и 2.6. В предыдущей главе все методы, за исключением методов из разде- ла 4.1.1.2, уменьшали размер задачи на 1 или 2. Однако в этой главе представлены в основном алгоритмы, которые делят размер задачи пополам. В этом случае рекурсивные вызовы решают одну задачу в половину размера исходной, так как методы вызывают себя лишь од-нажды. Некоторые авторы относят эту стратегию к методу «разделяй и властвуй». Однако мы будем использовать этот термин только для тех алгоритмов, которые должны будут решить несколько независи- мых подзадач, размеры которых – лишь часть исходной задачи. Такие\nГлава 5 Линейная рекурсия II: хвостовая рекурсия Вы хороши лишь настолько, насколько хорош ваш последний поступок. – Стивен Ричардс Хвостовая линейная рекурсия, или «концевая» рекурсия, – это разно-видность линейной рекурсии, когда рекурсивные условия вызывают метод только один раз. Но в отличие от обычной линейной рекурсии хвостовой рекурсивный вызов – это последнее выполняемое методом действие. Например, функция (1.15) относится к хвостовой рекурсии, так как в рекурсивном условии она ничего не делает с результатом вы-зова функции. Это значит, что она вернёт значение, полученное непо-средственно в начальном условии. Кроме того, такие функции могут требовать большего количества параметров для сохранения промежу - точных результатов, которые будут использоваться в начальных усло-виях для получения конечного результата. Хвостовые рекурсивные ме-тоды встречались ранее в листингах 2.3, 2.5 и 2.6. В предыдущей главе все методы, за исключением методов из разде- ла 4.1.1.2, уменьшали размер задачи на 1 или 2. Однако в этой главе представлены в основном алгоритмы, которые делят размер задачи пополам. В этом случае рекурсивные вызовы решают одну задачу в половину размера исходной, так как методы вызывают себя лишь од-нажды. Некоторые авторы относят эту стратегию к методу «разделяй и властвуй». Однако мы будем использовать этот термин только для тех алгоритмов, которые должны будут решить несколько независи- мых подзадач, размеры которых – лишь часть исходной задачи. Такие\n--- Страница 153 ---\n152  Глава 5. Линейная рекурсия II: хвостовая рекурсия алгоритмы представлены в главе 11. Наконец, особенность хвостовой рекурсии в том, что она тесно связана с итерацией, и в этой главе мы рассмотрим эту связь. 5.1. Логические функции Этот вводный раздел исследует, как выбор начальных условий может привести к линейным или хвостовым рекурсивным алгоритмам для не-которых логических (булевых) функций. 5.1.1. Есть ли в неотрицательном целом числе заданная цифра? Дано неотрицательное целое число n и некоторая (тоже целая) циф- ра d от 0 до 9. Цель задачи – определить, содержит ли n цифру d. Таким образом, рекурсивным методом будет логическая функция с парамет - рами n и d. Кроме того, будем считать, что n не может начинаться с циф- ры 0 (например, 358 не может быть записано как 0358), за исключением случая n = 0. 5.1.1.1. Линейно-рекурсивный алгоритм Первый шаг заключается в определении размера задачи, который, очевидно, равен количеству m цифр исходного числа n. Начальное ус - ловие выполняется, когда n состоит из одной цифры (то есть n < 10), а его результат – это результат сравнения (n = d). Допустим пока, что это – единственное начальное условие. Рекурсивное условие будет довольно громоздким, если выражать значение каждой цифры через значение n. Поэтому можно применить иное обозначение, обсуждавшееся в разделе 2.5.3. В частности, пусть d m–1 … d1d0 – последовательность из m цифр числа n по основанию 10. Тогда можно создать следующую схему с уменьшением размера задачи на 1 путём деления исходного числа n на 10 с отбрасыванием его наи- меньшей значащей цифры: Входы Результаты (n = dm–1 … d1d0, d) (n//10 = dm–1 … d1, d)(dm–1 = d) ∨ … ∨ (d1 = d) ∨ (d0 = d) ∨ (d0 = d) (dm–1 = d) ∨ … ∨ (d1 = d)\n--- Страница 154 ---\n5.1. Логические функции  153 где ∨ обозначает логическую операцию ИЛИ (дизъюнкцию). Из схемы ясно видно, что если d – цифра n, то она либо входит в n//10 (то есть в результат рекурсивного вызова), либо равна d0. В схеме допускаются и другие обозначения с использованием слов или выражений, не вполне корректных с логической или математиче- ской точки зрения. Например, можно воспользоваться явно неподходя-щим здесь символом принадлежности ∈, который применяется только к множествам. Так, d ∈ n на самом деле будет означать принадлежность цифры d множеству цифр числа n. Несмотря на это, схема выполняет свое назначение – точно определить рекурсивное условие функции. В листинге 5.1 приведён код, реализующий искомую функцию, где n%10 – наименьшая значащая цифра n. Заметьте, что метод – линей- но-рекурсивный, так как функция вызывает себя лишь раз и должна обработать результат подзадачи (то есть вычислить результат логиче-ского выражения с операцией or). Кроме того, если условие (n%10 == d) истинно, то компилятор или интерпретатор с «закорачиванием» (short-circuit) автоматически возвращал бы значение True, не вызывая contains_digit(n//10, d) . В частности, использование «закорачива- ния» позволяет избегать ненужных вычислений согласно свойствам ло-гических операций: True ∨ b = True и False ∧ b = False, где b – некоторое логическое выражение. Поскольку в этих случаях результат операции не зависит от значения b, то b можно не вычислять вообще. Листинг 5.1. Линейно-рекурсивная логическая функция, определяющая наличие в неотрицательном целом числе n заданной цифры d 1 2345def contains_digit(n, d): if n < 10: return n == d else: return (n % 10 == d) or contains_digit(n // 10, d)Входы Результаты (n, d) (n//10, d )d ∈ n d ∈ (n//10)∨ (n%10 = d )\n--- Страница 155 ---\n154  Глава 5. Линейная рекурсия II: хвостовая рекурсия 5.1.1.2. Алгоритм хвостовой рекурсии Большинство языков программирования поддерживает так называе- мое «закорачивание». Если его реализовать в дополнительном началь- ном условии, то это приведёт к хвостовому рекурсивному алгоритму. В частности, для этой задачи алгоритм может вернуть True, как только обнаружит цифру d в числе n. Поэтому можно вернуть True, если по- следняя цифра n равна d (то есть если n%10 = d). Взглянув на это началь- ное условие, можно убедиться, что в рекурсивном условии n%10 = d 0 ≠ d. Поэтому рекурсивная схема теперь будет такой: Она подразумевает, что результат подзадачи – это в точности резуль- тат исходной задачи и функция может вернуть результат рекурсивного вызова, не обрабатывая его. Вместе с начальными условиями она при-водит к хвостовому рекурсивному алгоритму, который можно закоди-ровать, как показано в листинге 5.2. Листинг 5.2. Хвостовая рекурсивная логическая функция, определяющая, содержит ли неотрицательное целое число n цифру d 1 234567def contains_digit_tail(n, d): if n < 10: return n == d elif n % 10 == d: return True else: return contains_digit_tail(n // 10, d) Важно понимать, что хотя выбранная декомпозиция делит входной параметр n на константу 10, размер задачи уменьшается всего на 1. Временнáя сложность алгоритма является логарифмом от числа n, но линейно зависит от количества его цифр m. Наконец, эта задача имеет аналогии, опирающиеся на такие структу - ры данных, как списки, массивы и т. д., поскольку они тоже представ-Входы Результаты (n = dm–1 … d1d0, d) (n//10 = dm–1 … d1, d)(dm–1 = d) ∨ … ∨ (d1 = d) (dm–1 = d) ∨ … ∨ (d1 = d)ничего не делать\n--- Страница 156 ---\n5.1. Логические функции  155 ляют собой последовательности элементов. Например, эта задача очень похожа на задачу о принадлежности некоторого символа строке или не-которого элемента списку. Хотя коды могут быть разными, но основное рассуждение, по сути, то же. 5.1.2. Равны ли строки? Следующая задача – сравнение двух строк (конечно, в языке Python мы можем просто воспользоваться операцией ==). Логическая функция, решающая эту задачу, будет иметь два строковых входных параметра. Если их длины различны, алгоритм немедленно вернёт False уже в на-чальном условии. Таким образом, сравнивать строки имеет смысл при одинаковой их длине, которая и является размером задачи. 5.1.2.1. Линейно-рекурсивный алгоритм Наименьший экземпляр задачи – когда обе строки пусты и результат, очевидно, равен True. В этом разделе мы предположим, что никаких дополнительных начальных условий, приводящих к линейно-рекур-сивной функции, нет. Применим декомпозицию с уменьшением разме-ра задачи на 1. Она сводится к поштучному отбрасыванию совпавших символов (в одной и той же позиции) в обеих входных строках. Отбра-сывание первых символов приводит к следующей рекурсивной схеме, где s и t – две входные строки длиной n: Ясно, что метод должен проверить совпадение первых символов и, оставшихся подстрок посредством рекурсивного вызова. Следователь-но, логическая функция будет такой: f(s, t) = 0 0 11 11False, ( ) ( ), True, 0, ( ) ( , ), 0 n nlength s length t n s t fs t n−−≠  =  =∧ > Входы (s, t) ∧ (s0 = t0) (s1 n–1, t1 n–1)f f n–1 ∧ i = 0(si = ti ) n–1 ∧ i = 1(si = ti ) если если еслиРезультаты\n--- Страница 157 ---\n156  Глава 5. Линейная рекурсия II: хвостовая рекурсия В листинге 5.3 приводится соответствующий код линейно-рекурсив- ной функции. Листинг 5.3. Линейно-рекурсивная функция, сопоставляющая две строки 1 234567def equal_strings(s, t): if len(s) != len(t): return False elif s == '': return True else: return s[0] == t[0] and equal_strings(s[1:], t[1:]) 5.1.2.2. Алгоритм хвостовой рекурсии На примере раздела 5.1.1 можно учесть «короткое замыкание», добавив дополнительное начальное условие. В частности, алгоритм может сразу вернуть False при обнаружении первого несовпадения символов в одной и той же позиции строк. Таким образом, можно до-бавить начальное условие с проверкой s 0 ≠ t0. В этом случае алгоритм мог бы сразу вернуть False. Такое начальное условие гарантирует, что в рекурсивном условии s 0 = t0. Таким образом, новая рекурсивная схе- ма будет такой: И опять результат подзадачи является в точности результатом исход- ной задачи, которая приводит к хвостовому рекурсивному алгоритму. В итоге вместе с начальными условиями функция может быть закоди-рована, как в листинге 5.4. 5.2. Алгоритмы поиска в списке Этот раздел посвящён алгоритмам, решающим классическую задачу поиска позиции i элемента x в списке a = [ a 0, a1, …, an–1]. Другими слова-Входы Результаты (s, t) ничего не делать (s1 n–1, t1 n–1)f f n–1 ∧ i = 0(si = ti ) n–1 ∧ i = 1(si = ti )\n--- Страница 158 ---\n5.2. Алгоритмы поиска в списке  157 ми, для заданных a и x найти индекс i, для которого ai = x. Если элемент x не единственный в списке, то метод решения задачи может вернуть любой индекс, указывающий на позицию x в списке. Для списка длины n метод решения задачи должен вернуть целочис - ленный индекс в пределах от 0 до n – 1, если элемент x найден в списке. Напротив, если список не содержит x, алгоритм должен вернуть неко- торое значение за пределами этого интервала. Некоторые реализации Python просто возвращают логическое значение False. Однако такой возможности нет во многих других языках (C, Java, Паскаль и т. д.), где методы могут возвращать только значения одного типа данных. По-скольку индексы – это, безусловно, целые числа, в этих языках резуль-тат должен быть также целым числом. Таким образом, ради совмести-мости с другими языками программирования мы будем использовать целочисленное значение –1 в случае, когда элемент не найден в спис - ке. Листинг 5.4. Функция с хвостовой рекурсией, сопоставляющая две строки 1 23456789def equal_strings_tail(s, t): if len(s) != len(t): return False elif s == '': return True elif s[0] != t[0]: return False else: return equal_strings_tail(s[1:], t[1:]) 5.2.1. Линейный поиск Сначала допустим, что список не (обязательно) сортирован. Любой алгоритм потребовал бы в худшем случае, когда элемент вообще не принадлежит списку, n сравнений. Отметим, что любой метод должен проверить каждый элемент списка, чтобы удостовериться, что его нет в списке. В этом случае алгоритм осуществляет «линейный поиск» эле-мента (последовательный перебор) в списке, время выполнения кото-рого O(n). Ясно, что размер задачи – n. Если список пуст, метод может просто вернуть –1. Другое начальное условие может вернуть позицию элемен-та, если он найден. Это начальное условие будет зависеть от способа де-\n--- Страница 159 ---\n158  Глава 5. Линейная рекурсия II: хвостовая рекурсия композиции. Если уменьшать размер задачи на 1, отбрасывая послед- ний элемент списка, то начальное условие должно проверить, находится ли x в последней позиции. Если действительно a n–1 = x, то метод может просто вернуть n – 1. Иначе будет выполняться рекурсивный вызов для решения подзадачи размера n – 1, а её результатом будет именно окон- чательный результат подзадачи, которая приводит к хвостовому рекур-сивному решению. В листинге 5.5 приводится возможная реализация описанной функции линейного поиска. Листинг 5.5. Хвостовая рекурсия при линейном поиске элемента в списке 1 2345678def linear_search_tail(a, x): n = len(a) if a == []: return –1 elif a[n – 1] == x: return n – 1 else: return linear_search_tail(a[:n – 1], x) В заключение стоит отметить, что в предыдущей декомпозиции по- зиции элементов подсписка совпадают с позициями исходного списка. Но если бы декомпозиция отбрасывала первый элемент списка, то все индексы в подсписке были бы на 1 меньше, чем в исходном. Например, если список – [2, 8, 5], то в первом случае элемент 8 в подсписке [2, 8] тоже был бы в позиции 1, а во втором он находился бы в позиции 0 в подсписке [8, 5]. Это приводит к более сложным методам, которые тре-буют дополнительного параметра. Например, в листинге 5.6 приведено решение, добавляющее 1 к результату каждого рекурсивного вызова. В тривиальном случае, когда x = a 0, метод возвращает 0, но для пустого списка начальное условие сложнее. Отметим, что по достижении этого начального условия алгоритм уже добавил n единиц в предыдущих n рекурсивных вызовах. Таким образом, он должен вернуть n – 1, где n – длина исходного списка (но не длину входного параметра, так как в этот момент он равен 0), чтобы в итоге вернуть –1, поскольку x не найден. Так как n не может быть получен из пустого списка, его нужно пере- давать дополнительным параметром каждому вызову функции, чтобы восстановить в начальном условии. По этой причине код требует охва-тывающего метода, когда третьим параметром рекурсивной функции является n.\n--- Страница 160 ---\n5.2. Алгоритмы поиска в списке  159 Листинг 5.6. Линейно-рекурсивный линейный поиск элемента в списке 1 234567891011def linear_search_linear(a, x, n): if a == []: return –n – 1 elif a[0] == x: return 0 else: return 1 + linear_search_linear(a[1:], x, n) def linear_search_linear_wrapper(a, x): return linear_search_linear(a, x, len(a)) В последней декомпозиции алгоритм начинает поиск элемента с ин- декса 0, постепенно достигая индекса n – 1. Другое решение заключа- ется в явном указании индекса элемента, который будет каждый раз сравниваться с x, в рекурсивном вызове. Для этого вводится новый па- раметр-сумматор, который увеличивается при каждом вызове функции и приводит к хвостовой рекурсии в листинге 5.7, возвращающей пра-вильное значение –1 для пустого списка. Функция должна вызываться с параметром-сумматором индекса, равным 0, из охватывающего ме-тода-оболочки. Наконец, обратите внимание, что результат хранится именно в этом параметре. Листинг 5.7. Альтернативный хвостовой рекурсивный линейный поиск элемента в списке 1 234567891011def linear_search_tail_alt(a, x, index): if a == []: return –1 elif a[0] == x: return index else: return linear_search_tail_alt(a[1:], x, index + 1) def linear_search_alt_tail_wrapper(a, x): return linear_search_tail_alt(a, x, 0) 5.2.2. Двоичный поиск в сортированном списке Если исходный список a уже отсортирован, то найти в нём нужный элемент можно гораздо быстрее. Пусть список отсортирован в порядке\n--- Страница 161 ---\n160  Глава 5. Линейная рекурсия II: хвостовая рекурсия возрастания, то есть ai ≤ ai+1 для i = 0, …, n – 2. Задача может быть реше- на за время O(log n) алгоритмами «двоичного поиска». Основная идея таких методов (а они могут быть разными) заключается в последова- тельном делении размера задачи пополам. Рисунок 5.1 иллюстрирует декомпозицию задачи. Рис. 5.1. Декомпозиция для алгоритмов двоичного поиска Сначала алгоритмы вычисляют средний индекс m. Если x = am, они за- канчивают работу в начальном условии, возвращая m. Иначе, поскольку список отсортирован, можно продолжить поиск x в одном из двух под- списков – справа или слева от m. В частности, если x < am, то x не может оказаться в правом подсписке [am, …, an–1], и методы могут продолжить поиск x в левом подсписке [a0, …, am–1], как показано на рис. 5.1(a). Ана- логично, если x > am, то x может появиться только в [am+1, …, an–1], как показано на рис. 5.1(b). В сущности, этот подход делит размер зада-чи (n) пополам. Поэтому время выполнения будет определяться форму - лой (3.20), то есть в самом худшем случае методы будут выполняться за логарифмическое время от n. Наконец, функции возвращают –1 (в на- чальном условии), если список пуст. Подобно функциям линейного поиска в листингах 5.6 и 5.7, методы двоичного поиска должны включать дополнительные входные параме-тры для указания индексов исходного списка. Например, рассмотрим поиск 8 в списке [1, 3, 3, 5, 6, 8, 9]. Если в рекурсивном вызове функции мы передаём ей только подсписок [6, 8, 9], то в нём 8 теперь имеет ин-декс 1, тогда как в исходном списке значение 8 находится в позиции 5. Таким образом, нужно указать, что первый индекс подсписка должен быть именно 5. Другими словами, нужно определить дополнительный параметр – начальную позицию подсписка в исходном списке. В лис - тинге 5.8 приведена реализация метода, который включает не только (a) (b)Исходная задача x < amИсходная задача Подзадача Подзадачаx > am m ma a\n--- Страница 162 ---\n5.3. Двоичные деревья поиска  161 этот параметр ( lower ), но и ещё один параметр ( upper ) – конечный ин- декс подсписка в исходном списке. Таким образом, lower и upper просто задают границы подсписка внутри a. Параметр upper в Python не обяза- телен, поскольку для определения верхнего индекса подсписка надо ис - пользовать длину списка (упражнение 5.4 предлагает реализовать ме- тод, использующий только параметр lower ). Однако код в листинге 5.8 проще в том смысле, что требует меньше арифметических операций, не передаёт сам себе подсписок (рекурсивные вызовы используют весь список a) и показывает, как можно реализовать метод в других языках программирования, где длина списков не доступна напрямую. В част - ности, если lower больше upper, то список пуст, а метод возвращает –1. В противном случае функция проверяет начальное условие x = am. Если x оно неверно, метод выполняет один из двух рекурсивных вызовов (с со-ответствующим подсписком) в зависимости от условия x < a m. Наконец, метод-оболочка используется для инициализации индексов lower и upper значениями 0 и n – 1 соответственно. Листинг 5.8. Двоичный поиск элемента в списке 1 2345678910111213141516def binary_search(a, x, lower, upper): if lower > upper: # empty list return –1 else: middle = (lower + upper) // 2 if x == a[middle]: return middle elif x < a[middle]: return binary_search(a, x, lower, middle – 1) else: return binary_search(a, x, middle + 1, upper) def binary_search(a, x): return binary_search(a, x, 0, len(a) – 1) 5.3. Двоичные деревья поиска Двоичные (бинарные) деревья поиска – это структура данных, исполь- зуемая для хранения элементов данных, каждому из которых назначен определенный ключ (будем считать ключи уникальными), подобно вхо-\n--- Страница 163 ---\n162  Глава 5. Линейная рекурсия II: хвостовая рекурсия дам в словаре языка Python. Это – важная структура данных, позволя- ющая эффективно выполнять такие операции, как поиск, вставка или удаление элементов. Данные в каждом узле двоичного дерева – это пара (ключ, элемент), а его узлы упорядочены по значению ключей, которые можно сравнивать операцией < или некоторой равнозначной ей функ - цией (то есть полное бинарное отношение предшествования). В част - ности, для любого узла дерева каждый ключ левого поддерева меньше ключа этого узла, тогда как все ключи правого поддерева больше ключа этого узла. Это основное «свойство двоичного дерева поиска», подразу - мевающее, что каждое поддерево двоичного дерева поиска – тоже дво-ичное дерево поиска. Например, эта структура данных может использоваться для хранения информации о днях рождения. На рис. 5.2 приведено двоичное дерево, позволяющее находить дни рождения семи человек по их именам-стро-кам, которые мы будем считать уникальными (для уникальной иден-тификации каждого человека можно, конечно, добавить ещё фамилии или прозвища). Ключи могут быть строками, поскольку их тоже можно сравнивать, например, в лексикографическом порядке (в Python можно просто воспользоваться операцией <). Поэтому имена в двоичном де-реве поиска отсортированы так же, как в обычном словаре. Например, если взять корневой узел «Emma», то можно заметить, что все имена в его левом поддереве располагаются в словаре до него, а все имена в правом поддереве – после него. Более того, этим свойством обладают все узлы двоичного дерева поиска. Рис. 5.2. Двоичное дерево поиска с информацией о днях рождения Прежде чем реализовать двоичное дерево поиска, нужно решить, как его представить. Существует несколько способов (один из наиболее общих подходов – воспользоваться объектно-ориентированными воз-можностями, определив, например, класс «узел дерева»), но в этой кни-Emma Anna Paul Lara Sara Luke John2002/08/23 1999/12/03 2000/01/13 1987/08/23 1995/03/14 2006/05/08 1976/07/31\n--- Страница 164 ---\n5.3. Двоичные деревья поиска  163 ге мы будем использовать обычные списки. В частности, каждый узел дерева будет списком из четырех элементов: ключа, элемента, левого и правого поддеревьев, где поддеревья – это тоже двоичные деревья. Таким образом, двоичное дерево на рис. 5.2 представлялось бы следую-щим списком: [Emma, 2002/08/23, [Anna, 1999/12/03, [], []], [Paul, 2000/01/13, [Lara, 1987/08/23, [John, 2006/05/08, [], []], [Luke, 1976/07/31, [], []]], [Sara, 1995/03/14, [], []]], (5.1) изображённым на рис. 5.3. Обратите внимание, что для всех листовых узлов их левые и правые поддеревья – пустые списки. Рис. 5.3. Двоичное дерево поиска (см. рис. 5.2 и 5.1), где каждый узел – список из четырёх элементов: имени (строка), дня рождения (строка), левого поддерева (список) и правого поддерева (список) 5.3.1. Поиск элемента Цель следующей задачи – найти в двоичном дереве поиска элемент с заданным ключом k и получить его значение. Можно предположить, что размер задачи – высота дерева. Тривиальное начальное условие вы-полняется, когда список, представляющий двоичное дерево, пуст. В этом случае алгоритм может просто вернуть None . Есть другая ситуация, когда алгоритм может выдать результат, не выполняя рекурсивного вызова. Если ключ корневого узла равен k, то элемент сразу же найден и является результатом решения задачи. Таким образом, в рекурсивных условиях нужно убедиться, что корневой узел не содержит искомого элемента. Цель следующего нашего шага – найти соответствующую декомпози- цию задачи, уменьшающую ее размер. Нам уже известно, что деревь я составляются рекурсивно из поддеревьев. Таким образом, нужно про-‘Emma’ ‘ Anna’ ‘Paul’ ‘Lara’ ‘Sara’ ‘Luke’ ‘John’‘2002/08/23’ ‘1999/12/03’ ‘2000/01/13’ ‘1987/08/23’ ‘1995/03/14’ ‘2006/05/08’ ‘1976/07/31’ [ ] [ ][ ] [ ] [ ] [ ][ ] [ ]\n--- Страница 165 ---\n164  Глава 5. Линейная рекурсия II: хвостовая рекурсия извести поиск элемента в двух поддеревьях двоичного дерева. Это га- рантирует уменьшение размера задачи на 1, так как корневой узел уже проверен. Однако легко видеть, что в этой задаче можно также избе-жать поиска во всем поддереве. Если ключ k меньше ключа корневого узла (k root), то понятно, что согласно свойству двоичного дерева поиска искомого элемента не может быть в правом поддереве. Аналогично, если k > k root, элемента не может быть в левом поддереве. Рисунок 5.4 ил- люстрирует эту идею, где xroot – элемент, сохранённый в корневом узле. Рис. 5.4. Декомпозиция для некоторых алгоритмов поиска в двоичном дереве Понятно, что для этой частной задачи существует два рекурсивных условия. Если k < kroot, метод должен продолжить поиск в левом поддере- ве посредством рекурсивного вызова, тогда как если k > kroot, он должен искать элемент в правом поддереве. В листинге 5.9 приведена реализа-ция алгоритма поиска, где каждый узел двоичного дерева – это список из четырёх компонентов, как описано в разделе 5.3. Листинг 5.9. Алгоритм поиска элемента с заданным ключом в двоичном дереве 1 23456789def bst_search(T, key): if T == []: return None elif T[0] == key: return T[1] # return the root item elif key < T[0]: return bst_search(T[2], key) # search in left subtree else: return bst_search(T[3], key) # search in right subtreek > krootПодзадачаИсходная задача ПодзадачаИсходная задача k < krootkrootkrootxrootxroot\n--- Страница 166 ---\n5.4. Схемы разбиения  165 В итоге временнáя стоимость алгоритма определяется в самом худ- шем случае высотой двоичного дерева. Если дерево сбалансировано (то есть имеет примерно равное количество узлов на одном и том же уров-не в левых и правых поддеревьях), то время его работы – (log n), где n – число узлов в дереве, поскольку при каждом рекурсивном вызове он пропускает примерно половину узлов. Но если дерево имеет линейную структуру, то оценка времени работы алгоритма – O(n). 5.3.2. Вставка элемента Цель этой задачи – вставить элемент с заданным ключом k в двоич- ное дерево так, чтобы получающееся дерево тоже удовлетворяло основ-ному свойству двоичного дерева. Метод представляет собой процеду - ру, которая получает два параметра: (1) кортеж x из ключа и значения элемента и (2) двоичное дерево T. Он должен, в частности, расширить список T, добавив в него новый лист. И здесь можно считать, что размер задачи – это высота дерева. Самое простое начальное условие выполняется для пустого дерева. В этом случае алгоритм должен расширить дерево, включив в него один узел, у которого, очевидно, нет дочерних записей. При декомпозиции задачи мы будем при-держиваться схемы на рис. 5.4. Очевидно, если дерево не пусто и k меньше ключа корневого узла, то процедура вставит узел в левое поддерево. Иначе она вставит его в правое поддерево. Сразу предположим, что k < k root. Есть два возможных сценария, приводящих к начальному и рекур- сивному условиям. Если у корневого узла нет левого поддерева, то про-цедура может просто заменить соответствующий пустой список узлом, содержащим ключ и элемент (и два пустых поддерева). Но если у кор-невого узла есть непустое левое поддерево, то метод должен вставить в него новый узел, что, естественно, приводит к рекурсивному вызову. То же справедливо и для правого поддерева. В листинге 5.10 приведена возможная реализация процедуры. 5.4. Схемы разбиения Известная задача в информатике – разбиение списка следующим спо-собом. 1. В списке выбирается «опорный» элемент – обычно первый, сред-ний или выбранный наугад. 2. Элементы входного списка меняются местами внутри него таким образом, чтобы начальные элементы были не больше опорного, а все остальные больше него.\n--- Страница 167 ---\n166  Глава 5. Линейная рекурсия II: хвостовая рекурсия Листинг 5.10. Процедура вставки элемента с заданным ключом в двоичное дерево 1 234567891011121314def insert_binary_tree(x, T): if T == []: T.extend([x[0], x[1], [], []]) else: if x[0] < T[0]: if T[2] == []: T[2] = [x[0], x[1], [], []] else: insert_binary_tree(x, T[2]) else: if T[3] == []: T[3] = [x[0], x[1], [], []] else: insert_binary_tree(x, T[3]) Рисунок 5.5 иллюстрирует идею на конкретном примере. Задача от - носится к числу важнейших, поскольку метод разбиения лежит в осно- ве таких выдающихся алгоритмов, как quickselect (см. раздел 5.5) или quicksort (см. раздел 6.2.2). Есть несколько известных и эффективных алгоритмов, также использующих «схему разбиения» и решающих ту же задачу. Самый популярный из них – метод разбиения, разработан-ный Чарльзом Хоаром, который мы вкратце рассмотрим в дальнейшем. Но сначала мы разберём более простые и интуитивно понятные рекур-сивные алгоритмы. Рис. 5.5. Разделение списка, используемого в алгоритмах quicksort и quickselectОпорный элемент > Опорный элемент ≤ Опорный элемент5 1 6 7 4 4 3 1 6 5 73 7 76 64 4\n--- Страница 168 ---\n5.4. Схемы разбиения  167 5.4.1. Основная схема разбиения Простая идея заключается в просмотре всего входного списка с це- лью построить: (1) новый список из элементов, не бóльших опорного, и (2) другой список из элементов, бóльших опорного. После чего их мож - но объединить, вставив между ними опорный элемент. Так как обе задачи очень похожи, мы разберём только первую. В част - ности, вход задачи – список длины n и некоторое значение x, исполняю- щее роль опорного элемента. Её размер – очевидно, длина списка. На-чальное условие возникает при пустом входном списке, когда алгоритм просто возвращает пустой список. Для вывода рекурсивного условия применим декомпозицию с уменьшением размера задачи на 1 путём отбрасывания первого элемента списка. В этом случае можно сформи-ровать следующие рекурсивные схемы в зависимости от соотношения между 1-м и опорным элементами списка. Если 1-й элемент не больше опорного, то схема для конкретного списка может быть такой: Ясно, что алгоритм должен объединить 1-й элемент списка с резуль- татом подзадачи. Напротив, если 1-й элемент больше опорного, то схе-ма будет такой: В этом случае алгоритм просто должен вернуть решение (список) подзадачи. В листинге 5.11 приведён линейно-рекурсивный код, ре-шающий обе задачи (обратите внимание, что в рекурсивных условиях, выполняющих объединение списков, вызов функции не является по-следним действием метода). Входы Результаты ([6, 1, 7, 4], 5)объединить с [3]([3, 6, 1, 7, 4], 5) [3, 1, 4] [1, 4] Входы Результаты ([6, 1, 7, 4], 5)([9, 6, 1, 7, 4], 5) [1, 4] [1, 4]ничего не делать\n--- Страница 169 ---\n168  Глава 5. Линейная рекурсия II: хвостовая рекурсия Листинг 5.11. Вспомогательные методы для разбиения списка 1 2345678910111213141516def get_smaller_than_or_equal_to(a, x): if a == []: return [] elif a[0] <= x: return [a[0]] + get_smaller_than_or_equal_to(a[1:], x) else: return get_smaller_than_or_equal_to(a[1:], x) def get_greater_than(a, x): if a == []: return [] elif a[0] > x: return [a[0]] + get_greater_than(a[1:], x) else: return get_greater_than(a[1:], x) Время выполнения методов можно оценить как: T(n) =1, 0, ( 1) 1, 0.n Tn n=  −+ >  Это значит, что время выполнения методов линейно относительно n. Наконец, функции можно заменить выражениями языка Python, реа- лизующими «фильтры». В частности, функции get_smaller_than_or_ equal_to(a, x) и get_greater_than(a, x) возвращают те же списки, что и выражения [y f o r y i n i f y <= x] и [y f o r y i n i f y > x] соответственно. 5.4.2. Метод разбиения Хоара В листинге 5.12 приведена итерационная версия алгоритма разбие- ния Хоара. В частности, он выполняет внутреннее разбиение списка a на подсписки, которые определяются своими нижним и верхним ин-дексами. Сначала метод выбирает опорный элемент (в данном случае – в се- редине подсписка) и меняет его с первым элементом подсписка (стро-ки 3–6). Затем он устанавливает левый индекс на второй позиции подсписка, а правый – на последней (строки 8 и 9). После чего метод за-пускает основной цикл алгоритма. В нём он последовательно увеличи-вает левый индекс, пока тот не укажет на элемент, больший, чем опор-ный (строки 13 и 14). Таким же образом он уменьшает правый индекс, если если\n--- Страница 170 ---\n5.4. Схемы разбиения  169 пока тот не укажет на элемент, не больший опорного (строки 16 и 17). После этого (строки 19–22) алгоритм меняет элементы, на которые ссы-лаются левый и правый индексы (если левый индекс меньше правого). Этот процесс повторяется до тех пор, пока индексы не пересекутся (то есть пока левый индекс не станет больше правого, что проверяется в строке 24). В конце цикла элементы до правого индекса будут не боль-ше опорного, а элементы после левого индекса (и до конца подсписка) будут больше опорного. В заключение процедура разбиения меняет мес тами элемент с правым индексом и опорный (строки 26 и 27) и воз- вращает его окончательную позицию. На рис. 5.6 приведён конкретный пример метода разбиения. Листинг 5.12. Итерационный алгоритм разбиения Хоара 1 234567891011121314151617181920212223242526272829def partition_Hoare(a, lower, upper): if upper >= 0: middle = (lower + upper) // 2 pivot = a[middle] a[middle] = a[lower] a[lower] = pivot left = lower + 1 right = upper finished = False while not finished: while left <= right and a[left] <= pivot: left = left + 1 while a[right] > pivot: right = right – 1 if left < right: aux = a[left] a[left] = a[right] a[right] = aux finished = left > right a[lower] = a[right] a[right] = pivot return right\n--- Страница 171 ---\n170  Глава 5. Линейная рекурсия II: хвостовая рекурсия Рис. 5.6. Пример метода разбиения Хоара Рассмотрим теперь алгоритм хвостовой рекурсии, который должен заменить основной цикл в схеме разбиения Хоара. Для заданных вход- ного списка a, начальных значений левого и правого индексов, а так -Индекс опорного элемента Выбрать опорный элемент и индексы левого и правого элементов Поменять местами опорный и первый элементы Переместить левый и правый индексы Поменять местами левый и правый элементы Поменять местами опорный и правый элементыПереместить левый и правый индексыlower upper 5 1 6 7 4 4 3 1 6 5 73 7 76 64 4 51 67 4 43 16 5 7 3 7 7 66 44left right 51 6 74 43 16 5 7 3 77 66 44leftright leftright\n--- Страница 172 ---\n5.4. Схемы разбиения  171 же опорного элемента метод должен, подобно циклу в методе Хоара, разбить список и вернуть заключительную позицию правого индекса. Размер задачи – это разность между левым и правым индексами, по-скольку именно она определяет количество операций увеличения и уменьшения индексов до их пересечения. Именно в тот момент, когда левый индекс становится больше правого, выполняется начальное ус - ловие, а метод просто возвращает правый индекс. В рекурсивном условии мы будем сокращать размер задачи путём увеличения левого индекса и/или уменьшения правого. Возможны два разных сценария, приведённых на рис. 5.7, где p – опорный элемент, left и right – соответственно левый и правый индексы. Рис. 5.7. Декомпозиция задачи о разбиении Хоара Если a[left] > p и a[right] ≤ p, то сначала метод должен поменять места- ми элементы с этими индексами и только после этого выполнить вызов функции с продвижением обоих индексов, как показано на рис. 5.7(a). Это приводит к первому рекурсивному условию, уменьшающему раз- мер задачи на две единицы. Если предыдущее условие не выполняет -(a) (b)поменять местами left right left right left right left right left right left right left right left right\n--- Страница 173 ---\n172  Глава 5. Линейная рекурсия II: хвостовая рекурсия ся, метод не поменяет местами элементы, а изменит, по крайней мере, один из индексов (уменьшив тем самым размер задачи), как показано на рис. 5.7(b). Если a[left] ≤ p, он увеличит левый индекс, а если a[right] > p – уменьшит правый. После этого метод вызывает сам себя с новыми зна-чениями индексов. В листинге 5.13 приводится соответствующий код вместе с методом-оболочкой, завершающим алгоритм разбиения. От - метим, что он идентичен листингу 5.12, цикл которого заменён вызо-вом рекурсивной функции. Наконец, метод работает за время O(n), так как время выполнения рекурсивного метода может быть в самом худ-шем случае оценено рекуррентным соотношением T(n) = T(n – 1) + 1. Листинг 5.13. Альтернативная рекурсивная версия схемы разбиения Хоара 1 2345678910111213141516171819202122232425262728293031def partition_Hoare_rec(a, left, right, pivot): if left > right: return right else: if a[left] > pivot and a[right] <= pivot: aux = a[left] a[left] = a[right] a[right] = aux return partition_Hoare_rec(a, left + 1, right – 1, pivot) else: if a[left] <= pivot: left = left + 1 if a[right] > pivot: right = right – 1 return partition_Hoare_rec(a, left, right, pivot) def partition_Hoare_rec(a, lower, upper): if upper >= 0: middle = (lower + upper) // 2 pivot = a[middle] a[middle] = a[lower] a[lower] = pivot right = partition_Hoare_rec(a, lower + 1, upper, pivot) a[lower] = a[right] a[right] = pivot return right\n--- Страница 174 ---\n5.5. Алгоритм quickselect  173 5.5. Алгоритм quickselect Алгоритм quickselect, также разработанный Чарльзом Хоаром, – это алгоритм поиска выбором, основанный на схеме разбиения Хоара (см. раздел 5.4.2). В частности, он находит в несортированном списке k-е наименьшее число (называемое также статистикой k-го порядка). Пусть экземпляр задачи определяется входными параметрами – чис - ловым списком a, нижним и верхним индексами внутри списка и поло- жительным целочисленным значением k. Тогда алгоритм должен найти k-е наименьшее число в заданном подсписке. Размер задачи – длина подсписка. Наименьшие экземпляры задачи соответствуют спискам из одного элемента. Поэтому начальное условие выполняется, когда нижний и верхний индексы совпадают, а метод просто возвращает этот единственный элемент списка. Для больших списков метод сначала применяет схему разбиения Хоа- ра, который делит список на три подсписка и упорядочивает каждый из них. Первый подсписок содержит элементы, не большие выбранного опорного элемента списка. За ним следует подсписок, состоящий толь-ко из одного опорного элемента. И наконец, третий подсписок содер-жит элементы, бóльшие опорного. Пусть i p обозначает индекс опорного элемента. Поскольку функция, реализующая схему разбиения Хоара, возвращает ip, можно проверить, равен ли он k – 1 (так как индексы начинаются с 0, а j-й элемент нахо- дится в позиции j – 1). Если это так, то опорный элемент – k-й наимень- ший элемент в a, и метод заканчивается на этом начальном условии. Этот сценарий приведён на рис. 5.8(a). Рис. 5.8. Начальное условие и декомпозиция задачи, используемые алгоритмом quickselectИсходная задачаПодзадачаip = k – 1 (a) (b) (c)Исходная задачаПодзадачаip > k – 1 ip < k – 1a a a\n--- Страница 175 ---\n174  Глава 5. Линейная рекурсия II: хвостовая рекурсия В рекурсивном условии алгоритм уменьшает размер задачи за счёт перехода либо к левому от опорного элемента подсписку, либо к право- му. Если ip > k – 1, то позиция искомого элемента будет меньше ip, алго- ритм может сосредоточиться на подсписке слева от опорного, как пока-зано на рис. 5.8(b). Иначе, если i p < k – 1, алгоритм продолжает решать подзадачу в правом от опорного подсписке, как показано на рис. 5.8(c). В заключение приведём листинг 5.14 с реализацией хвостовой рекур-сивной функции. Листинг 5.14. Хвостовой рекурсивный алгоритм quickselect 1 23456789101112def quickselect(a, lower, upper, k): if lower == upper: return a[lower] else: pivot_index = partition_Hoare_wrapper(a, lower, upper) if pivot_index == k – 1: return a[pivot_index] elif pivot_index < k – 1: return quickselect(a, pivot_index + 1, upper, k) else: return quickselect(a, lower, pivot_index – 1, k) Оценка времени выполнения алгоритма зависит от положения опор- ного элемента после выполнения декомпозиции. Если он всегда нахо- дится в середине списка, время выполнения характеризуется функцией T(n) =1, 1, ( /2) , 1,nn Tn c n≤  +>  поскольку алгоритму требуется решить подзадачу примерно в полови-ну размера исходной задачи, так как основанные на разбиении методы работают за линейное время. Это лучший вариант развития событий, когда T(n) ∈ Θ(n). Однако если опорный элемент всегда оказывается в крайних позициях списка, время выполнения может быть оценено функцией T(n) = 1, 1, ( 1) , 1,nn Tn c n≤  −+ >  которая является квадратичной, то есть T(n) ∈ Θ(n2). Эта ситуация соот - ветствует худшему варианту развития событий в алгоритме.если если если если\n--- Страница 176 ---\n5.6. Двоичный поиск корня функции  175 5.6. Двоичный поиск корня функции Рассмотрим непрерывную действительную функцию f(x), определен- ную на интервале [a, b]. Алгоритм двоичного поиска (также известный как метод деления интервала пополам, половинного деления, бисекции или дихотомии) – это способ поиска приближения z корня f(x) на ин- тервале (a, b). Напомним, что корень, или ноль f(x), – это значение r, для которого f(r) = 0. Входные параметры задачи – границы интервала a и b, где a ≤ b, функ - ция f и малое значение 𝜖 > 0, задающее точность приближения, то есть выходной параметр функции z должен удовлетворять условию | z – r | ≤ 𝜖. Таким образом, чем меньше 𝜖, тем точнее приближение. Ещё одно обя- зательное условие – то, что f(a) · f(b) < 0. Это гарантия того, что корень находится внутри интервала (a, b). Наконец, приближение z определя- ется серединой интервала (a, b), то есть z = (a + b)/2. Метод последовательно делит пополам тот интервал, где должен быть корень. На рис. 5.9 приведено несколько шагов этого процесса. Шаг 1 Шаг 2 Шаг 3Начальная установкаf(x) f(x)f(x) f(x)a a a ab b b bzˆ zˆ zˆ zˆr r r r Рис. 5.9. Несколько шагов алгоритма двоичного поиска корня В исходном положении корень расположен слева от первого прибли- жения z или середины интервала (r < z), поэтому на следующем шаге\n--- Страница 177 ---\n176  Глава 5. Линейная рекурсия II: хвостовая рекурсия граница b смещается ближе к этой середине. Точно так же на шаге 1 z < r, поэтому на следующем шаге a получит значение z. Эта процедура при- меняется многократно до тех пор, пока интервал не станет достаточно маленьким, чтобы обеспечить для z необходимую точность. Размер задачи зависит от длины отрезка [a, b], а начальное условие выполняется при b – a ≤ 2 𝜖, когда метод возвращает z = ( a + b)/2. Заме- тим, что это условие обеспечивает выполнение условия | z – r | ≤ 𝜖, как видно по рис. 5.10. В частности, если z – середина отрезка [a, b], то рас - стояние между z и r не может быть больше 𝜖. Кроме того, метод может просто вернуть z, если f(z) = 0 (или f(z) достаточно мала). f(x)zˆ | – r | ≤ 𝜖 𝜖r 𝜖a b zˆ Рис. 5.10. Начальное условие алгоритма двоичного поиска (b – a ≤ 2𝜖) Декомпозиция задачи заключается в делении её размера пополам. Это достигается заменой одного из граничных значений отрезка [a, b] его серединой z. Поскольку знаки значений функции на концах отрез- ка должны быть противоположными, z должен заменить b, когда f(a) и f(z) имеют противоположные знаки. Иначе z заменяет a. Это приводит к хвостовому рекурсивному методу в листинге 5.15, содержащему два рекурсивных условия. В коде используется функция f(x) = x 2 – 2, которая позволяет найти приближение √2 , поскольку это корень f(x). Отметим, что начальный интервал [0, 4] содержит √2 . Наконец, погрешность при- ближения будет не более 10–10 (результат получится с точностью до де- вяти десятичных цифр после десятичной запятой). Листинг 5.15. Алгоритм двоичного поиска корня функции 1 234567def f(x): return x * x – 2 def bisection(a, b, f, epsilon): z = (a + b) / 2\n--- Страница 178 ---\n5.7. Задача лесоруба  177 8 91011121314151617 if f(z) == 0 or b – a <= 2 * epsilon: return z elif (f(a) > 0 and f(z) < 0) or (f(a) < 0 and f(z) > 0): return bisection(a, z, f, epsilon) else: return bisection(z, b, f, epsilon) # Print an approximation of the square root of 2 print (bisection(0, 4, f, 10**(–10))) 5.7. Задача лесоруба В этой задаче лесорубу нужно заготовить w погонных метров древеси- ны на лесном участке из n деревьев. У него есть специальная машина, пилу которой можно установить на любую высоту h так, чтобы срезать деревья выше этой высоты. Пусть w – целое число (не превосходящее суммарной высоты всех деревьев на участке), а высоты n деревьев (тоже целочисленные) заданы в списке t. Цель задачи – найти наибольшее значение h, которое позволит лесорубу заготовить по крайней мере1 w погонных метров древесины. На рис. 5.11 приведён пример задачи для n = 20 деревьев, где высота самого высокого дерева H = 12. Если нуж - но заготовить 10 погонных метров леса, то лесоруб должен установить высоту пилы h = 8, чтобы спилить в точности 10 погонных метров. И даже если нужно заготовить 7, 8 или 9 погонных метров леса, то опти-мальная высота h всё равно была бы равна 8. Несмотря на то что лесо- руб заготовил бы несколько больше погонных метров древесины, h не должна быть больше, поскольку срез на высоте 9 дал бы только 6 погон-ных мет ров древесины. Задача представляет интерес с алгоритмической точки зрения, по- скольку может быть решена несколькими способами. Например, деревь я можно сначала отсортировать в порядке убывания их высот, а затем спиливать от самого высокого до самого низкого до получения опти-мального результата. Этот подход работал бы за время O(n log n), если бы мы применяли такие общие алгоритмы сортировки, как сортировка слиянием или quicksort (см. главу 6). Так как высоты – это целые числа, можно применить линейные алгоритмы сортировки за линейное время, как в методе сортировки подсчётом (см. упражнение 5.3), который при-вел бы к решению, работающему за время O(n + H). Таким образом, при малых значениях H этот подход мог бы быть наиболее эффективным. 1 То есть с минимальным излишком. – Прим. перев.\n--- Страница 179 ---\n178  Глава 5. Линейная рекурсия II: хвостовая рекурсия H h12 1110 98 76 5 4 3 2 1 0 1 n Рис. 5.11. Пример задачи лесоруба Теперь рассмотрим алгоритм решения задачи методом «двоичного поиска», который работает за время O(n log H) и не требует сортиров- ки деревьев по высоте. Сразу отметим, что алгоритм начинает работу с h = H – 1, постепенно уменьшая её на 1 до получения нужного коли- чества леса. Для простоты предположим, что метод вычисляет количество леса, полученное для каждой новой высоты h независимо от количества, по- лученного для других высот. Это значит, что вычисление количества леса, собранного с n деревьев, требует порядка n операций. Поэтому для решения всей задачи алгоритм потребовал бы O(nH) операций в самом худшем случае (для каждой из возможных высот H алгоритм должен будет выполнить n вычислений). В частности, количество леса, собран- ного для некоторой высоты h, может быть получено линейно-рекурсив- ной функцией из листинга 5.16 (в упражнении 11.2 предлагается реа-лизовать хвостовую рекурсивную версию этой функции). В начальном условии, когда список высот деревьев пуст, метод возвращает ноль. Ре-курсивное условие обрабатывает высоту первого дерева из списка. Если она больше h, то дерево будет спилено, а функция должна вернуть (за счёт рекурсивного вызова) разницу между высотой дерева t 0 и h плюс длина уже заготовленной с остальной части деревьев древесины. Если высота дерева не больше h, то дерево не спиливается, и метод может просто вернуть величину уже заготовленного леса.Цель: найти высоту (h) для сбора (10) единиц древесины\n--- Страница 180 ---\n5.7. Задача лесоруба  179 Листинг 5.16. Функция, вычисляющая количество древесины, если деревья срезаются на высоте h 1 2345678def compute_wood(t, h): if t == []: return 0 else: if t[0] > h: return t[0] – h + compute_wood(t[1:], h) else: return compute_wood(t[1:], h) Вместо постепенного уменьшения h на 1 следующий алгоритм ис - пользует стратегию, подобную двоичному поиску элемента в списке или методу деления пополам. Идея состоит в том, чтобы начать поиск высоты h с середины интервала [0, H] и постепенно делить его пополам, пока не будет получено решение. Таким образом, метод получает в ка-честве параметров высóты деревьев, погонный метраж заготовляемой древесины, а также нижний и верхний пределы интервала поиска h. Размер задачи – это разность между верхним и нижним предела- ми (сначала равна H). Первое начальное условие выполняется, если их значения равны. В этом случае высота h будет именно этим зна- чением. В противном случае алгоритм вычислит «среднюю» высоту как (целочисленное) среднее от нижнего и верхнего пределов. Если суммарная длина спиленной на этой средней высоте древесины рав-на w, то метод возвращает эту среднюю высоту во втором начальном условии. На рис. 5.12 показана используемая в алгоритме декомпозиция за- дачи. Исходная задача показана вверху с учётом нижнего и верхнего пределов. После вычисления общей длины древесины, которая могла быть собрана при средней высоте (h m), возможны два сценария. Пер- вый сценарий имеет место, когда hm превышает w. В этом случае мож - но, очевидно, исключить все высоты ниже hm и продолжить поиск оп- тимальной высоты (рекурсивным вызовом), изменив нижний предел на h m. Важно отметить, что hm все еще может быть решением, так как собранный для hm+1 лес может быть меньше необходимого количества w. Второй сценарий имеет место, когда собранный при hm лес меньше w. В этом случае можно отказаться от всех высот выше средней, так как они не позволят лесорубу получить достаточного количества древеси-ны. Поэтому соответствующее рекурсивное условие должно вызвать метод, заменив верхний предел h m–1.\n--- Страница 181 ---\n180  Глава 5. Линейная рекурсия II: хвостовая рекурсия Исходная задача Подзадача: средняя высота древесины > w Рис. 5.12. Декомпозиция задачи лесорубаПодзадача: средняя высота древесины < wверхний предел верхний предел верхний пределнижний предел нижний предел нижний пределсередина середина середина\n--- Страница 182 ---\n5.7. Задача лесоруба  181 Наконец, в предыдущей декомпозиции, когда верхний предел всего на единицу больше нижнего, средняя высота равна нижнему пределу. В этом случае первое рекурсивное условие не должно уменьшать раз-мер задачи (пределы не должны меняться). Таким образом, чтобы рабо-тать должным образом, алгоритм нуждается в дополнительном началь-ном условии. Когда возникает такая ситуация, метод должен вернуть либо нижний, либо верхний предел. В частности, если количество леса, соответствующего верхнему пределу, не меньше w, то верхний предел – правильный результат. Иначе им будет нижний предел. В листинге 5.17 приведён код, соответствующий упомянутым началь- ным и рекурсивным условиям. Листинг 5.17. Алгоритм двоичного поиска для задачи лесоруба 1 23456789101112131415def collect_wood(t, wood, lower, upper): middle_h = (lower + upper) // 2 wood_at_middle = compute_wood(t, middle_h) if wood_at_middle == wood or lower == upper: return middle_h elif lower == upper – 1: if compute_wood(t, upper) >= wood: return upper else: return lower elif wood_at_middle > wood: return collect_wood(t, wood, middle_h, upper) else: return collect_wood(t, wood, lower, middle_h – 1) Наконец, на рис. 5.13 приведена последовательность шагов алгорит - ма по решению задачи для конкретного примера на рис. 5.11. Шаг 1 соответствует начальному условию, когда нижний предел ра- вен нулю, а верхний – H = max{ti} для i = 1, …, n. Шаги 2 и 3 соответствуют применению первого и второго рекурсивных условий соответственно. Наконец, шаг 4 соответствует дополнительному начальному условию, когда верхний предел (8) на 1 больше нижнего (7). Решение – h = 8, по - скольку при такой высоте лесоруб получает требуемое количество леса (10 единиц).\n--- Страница 183 ---\n182  Глава 5. Линейная рекурсия II: хвостовая рекурсия Шаг 1 Шаг 2 Шаг 3 Шаг 412 8 4 012 8 4 0 12 8 4 012 8 4 0 Рис. 5.13. Шаги алгоритма двоичного поиска на примере задачи лесоруба для w = 10 5.8. Алгоритм Евклида Один из первых алгоритмов в истории известен как алгоритм Евкли- да, названный в честь древнегреческого математика Евклида, который описал его в своих «Началах» (прибл. 300 год до н. э.). Его цель – най-ти наибольший общий делитель (greatest common divisor, gcd), или со- кращённо НОД, двух неотрицательных ненулевых целых чисел m и n, то есть наибольшее положительное целое число k, на которое делят - ся без остатка и m, и n (очевидно, m/k и n/k – целые числа). Например, НОД(20, 24) = 4. Его можно также считать произведением общих прос - тых множителей m и n. Для m = 20 = 2 · 2 · 5 и n = 24 = 2 · 2 · 2 · 3 произве- дение общих множителей 2 · 2 = 4. Существует несколько вариантов метода. Первому варианту соот - ветствует следующая функция: gcd1(m, n) =, 0, gcd1( , ), , gcd1( , ) nm nm m nmn m=  >  −  (5.2) которую можно закодировать, как показано в листинге 5.18. если еслив противном случае,\n--- Страница 184 ---\n5.8. Алгоритм Евклида  183 Листинг 5.18. Алгоритм Евклида для вычисления НОД двух неотрицательных целых чисел 1 234567def gcd1(m, n): if n == 0: return n elif m > n: return gcd1(n, m) else: return gcd1(m, n – m) Во-первых, это – функция с хвостовой рекурсией, поскольку её значе- ние определяется вызовом самой себя в рекурсивных условиях. Кроме того, заметьте, что в начальном условии метод возвращает значение аргумента функции, что является обычным для многих рекурсивных хвостовых вызовов. В частности, ясно, что НОД для n > 0 и для 0 – это n, так как и n, и 0 делятся на n без остатка. Первое рекурсивное условие просто меняет местами аргументы. Это гарантирует, что во втором ре-курсивном условии первый из них будет не меньше второго. В этом по-следнем рекурсивном условии уменьшение размера задачи (который зависит от m и n) на 1 или деление его пополам не работает. Вместо этого рекурсивное условие уменьшает второй параметр путём вычи-тания из него m (отметим, что n – m ≥ 0, так как n ≥ m). Оно реализует математическое свойство НОД(m, n) = НОД(m, n – m), (5.3) которое не вполне очевидно. Показать его истинность можно следую-щим образом. Пусть n ≥ m, m = a · z и n = b · z, где a ≤ b и z = НОД(m, n) – произведение общих простых множителей n и m. Это означает, что a и b не содержат общих простых множителей. Кроме того, пусть b = a + c, тогда n и m можно выразить как: n = b · z = (a + c) z = (a 1 · … · ak + c1 · … · cl) z, (5.4) m = (a1 · … · ak) z, (5.5) где a1, …, ak и c1, …, cl – простые делители a и c соответственно. Ключ к до- казательству в том, что a и c не имеют общих простых делителей (то есть ai ≠ cj), потому что иначе в (5.4) их можно было бы вынести за скобки, предположив, что a и b имеют общие простые делители, а это неверно. Если же a и c не имеют общих простых делителей, то z = НОД(a · z, c · z), и мы можем заключить, что:\n--- Страница 185 ---\n184  Глава 5. Линейная рекурсия II: хвостовая рекурсия НОД(a · z, b · z) = z = НОД(a · z, c · z) · НОД(m, n) = НОД(m, n – m). Кроме того, можно показать, что алгоритм гарантирует достижение начального условия, поскольку значения аргументов уменьшаются, пока один из них не станет нулевым. Для m = 20 и n = 24 метод выполня- ет следующие рекурсивные вызовы: gcd1(20, 24) = gcd1(20, 4) = gcd1(4, 20) = = gcd1(4, 16) = gcd1(4, 12) = gcd1(4, 8) = = gcd1(4, 4) = gcd1(4, 0) = gcd1(0, 4) = 4. (5.6) Так как хвостовые рекурсивные функции не изменяют результаты рекурсивных вызовов, все они возвращают одно и то же значение, кото- рое получается в начальном условии (gcd1(0, 4) = 4). Поэтому хвостовые рекурсивные функции, по сути, определяют отношения между набора-ми аргументов. Например, в (5.6) все пары (20, 24), (20, 4) и т. д. связаны со значением 4. В заключение приведём более эффективный вариант алгоритма, который используется в настоящее время: gcd2(m, n) = , 0, gcd 2( % , ), 0.nm n mm m=  ≠  (5.7) Доказательство свойства рекурсивного условия здесь подобно (5.3). Пусть n ≥ m, m = a · z и n = b · z, где z – произведение общих простых делителей n и m и a ≤ b. Это значит, что a и b не имеют общих простых делителей. Кроме того, пусть b = q + r, где q и r – частное и остаток от деления b/a. Ключ этого доказательства в том, что a и r не имеют общих простых делителей, поскольку иначе они были бы простыми делителя- ми b, что невозможно, так как a и b не имеют общих простых делителей. Отсюда z = НОД(r · z, a · z). Таким образом, мы заключаем, что НОД(a · z, b · z) = z = НОД(r · z, a · z ) · НОД(m, n) = НОД(n % m, m). 5.9. Упражнения Упражнение 5.1. Определите и реализуйте линейную и хвостовую ре- курсивные логические функции, определяющие, содержит ли неотри-цательное целое число n нечётную цифру. Упражнение 5.2. Гораздо удобнее отображать полиномы в виде математической формулы, а не в виде списка его коэффициентов. Напишите метод, который получает список длины n с коэффициен-если если\n--- Страница 186 ---\n5.9. Упражнения  185 тами полинома степени n – 1 и печатает его математическую запись. Например, для входного списка p = [3, –5, 0, 1], соответствующего по- линому x3 – 5x1 + 3 (коэффициент pi соответствует степени xi), метод должен напечатать строку, подобную: +1x3 – 5x1 + 3. Будем считать, что pn–1 ≠ 0, за исключением случая, когда полином представляет собой константу 0. В заключение определите его асимптотическую стои- мость вычисления. Упражнение 5.3. Алгоритм «сортировки подсчётом» – это метод сор- тировки списка из n целых чисел в диапазоне [0, k], где k достаточно малое. Метод работает за время O(n + k), откуда следует, что он работает за время O(n) при k ∈ O(n). Для заданного списка a метод создаёт новый список b, который со- держит количество вхождений каждого целого числа в a, как показано на рис. 5.14 (шаг 1). Шаг 1 Шаг 2 Рис. 5.14. Шаги алгоритма сортировки подсчётом Например, b2 = 4, так как целое число 2 появляется в a четыре раза. Реализуйте хвостовую рекурсивную процедуру, которая получает спис - ки a и b (изначально нулевой) и заполняет список b количествами вхож - дений целых чисел в a. Кроме того, реализуйте линейно-рекурсивную функцию, которая по- лучает список b с количествами вхождений и возвращает новый спи- сок c – отсортированную версию a, как показано на рис. 5.14 (шаг 2). Наконец, реализуйте функцию алгоритма сортировки подсчётом, ко- торая вызывает предыдущие два метода, и определите её асимптотиче-скую стоимость вычисления. Упражнение 5.4. Реализуйте альтернативную листингу 5.8 версию алгоритма двоичного поиска, не использующего параметр upper . Опре- делите затем его асимптотическую стоимость вычисления.2 31 20 02 0 14 0 03 4 0 1 2 3 4 a 31 0b 22 3 14 c3 2 22 2\n--- Страница 187 ---\n186  Глава 5. Линейная рекурсия II: хвостовая рекурсия Упражнение 5.5. Реализуйте логическую функцию алгоритма «дво- ичного поиска», которая просто определяет, есть ли элемент x в списке a. Функции должны иметь всего два входных параметра x и a и опираться на декомпозицию задачи делением её размера пополам. В заключение определите её асимптотическую стоимость вычисления. Упражнение 5.6. Напишите функцию, которая ищет элемент с наи- меньшим ключом в двоичном дереве поиска T, представленного спис - ком, элементы которого состоят из четырех компонент, как в разделе 5.3. Упражнение 5.7. Пусть a – сортированный (в порядке возрастания) список различных целых чисел. Цель этой задачи – эффективный поиск элемента, значение которого совпадает с его позицией (индексом) в списке. Иными словами, нужно найти элемент i, для которого ai = i. На - пример, если a = [–3, –1, 2, 5, 6, 7, 9], то результатом будет 2, так как a2 = 2. Отметим, что первый элемент списка расположен в позиции 0. Для прос тоты считайте, что в a не более одного элемента, удовлетворяю- щего условию ai = i. Если в списке нет такого элемента, функция должна вернуть значение –1. Наконец, определите её асимптотическую стои- мость вычисления. Упражнение 5.8. Пусть a – список из n целых чисел, упорядоченных так, что чётные числа расположены перед нечётными (индекс любого чётного числа меньше индекса любого нечётного числа). Иными слова-ми, для любого чётного a i и любого нечётного aj их индексы находятся в отношении j > i. Цель задачи – разработать эффективный рекурсивный алгоритм определения наибольшего индекса чётного числа. Например, если список a = [2, –4, 10, 8, 0, 12, 9, 3, –15, 3, 1], то метод возвращает i = 5, так как a 5 = 12 – чётное, а a6 = 9 – нечётное (как a7, a8 и т. д.). Если в a нет чётных чисел, то результат должен быть –1. Если же a состоит только из чётных чисел, то результат должен быть n – 1. После этого определите асимптотическую стоимость вычисления функции. Упражнение 5.9. Метод Ньютона (метод касательных) служит для поиска корня вещественной дифференцируемой функции f(x) после- довательным приближением к нему или уточнением его значения. Он опирается на следующее рекурсивное правило x n = xn–1 – f(xn–1) / f '(xn–1), геометрическая интерпретация которого приведена на рис. 5.15. Пусть у нас есть начальное приближение xn–1 корня r функции f(x). Процедура проводит касательную (тангенсоиду) к f(x) в точке xn–1 и вы- числяет новое приближение корня (xn) – точку пересечения этой каса- тельной с осью X (заметьте, что xn становится ближе к r). Таким образом,\n--- Страница 188 ---\n5.9. Упражнения  187 начав с некоторого исходного значения x0, z = xn будет приближением корня f(x) после n-го применения рекурсивного правила. Например, с помощью этой процедуры всего за несколько шагов можно получить достаточно точное приближение квадратного корня числа. Скажем, нам нужно вычислить √a , которое является некоторым неизвестным значением x. В этом случае у нас есть следующие тожде- ства: x = √ a, то есть x2 = a или x2 – a = 0. Поэтому квадратным корнем из a будет корень функции x2 – a. В этом случае согласно методу Ньютона рекурсивная формула будет такой: xn = xn–1 – xn–1 /2 + a/2xn–1. (5.8) Реализуйте линейную и хвостовую рекурсивные функции, получаю- щие в качестве аргументов значение a, его положительное начальное приближение x0 и количество шагов n и возвращающие последнее при- ближение z = xn после n-кратного применения (5.8). После этого опреде- лите их асимптотическую стоимость вычисления. (xn–1, f(xn–1))xn–1 xnf(x) r Рис. 5.15. Основная идея метода Ньютона",
      "debug": {
        "start_page": 152,
        "end_page": 188
      }
    },
    {
      "name": "Глава 6. Множественная рекурсия I: «разделяй и властвуй» 188",
      "content": "--- Страница 189 --- (продолжение)\nГлава 6 Множественная рекурсия I: «разделяй и властвуй» ι α ι ´ρ ε ι κ α ι β α σ ι´ λ ε υ ε (Разделяй и властвуй). – Филип II Македонский Такие преимущества рекурсии над итерацией, как ясность кода или неявное управление стеком (см. раздел 10.3.5), проявляются главным образом при использовании множественной рекурсии. Основанные на этом типе рекурсии методы вызывают себя несколько раз, по крайней мере, в одном рекурсивном условии. Поэтому такие алгоритмы решают несколько простых подзадач, а затем должны объединить, расширить и/или изменить их результаты для получения решения исходной задачи. Множественной рекурсии посвящены три главы книги, которые, как и вся книга, содержат дополнительные примеры. Эта глава охватывает важный класс алгоритмов с множественной рекурсией для задач, де-композиция которых основана на делении их размера на некоторую константу. Говорят, что такие алгоритмы следуют принципу «разделяй и властвуй» – одной из самых важных парадигм разработки алгорит - мов. Его можно рассматривать как общую стратегию решения задач, состоящую в разбиении задачи на несколько подобных себе подзадач, размер которых составляет некоторую часть размера исходной задачи. Поэтому такой подход имеет прямое отношение к рекурсии (итераци-онные алгоритмы тоже могут следовать этой стратегии), поскольку он опирается на рекурсивную декомпозицию задачи (см. рис. 1.4). Функ - ция в листинге 1.2 и третий метод в листинге 1.5 – примеры такого подхода к разработке алгоритма.\nГлава 6 Множественная рекурсия I: «разделяй и властвуй» ι α ι ´ρ ε ι κ α ι β α σ ι´ λ ε υ ε (Разделяй и властвуй). – Филип II Македонский Такие преимущества рекурсии над итерацией, как ясность кода или неявное управление стеком (см. раздел 10.3.5), проявляются главным образом при использовании множественной рекурсии. Основанные на этом типе рекурсии методы вызывают себя несколько раз, по крайней мере, в одном рекурсивном условии. Поэтому такие алгоритмы решают несколько простых подзадач, а затем должны объединить, расширить и/или изменить их результаты для получения решения исходной задачи. Множественной рекурсии посвящены три главы книги, которые, как и вся книга, содержат дополнительные примеры. Эта глава охватывает важный класс алгоритмов с множественной рекурсией для задач, де-композиция которых основана на делении их размера на некоторую константу. Говорят, что такие алгоритмы следуют принципу «разделяй и властвуй» – одной из самых важных парадигм разработки алгорит - мов. Его можно рассматривать как общую стратегию решения задач, состоящую в разбиении задачи на несколько подобных себе подзадач, размер которых составляет некоторую часть размера исходной задачи. Поэтому такой подход имеет прямое отношение к рекурсии (итераци-онные алгоритмы тоже могут следовать этой стратегии), поскольку он опирается на рекурсивную декомпозицию задачи (см. рис. 1.4). Функ - ция в листинге 1.2 и третий метод в листинге 1.5 – примеры такого подхода к разработке алгоритма.\n--- Страница 190 ---\n6.1. Отсортирован ли список?  189 В некоторых источниках термин «разделяй и властвуй» применяется и к тем алгоритмам, декомпозиция которых сводится к единственной подзадаче в половину размера исходной (с единственным вызовом ме-тода). Однако многие авторы полагают, что этот термин должен приме-няться только тогда, когда решение предполагает разбиение задачи на две и более подзадач. В этой книге принимается именно это последнее соглашение. Таким образом, методы, делящие размер задачи пополам, но вызывающие себя лишь раз, уже включены в более ранние главы (в основном в главу 5). В следующих разделах описаны классические рекурсивные алгоритмы, следующие принципу «разделяй и властвуй». 6.1. Отсортирован ли список? В этой задаче сортировки (скажем, по возрастанию) входом является список a из n элементов, которые можно отсортировать операцией ≤ (или некоторой функцией, позволяющей сравнивать элементы, реали-зуя полное бинарное отношение следования), а выходом – логическое значение, которое можно выразить как n 2 i i1i 0 ( ) (a a )fa− +==≤∧ . (6.1) Таким образом, результат равен True, если элементы списка распола- гаются (не строго) в возрастающем или неубывающем порядке. Размер этой задачи – количество элементов списка. Если список со- держит один элемент, то результат – очевидно, True. Кроме того, можно считать, что пустой список тоже упорядочен. Задачу можно решить линейно-рекурсивным методом, который на этапе декомпозиции уменьшает размер задачи на 1. Однако мы пред-ставим решение, которое делит входной список задачи пополам и при-водит её к следующей декомпозиции: f(a) = (a 0 ≤ a1)∧ … ∧ (a⌊n/2⌋–2 ≤ a⌊n/2⌋–1) {подзадача 1} ∧ ( a⌊n/2⌋–1 ≤ a⌊n/2⌋) ∧ (a⌊n/2⌋ ≤ a⌊n/2⌋+1)∧ … ∧ (an–2 ≤ an–1). {подзадача 2} Очевидно, если весь список отсортирован по возрастанию, то обе его половины тоже должны быть отсортированы по возрастанию. Таким образом, метод может вызвать себя дважды с двумя соответствующими подсписками и выполнить логическую операцию И с их результатами. Наконец, объединение результатов подзадач требует дополнительного\n--- Страница 191 ---\n190  Глава 6. Усовершенствование функциональных тестов шага. В частности, последний элемент первого подсписка a⌊n/2⌋–1 должен быть не больше первого элемента второго подсписка a⌊n/2⌋. Это условие также требует ещё одной операции И в рекурсивном условии. В листин- ге 6.1 приведена возможная реализация метода, который работает за время O(n), поскольку его стоимость вычисления: 1, 1,()2 ( /2) 1, 1. nTnTn n≤ =+>  Листинг 6.1. Функция, определяющая, отсортирован ли список по возрастанию 1 2345678def is_list_sorted(a): n = len(a) if n <= 1: return True else: return (is_list_sorted(a[0:n // 2]) and a[n // 2 – 1] <= a[n // 2] and is_list_sorted(a[n // 2:n])) 6.2. Сортировка Алгоритм сортировки произвольного списка (массива, последователь- ности и т. д.) – одна из наиболее изученных задач в информатике. Её можно решить многими способами, которые могут использоваться, чтобы ввести основные понятия, связанные с вычислительной сложно-стью и анализом времени выполнения, парадигмами разработки алго-ритмов или структурами данных. Алгоритмы сортировки из этой главы предполагают, что вход задачи – это список a из n вещественных чисел. Выход – перегруппировка (или перестановка) элементов, которая даёт другой список a', где a' i ≤ a'i+1 для i = 0, …, n – 2 (≤ можно считать ло- гической функцией, позволяющей определить, предшествует ли один элемент другому, и реализующей полное бинарное отношение следо-вания). Выбор вещественного типа для элементов списка подразумева-ет, что алгоритмы должны выполнять сравнения операцией ≤. Можно показать, что любой алгоритм решения этой задачи требует Ω(n logn) сравнений (то есть, по крайней мере, порядка n logn проверок ≤). Нако- нец, есть алгоритмы сортировки, не использующие сравнение элемен-тов и требующие Ω(n) операций. Однако для их применения элемен-ты списка должны удовлетворять определенным условиям. Например, если если\n--- Страница 192 ---\n6.2. Сортировка  191 алгоритм «сортировки подсчётом» сортирует только целые числа, при- надлежащие малому интервалу [0, k] (см. упражнение 9.2). 6.2.1. Алгоритм сортировки слиянием Алгоритм сортировки слиянием – один из широко используемых примеров для демонстрации возможностей подхода «разделяй и власт - вуй». В то время как многие алгоритмы сортировки работают в худшем случае за время O(n 2) (см. раздел 4.4.1 и упражнение 4.17), алгоритм со- ртировки слиянием работает за время Θ(n log n). Иными словами, его вычислительная эффективность сулит лучшие перспективы. Размер задачи – длина списка (n). Наименьшие экземпляры задачи возникают при n ≤ 1, когда алгоритм просто должен вернуть входной список. В рекурсивном условии алгоритм разбивает задачу путём деле-ния входного списка на две половины, порождая тем самым две разные подзадачи (примерно) в половину размера исходной. В следующей схе-ме приводится конкретный пример рекурсивного процесса осмысле-ния будущего алгоритма: Рис. 6.1. Алгоритм сортировки слиянием5 35 98 05 9 54 0 3 4merge_sort 3 5 8 53 8 43 9 3 0merge_sort merge_sort merge\n--- Страница 193 ---\n192  Глава 6. Усовершенствование функциональных тестов Рекурсивное условие здесь сложнее, чем в предыдущих примерах, так как окончательный сортированный список не может быть создан прос - той операцией (например, суммированием, вычислением максимума двух чисел, соединением двух списков и т. д.). В этом случае необхо-димо решить новую задачу слияния (объединения) решений подзадач. В частности, для получения итогового сортированного списка рекур-сивное условие должно «слить» два сортированных списка (выходы двух подзадач). В листинге 6.2 приводится компактная реализация ме-тода сортировки слиянием в предположении, что решающая эту задачу функция merge (см. ниже) уже реализована. Отметим лёгкость восприя-тия кода и простоту алгоритма, который в точности отвечает стратегии «разделяй и властвуй». Листинг 6.2. Метод сортировки слиянием 1 2345678def merge_sort(a): n = len(a) if n <= 1: return a else: a1 = merge_sort(a[0:n // 2]) a2 = merge_sort(a[n // 2:n]) return merge(a1, a2) Входы Результаты [7, 3, 4, 8][7, 3, 4, 8, 4, 6, 4, 6] [3, 4, 4, 4, 6, 6, 7, 8] [3, 4, 7, 8] [4, 6, 4, 6] [4, 4, 6, 6] Оценка времени выполнения этого алгоритма: 1, 1,()2 ( /2) ( ), 1, nTnTn fn n≤ =+>  где мы также предположили, что разделение списка требует постоянно- го числа операций. Иными словами, мы решили, что a[0:n//2] и a[n//2:n] если еслиmerge\n--- Страница 194 ---\n6.2. Сортировка  193 можно получить за время Θ(1). Кроме того, f(n) оценивает количество операций, необходимых методу слияния для объединения двух сорти- рованных списков (приблизительно) из n/2 элементов. В этом случае, согласно основной теореме (3.28), если бы f(n) была линейной функци- ей, то алгоритм сортировки слиянием работал бы за (оптимальное) вре-мя порядка Θ(n log n). Скоро мы увидим, что на самом деле задачу слия- ния можно решить за линейное время. Вообще, сталкиваясь с подобной задачей, разработчики алгоритма всегда стремятся создать наиболее эффективную комбинацию методов, снижающую издержки алгоритма «разделяй и властвуй». Входы задачи слияния – два сортированных списка a и b с длинами n a и nb соответственно. Выход – другой сортированный список длины n = na + nb. Можно считать, что размер задачи – это количество опе- раций, необходимых рекурсивному алгоритму, чтобы «спуститься» до тривиального решения. При таком сценарии размер задачи будет m = min(n a, nb), поскольку если один из списков пуст, то решением за- дачи будет, очевидно, второй список. Это – начальные условия. Для рекурсивного условия можно использовать следующую схему с под-списками из предыдущего примера: Декомпозиция уменьшает размер задачи на 1 за счёт отбрасывания наименьшего элемента в обоих списках. Естественно, он может ока-заться в начальной позиции списков, поскольку они отсортированы по возрастанию. В примере наименьший элемент (3) – первый в первом входном списке. Очевидно, что рекурсивное условие должно просто присоединить этот элемент к результату подзадачи. В листинге 6.3 при-ведён соответствующий код. Оценка времени его выполнения характе-ризуется функцией 1, 0,()( 1) 1, 0mTmTm m= =−+ > если если ,объединить с [3]Входы Результаты ([4, 7, 8], [4, 4, 6, 6])([3, 4, 7, 8], [4, 4, 6, 6]) [3, 4, 4, 4, 6, 6, 7, 8] [4, 4, 4, 6, 6, 7, 8]\n--- Страница 195 ---\n194  Глава 6. Усовершенствование функциональных тестов в предположении, что хвост списка (то есть x[1: ]) можно получить за конечное время. Так как его нерекурсивное выражение – T(m) = m + 1, функция слияния выполняется за линейное время от m и от n тоже. А это значит, что алгоритм сортировки слиянием работает за время Θ(n log n). Листинг 6.3. Метод для слияния двух сортированных списков 1 234567891011# Lists a and b are sorted in ascending order def merge(a, b): if a == []: return b elif b == []: return a else: if a[0] < b[0]: return [a[0]] + merge(a[1:], b) else: return [b[0]] + merge(a, b[1:]) 6.2.2. Алгоритм быстрой сортировки Алгоритм быстрой сортировки quicksort – ещё один метод, разрабо- танный Чарльзом Хоаром. В нём применён подход «разделяй и власт - вуй», и он получил свое название из-за своей поразительной эффек - тивности. В отличие от алгоритма сортировки слиянием время его выполнения в худшем случае – O(n2). Однако в лучших и средних слу - чаях он выполняется за время Θ(n log n) и может быть практически в несколько раз быстрее алгоритма сортировки слиянием. Чтобы понять разницу между двумя методами, отметим, что деком- позиция в сортировке слиянием проста. В частности, входной список можно разделить пополам, используя просто соответствующие индекс - ные диапазоны (0:n//2 и n//2:n). Однако объединение результатов под- задач требует решения еще одной задачи – слияния, которая не очень проста. Напротив, в алгоритме quicksort декомпозиция сложна, однако этап объединения не только тривиален, но в некоторых реализациях даже не всегда нужен. А именно вместо простого деления списка пополам декомпозиция quicksort использует схему разделения, подобную схеме из раздела 5.4. Рисунок 6.2 иллюстрирует такой тип декомпозиции, когда подсписки внутри исходного списка разделены опорным элементом: элементы правого списка не больше опорного, а левого – больше опорного.\n--- Страница 196 ---\n6.2. Сортировка  195 Опорный элемент Декомпозиция Рис. 6.2. Декомпозиция алгоритма quicksort Примерная рекурсивная схема при такой декомпозиции могла бы быть такой: Из схемы видно, что сортировка исходного списка требует сначала решения двух подзадач посредством рекурсивных вызовов и затем объединения отсортированных подсписков при обработке опорного элемента между ними. Таким образом, после рекурсивного решения подзадач объединение их результатов становится простым. Наконец, важная деталь этой декомпозиции заключается в том, что опорный элемент удаляется из списка не превосходящих его элементов. Это – гарантия того, что размер подзадачи действительно меньше размера исходной задачи. В листинге 6.4 приводится более медленный вариант метода, осно- ванный на простых схемах разделения из раздела 5.4.1. Сначала он проверяет, соответствует ли вход начальному условию (которое является тем же, что в методе сортировки слиянием). В рекур-сивном условии общая стратегия состоит в том, что в качестве опорно-[4, 1, 3]Входы Результаты [6, 7, 7, 6, 5][6, 4, 1, 7, 4 , 7, 3, 6, 5] [1, 3, 4, 4 , 5, 6, 6, 7, 7] [1, 3, 4] [5, 6, 6, 7, 7]56 1 7 44 3 4 1 65 7 47 36 6 7 объединить с [4] между отсортированных подсписков\n--- Страница 197 ---\n196  Глава 6. Усовершенствование функциональных тестов го элемента берётся первый элемент списка. При таком выборе возмо- жен наихудший случай, когда входной список уже отсортирован. Кроме того, этот алгоритм может оказаться плохим ещё и тогда, когда вход почти отсортирован. Поскольку такие ситуации возникают на практи-ке довольно часто, функция использует в качестве опорного средний элемент входного списка. После этого метод, согласно декомпозиции, получает два подсписка (удаляя опорный элемент из содержащего его подсписка) и наконец объединяет результаты подзадач, вставляя опор-ный элемент между ними. Листинг 6.4. Вариант алгоритма quicksort 1 234567891011def quicksort_variant(a): n = len(a) if n <= 1: return a else: pivot = a[n // 2] v1 = get_smaller_than_or_equal_to(a, pivot) v1.remove(pivot) v2 = get_greater_than(a, pivot) return (quicksort_variant(v1) + [pivot] + quicksort_variant(v2)) Метод сортировки слиянием в листинге 6.2 и функция quicksort в лис - тинге 6.4 не меняют входной список и возвращают свои результаты в но- вом списке, что требует вдвое больше памяти. Такие типы алгоритмов называются алгоритмами «внешней» сортировки. Вместо этого можно реализовать варианты, которые изменяют входной список и не требу - ют дополнительной памяти для всего списка длины n. Такие алгорит - мы называются алгоритмами «внутренней» сортировки. В листинге 6.5 приводится алгоритм quicksort внутренней сортировки, использующий нижний и верхний пределы для указания границ подсписка внутри ис - ходного списка. Код включает рекурсивную версию метода разбиения Хоара из листинга 5.13 (конечно, более эффективная итерационная версия тоже допустима), выполняющего декомпозицию задачи. Оценка времени выполнения алгоритма подобна таковой для алго- ритма quickselect. Основное различие – в том, что вместо решения од-ной подзадачи quicksort решает две, вызывая себя дважды. Наилучший случай – когда опорный элемент всегда находится в середине списка. В этом случае время выполнения характеризуется функцией\n--- Страница 198 ---\n6.3. Мажоритарный элемент списка  197 1, 1, () ( /2) , 1,nn Tn Tn c n≤ =+>  где T(n) ∈ Θ(n logn). Наоборот, худший случай – когда опорный элемент всегда располагается в крайнем положении списка. В этом случае время выполнения определяется функцией 1, 1, () ( 1) , 1,nn Tn Tn c n≤ =−+ >  которая имеет квадратичный порядок роста (T(n) ∈ Θ(n2)). Листинг 6.5. Алгоритм внутренней сортировки quicksort 1 23456def quick_sort_inplace(a, lower, upper): if lower < upper: pivot_index = partition_Hoare_wrapper (a, lower, upper) quick_sort_inplace(a, lower, pivot_index – 1) quick_sort_inplace(a, pivot_index + 1, upper) 6.3. Мажоритарный элемент списка Говорят, что в списке есть «мажоритарный элемент» (или доминирую- щий, преобладающий), если более половины его элементов одинаковы. В этой классической задаче цель состоит в том, чтобы выяснить, есть ли в списке длины n мажоритарный элемент, и, если есть, найти его. Кроме того, задача предполагает, что элементы сравниваются за (постоянное) время Θ(1) при использовании операции сравнения (==). Иными слова- ми, запрещаются сравнения <, >, ≤ или ≥ (в примерах будут использо-ваться только целочисленные операции). Для решения задачи существует несколько вариантов применения принципа «разделяй и властвуй». Мы рассмотрим метод, возвращаю-щий кортеж (или список) из трёх значений: 1) признак «содержит ли список мажоритарный элемент» (логиче-ская переменная); 2) мажоритарный элемент, если он есть. Иначе это значение не определено (функция может просто вернуть None ); 3) количество вхождений мажоритарного элемента (0, если его нет).если если если если\n--- Страница 199 ---\n198  Глава 6. Усовершенствование функциональных тестов Размер задачи – n. Первое начальное условие может соответствовать пустому списку, результатом которого был бы кортеж (False, x, 0), где значение x не определено. Кроме того, если список содержит один эле- мент, функция должна вернуть (True, a0, 1). Рекурсивное условие выводится путём деления списка пополам и ре- шения соответствующих подзадач. Чтобы понять, как объединить ре- шения подзадач, построим на конкретном примере начальные рекур-сивные схемы. Например: В этом конкретном случае результат обеих подзадач – False. Это значит, что входной список не содержит мажоритарного элемента (хотя список содержит ровно n/2 вхождений элемента 4, этого недостаточно для ис - тинного результата). Вообще, это можно доказать следующим образом. Сначала исходный список делится пополам (независимо от чётности n, так как n = ⌊n/2⌋ + ⌊n/2⌋) на два подсписка – b длины ⌊n/2⌋ и c длины ⌊n/2⌋. Если результат обеих подзадач – False, то элемент может появиться не более ⌊⌊n /2⌋/2⌋ раз в b и ⌊⌊n /2⌋/2⌋ раз в c . Сложение этих величин даёт: ⌊⌊n/2⌋/2⌋ + ⌊⌊n/2⌋/2⌋ ≤ (⌊n/2⌋ + ⌊n/2⌋)/2 = n/2 ≤ n/2. Отсюда можно заключить, что элемент не может появиться в исход- ном списке более n/2 раз. Схема для другого конкретного примера могла бы быть такой: b =[4, 4, 5, 1]Входы Результаты a = [4, 4, 5, 1, 4, 2, 4, 3] (False, -, 0) c =[4, 2, 4, 3] b = [4, 4, 5, 4]Входы Результаты a = [4, 4, 5, 1, 4, 2, 4, 3] c = [1, 2, 4, 3](False, -, 0) (False, -, 0) (False, -, 0)(False, -, 0) (True, 4, 3 ) 3 + #(c , 4) > n /2 ?ложный результат\n--- Страница 200 ---\n6.3. Мажоритарный элемент списка  199 В этом случае элемент 4 трижды появляется в первом подсписке и потому является мажоритарным, так как 3 > n/2 = 2. Поэтому алгоритм должен посчитать число вхождений 4 во второй подсписок (обозначен- ный #(c, 4)), чтобы определить, является ли он мажоритарным для ис - ходного списка a. Это можно сделать с помощью простой линейно-ре- курсивной функции (см. листинг 6.6), получающей на входе список a и элемент x. Если a пуст, результат, очевидно, 0. В противном случае результатом будет вызов метода, который применяется к хвосту списка a (a 1…n – 1) и x (плюс единица, если a0 = x). Листинг 6.6. Подсчёт количества элементов в списке 1 2345def occurrences_in_list(a, x): if a == []: return 0 else: return int (a[0] ==x) + occurrences_in_list(a[1:], x) В листинге 6.7 приводится возможная реализация функции, решаю- щей задачу поиска мажоритарного элемента. Начальные условия – в строках 3–6. Строки 8 и 9 делят входной список пополам. Строка 11 вызывает метод для первого подсписка, и если в нём есть мажоритар-ный элемент (строка 12), то вычисляется количество вхождений это-го элемента во второй подсписок (строка 13). Если общее количество вхождений элемента (в двух подсписках) больше n/2 (строка 14), метод возвращает кортеж (строка 15) со значениями (True, мажоритарный элемент, количество появлений во входном списке). Строки 17–21 ана-логичны, но меняют списки ролями. Наконец, если функция не верну - ла результат, то список вообще не содержит мажоритарного элемента (строка 23). В рекурсивных условиях метод должен вызвать себя дважды для каж - дой половины входного списка, а также вычислить количество вхожде-ний элемента в оба подсписка длиной (примерно) n/2. Поскольку эта последняя вспомогательная функция выполняется за линейное время, временнáя сложность метода может быть оценена функцией 1, 1, () ( /2) , 1.nn Tn Tn c n≤ =+>  Таким образом, временнaя сложность алгоритма – порядка Θ(n logn) (см. (3.28)). В заключение добавим, что эта задача может быть решена если если\n--- Страница 201 ---\n200  Глава 6. Множественная рекурсия I: «разделяй и властвуй» за линейное время с помощью алгоритма «большинства голосов» Бойе- ра–Мура (Boyer–Moore majority vote algorithm). Листинг 6.7. Решение задачи о мажоритарном элементе 1 234567891011121314151617181920212223def majority_element_in_list(a): n = len(a) if n == 0: return (False, None, 0) elif n == 0: return (True, a[0], 1) else: b = a[0:n // 2] c = a[n // 2:n] t = majority_element_in_list(b): if t[0]: occurrences = occurrences_in_list(c, t[1]) if t[2] + occurrences > n / 2 return (True, t[1], t[2] + occurrences) t = majority_element_in_list(c): if t[0]: occurrences = occurrences_in_list(b, t[1]) if t[2] + occurrences > n / 2 return (True, t[1], t[2] + occurrences) return (False, None, 0) 6.4. Быстрое целочисленное умножение Известный ещё со школы классический алгоритм поразрядного умно- жения двух неотрицательных N-разрядных целых чисел требует време- ни порядка n2. В этом разделе мы разберём более быстрый алгоритм Карацубы. Метод можно применять к числам в любой системе счис - ления, но мы сосредоточимся на умножении двоичных чисел. В част - ности, пусть x и y – два неотрицательных целых числа, состоящих из bx и by двоичных разрядов соответственно. Применив подход «разделяй и властвуй», каждое двоичное число можно разделить на два следую-щим образом: x = a · 2 m + b, y = c · 2m + d, (6.2) где m = min (⌊bx/2⌋, ⌊by/2⌋).\n--- Страница 202 ---\n6.4. Быстрое целочисленное умножение  201 Например, для x = 594 и y = 69 декомпозиция будет такой: x = 10010100102 = 1001010{a = 74}010{b = 2} = 74 · 23 + 2, y = 10001012 = 1000{c = 8}101{d = 5} = 8 · 23 + 5, где bx = 10, by = 7, m = 3, a = 74, b = 2, c = 8 и d = 5. Таким образом, меньшее число (в данном случае – y) разделено на две части (примерно) с оди- наковым количеством двоичных разрядов, а младшие части разбиения (b и d) имеют одинаковое количество двоичных разрядов. Во многих языках программирования вычислить значения a, b, c и d можно с помощью операций поразрядного сдвига (в языке Python таки-ми операциями являются << и >>). Сдвиг x влево на m разрядов (x << m) с добавлением m младших нулей равнозначен ⌊x · 2 m⌋. Сдвиг x вправо на m разрядов (x >> m) с отбрасыванием m младших разрядов равнозна- чен ⌊x/2m⌋. Такие поразрядные операции полезны при целочисленном умножении (или делении) на степень двух и могут использоваться для разбиения x и y согласно (6.2) следующим образом: a = x >> m, b = x – ( a << m), c = y >> m, d = y – ( c << m), где круглые скобки необходимы в силу правил старшинства операций. Согласно декомпозиции, произведение x и y можно записать как x · y = (a · 2 m + b)(c · 2m + d) = a · c22m + (a · d + b · c)2m + b · d. (6.3) Этот первоначальный (примитивный) подход разбивает исходную задачу (умножения) на четыре меньшие подзадачи умножения ac, ad, bc и bd, решение которых можно получить четырьмя рекурсивными вызо- вами (затратами времени на умножение на степень двух можно пренеб- речь, поскольку его очень эффективно заменяют операции поразрядно-го сдвига). Однако этот подход не намного эффективнее «школьного», так как он тоже требует n 2 поразрядных умножений для двух n-разряд- ных чисел. Предложенный Карацубой алгоритм может снизить затраты времени примерно до 1,585 · n за счёт перегруппировки слагаемых и увеличения числа операций сложения и вычитания, которые оказыва-ют незначительное влияние на асимптотическую сложность вычисле-ний. В частности, произведение xy можно заново переписать как x · y = a · c2 2m + ((a + b)(c + d) – a · c – b · d)2m + b · d, (6.4) где требуется всего три более простых произведения a · c, b · d и (a + b) (c + d), что приводит к более быстрому алгоритму, выполняющему толь-ко три рекурсивных вызова.\n--- Страница 203 ---\n202  Глава 6. Множественная рекурсия I: «разделяй и властвуй» В листинге 6.8 приведена реализация метода Карацубы вместе со вспомогательной функцией, вычисляющей количество двоичных раз- рядов неотрицательного целого числа n, равное ⌊log2n⌋ + 1 для n ≥ 1. Листинг 6.8. Быстрый алгоритм Карацубы умножения двух неотрицательных целых чисел 1 23456789101112131415161718192021222324252627282930def number_of_bits(n): if n < 2: return 1 else: return 1 + number_of_bits(n >> 1) def multiply_karatsuba(x, y): if x == 0 or y == 0: return 0 elif x == 1: return y elif y == 1: return x else: n_bits_x = number_of_bits(x) n_bits_y = number_of_bits(y) m = min(n_bits_x // 2, n_bits_y // 2) a = x >> m b = x – (a << m) c = y >> m d = y – (c << m) ac = multiply_karatsuba(a, c) bd = multiply_karatsuba(b, d) t = multiply_karatsuba(a + b, c + d) – ac – bd return (ac << (2 * m)) + (t << m) + bd Размер задачи – min(bx, by). Таким образом, начальные условия долж - ны проверить входы на равенство 0 или 1, приводящие к тривиальным результатам. Рекурсивные условия реализуют (6.4) тремя рекурсивны-ми вызовами. Что касается эффективности этого алгоритма, то предположим, что оба входа имеют одинаковое количество двоичных разрядов n, являю-\n--- Страница 204 ---\n6.5. Умножение матриц  203 щееся степенью двух (то есть n = 2k). Такое допущение возможно, по- скольку к входным целочисленным значениям всегда можно добавить ведущие нули так, чтобы предположение выполнилось. В этом случае время выполнения алгоритма описывается функцией: 1, 1, () 3 ( /2) , 1.nn Tn Tn c d n≤ =++ >  Слагаемое cn + d возникает из-за сложений, вычитаний, операций сдвига и вызовов number_of_bits , которые выполняются за линейное время относительно n. Применяя основную теорему, T(n) ∈ Θ(n log23) = Θ(n · 1,585…). Таким образом, этот метод эффективнее подхода, связан-ного с (6.3), чья стоимость вычислений описывается функцией: 1, 1, () 4 ( /2) , 1,nn Tn Tn e f n≤ =++ >  где T(n) ∈ Θ(n2). Алгоритм Карацубы использует меньше умножений (соответствую- щих рекурсивным вызовам), чем школьный метод, но выполняет боль-ше сложений и вычитаний. На практике алгоритм будет быстрее для больших значений n. Однако если n мало, дополнительные операции могут сделать его медленнее традиционного метода. В любом случае, метод примечателен тем, что он может сократить количество операций умножения, которые значительно дороже сложения или вычитания. 6.5. Умножение матриц Две матрицы можно перемножить, предварительно разбив их на блоки (подматрицы), как описано в разделе 2.4. Применив принцип «разделяй и властвуй», рассмотрим теперь простой рекурсивный метод, требую-щий n 3 элементарных умножений для вычисления произведения двух матриц размерности n×n (используя спецпакет NumPy языка Python). Кроме того, рассмотрим алгоритм Штрассена, требующий для получе-ния результата примерно n 2,8 элементарных умножений. 6.5.1. Умножение матриц методом «разделяй и властвуй» Пусть A и B – матрицы размерностей p×q и q×r соответственно. Раз- мер задачи зависит от этих трех размерностей p, q и r. Тривиальное на- чальное условие имеет место при p = q = r = 1, когда результат – просто если если если если\n--- Страница 205 ---\n204  Глава 6. Множественная рекурсия I: «разделяй и властвуй» число. Кроме того, некоторые реализации могут рассматривать размер- ности 0. В таких случаях результатом должна быть пустая матрица, о чём мы также коротко скажем. Довольно простой способ декомпозиции задачи – разделить каждую матрицу на четыре блока (образующих блочную матрицу размерности 2×2). В этом случае их произведение определяется следующим обра-зом: 1,1 1,2 1,1 1,2 1,1 1,1 1,2 2,1 1,1 2,1 1,2 2,2 2,1 2,2 2,1 2,2 2,1 1,1 2,2 2,1 2,1 1,2 2,2 2,2 ++     =     ++     A A B B AB AB AB AB A A B B AB AB AB AB. (6.5) Обратите внимание, что формула похожа на умножение двух мат - риц размерности 2×2. Например, верхний левый блок результата (A1,1B1,1 + A1,2B2,1) можно считать произведением первой строки (бло- ков) A и первого столбца (блоков) B. Декомпозиция приводит к вычислению восьми более простых произ- ведений матриц. Таким образом, в рекурсивном условии метод вызовет себя восемь раз. Результат каждого произведения должен добавляться и помещаться в стек так, чтобы получить матрицу-результат. В листин-ге 6.9 приводится возможная реализация. Рекурсивное условие сначала определяет каждую из меньших блоч- ных матриц, добавляет их произведения и выстраивает матрицу-ре-зультат методами vstack и hstack. Одно из начальных условий вычисляет простое произведение при p = q = r = 1. Кроме того, в коде учитывается также случай пустых входных матриц, поскольку они могут появиться в рекурсивном условии при разбиении матрицы, одна из размерностей которой равна 1 (очевидно, вектор не может быть разбит на четыре век - тора согласно (6.5)). Таким образом, если какая-то из размерностей рав-на 0, в соответствующем начальном условии создаётся пустая матрица размерности p×r, которая должным образом обрабатывается средства- ми языка Python. Предыдущий метод создаёт матрицы размерности 1×1 (в начальном условии) и постепенно накапливает их в стеке для формирования ко-нечной матрицы размерности p×r. Кроме того, отметим, что в методы не передаются размерности входных матриц. Другой более эффективный способ состоит в передаче матриц A и B целиком в каждом вызове метода, тогда как сами перемножаемые бло-ки задаются как дополнительные параметры своими границами внутри\n--- Страница 206 ---\n6.5. Умножение матриц  205 этих матриц (см. листинг 1.6). Кроме того, результат можно сохранить в матрице-параметре C размерности p×r (передаваемой по ссылке). В лис тинге 6.10 приведена возможная реализация этого альтернатив- ного решения. Листинг 6.9. Умножение матриц по принципу «разделяй и властвуй» 1 234567891011121314151617181920212223242526272829303132333435import numpy as np def matrix_mult(A, B): p = A.shape[0] q = A.shape[1] r = B.shape[1] if p == 0 or q == 0 or r == 0: return np.zeros((p, r)) elif p == 1 and q == 1 and r == 1: return np.matrix([[A[0, 0] * B[0, 0]]]) else: A11 = A[0:p // 2, 0:q // 2] A21 = A[p // 2:p, 0:q // 2] A12 = A[0:p // 2, q // 2:q] A22 = A[p // 2:p, q // 2:q] B11 = B[0:q // 2, 0:r // 2] B21 = B[q // 2:q, 0:r // 2] B12 = B[0:q // 2, r // 2:r] B22 = B[q // 2:q, r // 2:r] C11 = matrix_mult(A11, B11) + matrix_mult(A12, B21) C12 = matrix_mult(A11, B12) + matrix_mult(A12, B22) C21 = matrix_mult(A21, B11) + matrix_mult(A22, B21) C22 = matrix_mult(A21, B12) + matrix_mult(A22, B22) return np.vstack([np.hstack([C11, C12]), np.hstack([C21, C22])]) A == np.matrix([[2, 3, 1, –3], [4, –2, 1, 2]]) B == np.matrix([[2, 3, 1], [4, –1, –5], [0, –6, 3], [1, –1, 1]]) print(matrix_mult(A, B))\n--- Страница 207 ---\n206  Глава 6. Множественная рекурсия I: «разделяй и властвуй» Листинг 6.10. Альтернативное умножение матриц по принципу «разделяй и властвуй» 1 23456789101112131415161718192021222324252627282930313233343536373839404142import numpy as np def add_matrices_limits(A, B, C, lp, up, lr, ur): for i in range(lp, up + 1) for k in range(lr, ur + 1) C[i, k] = A[i, k] + B[i, k] def matrix_mult_limits(A, B, C, lp, up, lq, uq, lr, ur): mp = (lp + up) // 2 mq = (lq + uq) // 2 mr = (lr + ur) // 2 if lp == up and lq == uq and lr == ur: C[mp, mr] = A[mp, mq] * B[mq, mr] elif lp <= up and lq <= uq and lr <= ur: M1 = np.zeros((A.shape[0], B.shape[1])) M2 = np.zeros((A.shape[0], B.shape[1])) matrix_mult_limits(A, B, M1, lp, mp, lq, mq, lr, mr) matrix_mult_limits(A, B, M2, lp, mp, mq + 1, uq, lr, mr) add_matrices_limits(M1, M2, C, lp, mp, lr, mr) matrix_mult_limits(A, B, M1, lp, mp, lq, mq, mr + 1, ur) matrix_mult_limits(A, B, M2, lp, mp, mq + 1, uq, mr + 1, ur) add_matrices_limits(M1, M2, C, lp, mp, mr + 1, ur) matrix_mult_limits(A, B, M1, mp + 1, up, lq, mq, lr, mr) matrix_mult_limits(A, B, M2, mp + 1, up, mq + 1, uq, lr, mr) add_matrices_limits(M1, M2, C, mp + 1, up, lr, mr) matrix_mult_limits(A, B, M1, mp + 1, up, lq, mq, mr + 1, ur) matrix_mult_limits( A, B, M2, mp + 1, up, mq + 1, uq, mr + 1, ur) add_matrices_limits(M1, M2, C, mp + 1, up, mr + 1, ur) def matrix_mult_limits_vrapper(A, B): C = np.zeros((A.shape[0], B.shape[1])) matrix_mult_limits(A, B, C, 0, A.shape[0] – 1, 0, A.shape[1] – 1, 0, B.shape[1] – 1) return C\n--- Страница 208 ---\n6.5. Умножение матриц  207 Метод matrix_mult_limits в каждом вызове передает матрицы A и B целиком, сохраняя результат в третьем параметре – матрице C размерности p×r. Остальные параметры – это нижние и верхние гра- ницы перемножаемых подматриц, связанные с размерностями p, q и r. Начальное условие в matrix_mult_limits выполняется, когда обе подматрицы, скажем A[i,j] и B[j,k] , – скаляры. В этом случае метод просто сохраняет их произведение в строке i и столбце k матрицы C. Метод не является функцией, так как он не возвращает результат (мат - рицу). Вместо этого он изменяет параметр C, где хранится результат. Наконец, итерационный метод add_matrices_limits складывает эле- менты подматриц, переданных в двух первых входных параметрах, и сохраняет результат в своём третьем параметре (подматрицы задают - ся параметрами-границами). 6.5.2. Алгоритм Штрассена умножения матриц Самая затратная по времени арифметическая операция в предыду - щих алгоритмах – это скалярное умножение в двух начальных услови-ях. Оба они, подобно простой итерационной версии с тройным циклом, требуют p·q·r таких умножений. Однако небезынтересно оценить вре- менную сложность для исходных матриц размерности n×n. В этом слу - чае время выполнения можно определить следующей функцией: 21, 1, () 8 ( /2) 4 ( ), 1,n Tn Tn n n≤ =+Θ >  (6.6) поскольку методы вызывают сами себя восемь раз и должны выполнить четыре сложения матриц стоимостью порядка n2. Поэтому согласно ос - новной теореме (3.28) T(n) ∈ Θ(nlog28) = Θ(n3). Теперь рассмотрим алго- ритм Штрассена – известный метод, который сокращает временную сложность до Θ(nlog27) = Θ(n2,807…). Метод, как и стандартный алгоритм, разбивает каждую из вход- ных матриц на четыре блока. Таким образом, AB = C можно запи- сать как: 1,1 1,2 1,1 1,2 1,1 1,2 2,1 2,2 2,1 2,2 2,1 2,2     =        AA BB CC AA BB CC. Цель метода – определить следующие новые матрицы, которые ис - пользуют всего одну операцию умножения матриц:если если\n--- Страница 209 ---\n208  Глава 6. Множественная рекурсия I: «разделяй и властвуй» M1 = (A1,1 + A2,2)(B1,1 + B2,2) M2 = (A2,1 + A2,2)B1,1 M3 = A1,1 (B1,2 – B2,2) (6.7) M4 = A2,2 (B2,1 – B1,1) M5 = (A1,1 + A1,2) B2,2 M6 = (A2,1 – A1,1)(B1,1 + B1,2) M7 = (A1,2 – A2,2)(B2,1 + B2,2). После чего эти матрицы могут быть сгруппированы так, чтобы сфор- мировать выходные блочные матрицы: C1,1 = M1 + M4 – M5 + M7 C1,2 = M3 + M5 (6.8)C2,1 = M2 + M4 C2,2 = M1 – M2 + M3 + M6. Таким образом, в каждом рекурсивном вызове алгоритм выполня- ет 7 произведений и 18 сложений (или вычитаний). Поэтому оценка времени его выполнения: 21, 1, () 7 ( /2) 18 ( ), 1,n Tn Tn n n≤ =+Θ >  (6.9) где T(n) = Θ(nlog27) = Θ(n2,807…). Этот алгоритм для больших значений n мо - жет быть быстрее стандартного со временем выполнения Θ(n3). Однако для малых или средних матриц он может быть медленнее из-за боль- ших постоянных множителей, имеющих значение на практике. Наконец, теоретически входы этого алгоритма должны быть квадрат - ными матрицами n×n, где n – степень двух. На практике эффективные реализации разбивают матрицы на множество квадратных подматриц и неоднократно применяют этот алгоритм. Более простая, но медлен-ная альтернатива – дополнить (расширить) входные матрицы нулями до размерности 2 k×2k (см. упражнение 6.6). 6.6. Задача укладки тримино Тримино – многоугольник из трёх равных смежных квадратов. Без учё-та вращений и зеркальных отражений тримино бывают только двух ти-пов – типа «I» и типа «L», как показано на рис. 6.3. если если\n--- Страница 210 ---\n6.6. Задача укладки тримино  209 Рис. 6.3. Типы тримино без вращений и симметрии Задача укладки тримино – покрыть L-тримино квадратное поле (воз- можно, с «дырами») размером n×n, где n ≥ 2 есть степень двух. Рису - нок 6.4 поясняет задачу на графическом примере. Рис. 6.4. Задача укладки тримино Размер задачи – очевидно, n. Наименьшие экземпляры задачи соот - ветствуют полям размера 2×2, решения для которых тривиальны. На рис. 6.5 показана декомпозиция методом «разделяй и властвуй», ис - пользуемая в рекурсивном условии. Рис. 6.5. Декомпозиция задачи укладки тримино Исходное поле (a) поделено на четыре меньших квадратных поля размером n/2 (b). Однако только одно из этих меньших полей будет со- держать исходную дыру. Поэтому остальные три поля не являются под-задачами, подобными исходной. Но этот вопрос решается размещени-ем тримино в центре поля так, чтобы три его квадрата стали дырами в меньших полях и тем самым обеспечили бы подобие подзадач исход-ной задаче (c).n = 2kI-тримино (a) (b) (c)L-тримино n = 2k nn/2 n/2\n--- Страница 211 ---\n210  Глава 6. Множественная рекурсия I: «разделяй и властвуй» Для графического отображения решения задачи будем использовать пакет Matplotlib. В частности, само тримино можно изобразить шесть ю отрезками прямой. Но поскольку за счёт поворотов возможны четыре варианта L-тримино (см. рис. 6.6), в листинге 6.11 определяются четы-ре вспомогательные функции для каждого из таких случаев. Функции получают координаты ( x, y) нижнего левого угла квадрата 2×2, охва- тывающего тримино. Команда plot ([x1, x2], [y1, y2], 'k-'), чертит отрезок прямой между точками (x1, y1) и (x2, y2). Рис. 6.6. Вращения L-тримино В листинге 6.12 приводится возможная реализация рекурсивного метода. Процедура должна знать, какую задачу/подзадачу она долж - на решить. Эта информация задаётся первыми тремя её параметрами. Первые два – это координаты левой нижней точки ( x, y) поля, а третий – размер поля ( n). Последние два параметра задают положение дырки (в частности, ( p, q) определяют левый нижний угол квадрата 1×1). И на- чальные, и рекурсивные условия используются методом для определе-ния относительного положения дырки и рисования соответствующего тримино. Наконец, в рекурсивном условии метод вызывает себя четы-режды с разными параметрами для разных подзадач вместе с новыми дырами в трех из них. В заключительном листинге 6.13 приводится фрагмент кода, кото- рый можно использовать для вызова метода тримино. Строка 7 созда-ет фигуру, строка 8 устанавливает белый цвет её фона, а ax в строке 9 фиксирует оси внутри фигуры. После определения размера исходного поля (строка 10) в нём наугад выбирается и рисуется дыра (строка 13). Если используется пакет Matplotlib, то прямоугольник можно нарисо-вать вызовом метода Rectangle. Он получает координаты левой ниж - ней вершины вместе с шириной, высотой и, возможно, другими пара-метрами. В строке 14 вызывается основной метод, а последние строки подавляют масштабирование, убирают оси внутри фигуры и рисуют её.(x, y) (x, y) (x, y) (x, y)L1 L2 L3 L4\n--- Страница 212 ---\n6.6. Задача укладки тримино  211 Листинг 6.11. Вспомогательные функции для рисования тримино 1 2345678910111213141516171819202122232425262728293031323334def draw_L1(x, y): plt.plot = ([x, x + 2], [y + 2, y + 2], 'k–') plt.plot = ([x, x + 1], [y + 1, y + 1], 'k–') plt.plot = ([x + 1, x + 2], [y, y], 'k–') plt.plot = ([x, x], [y + 1, y + 2], 'k–') plt.plot = ([x + 1, x + 1], [y, y + 1], 'k–') plt.plot = ([x + 2, x + 2], [y, y + 2], 'k–') def draw_L2(x, y): plt.plot = ([x, x + 2], [y + 2, y + 2], 'k–') plt.plot = ([x, x + 1], [y, y], 'k–') plt.plot = ([x + 1, x + 2], [y + 1, y + 1], 'k–') plt.plot = ([x, x], [y, y + 2], 'k–') plt.plot = ([x + 1, x + 1], [y, y + 1], 'k–') plt.plot = ([x + 2, x + 2], [y + 1, y + 2], 'k–') def draw_L3(x, y): plt.plot = ([x, x + 2], [y, y], 'k–') plt.plot = ([x, x + 1], [y + 1, y + 1], 'k–') plt.plot = ([x + 1, x + 2], [y + 2, y + 2], 'k–') plt.plot = ([x, x], [y, y + 1], 'k–') plt.plot = ([x + 1, x + 1], [y + 1, y + 2], 'k–') plt.plot = ([x + 2, x + 2], [y, y + 2], 'k–') def draw_L4(x, y): plt.plot = ([x, x + 2], [y, y], 'k–') plt.plot = ([x, x + 1], [y + 2, y + 2], 'k–') plt.plot = ([x + 1, x + 2], [y + 1, y + 1], 'k–') plt.plot = ([x, x], [y, y + 2], 'k–') plt.plot = ([x + 1, x + 1], [y + 1, y + 2], 'k–') plt.plot = ([x + 2, x + 2], [y, y + 1], 'k–')\n--- Страница 213 ---\n212  Глава 6. Множественная рекурсия I: «разделяй и властвуй» Листинг 6.12. Рекурсивный метод рисования тримино 1 2345678910111213141516171819202122232425262728293031323334353637383940414243444546def trominoes(x, y, n, p, q) if n == 2: if y == q: # hole in bottom tiles if x == p: # hole in bottom–left tile draw_L1(x, y) else: # hole in bottom–right tile draw_L2(x, y) else: # hole in top tiles if x == p: # hole in top–left tile draw_L3(x, y) else: # hole in top–right tile draw_L4(x, y) else: mid_x = x + n // 2 mid_y = y + n // 2 if q < mid_y: # hole in bottom squares if p < mid_x: # hole in bottom–left square draw_L1(mid_x – 1, mid_y – 1) trominoes(x, y, n // 2, p, q) trominoes(x, mid_y, n // 2, mid_x – 1, mid_y) trominoes(mid_x, y, n // 2, mid_x, mid_y – 1) trominoes(mid_x, mid_y, n // 2, mid_x, mid_y) else: # hole in bottom–right square draw_L2(mid_x – 1, mid_y – 1) trominoes(x, y, n // 2, mid_x – 1, mid_y – 1) trominoes(x, mid_y, n // 2, mid_x – 1, mid_y) trominoes(mid_x, y, n // 2, p, q) trominoes(mid_x, mid_y, n // 2, mid_x, mid_y) else: # hole in top squares if p < mid_x: # hole in top–left square draw_L3(mid_x – 1, mid_y – 1) trominoes(x, y, n // 2, mid_x – 1, mid_y – 1) trominoes(x, mid_y, n // 2, p, q) trominoes(mid_x, y, n // 2, mid_x, mid_y – 1) trominoes(mid_x, mid_y, n // 2, mid_x, mid_y) else: # hole in top–right square draw_L4(mid_x – 1, mid_y – 1) trominoes(x, y, n // 2, mid_x – 1, mid_y – 1) trominoes(x, mid_y, n // 2, mid_x – 1, mid_y) trominoes(mid_x, y, n // 2, mid_x, mid_y – 1) trominoes(mid_x, mid_y, n // 2, p, q)\n--- Страница 214 ---\n6.7. Задача очертания  213 Листинг 6.13. Вызов метода тримино 1 234567891011121314151617import random import matplotlib.pyplot as plt from matplotlib.patches import Rectangle # Include tromino methods here fig = plt.figure() fig.patch.set_facecolor('white')ax = plt.gca()n = 16 # power of 2 p = random.choice([i for i in range(n)]) q = random.choice([i for i in range(n)])ax.add_patch(Rectangle((p, q), 1, 1, facecolor=(0.5, 0.5, 0.5)))trominoes(0, 0, n, p, q)plt.axis('equal') plt.axis('off') plt.show() 6.7. Задача очертания Задача очертания заключается в том, чтобы определить контур на фоне неба ряда прямоугольных зданий. Рисунок 6.7 поясняет задачу. Вход задачи – список из n ≥ 1 прямоугольников, изображающих здания (см. рис. 6.7(a)). Нижняя сторона прямоугольников всегда расположена на уровне 0. Таким образом, каждое здание можно определить всего тремя параметрами. В данном случае мы будем использовать кортежи вида (x 1, x2, h), где x1 – положение левой стены здания, x2 – положение его пра- вой стены, а h – его высота, причём x1 < x2 и h > 0. Например, [(1,7,7), (18,20,7), (2,9,5), (17,19,2), (12,24,3), (3,8,8), (11,13,5), (15,21,6)]. Отметим, что нет необходимости сортировать здания каким-либо образом (ска-жем, по значению x 1). Контур, выделенный жирной линией на рис. 6.7(b), – это ломаная ли- ния, высота которой в любой точке оси X является высотой максималь- но высокого здания в этой точке. Так как здания суть прямоугольники, то их контур можно определить набором координат (x, h) на плоскости, которые задают точки x изменения высоты h, как показано на рис. 6.7(c). Таким образом, результат задачи – упорядоченный по возрастанию x список пар координат, которые можно представить кортежами. Для приведённого выше примера результатом будет список [(1,7), (3,8), (8,5), (9,0), (11,5), (13,3), (15,6), (18,7), (20,6), (21,3), (24,0)].\n--- Страница 215 ---\n214  Глава 6. Множественная рекурсия I: «разделяй и властвуй» Рис. 6.7. Задача очертания Размер задачи – количество зданий n. Начальному условию соответ - ствует наименьший экземпляр задачи – одно здание. Если оно задано кортежем (x1, x2, h), то результатом будет список [(x1, h), (x2, 0)], как пока- зано на рис. 6.8. Рис. 6.8. Начальное условие задачи очертания для одного здания(a) (b)5 10 15 20 25 (x1, x2, h)(x1, h) (x2, 0)5 10 15 20 25 5 10 15 20 25 (c)8 6 4 2 86 4 2 86 4 2\n--- Страница 216 ---\n6.7. Задача очертания  215 Декомпозицию этой задачи можно осуществить уменьшением её размера на 1. Однако это приводит к алгоритму со временем выполне- ния в худшем случае O(n2). Вместо него мы применим подход «разделяй и властвуй», который позволяет решить задачу за время Θ(n log n). Ри - сунок 6.9 иллюстрирует эту идею, которая подобна подходу, применён-ному в алгоритме сортировки слиянием. Рис. 6.9. Рекурсивное условие задачи очертанияИсходная задача Подзадача 1 Подзадача 2 Очертание 1 Очертание 2 Задача объединения Решение 5 10 15 20 25 5 10 15 20 25 5 10 15 20 25 5 10 15 20 25 5 10 15 20 25 5 10 15 20 25 5 10 15 20 258 64 2 8 64 28 64 2 8 64 28 64 2 8 64 2 8 64 2\n--- Страница 217 ---\n216  Глава 6. Множественная рекурсия I: «разделяй и властвуй» Шаг декомпозиции заключается в делении входного списка на два меньших подсписка примерно из n/2 зданий. Тогда метод выполняет два рекурсивных вызова с этими подсписками, которые возвращают два независимых контура. Предположив на основании индукции, что контуры были созданы правильно, последним и главным для получения результата шагом будет объединение контуров. В листинге 6.14 приво-дится отвечающий принципу «разделяй и властвуй» метод, структура которого, в сущности, совпадает с таковой в листинге 6.2. Листинг 6.14. Основной рекурсивный метод вычисления очертания 1 2 3 45 6 78 9def compute_skyline(buildings): n = len(buildings) if n == 1: return ([(buildings[0][0], buildings[0][2]), (buildings[0][1], 0)]) else: skylines1 = compute_skyline(buildings[0:n // 2]) skylines2 = compute_skyline(buildings[n // 2:n]) return merge_skylines(skyline1, skyline2, 0, 0) Задача объединения контуров – новая отдельная вычислительная задача. В то время как большинство решений в различных источниках является итерационными, мы предложим линейно-рекурсивный ме-тод. Его входы – два сортированных списка кортежей, представляющих собой контур. Кроме того, поскольку кортеж задаёт изменение высоты контура, метод, прежде чем изменить высоту, должен иметь доступ к предыдущей высоте. Более того, поскольку предлагаемый алгоритм об-рабатывает список с первого кортежа (до исчерпания списка), последо-вательно удаляя обработанные кортежи, предыдущих высот не будет во входных списках. Таким образом, метод требует двух дополнительных параметров, скажем p 1 и p2, для сохранения предыдущих высот конту - ра. Естественно, оба этих параметра должны получить начальное зна-чение 0 при первом вызове метода из основной функции (см. строку 9 листинга 6.14). Размер задачи зависит от длин входных списков контуров, скажем n 1 и n2. Можно считать, что начальное условие выполняется, когда один из списков пуст, и метод в таком случае должен тривиально вернуть второй список. В листинге 6.15 приведён код, где начальные условия описаны в строках 2–5.\n--- Страница 218 ---\n6.7. Задача очертания  217 Листинг 6.15. Рекурсивный метод объединения контуров 1 2345678910111213141516171819202122232425262728293031323334353637383940414243444546def merge_skylines(sky1, sky2, p1, p2): if sky1 == []: return sky2 elif sky2 == [] return sky1 else: x1 = sky1[0][0] x2 = sky2[0][0] h1 = sky1[0][1] h2 = sky2[0][1] if x1 == x2: h = max(p1, p2) new_h = max(h1, h2) if h == new_h: return merge_skylines(sky1[1:], sky2[1:], h1, h2) else: return ([(x1, new_h)] + merge_skylines(sky1[1:], sky2[1:], h1, h2)) elif x1 < x2 if h1 > p2: return ([(x1, h1)] + merge_skylines(sky1[1:], sky2, h1, p2)) elif p1 > p2: return ([(x1, p2)] + merge_skylines(sky1[1:], sky2, h1, p2)) else: return merge_skylines(sky1[1:], sky2, h1, p2)) else: if h1 > p1: return ([(x2, h2)] + merge_skylines(sky1, sky2[1:], p1, h2)) elif p2 > p1: return ([(x2, p1)] + merge_skylines(sky1, sky2[1:], p1, h2)) else: return merge_skylines(sky1, sky2[1:], p1, h2))\n--- Страница 219 ---\n218  Глава 6. Множественная рекурсия I: «разделяй и властвуй» Ключом для определения подходящей декомпозиции является то, что результат объединяющей функции – это новое очертание (контур), кортежи которого отсортированы в порядке возрастания значения x. Таким образом, алгоритм анализирует первые кортежи каждого спис - ка и обрабатывает тот, что имеет меньшее значение x (или оба, если их значения x равны). Значит, в рекурсивных условиях, помимо первых кортежей контуров (x1, h1) и (x2, h2), нам нужны ещё и их предыдущие высоты p1 и p2. Давайте сначала рассмотрим случай, когда x1 = x2 = x. Так как кортежи маркируют изменения в горизонте, нам, возможно, придётся включать в решение кортеж с наибольшей высотой. Например, на рис. 6.10(a) точ-ка (x, h 2) должна быть включена в конечный горизонт. Рис. 6.10. Случаи объединения контуров, когда их высота меняется в одной и той же точке x Далее рекурсивный вызов будет использовать хвосты обоих входных списков без (x, h1) и (x, h2), так как возможные изменения в точке x уже обработаны правильно. Это делается в строках 19–21. Наконец, бывают ситуации, когда новый кортеж не включается в решение. Это происхо-дит, когда новая наибольшая высота совпадает с предыдущей наиболь-шей высотой контура (то есть когда max(h 1, h2) = max(p1, p2)), так как в точке x высота не меняется. Рисунок 6.10(b) иллюстрирует этот случай, где точка (x, h2) не должна включаться в конечный контур (см. строки 16 и 17). Теперь проанализируем возможные сценарии, когда значения x пер- вых кортежей горизонтов не равны. Без потери общности допустим, что x 1 < x2. В этом случае алгоритм должен решить, включать ли кортеж (x1, h1), или (x1, p2), или ни тот, ни другой, как показано на рис. 6.11. Если h1 > p2, то в точке x1 первый контур выше второго, и поэтому в объединение должен быть включён кортеж (x1, h1) (см. строки 25–27). Если же h1 ≤ p2, то алгоритм должен проверить условие p1 > p2. Если ус - ловие истинно, то метод включает кортеж (x1, p2) (см. строки 29–31). Об-(a) (b)(x1, h1)(x1, h1)(x2, h2)(x2, h2) h2h2 p2 p2p1 p1 h1h1 x x\n--- Страница 220 ---\n6.8. Упражнения  219 ратите внимание, что при h1 < p2 создаётся новый кортеж, которого нет во входных списках контуров. Случаи p2 ≥ h1 и p2 ≥ p1 означают, что объ- единённый контур не меняется в x1. В итоге, обработав первый кортеж первого контура (x1, h1), метод отбрасывает его при вызове самого себя в соответствующих рекурсивных условиях. Кроме этого, аргументами, задающими предыдущие высоты горизонтов, будут h1 и p2 (см. строки 27, 31 и 34). Остальная часть кода в строках 36–46 похожа на код в стро-ках 23–34 и обрабатывает случай x 2 < x1. Рис. 6.11. Возможные варианты слияния контуров при x1 < x2 6.8. Упражнения Упражнение 6.1. Применив подход «разделяй и властвуй», реализуйте алгоритм, определяющий наличие в списке элемента x.p2 p2p2 p2 p2p2p1p1 p1p1 p1 p1p1p1h1 h1h1 h1 h1 h1h1h1 x1x1x1x1 x1x1 x1x1x1x1p1 = p2 p1 = p2h1 = p2h1 = p2 h1 ≤ p2 и p1 > p2 – Включить пару (x1, p2)h1 > p2 – Включить пару (x1, h1) Иначе – не включать пару\n--- Страница 221 ---\n220  Глава 6. Множественная рекурсия I: «разделяй и властвуй» Упражнение 6.2. Пусть a – список из n неотрицательных целых чисел. Опираясь на подход «разделяй и властвуй», напишите функцию, воз- вращающую множество цифр, входящих во все значения элементов a, и определите её асимптотическую стоимость вычисления. Например, для a = [2 348, 1349, 7523, 3215] результатом будет {3}. Функция должна вызывать другую функцию, которая возвращает множество цифр не-отрицательного целого числа. Реализуйте и её тоже. Упражнение 6.3. Задача о максимальном подсписке заключается в поиске внутри списка чисел непрерывной цепочки элементов (подспис - ка) с наибольшей суммой их значений. Например, для списка [–1, –4, 5, 2, –3, 4, 2, –5] максимальный подсписок – [5, 2, –3, 4, 2] с суммой значе-ний 10. Считая исходный список чисел непустым, реализуйте с приме-нением подхода «разделяй и властвуй» функцию, возвращающую сум-му элементов максимального подсписка. Упражнение 6.4. Разработайте рекурсивный алгоритм быстрого умно жения полиномов, основанный на декомпозиции способом «раз- деляй и властвуй», подобной той, что применялась в алгоритме Кара- цубы (см. раздел 6.4). Полиномы задаются списками своих коэффици- ентов, как описано в упражнении 5.2. Метод должен вызвать функции сложения и вычитания полиномов. Реализуйте также и эти функции. Упражнение 6.5. Реализуйте рекурсивную функцию, которая полу - чает матрицу A размерности n×m и транспонирует её в матрицу раз- мерности m×n ( A T). Используйте пакет NumPy и следующую декомпо- зицию способом «разделяй и властвуй», которая разбивает исходную матрицу делением каждой её размерности пополам на четыре блока: A = 1,1 1,2 2,1 2,2 AA AA. В этом случае транспонирование A можно определить как AT = 1,1 2,1 1,2 2,2 AA AATT TT . Упражнение 6.6. Реализуйте алгоритм Штрассена для умножения матриц. Код должен включать функцию-оболочку, которая позволяет умножать матрицы размерности p×q на матрицы размерности q×r, до - полняя их нулями до квадратных.\n--- Страница 222 ---\n6.8. Упражнения  221 Упражнение 6.7. Реализуйте алгоритм умножения матриц, разбив их следующим образом: A · B = ( )1 12 2⋅BAAB = A1B1 + A2B2. Упражнение 6.8. Реализуйте алгоритм умножения матриц, разбив входные матрицы следующим образом: ( )1 11 12 12 2 21 22  ⋅=    A AB ABBBA AB AB.",
      "debug": {
        "start_page": 189,
        "end_page": 222
      }
    },
    {
      "name": "Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее 222",
      "content": "--- Страница 223 --- (продолжение)\nГлава 7 Множественная рекурсия II: пазлы, фракталы и прочее Вычисления, электрические батареи, телефон, па- ровой двигатель, радио – все эти революционные инновации натолкнулись на массу изобретателей, работающих параллельно и ничего не знающих друг о друге. – Стивен Джонсон В предыдущей главе были представлены алгоритмы, опирающие-ся на принцип «разделяй и властвуй» и разбивающие задачу на не-сколько час тей. В этой главе предлагаются решения задач повышен- ной сложнос ти, которые тоже разбиваются на несколько подзадач, но уменьшают их размер на 1 или 2. Предыдущие примеры таких алгорит - мов – функция (1.2), определяющая числа Фибоначчи, или (3.2), вычис - ляющая биномиальные коэффициенты (в упражнении 7.1 предлагается реализовать такую функцию). Настоящая глава включает классическую задачу «Ханойская башня» – излюбленный пример для иллюстрации множественной рекурсии. Кроме того, в главе рассматриваются задачи о фракталах, для рисования которых используется популярный модуль Matplotlib . 7.1. Путь через болото В этой задаче (также известной как «проход по трясине») прямоугольное болото из квадратных участков задаётся матрицей A размерности n×m\nГлава 7 Множественная рекурсия II: пазлы, фракталы и прочее Вычисления, электрические батареи, телефон, па- ровой двигатель, радио – все эти революционные инновации натолкнулись на массу изобретателей, работающих параллельно и ничего не знающих друг о друге. – Стивен Джонсон В предыдущей главе были представлены алгоритмы, опирающие-ся на принцип «разделяй и властвуй» и разбивающие задачу на не-сколько час тей. В этой главе предлагаются решения задач повышен- ной сложнос ти, которые тоже разбиваются на несколько подзадач, но уменьшают их размер на 1 или 2. Предыдущие примеры таких алгорит - мов – функция (1.2), определяющая числа Фибоначчи, или (3.2), вычис - ляющая биномиальные коэффициенты (в упражнении 7.1 предлагается реализовать такую функцию). Настоящая глава включает классическую задачу «Ханойская башня» – излюбленный пример для иллюстрации множественной рекурсии. Кроме того, в главе рассматриваются задачи о фракталах, для рисования которых используется популярный модуль Matplotlib . 7.1. Путь через болото В этой задаче (также известной как «проход по трясине») прямоугольное болото из квадратных участков задаётся матрицей A размерности n×m\n--- Страница 224 ---\n7.1. Путь через болото  223 и начальной строкой r. Элементы матрицы (ai,j) могут иметь только два значения – «суша» («кочка») или «топь». Цель задачи – найти путь через болото (от левого его края до правого), начав с заданного на его левом краю участка суши a r,0, согласно следующим правилам (см. рис. 7.1(a)): • путь через болото может проходить только по суше; • продвигаться можно только вправо и только по смежным участ - кам суши. Например, с участка ai,j можно шагнуть только на участ - ки ai–1, j+1, ai, j+1 или ai+1, j+1. Отметим, что движение по вертикали запрещено. Путь не может пересекать нижнего и верхнего краёв болота; • путь должен заканчиваться на любом участке суши на правом краю болота. Рисунок 7.1(b) показывает путь через болото, где участки суши и топи изображаются светлыми и темными квадратами соответственно. Рис. 7.1. Задача о пути по болоту Можно предположить, что размер задачи – это ширина болота (m). В первом начальном условии метод может просто вернуть False, если r выходит за пределы болота (r < 0 или r ≥ n) или если начальный учас - ток ar,0 – топь (отметим, что это последнее условие было бы ненужным, если бы мы сразу условились, что первый участок – это суша). Иначе функция должна будет вернуть True, если ширина болота равна 1 (это обеспечивается предыдущим начальным условием, проверяющим, что участок является сушей). В листинге 7.1 приведена одна из многих возможных реализаций функции. Матрица (из пакета NumPy ) содержит символы, где символ 'W' обозначает топь. Строки 2–5 определяют начальные условия. В стро-ках 7, 8 и 9 метод определяет, можно ли перейти к a r–1,1 (по диагонали вверх), ar,1 (по горизонтали вправо) или ar+1,1 (по диагонали вниз) соот - ветственно.(a) (b)Суша Топь ВходВыход\n--- Страница 225 ---\n224  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее Листинг 7.1. Функция поиска пути через болото 1 23456789def exists_path_swamp(A, r): if r < 0 or r >= A.shape[0] or A[r, 0] == 'W': return False elif A.shape[1] == 1: return True else: return (exists_path_swamp(A[:, 1:], r – 1) or exists_path_swamp(A[:, 1:], r) or exists_path_swamp(A[:, 1:], r + 1)) В рекурсивном условии задача разбивается на три подзадачи размера m – 1 (см. рис. 7.2). В частности, можно предположить, что нам известен правильный путь через болото, начинающийся с участков a r–1,1, ar,1 или ar+1,1. Иными словами, можно считать, что нам известны решения трех меньших подзадач, возникающих после отбрасывания первого столб-ца болота и начинающихся с участков в строках r – 1, r и r + 1. Таким образом, рекурсивное условие будет состоять из трёх соответствующих подзадачам рекурсивных вызовов. Рис. 7.2. Декомпозиция задачи о пути через болото Интересно выяснить, как влияют на алгоритм предварительные ус - ловия. В листинге 7.2 есть предварительное условие для входа ar,0 ≠ 'W'. (a) (b)Исходная задача (c) (d)Подзадачиm rr r rm – 1\n--- Страница 226 ---\n7.1. Путь через болото  225 Поэтому ему не нужна проверка ar,0 = 'W' (см. строку 2 в листинге 7.1). Кроме того, любой вызов метода, которому предшествует условный оператор, должен убедиться, что ar,0 ≠ 'W'. В итоге эффективность кода возросла за счёт включения условных операторов в строках 10 и 17, ко-торые устраняют лишние рекурсивные вызовы, если путь через болото уже найден. Например, если уже существует путь вверх по диагонали, то не нужно проверять другие направления – по горизонтали или вниз по диагонали. Листинг 7.2. Альтернативная функция поиска пути через болото 1 23456789101112131415161718192021222324def exists_path_swamp_alt(A, r): if A.shape[1] == 1: return A[r, 0] != 'W' else: if r == 0 or A[r – 1, 1] == 'W': diag_up == False else: diag_up == exists_path_swamp_alt(A[:, 1:], r – 1) if not diag_up: if r == A.shape[0] – 1 or A[r + 1, 1] == 'W': diag_down == False else: diag_down == exists_path_swamp_alt( A[:, 1:], r + 1) if not diag_down: if A[r, 1] == 'W': horizontal == False else: horizontal == exists_path_swamp_alt( A[:, 1:], r) return diag_up or diag_down or horizontal Наконец, в листингах 7.1 и 7.2 размер матрицы уменьшается явно – вызовом метода с параметром A[:, 1:]. Другая возможность состоит в том, чтобы всегда передавать матрицу n×m целиком и управлять раз- мером задачи с помощью входного параметра, задающего столбец c, с которого метод должен начать поиск пути. При таком сценарии от - правной точкой пути была бы ar,c. В результате код оказался бы более общим, позволяя найти правильный путь через болото не только из его\n--- Страница 227 ---\n226  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее левого края, но и из любого участка суши ar,c. В упражнении 7.2 предла- гается реализовать этот вариант. 7.2. Ханойская башня Игра «Ханойская башня» – одна из самых популярных задач для иллюст - рации рекурсии. Несмотря на то что её можно решить с помощью от - носительно простых итерационных алгоритмов, она также допускает короткое и изящное рекурсивное решение, которое не только подчер-кивает роль декомпозиции и индукции в рекурсии, но и демонстрирует их возможности при решении задач. Игра состоит из трёх вертикальных стержней и n дисков, которые можно насадить на любой стержень, как показано на рис. 7.3 для n = 7 дисков. Диски имеют разные радиусы, и можно считать, что радиус дис - ка i равен i. Рис. 7.3. Головоломка «Ханойская башня» В исходном положении все n дисков насажены на один из стержней в порядке убывания (индекса или радиуса), как показано на рис. 7.3(a). Цель игры состоит в том, чтобы, используя третий (вспомогательный) стержень, переместить всю башню лежащих друг на друге дисков с со-(a) (b) (c)\n--- Страница 228 ---\n7.2. Ханойская башня  227 хранением их порядка следования с первого (начального) стержня на другой (конечный) стержень, руководствуясь следующими правилами: • только один диск может быть перемещён за один раз; • при каждом перемещении с одного из стержней снимается верх - ний диск и насаживается на другой стержень; • на любом стержне больший диск не может лежать на меньшем. На рис. 7.3(b) приведено положение дисков на некотором проме- жуточном шаге после выполнения нескольких перемещений, а на рис. 7.3(c) – заключительное состояние дисков, когда задача решена и все диски находятся на нужном стержне. Размер задачи определяется количеством дисков. Начальное условие возникает при n = 1, когда решение тривиально и заключается в пере- мещении диска с исходного стержня на заключительный (см. рис. 7.4). На первом шаге меньший диск переносится на вспомогательный стер-жень, что позволяет переместить больший диск на конечный стержень. На последнем шаге меньший диск просто перемещается на конечный стержень. Рис. 7.4. Решение головоломки «Ханойская башня» с количеством дисков n = 2 Можно доказать, что минимальное число перемещений, необходи- мое для решения задачи с n дисками, равно 2n – 1. Для n = 4 задача может быть решена за 15 перемещений (см. рис. 7.5).Перемещение 1 Перемещение 2 Перемещение 3 Начальный Вспомогательный Конечный\n--- Страница 229 ---\n228  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее Рис. 7.5. Решение головоломки «Ханойская башня» с количеством дисков n = 4 Несмотря на то что число перемещений растёт экспоненциально от - носительно n, при использовании рекурсии сложность задачи, в сущ- ности, та же, что для случая n = 2. Самые интересные конфигурации дисков при n = 4 – после перемещений 7 и 8. Заметим, что после 7-го Начальный Вспомогательный Конечный Начальный Вспомогательный Конечный8 91011121314151234567\n--- Страница 230 ---\n7.2. Ханойская башня  229 перемещения на вспомогательном стержне находится (n – 1)-й диск. Эта комбинация нужна для перемещения наибольшего диска на конеч-ный стержень. Таким образом, первые семь шагов состоят из решения задачи для n – 1 = 3 дисков, когда цель заключается в перемещении этих трёх дисков с начального стержня на вспомогательный при посредстве конечного стержня. Другими словами, конечный и вспомогательный стержни меняются ролями. Восьмое перемещение – главная операция по перемещению наибольшего диска. После того как он помещён на конечный стержень, на вспомогательном стержне находится стопка из n – 1 дисков, которую нужно переместить на конечный стержень. Таким образом, семь оставшихся шагов – это решение другой задачи из n – 1 дисков, когда роли вспомогательного и конечного стержней меняются местами. Этот вывод, опирающийся на декомпозицию задачи и индук - цию, показан на рис. 7.6. Рис. 7.6. Декомпозиция задачи «Ханойская башня» В частности, декомпозиция рассматривает две задачи размером n – 1, решение которых состоит из трёх шагов. Если на первом и третьем ша-гах решается одна из подзадач, то на втором шаге наибольший диск пе-ремещается на конечный стержень. Следовательно, рекурсивное реше-Перемещение стопкиРешение подзадачи Начальный Вспомогательный Конечныйn n – 1 Перемещение дискаОсновная операция Решение подзадачиПеремещение стопки\n--- Страница 231 ---\n230  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее ние может опираться на индукцию, чтобы предположить, что мы можем переместить всю стопку из n – 1 дисков за один шаг (соответствующий рекурсивному вызову). Отметим, что в этом случае решение концепту - ально подобно случаю n = 2. В частности, отметим подобие рис. 7.4 и 7.6. Оба решения состоят из трёх шагов, когда диск 1 заменяется стопкой из n – 1 дисков на рис. 7.6 (а диск 2 играет ту же роль, что диск n). В листинге 7.3 приведена реализация процедуры, которая выводит на экран протокол перемещений дисков. Листинг 7.3. Процедура решения задачи «Ханойская башня» 1 234567891011121314151617def towers_of_Hanoi(n, o, d, a): if n == 1: print ('Move disk', n, 'from rod', o, 'to rod', d), else: towers_of_Hanoi(n – 1, o, a, d) print ('Move disk', n, 'from rod', o, 'to rod', d), towers_of_Hanoi(n – 1, a, d, o) def towers_of_Hanoi_alt(n, o, d, a): if n > 0: towers_of_Hanoi_alt(n – 1, o, a, d) print ('Move disk', n, 'from rod', o, 'to rod', d), towers_of_Hanoi_alt(n – 1, a, d, o) towers_of_Hanoi(4, 'O', 'D', 'A') Последняя строка кода просто вызывает метод, который выводит про- токол перемещений (см. рис. 7.7) для n = 4. Параметры, относящиеся к стержням, нужны для правильного задания отдельных подзадач (включая исходную). В коде также приведена альтернативная процедура, рассмат - ривающая начальное условие для n = 0, когда ничего делать не нужно. 7.3. Обходы дерева Обход дерева – это процесс однократного посещения каждого из узлов дерева (понимаемого как неориентированный граф) в заданном поряд-ке. В этом разделе мы разберём три способа обхода дерева «в глубину» в заданном порядке. Это значит, что всё поддерево узла обходится до об-хода его «братьев» (элементов того же уровня) и их поддеревьев. Кроме\n--- Страница 232 ---\n7.3. Обходы дерева  231 того, мы рассмотрим обходы дерева только слева направо, когда «дети» некоторого родительского узла обрабатываются строго слева направо. Рекурсивные обходы дерева привлекают своей простотой и не требуют ни стека, ни очереди, ни итераций. Рис. 7.7. Результат процедуры из листинга 7.3 при решении задачи «Ханойская башня» с количеством дисков n = 4 7.3.1. Внутренний обход Рассмотрим задачу печати узлов двоичного дерева поиска (см. раз- дел 5.3) в порядке следования его ключей. Рекурсивный алгоритм ре-шения задачи можно разработать следующим образом. Понятно, если дерево пусто, то алгоритм не выполняет никаких действий. Это – на-чальное условие. Для вывода рекурсивного условия рассмотрим схему на рис. 7.8, где корень дерева отбрасывается, а дерево разбивается на левое поддерево и правое поддерево. В первую очередь мы уверены, что любой ключ левого поддерева меньше ключа его корня. Кроме того, согласно основному свойству двоичных деревьев поиска левое поддерево – это тоже двоичное дерево поиска. Поэтому согласно принципу индукции можно считать, что ре-курсивный вызов для левого поддерева, как и рекурсивный вызов для Переместить диск 1 со стержня O на стержень A Переместить диск 2 со стержня O на стержень DПереместить диск 1 со стержня A на стержень DПереместить диск 3 со стержня O на стержень AПереместить диск 1 со стержня D на стержень OПереместить диск 2 со стержня D на стержень AПереместить диск 1 со стержня O на стержень AПереместить диск 4 со стержня O на стержень DПереместить диск 1 со стержня A на стержень DПереместить диск 2 со стержня A на стержень OПереместить диск 1 со стержня D на стержень OПереместить диск 3 со стержня A на стержень DПереместить диск 1 со стержня O на стержень AПереместить диск 2 со стержня O на стержень DПереместить диск 1 со стержня A на стержень D\n--- Страница 233 ---\n232  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее правого поддерева, напечатает свои ключи в нужном порядке. Отсюда понятно, что метод просто должен получить результаты обеих подза-дач, а между ними напечатать ключ корневого узла. Напечатать \"5\" между поддеревьямиВходы Результаты 5 2 2 2 42 4 5 6 7 8 9 6 7 8 9 79 68479 68 4   Рис. 7.8. Пример декомпозиции задачи внутреннего обхода дерева Процедура внутреннего обхода дерева приведена в листинге 7.4, где предполагается, что каждый узел исходного двоичного дерева поиска – это список из четырех элементов (см. раздел 5.3). Листинг 7.4. Внутренний обход двоичного дерева 1 2345def inorder_traversal(T): if T != []: inorder_traversal(T[2]) # process left subtree print (T[0], ': ', T[1], sep='') # print key and item inorder_traversal(T[3]) # process right subtree\n--- Страница 234 ---\n7.3. Обходы дерева  233 Например, применительно к дереву дней рождения из (5.1) этот код напечатает элементы дерева в алфавитном порядке имён (ключей) людей. Таким образом, мы говорим, что метод выполняет внутренний (inorder) обход двоичного дерева поиска. 7.3.2. Прямой и обратный обходы При прямом (preorder) и обратном (postorder) порядках обхода дво- ичного дерева корневой ключ (и сам корневой узел) печатается не меж - ду рекурсивными вызовами, а до и после них соответственно. В листин- ге 7.5 приводятся методы, осуществляющие такие обходы. Листинг 7.5. Прямой и обратный обходы двоичного дерева 1 23456789101112def preorder_traversal(T): if T != []: print (T[0], ': ', T[1], sep='') # print key and item inorder_traversal(T[2]) # process left subtree inorder_traversal(T[3]) # process right subtree def postorder_traversal(T): if T != []: postorder_traversal(T[2]) # process left subtree postorder_traversal(T[3]) # process right subtree print (T[0], ': ', T[1], sep='') # print key and item Отметим, что процедура прямого обхода печатает ключ корневого узла всего дерева или любого из его поддеревьев перед вызовом ме- тода с непустым деревом. Поэтому прямой обход задаёт порядок, при котором рекурсивные вызовы только предполагается выполнить (один для каждого узла двоичного дерева). В частности, метод preorder_ traversal для списка (5.1) даст следующий результат: Напротив, последовательность ключей обратного обхода отражает порядок, при котором рекурсивные вызовы уже выполнены. В частнос -Emma: 2002/05/23 Anna: 1999/12/03 Paul: 2000/01/13 Lara: 1987/08/23John: 2006/05/08 Luke: 1976/07/31 Sara: 1995/03/14\n--- Страница 235 ---\n234  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее ти, обратный обход двоичного дерева дней рождения даст следующую последовательность ключей: ' Anna', 'John', 'Luke', 'Lara', 'Сaра', 'Sara', 'Emma'. Заметьте, что ключ корня исходного дерева ('Emma') оказыва-ется последним, поскольку вызов метода для дерева в целом является последним, завершающим. 7.4. Самый длинный палиндром в строке В этой задаче в заданной исходной строке s = s0 s1 … sn–2 sn–1 длины n, где si – её символы, нужно найти самую длинную подстроку-палиндром. Если таких палиндромов несколько, алгоритм возвращает любой из них. Важно понимать, что подстрока – это непрерывная последовательность элементов s, дабы не путать её с понятием подпоследовательности, эле - менты которой не обязательно идут подряд. Кроме того, это задача оп- тимизации, цель которой – в достижении максимального значения не-которой функции от исходной строки. Такие задачи обычно решаются методами «динамического программирования» (см. раздел 10.4), кото-рые применяются к определенному классу задач оптимизации. Размер задачи – это длина исходной строки n. Наименьшие её экземп- ляры – это строки длины 0 (пустая строка) и 1 (строка из одного символа), когда алгоритм в начальном условии просто возвращает входную стро-ку. Задачу можно упростить, отказавшись от крайних символов строки. Таким образом, декомпозиция исходной задачи на рис. 7.9(a) предпо-лагает решение двух подзадач на рис. 7.9(b) и 7.9(c). Понятно, что если самая длинная подстрока-палиндром не содержит самый левый символ (s 0) исходной строки, то результатом будет выход метода, применённого к оставшейся подстроке (s1 n–1), независимо от того, принадлежит ли sn–1 решению. Точно так же, если самая длинная подстрока-палиндром не содержит s n–1, алгоритм должен вернуть самую длинную подстроку-па- линдром строки s0 n–2. Наконец, вся входная строка может оказаться па- линдромом, что проверяется функцией из листинга 10.9, которая, поми-мо этого, возвращает истинное значение для начальных условий. В листинге 7.6 приведена реализация рекурсивного метода. Так как эта задача подобна задаче поиска самого длинного палиндро- ма-подсписка, код работает так же, как если бы вход был списком. Если вход s – палиндром (см. раздел 4.3.2), то результатом будет просто s, ко - торый, естественно, включает и пустую строку, и строку из одного эле-мента. В противном случае алгоритм ищет самый длинный палиндром в двух подстроках длины n – 1 и возвращает самое длинное решение. Оценку времени его выполнения можно определить как\n--- Страница 236 ---\n7.4. Самый длинный палиндром в строке  235 1, 0 1,()2 ( 1) /2 1, 1,nTnTn n n≤≤ =−+ + >  где n/2 – слагаемое, связанное с вызовом is_palindrome . Нерекурсив- ное выражение T(n) = (7/4)2n – n/2 – 2. Таким образом, T(n) ∈ Θ(2n) имеет экспоненциальный рост. Рис. 7.9. Декомпозиция задачи поиска в строке самого длинного палиндрома Листинг 7.6. Поиск самого длинного палиндрома в строке 1 234567891011def longest_palindrome_substring(s): n = len(s) if is_palindrome(s): return s else: s_aux_1 = longest_palindrome_substring(s[1:n]) s_aux_2 = longest_palindrome_substring(s[0:n – 1]) if len(s_aux_1) > len(s_aux_2): return s_aux_1 else: return s_aux_2 Понятно, что рекурсивный алгоритм неэффективен, так как задача может быть решена «в лоб» за время O(n3). Отметим, что существует порядка n2 подстрок (их можно задать двумя граничными индекса- ми, управляемыми двумя циклами), требующих порядка n операций для определения, является ли строка палиндромом. Неэффективность листинга 7.6 происходит из-за наличия многочисленных идентичных перекрывающихся подзадач. Например, оба рекурсивных вызова на рис. 7.9(d) решают подзадачу длины n – 2, что влечёт за собой повто- рение идентичных и потому избыточных действий. Более того, мень-если если (a) (b) (c)s0 sn – 1 (d) s0n sn – 1\n--- Страница 237 ---\n236  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее шие идентичные подзадачи решаются за показательное время. Тем не менее такие рекурсивные решения полезны на практике, так как их разработка может быть первым шагом к проектированию более эффек - тивных алгоритмов. В разделе 10.4 обсуждается, как избежать перекры-тия подзадач в рекурсивных решениях с помощью подхода, известного как мемоизация, или применения динамического программирования, которое является выдающимся методом проектирования алгоритмов. Основанные на динамическом программировании решения этой зада-чи могут работать за время O(n 2). Наконец, было разработано несколько алгоритмов, способных решить эту задачу за линейное время. Итак, в листинге 7.6 используется функция is_palindrome для опре- деления, является ли строка палиндромом. Следующий пример заме-няет эту функцию другим рекурсивным вызовом. Очевидно, строка s длины n является палиндромом, если самая длинная её подстрока-па- линдром имеет длину n. Таким образом, можно проверить, является ли s палиндромом, оценивая, есть ли у самой длинной подстроки па- линдрома s 1…n–2 длина – 2 с s0 = sn–1. В листинге 7.7 приводится альтер- нативный метод, вызывающий только себя и использующий решение подзадачи на рис. 7.9(d). Время его выполнения: 1, 0 1,()2 ( 1) ( 2) 1, 1,nTnTn Tn n≤≤ =−+ − + >  чей порядок роста – Θ((1 + √2 )n) = Θ((2.41…)n). Так что этот метод ещё менее эффективен, чем метод в листинге 7.6, поскольку обрабатывает гораздо больше перекрывающихся идентичных подзадач. 7.5. Фракталы Фрактал – это геометрический объект, структура которого повторяется в разных масштабах. В этом разделе мы узнаем, как генерировать сне-жинку Коха и ковёр Серпиньского – два первых фрактальных рисунка. 7.5.1. Снежинка Коха Снежинка Коха – это фрактальный рисунок, состоящий из множества прямых отрезков и называемый «кривой Коха». Эта кривая создаётся многократным применением к отрезкам прямой следующего правила. Исходный отрезок прямой длины L (см. рис. 7.10) делится на 3 равных отрезка длины L/3, и средний из них «ломается» – заменяется двумя сторонами равностороннего треугольника с длиной стороны L/3 (шаг 1). если если\n--- Страница 238 ---\n7.5. Фракталы  237 Листинг 7.7. Альтернативный метод поиска самого длинного палиндрома в строке 1 2345678910111213141516def longest_palindrome_substring_alt(s): n = len(s) if n <= 1: return s else: s_aux_1 = longest_palindrome_substring_alt(s[0:n – 1]) if len(s_aux_1) == n – 2 and s[0] == s[n – 1]: return s else: s_aux_2 = longest_palindrome_substring_alt(s[1:n]) s_aux_3 = longest_palindrome_substring_alt( s[0:n – 1]) if len(s_aux_1) > len(s_aux_2): return s_aux_2 else: return s_aux_3 Рис. 7.10. Фрактальная кривая Коха Таким образом, новая кривая имеет длину 4L/3. Фрактал Коха фор- мируется применением этого правила к каждому отрезку кривой. Так, например, кривая на шаге 2 получается применением этого правила к каждому из четырёх прямых отрезков шага 1. Новая кривая состоит уже из 16 отрезков длиной L/9 каждый, а её полная длина – (4/3) 2L. Понятно, что после n итераций длина кривой будет равна (4/3)nL, которая вместе с n стремится к бесконечности.Исходный отрезок Итерация 1 Итерация 2 Итерация 3 Итерация 4 Итерация 5\n--- Страница 239 ---\n238  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее Снежинка Коха создаётся применением этого правила к каждой из трёх сторон равностороннего треугольника с генерацией трёх кривых Коха). На рис. 7.11 показано несколько первых шагов создания снежин-ки Коха. Рис. 7.11. Фрактальная снежинка КохаИсходный отрезок Итерация 1 Итерация 2 Итерация 3 Итерация 4 Итерация 5\n--- Страница 240 ---\n7.5. Фракталы  239 С вычислительной точки зрения задача генерации кривой Коха опре- деляется тремя входными параметрами – двумя концевыми точками p и q (координатами на плоскости) исходного отрезка прямой и коли- чеством итераций n. Понятно, что размер задачи – n, так как он опреде- ляет количество шагов для генерации рекурсивного изображения. На-чальное условие – это простейший случай n = 0, когда алгоритм просто чертит линию от p до q. На рис. 7.12 показана декомпозиция задачи, которую мы будем ис - пользовать для вывода рекурсивного условия. Отметим, что кривая Коха после n шагов состоит из четырех более простых кривых Коха, соз- данных на шаге n – 1. Рис. 7.12. Декомпозиция кривой Коха Основная математическая задача состоит в том, чтобы определить концевые точки каждой меньшей кривой Коха. На рис. 7.13 показан один из способов их получения с использованием векторов. (a) (b)\n--- Страница 241 ---\n240  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее (a) (b) (c) (d)v = q – pv/3 2v/3 v/3R60°v/3p q p qp q p qx Рис. 7.13. Новые концевые точки на очередном шаге построения кривой Коха Во-первых, отрезок прямой от точки p до точки q можно считать век - тором на плоскости (a). Кроме того, пусть v = q – p, тогда концевые точ- ки на исходном отрезке находятся на расстоянии одной и двух третей его длины от p, то есть p + v/3 и p + 2 v/3 соответственно (b), (с). Послед- нюю концевую точку x, лежащую вне отрезка (p, q), можно получить как сумму p + v/3 + R60°v/3, где 60cos 60 sin 60 1/ 2 3 / 2 sin 60 cos 60 3/2 1/2R  −−==     – матрица поворота вектора на 60° против часовой стрелки (d). Для генерации кривых Коха листинг 7.8 использует пакеты NumPy и Matplotlib . Начальное условие просто чертит отрезок прямой от p до q. Рекурсивное условие вызывает метод четырежды с соответствующими концевыми точками, уменьшая количество итераций на 1. Снежин-ку Коха можно получить, генерируя кривые Коха для трёх начальных отрезков, которые образуют равносторонний треугольник. Наконец, отметим, что код определяет векторы-столбцы согласно большинству источников, где векторы соответствуют векторам-столбцам.\n--- Страница 242 ---\n7.5. Фракталы  241 Листинг 7.8. Генерация кривых и снежинки Коха 1 234567891011121314151617181920212223242526272829303132333435363738394041import math import numpy as npimport matplotlib.pyplot as plt def koch_curve(p, q, n): if n == 0: # The base case is just a line sigment plt.plot([p[0, 0], q[0, 0]], [p[1, 0], q[1, 0]], 'k–'), else: v = q – p koch_curve(p, p + v / 3, n – 1) R_60 = np.matrix([[math.cos(math.pi \\ 3), –math.sin(math.pi \\ 3)], [math.sin(math.pi \\ 3), –math.cos(math.pi \\ 3)]]), x = p + v / 3 + R_60 * v / 3 koch_curve(p + v / 3, x, n – 1) koch_curve(x, p + 2 * v / 3, n – 1) koch_curve(p + 2 * v / 3, q, n – 1) def koch_snowflake(n): p = np.array([[0], [0]]) q = np.array([[1], [0]]) r = np.array([[0.5], [math.sqrt(3) / 2]]) koch_curve(p, r, n) koch_curve(r, q, n) koch_curve(q, p, n) fig = plt.figure() fig.patch.set_facecolor('white') koch_snowflake(3) plt.axis('equal') plt.axis('off')plt.show()\n--- Страница 243 ---\n242  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее 7.5.2. Ковёр Серпиньского Ковёр Серпиньского – второй классический фрактал, который фор- мируется следующим образом. Заданный пустой квадрат с длиной стороны s делится на 9 равных квадратов с длиной стороны s/3, и цен- тральный из них закрашивается (то есть заполняется некоторым цве-том), как показано на рис. 7.14 (шаг 1). Затем то же самое проделывается с восемью меньшими пустыми квадратами, окружающими централь-ный, что приводит к картинке на рис. 7.14 (шаг 2). Этот процесс можно повторять и дальше вплоть до некоторого n-го шага. Добавим только, что квадратные рамки вокруг фрактальных картинок на рис. 7.14 служат лишь для удобства их восприятия, но не являются частью фрактала. Рис. 7.14. Ковёр Серпиньского после 0-го, 1-го, 2-го и 3-го шаговИсходный ковёр (Итерация 0) Итерация 1 Итерация 2 Итерация 3\n--- Страница 244 ---\n7.5. Фракталы  243 Входами задачи могут быть координаты начальной точки p на плос - кости – центра пустого исходного квадрата (без краёв), длина его сто- роны s и количество желаемых шагов n. Ясно, что размер задачи опре- деляется n, а начальное условие возникает при n = 0, что не требует никаких действий. На рис. 7.15 показана декомпозиция задачи для общего рекурсивно- го условия, когда квадрат делится на девять подквадратов со сторона-ми s/3, а в листинге 7.9 приведена возможная реализация метода. Если n > 0, то прежде всего рисуется квадрат с центром в точке p. Его левый нижний угол расположен в точке p – [s/6, s/6], а длина его стороны – s/3 (эти значения используются методом Rectangle из Matplotlib ). За- тем на шаге n – 1 на оставшихся восьми меньших квадратах рекурсив- но рисуются восемь ковров Серпиньского размером s/3. Координаты центров этих квадратов – p + s/3, 0, или –s /3 по каждой размерности. Наконец, код в строках 39–41 просто рисует границы пустого исход-ного квадрата. Рис. 7.15. Декомпозиция ковра Серпиньского\n--- Страница 245 ---\n244  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее Листинг 7.9. Генерация ковра Серпиньского 1 234567891011121314151617181920212223242526272829303132333435363738394041424344import numpy as np import matplotlib.pyplot as plt from matplotlib.patches import Rectangle def sierpinski_carpet(ax, p, n, size): if n > 0: ax.add_patch(Rectangle((p[0, 0] – size / 6, p[1, 0] – size / 6), size / 3, size / 3, facecolor=(0.5, 0.5, 0.5), linewidth=0)) q = np.array([[–size / 3], [–size / 3]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) q = np.array([[–size / 3], [0]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) q = np.array([[–size / 3], [size / 3]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) q = np.array([[0], [–size / 3]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) q = np.array([[0], [size / 3]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) q = np.array([[size / 3], [–size / 3]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) q = np.array([[size / 3], [0]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) q = np.array([[size / 3], [size / 3]]) sierpinski_carpet(ax, p + q, n – 1, size / 3) fig = plt.figure() fig.patch.set_facecolor('white') ax = plt.gca() p = np.array([[0], [0]]) sierpinski_carpet(ax, p, 4, 1) ax.add_patch(Rectangle((–1 / 2, –1 / 2), 1, 1, fill=False, edgecolor=(0, 0, 0), linewidth=0.5)) plt.axis('equal') plt.axis('off') plt.show()\n--- Страница 246 ---\n7.6. Упражнения  245 7.6. Упражнения Упражнение 7.1. Реализуйте функцию из (3.2), вычисляющую биноми- альный коэффициент. Упражнение 7.2. Цель этого упражнения – разработать другое реше- ние задачи о пути по болоту из раздела 7.1. В листингах 7.1 и 7.2 вход-ная матрица уменьшается при каждом новом вызове функции, пока не станет вектором-столбцом. В некоторых языках программирования в каждом рекурсивном вызове проще (а в некоторых случаях просто не-обходимо) передавать входную матрицу целиком. В таких случаях раз-мер задачи может определяться дополнительными параметрами. Реа-лизуйте вариант такого алгоритма, который выясняет наличие пути по болоту (от правого его края), начиная с участка суши a r,c. Метод требует дополнительного параметра c и может в каждом рекурсивном вызове передавать входную матрицу целиком. Упражнение 7.3. Реализуйте рекурсивный метод, который модели- рует печать делений английской дюймовой линейки. Для заданного не- отрицательного целого числа n программа должна напечатать на кон- соли деления от 0 до n дюймов, как показано на рис. 7.16. Кроме того, она должна печатать деления дюйма согласно заданной точности k. В частности, каждый дюйм должен быть разделён на 2k частей (то есть должны печататься деления в 1/2k дюйма). На рис. 7.16(a) k = 2, тогда как на рис. 7.16(b) k = 3. Наконец, деления в 1/2j дюйма (для минимально возможного значения j) должны быть представлены k + 1 – j символами дефиса. Например, в (b) деления в 1/4 (3/4, 5/4, 7/4 и т. д.) дюйма состоят из 3 + 1 – 2 = 2 дефисов. Упражнение 7.4. Цель упражнения – решение иного варианта голово- ломки «Ханойская башня», которую назовём «узкой» задачей «Ханойс - кая башня». Пусть три стержня упорядочены слева направо. Правила те же, что в исходной задаче, но диски нельзя перемещать между крайни- ми стержнями, как показано на рис. 7.17. Создайте процедуру, использующую множественную рекурсию для перемещения стопки из n дисков с левого стержня на правый, или наоборот (упражнение включает методы перемещения дисков меж - ду средним стержнем и левым или правым стержнями). Кроме того, определите количество перемещений отдельных дисков стопки из n дисков.\n--- Страница 247 ---\n246  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее (a) (b)––– 0 ––– – ––– 1––– – ––– 2 – ––– ––– 3 – –– –––– 4  ––– n–––– 0 ––– – –––––– – –––– 1 – ––– ––– – –– ––––– 2  –––– n Рис. 7.16. Деления английской дюймовой линейки   Рис. 7.17. Дополнительное условие «узкой» задачи «Ханойская башня» Упражнение 7.5. Реализуйте функцию, вычисляющую количество узлов в двоичном дереве поиска. Считайте, что дерево представлено в виде списка четырехкомпонентных элементов, как описано в разде-ле 5.3. Упражнение 7.6. Реализуйте функцию, которая для заданного вход- ного списка a из n элементов определяет самый длинный непрерывный\n--- Страница 248 ---\n7.6. Упражнения  247 его подсписок одинаковых элементов. Например, для a = [1, 3, 5, 5, 4, 4, 4, 5, 5, 6] результатом будет подсписок [4, 4, 4]. Разбейте задачу так же, как в листинге 7.6, и примените вспомогательную рекурсивную функцию, определяющую одинаковость всех элементов подсписка. Кроме того, реализуйте рекурсивную функцию, которая не вызывает вспомогатель-ный метод, как в листинге 7.7. Упражнение 7.7. Разработайте и реализуйте рекурсивный метод, вычисляющий самую длинную подстроку-палиндром в заданном спис - ке из n элементов. Это не та задача, что описана в разделе 7.4, так как подпоследовательность списка не обязательно состоит из смежных эле-ментов. Например, самая длинная подпоследовательность-палиндром списка [1, 3, 4, 4, 6, 3, 1, 5, 1, 3] – это [1, 3, 4, 4, 3, 1], тогда как самый длин-ный (непрерывный) палиндром – это подсписок [3, 1, 5, 1, 3]. Упражнение 7.8. Реализуйте рекурсивный метод, рисующий треу - гольник Серпиньского (см. рис. 7.18). Треугольник Серпиньского может быть сгенерирован, начиная с равностороннего треугольника вида △, который делится на четыре меньших равносторонних треугольника со стороной, вдвое меньшей, чем у исходного. Один из них (централь-ный) будет перевёрнутым ▽, а три других – того же вида △, что исход- ный. Для этих трёх треугольников процесс повторяется итерационно (см. рис. 7.18). Для решения своей задачи метод должен получать коор-динаты точки на плоскости (например, нижней левой вершины тре-угольника), длину его стороны и количество итераций n. Используйте пакеты Numpy и Matplotlib . Упражнение 7.9. Кривая Гильберта – это непрерывная фрактальная кривая, заполняющая некоторое пространство. На рис. 7.19 показаны первые шесть кривых Гильберта. Длина кривой растёт экспоненциаль-но с ростом порядка (размерности) задачи, постепенно заполняя всю площадь ограниченного пространства (квадрата). Рекурсивная деком-позиция задачи заключается в разбиении фрактала на четыре кривых меньшего размера с соответствующей ориентацией. Кроме того, так как вся кривая непрерывна, четыре меньшие кривые должны соединяться, и именно это соединение малых кривых в одну фактически заверша-ет процесс формирования всей кривой. Цель этого сложного упражне-ния – реализовать рекурсивный метод, рисующий кривую Гильберта n-го порядка.\n--- Страница 249 ---\n248  Глава 7. Множественная рекурсия II: пазлы, фракталы и прочее Рис. 7.18. Треугольный ковёр СерпиньскогоИсходный треугольник Итерация 1 Итерация 2 Итерация 3 Итерация 4 Итерация 5\n--- Страница 250 ---\n7.6. Упражнения  249 Рис. 7.19. Первые шесть шагов построения кривой ГильбертаПорядок 1 Порядок 2 Порядок 3 Порядок 4 Порядок 5 Порядок 6",
      "debug": {
        "start_page": 223,
        "end_page": 250
      }
    },
    {
      "name": "Глава 8. Задачи подсчёта 250",
      "content": "--- Страница 251 --- (продолжение)\nГлава 8 Задачи подсчёта Музыка – это удовольствие от подсчётов, которое испытывает человеческая душа, не осознающая, что она считает. – Готфрид Лейбниц Рекурсия широко используется в комбинаторике – разделе математики, изучающем подсчёт на дискретных множествах объектов и играющем важнейшую роль в анализе алгоритмов. Эта глава посвящена рекурсив-ным решениям вычислительных задач подсчёта, цель которых – сло-жение определенного числа элементов, объектов, вариантов, понятий и т. д. Общая стратегия заключается в разбиении подлежащих подсчёту элементов на несколько непересекающихся подмножеств с последую-щим сложением количеств в каждом из них. С точки зрения рекурсии исходная задача должна разбиваться на несколько меньших подзадач, а её результатом должна быть сумма результатов этих меньших подза-дач. В предыдущих главах мы уже встречались с несколькими из таких за- дач. Например, вычисление суммы первых положительных целых чи-сел можно понимать как подсчёт числа квадратных блоков треугольных структур, как показано на рис. 1.5(a). Другой пример – задача подсчёта битов из упражнения. В этой главе мы изучим две альтернативные ре-курсивные стратегии подсчёта битов, опирающиеся на две разные де-композиции. Мы увидим, что несколько из широко известных рекурсивных функ - ций связано с фундаментальными комбинаторными понятиями. На-пример, факториал, мощность и биномиальные коэффициенты связаны с перестановками, размещениями (с повторами) и сочетаниями соот -\nГлава 8 Задачи подсчёта Музыка – это удовольствие от подсчётов, которое испытывает человеческая душа, не осознающая, что она считает. – Готфрид Лейбниц Рекурсия широко используется в комбинаторике – разделе математики, изучающем подсчёт на дискретных множествах объектов и играющем важнейшую роль в анализе алгоритмов. Эта глава посвящена рекурсив-ным решениям вычислительных задач подсчёта, цель которых – сло-жение определенного числа элементов, объектов, вариантов, понятий и т. д. Общая стратегия заключается в разбиении подлежащих подсчёту элементов на несколько непересекающихся подмножеств с последую-щим сложением количеств в каждом из них. С точки зрения рекурсии исходная задача должна разбиваться на несколько меньших подзадач, а её результатом должна быть сумма результатов этих меньших подза-дач. В предыдущих главах мы уже встречались с несколькими из таких за- дач. Например, вычисление суммы первых положительных целых чи-сел можно понимать как подсчёт числа квадратных блоков треугольных структур, как показано на рис. 1.5(a). Другой пример – задача подсчёта битов из упражнения. В этой главе мы изучим две альтернативные ре-курсивные стратегии подсчёта битов, опирающиеся на две разные де-композиции. Мы увидим, что несколько из широко известных рекурсивных функ - ций связано с фундаментальными комбинаторными понятиями. На-пример, факториал, мощность и биномиальные коэффициенты связаны с перестановками, размещениями (с повторами) и сочетаниями соот -\n--- Страница 252 ---\n8.1. Перестановки  251 ветственно. Кроме того, во многих комбинаторных задачах возникают ещё и числа Фибоначчи. В этой главе мы будем выводить эти функции, расчленяя соответствующие задачи подсчёта, а не их математические формулы и определения. Хотя все эти задачи – чисто математические, мы будем решать их, используя те же понятия, приёмы и методики, что были изложены в предыдущих главах. Наконец, поскольку решения задач подсчёта либо просты для про- граммирования, либо уже появлялись в книге, глава не содержит их кода (некоторые упражнения предлагают реализовать лишь отдельные функции). В этом смысле её основная цель – побудить к рекурсивному мышлению при решении разного рода вычислительных задач. 8.1. Перестановки Под перестановкой множества элементов понимается определённая по-следовательность этих элементов (или действие по изменению порядка следования элементов в заданной последовательности). В этом разде-ле мы разберём перестановки «без повторений», когда все их элементы различны. В частности, рассмотрим задачу подсчета общего количест - ва возможных перестановок из n различных элементов. Для простоты предположим, что эти n элементов – целые числа 1, 2, …, n, а переста- новка – упорядоченный список этих элементов. Для n = 4 существует 24 различные перестановки, представленные списками на рис. 8.1 (в раз-деле 12.2.2 описывается алгоритм генерации всех таких перестановок). Рис. 8.1. Возможные перестановки (списки) первых четырех положительных целых чисел[1,2,3,4] [2,1,3,4] [3,1,2,4] [4,1,2,3] [1,2,4,3] [2,1,4,3] [3,1,4,2] [4,1,3,2] [1,3,2,4] [2,3,1,4] [3,2,1,4] [4,2,1,3] [1,3,4,2] [2,3,4,1] [3,2,4,1] [4,2,3,1][1,4,2,3] [2,4,1,3] [3,4,1,2] [4,3,1,2] [1,4,3,2] [2,4,3,1] [3,4,2,1] [4,3,2,1]\n--- Страница 253 ---\n252  Глава 8. Задачи подсчёта Для определения математической рекурсивной функции, обеспечи- вающей результат для заданного n, можно, как обычно, следовать схеме на рис. 2.1. Для задач подсчёта их размер связан с общим числом скла- дываемых элементов. Размер данной задачи – это просто n, поскольку число перестановок растет, как функция от n. Тривиальное начальное условие выполняется при n = 1, когда получается всего одна перестанов- ка единственного элемента. Кроме этого, можно рассмотреть случай, когда n = 0. Хотя может показаться, что результатом будет 0 перестано- вок, математики ради удобства считают, что число перестановок в этом случае равно 1. Например, если перестановке соответствует список, то можно считать, что при n = 0 получается один список – пустой. Для вывода рекурсивного условия можно разбить результат на n подзадач размера n – 1, как показано на рис. 8.2, где каждая из подза- дач подсчитывает возможные перестановки в разных подмножест - вах. Рис. 8.2. Декомпозиция задачи подсчёта возможных перестановок f(n) для n различных элементов Пусть f(n) – функция, которая вычисляет количество возможных пе- рестановок n различных элементов. Если мы зафиксировали элемент в первой позиции перестановки, то нам нужно посчитать количество возможных перестановок для оставшихся n – 1 элементов. По нашему определению, это количество равно f(n – 1), которое, по принципу ин- дукции, мы считаем известным. Наконец, поскольку в первой позиции перестановки может оказаться каждый из n элементов, f(n) определяет - ся как f(n – 1), сложенное с собой n раз, что, очевидно, можно записать как n · f(n – 1). Таким образом, вместе с начальными условиями опреде- ление функции будетn – 1 n-й= f (n– 1) = f (n– 1) = f (n– 1) = f(n– 1) f(n) =1-й 2-й 3-йn\n--- Страница 254 ---\n8.2. Размещения с повторениями  253 1, 0,()( 1), 0nfnnfn n= =⋅− > и является функцией-факториалом (начальное условие для n = 1 избы- точно). На рис. 8.3 приведено обоснование декомпозиции задачи для n = 4, где вычисляемые перестановки разделены на 4 подмножества (со-ответствующих подзадачам размера n – 1), каждое из которых содержит перестановки для фиксированного первого элемента. Рис. 8.3. Декомпозиция возможных перестановок первых четырёх положительных целых чисел Наконец, нетрудно видеть, что нужный результат даёт функция вы- числения факториала, поскольку существует ровно n способов выбрать первый элемент перестановки, n – 1 способов выбрать второй (зафик - сировав первый), n – 2 способов выбрать третий и т. д. Это, естественно, приводит к n! = n × ( n – 1) × (n – 2) × … × 1 различным перестановкам. Однако такое рассуждение ближе к итерационному, тогда как представ-ленное выше рекурсивное решение опирается на индукцию и декомпо-зицию задачи. 8.2. Размещения с повторениями Рассмотрим некоторое множество из n элементов. В комбинаторике размещением из n элементов множества по k элементов называется последовательность из k ≤ n элементов, в которой имеет значение поря-если если , [1,2,3,4] [1,2,4,3] [1,3,2,4] [1,3,4,2][1,4,2,3] [1,4,3,2][2,1,3,4] [2,1,4,3] [2,3,1,4] [2,3,4,1][2,4,1,3] [2,4,3,1][3,1,2,4] [3,1,4,2] [3,2,1,4] [3,2,4,1][3,4,1,2] [3,4,2,1][4,1,2,3] [4,1,3,2] [4,2,1,3] [4,2,3,1][4,3,1,2] [4,3,2,1]\n--- Страница 255 ---\n254  Глава 8. Задачи подсчёта док следования элементов. Если для записи размещений использовать спис ки, то [a1, a5, a8] и [a8, a5, a1] – это два разных размещения по 3 эле- мента на множестве {a1, a2, …, a10}. Кроме того, если элементу разрешает - ся появляться в последовательности не один раз, то такое размещение называется размещением «с повторениями» (например, [a 1, a5, a1] было бы правильным размещением). В этом разделе мы изучим именно этот вид размещения с повторениями. На рис. 8.4 приведён конкретный пример, где квадратиками обозначены элементы мно жества, кружоч- ками – положения элементов в размещении, а стрелками – ссылки на конкретные элементы множества, вошедшие в размещение (в упражне-нии 8.1 используется другое представление). Рис. 8.4. Пример размещения с повторениями по k элементам из n элементов множества Нетрудно видеть, что согласно «принципу умножения» число разме- щений с повторениями по k элементов на множестве из n элементов есть nk, так как на каждом месте в размещении из k элементов может находиться (в том числе повторно) каждый из n элементов множества. Тем не менее мы выведем этот факт, используя рекурсию. Задача определяется параметрами k и n. Хотя задачу можно свести к меньшим подзадачам путём уменьшения k и/или n, декомпозиция будет проще, если считать размером задачи k. Тривиальное начальное условие выполняется при k = 1, когда существует ровно n различных способов выбрать один элемент из множества. Кроме того, как в задаче о перестановках, можно рассмотреть случай, когда k = 0, который можно понимать как пустое размещение. Для вывода рекурсивного условия можно воспользоваться схемой на рис. 8.5. n k\n--- Страница 256 ---\n8.3. Сочетания  255 Рис. 8.5. Декомпозиция задачи подсчёта размещений с повторениями n элементов множества в k позициях Исходная задача, обозначенная f(n, k ), показана на рис. 8.5(a), где тол- стая стрелка заключает в себе все возможные отношения между мно- жеством и размещением. На рис. 8.5(b) приведена подзадача с умень-шенным на 1 исходным размером, которая подсчитывает все способы размещения n элементов в k – 1 позициях. Наконец, поскольку сущест - вует n способов разместить элементы множества в последней k-й по- зиции, общее количество размещений будет f(n, k – 1), сложенное n раз. Таким образом, рекурсивная функция определяется как 1, 0,(, )( , 1) , 0,kf nkfnk n k= =−⋅ >  и является степенью nk (см. листинг 4.1). 8.3. Сочетания Сочетание из n различных элементов по k без повторений – это просто подмножество из k элементов исходного множества. Сочетания подоб-если если(a) (b)k – 1 1 2 3 n 1 2 k 1 2 3 n 1 kf (n, k) f (n, k) f (n, k – 1)\n--- Страница 257 ---\n256  Глава 8. Задачи подсчёта ны размещениям, только порядок следования элементов здесь не имеет значения. Поэтому сочетание соответствует (под)множеству, а не по-следовательности. Например, подмножество {a 1, a2, a3} – это сочетание элементов на множестве {a1, a2, …, a10}, причём {a1, a2, a3} и {a3, a1, a2} не различаются. В этом разделе мы займёмся подсчётом всех сочетаний из n различных элементов по k элементов без повторений. Размер этой задачи зависит и от k, и от n (где k ≤ n). Как мы вскоре уви- дим, для разработки рекурсивного решения их необходимо уменьшать вместе. Но мы начнём с определения начальных условий. Тривиальное выполняется при k = n, когда существует лишь одно правильное сочета- ние – это всё множество из n элементов. Другое простое условие выпол- няется при k = 1, когда результат, очевидно, равен n. Кроме того, при k = 0 можно считать, что есть только одна правильная комбинация – пустое множество. Как и в предыдущих разделах, если у нас есть начальное ус - ловие для k = 0, то необходимость в начальном условии для k = 1 отпадает. Для вывода рекурсивного условия разобьём все сочетания на два мно- жества. Рассмотрим исходное множество из n элементов {a 1, a2, …, an} и отдельный его элемент, скажем, a1. Обратите внимание, что существует два типа сочетаний: (a) содержащие a1 и (b) не содержащие a1. Таким образом, исходную задачу f(n, k) можно разбить на две в зависимости от типа сочетания, как показано на рис. 8.6. Если сочетания содержат a1, то оставшиеся k – 1 элементов – это со- четания из n – 1 элементов подмножества {a2, …, an} по k – 1 элементов. А этот набор сочетаний определяется функцией f(n – 1, k – 1). Если же a1 не содержится в сочетаниях, то это – сочетания из того же подмно жества {a2, …, an} по k элементов, а количество таких сочетаний – f(n – 1, k). Та - ким образом, результатом будет сумма обоих типов сочетаний, а ре- курсивная формула – f(n, k) = f(n – 1, k – 1) + f(n – 1, k). В итоге вместе с начальными условиями функция определяется как 1, 0 ,(,)( 1, 1) ( 1, ), k knf nkfn k fn k== =− −+ −  и определяет биномиальный коэффициент (см. (3.2)). 8.4. Подъём по лестнице Цель следующей задачи – посчитать количество возможных способов подняться по лестнице из n ступенек с шагом в одну или две ступень- ки. На рис. 8.7 показан один из способов подъёма по лестнице из семи ступенек.если или в противном случае\n--- Страница 258 ---\n8.4. Подъём по лестнице  257 Рис. 8.6. Декомпозиция задачи подсчёта сочетаний из n элементов по k Рис. 8.7. Один из способов подняться по лестнице с шагом в 1 или 2 ступеньки Понятно, что размер задачи – n. Рассмотрим несколько начальных условий. Если n = 1, то существует только один способ подняться по лестнице. Если n = 2, то можно сделать либо два шага, либо один (через ступеньку). Кроме того, если представлять способ подъёма списком, то можно также считать, что при n = 0 результатом будет пустой список.Исходная задача: f(n, k) Включает a1: f(n – 1, k – 1) Не включает a1: f(n – 1, k )a1 k – 1 kn – 1k n – 1n a1 a1a1a2 a2a2an anan\n--- Страница 259 ---\n258  Глава 8. Задачи подсчёта Для вывода рекурсивного условия задачу можно разбить так, как по- казано на рис. 8.8. Рис. 8.8. Декомпозиция задачи подсчёта всех способов подняться по лестнице с шагом в 1 или 2 ступеньки В исходной задаче (рис. 8.8(а)) темная стрелка представляет общее количество способов f(n) подъёма по лестнице из n ступенек. А сами способы подъёма можно разделить на две группы. Одна из них вклю- чает последовательность дальнейших шагов после одиночного шага. После одиночного шага будет ещё f(n – 1) способов добраться до вер- шины лестницы, делая одиночные или двойные шаги (рис. 8.8(b)). По-этому жирная стрелка представляет подзадачу размера n – 1. Во второй группе – дальнейшая последовательность шагов после двойного шага. В этом случае (рис. 8.8(c)) количество способов подняться по лестнице будет f(n – 2), где жирная стрелка указывает на подзадачу размера n – 2. Наконец, поскольку обе группы последовательностей представляют об-щее количество способов подняться по лестнице, решение – f(n – 1) + f(n – 2). Вместе с начальными условиями функция может быть опреде-лена следующим образом: 1, 1, ( ) 2, 2, ( 1) ( 2), 3, n fn n fn fn n=  == −+ − ≥  что очень напоминает функцию Фибоначчи F(n) (см. (1.2)), а точнее f(n) = F(n + 1).если еслиесли(a) (b) (c)f(n) способов подняться на n ступенек f(n – 1) способов подняться на n – 1 ступенекf(n – 2) способов подняться на n – 2 ступенек\n--- Страница 260 ---\n8.5. Путь по Манхэттену  259 8.5. Путь по Манхэттену Во многих городах улицы и авеню перпендикулярны друг другу. Пред- положим, что они образуют прямоугольную систему координат, как на рис. 8.9. Рис. 8.9. Задача о пути по Манхэттену Цель задачи – определить количество путей, ведущих к пересечению авеню m ≥ 0 с улицей n ≥ 0 (где m и n – целые числа), начиная с авеню 0 и улицы 0. Чтобы это сделать, предположим, что на каждом шаге раз- решается идти только к улице или авеню с большим номером, то есть вверх или вправо. Можно считать, что размер задачи – min(m, n). В этом случае простей- шее начальное условие выполняется, когда один из параметров равен 0, поскольку в этом случае к точке (m, n) ведёт только один правильный путь по прямой. Кроме того, если оба параметра равны 0, такой путь можно считать «пустым». Задачу можно разбить на две отдельные подзадачи, как показано на рис. 8.10. Пусть f(m, n) – общее количество путей от (0, 0) к (m, n). Обратите вни- мание, что можно разделить пути на два несвязных множества в зави-симости от выбора первого шага. Если мы пошли вправо к точке (1, 0), то от неё до (m, n) будет f(m – 1, n) путей. И наоборот, если мы пошли вверх к точке (0, 1), то от неё до (m, n) будет f(m, n – 1) путей. Сумма этих количеств даст рекурсивное решение. Функция выглядит следующим образом: 1, 0 0,( ,)( 1, ) ( , 1), mnf mnfm n fmn== =−+ −  Наконец, путь к (m, n) – это последовательность из m + n шагов, где m – количество шагов вправо, а n – количество шагов вверх. Иными сло- вами, весь путь можно представить двоичной последовательностью длины m + n. Следовательно, его можно задать последовательностью если или в противном случае.(m, n) (0, 0)Допустимые перемещения\n--- Страница 261 ---\n260  Глава 8. Задачи подсчёта направлений движения – вправо (это сочетание из n + m элементов по m) или, аналогично, прямо (это сочетание из n + m элементов по n). Таким образом, функция – это биномиальный коэффициент: ( , ) ( )!/( ! !)nm mn mn f mn C C m n m n++=== + ⋅ . В итоге можно считать, что формула определяет количество сочета- ний из m + n элементов по m или по n элементов, где количество шагов вправо m, как и количество шагов вверх n, неизменно. Рис. 8.10. Декомпозиция задачи о пути по Манхэттену 8.6. Триангуляция выпуклого многоугольника Триангуляция многоугольника – это множество непересекающихся треугольников, которые покрывают (без перекрытий) всю область мно-гоугольника и вершины которых являются вершинами многоуголь-ника. На рис. 8.11 показаны две триангуляции выпуклого 7-угольника (выпуклый многоугольник – это многоугольник, в котором любой от - резок, соединяющий любые две его внутренние точки, лежит внутри многоугольника). Следующая задача состоит в определении функции, вычисляющей все возможные различные способы разбиения выпукло-го n-угольника на треугольники.(m, n) (0, 0) (m, n) (0, 0)(m, n) (0, 0)(0, 1) (0, 1) f (m – 1, n) f (m – 1, n)f (m, n)\n--- Страница 262 ---\n8.6. Триангуляция выпуклого многоугольника  261 Рис. 8.11. Две возможные триангуляции одного выпуклого 7-угольника Размер задачи – n. Тривиальное начальное условие выполняется при n = 3, когда результат, очевидно, равен 1. Кроме того, подобно предыду - щим задачам, если n = 2, то результат тоже равен 1 (что будет уточнено ниже). Рекурсивное условие здесь сложнее, чем в предыдущих примерах, так как решение потребует рассмотрения нескольких подзадач меньшего размера. Для понимания декомпозиции воспользуемся конкретным примером. Рассмотрим, например, нижнюю сторону 8-угольника на рис. 8.12. Рис. 8.12. Шесть (n – 2) треугольников на базе нижней стороны восьмиугольника (n = 8) Естественно, что она должна принадлежать одному из треугольников триангуляции, но таких различных треугольников, включающих эту сторону, – 6 (n – 2) по числу вершин многоугольника, не принадлежа-щих его нижней стороне. Поэтому триангуляции могут быть разбиты на 6 независимых множеств, отвечающих конкретному треугольнику на базе нижней стороны. Другими словами, затененный треугольник определяет соответствующее ему множество триангуляций, а общее ко-личество триангуляций будет суммой триангуляций в каждом из шести множеств. Выбрав один из затенённых треугольников, по обе его стороны мы получим два выпуклых многоугольника (один из которых может быть пустым), которые также должны быть разбиты на треугольники. От - метим, что оба многоугольника примыкают к сторонам затенённого треугольника. Согласно принципу умножения, общее количество три-ангуляций, связанных с выбранным затенённым треугольником, будет равно произведению числа триангуляций каждого из смежных много-угольников, как показано на рис. 8.13.\n--- Страница 263 ---\n262  Глава 8. Задачи подсчёта Рис. 8.13. Декомпозиция задачи триангуляции выпуклого многоугольника для конкретного треугольника Пусть f(n) – целевая функция задачи, тогда на рис. 8.13(a) слева от затенённого треугольника – подзадача размера 4, а справа – подзада- ча размера 5. Количество триангуляций, связанных с затенённым тре-угольником, будет f(4) · f(5). В случае (b) одна из подзадач имеет раз- мер 7, а вторая – размер 2, поэтому мы имеем f(7) · f(2) триангуляций, связанных с затенённым треугольником. Несмотря на то что один из многоугольников (связанный с f(2)) пуст, количество возможных три- ангуляций, связанных с затенённым треугольником, даст f(7), что под- тверждает использование в качестве начального условия f(2) = 1. В конце концов, нужно сложить все триангуляции, связанные с шесть ю затененными треугольниками. В приведённом примере, как показано на рис. 8.14, мы получим: f(8) = f(2) · f(7) + f(3) · f(6) + f(4) · f(5) + f(5) · f(4) + f(6) · f(3) + f(7) · f(2). Рис. 8.14. Общее количество триангуляций в восьмиугольнике В общем виде рекурсивную функцию можно определить как 1 21, 2, ()( ) ( 1 ), 2.n in fnfi fn i n− ==  =⋅ +− >∑ Отметим, что дополнительное начальное условие для n = 3 не обяза- тельно.если если(a) (b) f(8) = f(2) · f(7) + f(3) · f(6) + f(4) · f(5) + f(5) · f(4) + f(6) · f(3) + f(7) · f(2)f(4) · f (5) триангуляций f(7) · f (2) триангуляций f(7) f(2)f(5) f(4)\n--- Страница 264 ---\n8.7. Пирамиды из кругов  263 Наконец, f(n) имеет отношение к часто встречающимся в комбинато- рике числам Каталана и может быть определена как 1 01, 0, ()( ) ( 1 ), 0.n in CnCi Cn i n− ==  =⋅ −− >∑ (8.1) В частности, f(n) = C(n – 2). 8.7. Пирамиды из кругов В следующей задаче нужно определить количество возможных спосо- бов укладки кругов рядами внутри пирамиды. Начав с непрерывного ряда кругов в основании, нужно укладывать на него круги согласно сле-дующим правилам: 1) все круги в ряду должны примыкать друг к другу, то есть между ними не должно быть промежутков; 2) каждый круг не из нижнего ряда должен лежать на двух кругах рядом ниже, образуя равносторонний треугольник («пирамиду»). На рис. 8.15 приведены примеры правильных и неправильных укла- док кругов. Задача состоит в том, чтобы определить функцию, которая подсчитывает количество правильных укладок кругов, начиная с n кру - гов нижнего ряда. Рис. 8.15. Правильные и неправильные пирамиды из кругов Размер задачи – n. Тривиальное начальное условие выполняется при n = 1, когда результат, очевидно, равен 1. Для вывода рекурсивного ус - ловия будем делить возможные пирамидальные конфигурации на не-если если Неправильные Правильные\n--- Страница 265 ---\n264  Глава 8. Задачи подсчёта сколько несвязных групп по количеству кругов непосредственно над нижним рядом. Рисунок 8.16 иллюстрирует эту идею для n = 4. Рис. 8.16. Пирамиды, сгруппированные по количеству кругов непосредственно над нижним рядом из n = 4 кругов Ключ к решению – в том, что меньшие пирамиды (подзадачи) с оди- наковым количеством кругов в нижнем ряду можно разместить не-сколькими способами над нижним рядом кругов исходной задачи (см. рис. 8.17). В частности, для начального входного параметра n существу - ет n – i способов размещения подобной пирамиды размера i. На рисунке i = 3 и n = 7, тогда существует n – i = 4 способа разместить подобные ис - ходной пирамиды размера 3 над нижним рядом из n = 7 кругов. Рис. 8.17. Декомпозиция задачи о пирамиде из кругов на подзадачи конечного размераИсходная задача для n = 7\n--- Страница 266 ---\n8.8. Упражнения  265 В итоге, поскольку размер меньших подзадач варьируется от 1 до n – 1, функция должна сложить все возможные конфигурации кругов. Кроме того, поскольку сам полный нижний ряд кругов (без кругов над ним) считается правильной укладкой, к функции следует добавить ещё 1. Ниже приведена функция, решающая задачу: 1 11, 1, ()1 ( ) ( ), 1.n in fnn i fi n− ==  =+ −⋅ >∑ (8.2) Таким образом, результат представляет собой функцию Фибоначчи. В частности, можно доказать, что f(n) = F(2n – 1), где F – функция Фибо- наччи. 8.8. Упражнения Упражнение 8.1. Пусть f(n, k) – количество размещений с повторениями из n элементов по k элементов. Существует n способов выбрать первый элемент размещения, n способов выбрать второй и т. д. Все эти вариан- ты можно представить полным деревом-списком высоты k, внутренние узлы которого всегда имеют n дочерних узлов, а листья представляют собой размещения. На рис. 8.18 приведён пример всех размещений с повторениями из 4 элементов множества {a, b, c, d} по 2 элемента. Рис. 8.18. Размещения с повторениями из четырех элементов множества {a, b, c, d} по два элемента Узловые элементы списка – это частичные подпоследовательности в процессе построения размещения, тогда как помеченные ветви – это конкретные элементы, добавляемые к частичной подпоследователь- ности. Таким образом, каждое размещение в дереве – это путь от кор-невого узла до листа.если если [ ] [a] [b] [c] [d] [a,a] [a,b] [a,c] [a,d] [b,a] [b,b] [b,c] [b,d] [c,a] [c,b] [c,c] [c,d] [d,a] [d,b] [d,c] [d,d]a a a aab b b b bcd c c c cd d d d\n--- Страница 267 ---\n266  Глава 8. Задачи подсчёта Для данного древовидного представления размещений нарисуйте схему вывода рекурсивного правила f(n, k) = f(n, k – 1) · n. Исходная за- дача и её подзадачи должны представляться деревьями. Для простоты можно опустить метки узлов и ветвей. Упражнение 8.2. У нас есть n одинаковых костей для игры в «доми- но» размера 1×2 (или 2×1 при повороте на 90°). Выведите рекурсивную функцию, определяющую количество способов выложить из костей (без наложений и дыр) прямоугольник размером 2×n. На рис. 8.19 приведён конкретный пример для n = 10. Рис. 8.19. Выкладывание прямоугольника размером 2×10 из костей домино размером 1×2 или 2×1 Упражнение 8.3. Баскетбольная команда может набирать очки тремя различными способами: штрафной бросок – одно очко, бросок с игры (в пределах трёхочковой зоны) – два очка и бросок из-за трёхочковой зоны – три очка. Найдите функцию, определяющую количество вари-антов набора баскетбольной командой n очков. Например, существует 4 варианта набрать 3 очка: 1 + 1 + 1, 1 + 2, 2 + 1 и 3. Как видим, последо-вательность получения очков имеет значение. Упражнение 8.4. Решите задачу из упражнения 3.8, используя вмес - то формулы сложения битов рекурсию. Нарисуйте исходную задачу, как на рис. 3.11, и определите в ней подзадачи. Упражнение 8.5. Реализуйте функцию вычисления чисел Каталана C(n) в (8.1). Упражнение 8.6. В двоичном дереве каждый узел может иметь ни одного, один или два дочерних узла. Определите рекурсивную функ - цию f(n), вычисляющую количество различных двоичных деревьев, со- стоящих из n узлов. Учтите разницу между левыми и правыми дочер- ними узлами. Например, на рис. 8.20 показано 5 возможных двоичных деревьев, состоящих из n = 3 узлов. Рис. 8.20. Пять различных двоичных деревьев из трёх узлов\n--- Страница 268 ---\n8.8. Упражнения  267 Упражнение 8.7. Рассмотрим задачу о пирамиде из кругов из разде- ла 8.7. В этом упражнении для решения задачи предлагается восполь- зоваться другой декомпозицией. А именно разбивать различные пира-миды по их высоте, как показано на рис. 8.21, где g(h, n) – количество пирамид высоты h, которые можно построить на базе n кругов нижнего ряда. Таким образом, цель этого упражнения – рекурсивное определе-ние функции g(h, n). В заключение убедитесь в правильности функции, закодировав её и вычислив общее количество пирамид, построенных на базе нижнего ряда из n кругов: 1( , ) ( ) (2 1),n ighn f n F n === − ∑ (8.3) где f – функция (8.2), а F – функция Фибоначчи. Рис. 8.21. Пирамиды на базе n = 4 кругов нижнего ряда, сгруппированные по их высотеg(1, 4) g(3, 4)g(2, 4) g(4, 4)",
      "debug": {
        "start_page": 251,
        "end_page": 268
      }
    },
    {
      "name": "Глава 9. Взаимная рекурсия 268",
      "content": "--- Страница 269 --- (продолжение)\nГлава 9 Взаимная рекурсия В одиночку мы можем так мало, а вместе – так много. – Хелен Келлер Метод, явно вызывающий сам себя, рекурсивен по определению. Одна-ко рекурсивный метод не обязательно вызывает себя явно. Он может быть вызван другим методом, который, в свою очередь, вызывает его. Таким образом, вызов метода может повлечь множество последующих обращений к нему. Такой тип рекурсии называют взаимной, или кос - венной, рекурсией. Вообще говоря, несколько методов взаимно-рекурсивны, если они вызывают друг друга циклически. Для примера рассмотрим множество методов {f 1, f2, …, fn}. Если f1 вызывает f2, f2 вызывает f3 и т. д. и, наконец, fn вызывает f1, то говорят, что эти методы взаимно-рекурсивны. При этом они не обязаны вызывать друг друга строго циклически. Они могут вызвать несколько методов, включая себя, как показано на рис. 9.1, где стрелки означают вызов метода (например, f 8 вызывает f1 и f4). В этом примере только f3 вызывает себя явно, а все остальные методы взаим- но-рекурсивны. На первом шаге применения взаимной рекурсии задача разбивается на несколько разных задач (а не просто подзадач). После чего каждая из этих задач решается рекурсивно, опираясь на решения своих подзадач. Для взаимной рекурсии характерно то, что при решении некоторой за-дачи P используются рекурсивные решения подзадач, которые не обя- зательно являются меньшими экземплярами P. Конечно, разбиение ис - ходной задачи на несколько разных задач требует больше труда. Но как только эти задачи определены, процесс рекурсивного проектирования уподобляется работе с единственным методом. Иными словами, мы,\nГлава 9 Взаимная рекурсия В одиночку мы можем так мало, а вместе – так много. – Хелен Келлер Метод, явно вызывающий сам себя, рекурсивен по определению. Одна-ко рекурсивный метод не обязательно вызывает себя явно. Он может быть вызван другим методом, который, в свою очередь, вызывает его. Таким образом, вызов метода может повлечь множество последующих обращений к нему. Такой тип рекурсии называют взаимной, или кос - венной, рекурсией. Вообще говоря, несколько методов взаимно-рекурсивны, если они вызывают друг друга циклически. Для примера рассмотрим множество методов {f 1, f2, …, fn}. Если f1 вызывает f2, f2 вызывает f3 и т. д. и, наконец, fn вызывает f1, то говорят, что эти методы взаимно-рекурсивны. При этом они не обязаны вызывать друг друга строго циклически. Они могут вызвать несколько методов, включая себя, как показано на рис. 9.1, где стрелки означают вызов метода (например, f 8 вызывает f1 и f4). В этом примере только f3 вызывает себя явно, а все остальные методы взаим- но-рекурсивны. На первом шаге применения взаимной рекурсии задача разбивается на несколько разных задач (а не просто подзадач). После чего каждая из этих задач решается рекурсивно, опираясь на решения своих подзадач. Для взаимной рекурсии характерно то, что при решении некоторой за-дачи P используются рекурсивные решения подзадач, которые не обя- зательно являются меньшими экземплярами P. Конечно, разбиение ис - ходной задачи на несколько разных задач требует больше труда. Но как только эти задачи определены, процесс рекурсивного проектирования уподобляется работе с единственным методом. Иными словами, мы,\n--- Страница 270 ---\n9.1. Чётность числа  269 как обычно, применяем декомпозицию и индукцию. Более того, бóль- шая сложность задач и характер их декомпозиции только подчеркнут важность этих принципиальных понятий. В конце главы приводится несколько задач повышенной сложности, некоторые из которых являются вариациями других задач этой книги. Если читатель разберётся в их решениях и сможет самостоятельно раз-рабатывать алгоритмы, то он приобретёт прочное основание в навыках рекурсивного мышления. Рис. 9.1. Вызовы взаимно-рекурсивных методов 9.1. Чётность числа Одна из самых простых и самых популярных задач, используемых для иллюстрации взаимной рекурсии, состоит в определении чётности не-отрицательного целого числа n. Мы уже решали задачу определения чётности n (см. листинг 2.6), уменьшая её размер на две единицы. Кроме того, в упражнении 4.1 предлагалось решить задачу с помощью одной линейно-рекурсивной функции. Теперь же мы создадим две взаимоза-висимые функции – одну, проверяющую n на чётность, и вторую, про- веряющую n на нечётность. Таким образом, помимо решения исходной задачи (является ли n чётным), мы решим и другую задачу – является ли n нечётным. Пусть f(n) проверяет чётность n, а g(n) – нечётность n. Если считать размером задачи n, то начальное условие для f(n) выполняется при n = 0 с очевидным результатом True. Напротив, g(0) = False. Для вывода рекурсивных условий можно уменьшать размер задачи на 1. Посколь-ку мы намерены вывести и f(n), и g(n), на основании индукции можно f1f2 f3 f4 f5f6f7f8\n--- Страница 271 ---\n270  Глава 9. Взаимная рекурсия предположить, что они применимы к n – 1. Крайне важно, что для вы- вода f(n) нужно использовать g(n – 1), а для вывода g(n) – f(n – 1). С этой целью можно воспользоваться, например, такими простейшими свой- ствами: f(n) = g(n – 1) и g(n) = f(n – 1). Тогда два взаимно-рекурсивных метода можно закодировать, как в листинге 9.1. Листинг 9.1. Взаимно-рекурсивные функции для определения чётности неотрицательного целого числа n 1 23456789 10 11 12def is_even(n): if n == 0: return True else: return is_odd(n – 1) def is_odd(n): if n == 0: return False else: return is_even(n – 1) 9.2. Игры со многими игроками При написании подпрограмм хорошей общепринятой практикой про-граммирования является то, чтобы сделать их по возможности корот - кими и простыми, что заметно повышает удобочитаемость кода. В этом смысле взаимная рекурсия может быть полезной для реализации раз-личных действий или способов поведения. Например, в играх со многи-ми игроками различные роли игроков можно реализовать отдельными методами. Следующий пример моделирует две различные стратегии поведения игроков в простой игре. Из кучки, состоящей изначально из n камешков, два игрока по очереди убирают один или два камешка. Вы-игрывает тот, кто уберёт последние камешки. Допустим, первый игрок (Боб) решил всякий раз убирать по одному камешку, тогда как второй игрок (Элис) убирает один камешек, если оставшееся их число нечётно, и два – если чётно. Эту простую игру можно легко закодировать, используя всего один метод. Однако в листинге 9.2 приводится решение, основанное на двух взаимно-рекурсивных методах, в каждом из которых реализована своя\n--- Страница 272 ---\n9.3. Размножение кроликов  271 стратегия игры. В частности, в начальных условиях проверяется, вы- играет ли игрок игру, тогда как в рекурсивных условиях очередь переда-ётся другому игроку. Параметр функции, реализующей стратегию дру - гого игрока, уменьшается на число убранных из кучки камешков. Важно отметить, что каждая стратегия реализована отдельной процедурой, что упрощает понимание и изменение кода. Наконец, более сложная стратегия Элис явно лучше, чем у Боба. В частности, Боб победит только тогда, когда исходная кучка состоит из одного камешка. Листинг 9.2. Взаимно-рекурсивные процедуры, реализующие игровые стратегии Элис и Боба 1 23456789 10 11 121314151617def play_Alice(n): if n <= 2: print('Alice wins') elif n & 1: # Alice removes one pebble play_Bob(n – 1) # Turn switches to Bob else: # Alice removes two pebbles play_Bob(n – 2) # Turn switches to Bob def play_Bob(n): if n == 1: print('Bob wins') else: # Bob removes one pebble play_Alice(n – 1) # Turn switches to Alice 9.3. Размножение кроликов Следующая задача из разряда умозрительных касается искусственного размножения кроликов, число которых растёт по следующим правилам. 1. Новорождённая пара кроликов, самец и самка, пасётся один ме-сяц до полового созревания. 2. Зрелая пара кроликов спаривается в начале каждого месяца и ровно через месяц рожает новую пару кроликов. 3. Крольчиха всегда рожает одного самца и одну самку, которые спа-риваются только между собой. 4. Кролики никогда не умирают.\n--- Страница 273 ---\n272  Глава 9. Взаимная рекурсия Цель задачи (подсчёта) – вычислить общее количество R(n) кроликов через n месяцев. В следующих подразделах приводится два решения на основе взаимной рекурсии. 9.3.1. Зрелые и незрелые пары кроликов Вместо прямого подсчёта объёма всей популяции можно подсчитать число зрелых и незрелых пар для каждого месяца в отдельности. Это приводит к двум различным задачам размера n. В частности, пусть A(n) и B(n) обозначают, соответственно, количество зрелых и незрелых пар в каждом месяце n. Тогда начальными условиями будут A(1) = 0 и B(1) = 1, поскольку вначале есть только одна пара незрелых кроликов. На вто-ром месяце появится пара кроликов, еще не способных производить потомст во. Таким образом, B(2) = 0 и A(2) = 1. Для рекурсивных условий правила роста популяции показаны на рис. 9.2, где маленькие и большие кролики изображают незрелые и зрелые пары соответственно. С одной стороны, каждая пара незрелых кроликов в данном месяце созревает во взрослую пару в следующем ме-сяце. С другой стороны, каждая зрелая пара появляется и в следующем месяце (поскольку кролики никогда не умирают), и она также спарива-ется, создавая новую пару потомства. зрелая пара незрелая пара созревает не умирает спариваетсямесяц n – 1 месяц n Рис. 9.2. Правила размножения кроликов Согласно методу индукции, нам известен объём популяции зрелых и незрелых пар в месяце n – 1 (то есть A(n – 1) и B(n – 1)), откуда довольно просто вывести рекурсивные условия для A(n) и B(n). Во-первых, число незрелых пар в n-м месяце равно числу зрелых пар в прошлом месяце, поскольку зрелой паре нужен один месяц, чтобы спариться и произвес - ти новую пару незрелых кроликов. Поэтому B(n) = A(n – 1). Что касается A(n), то все зрелые пары, жившие в месяце n – 1, будут живы и в меся- це n, так как кролики не умирают. Кроме того, все незрелые пары в те- чение месяца n – 1 созревают и превращаются в зрелые. Таким образом,\n--- Страница 274 ---\n9.3. Размножение кроликов  273 рекурсивное условие – A(n) = A(n – 1) + B(n – 1). Обе функции можно определить следующим образом: 0, 1,()( 1) ( 1), 1,nAnAn Bn n= =−+ − >  (9.1) 1, 1,()( 1), 1,nBnAn n= =−>  (9.2) В них не нужны явные начальные условия для n = 2, так как они – именно те самые функции, которые были введены в разделе 1.6.4. Ясно, что A – рекурсивная функция, потому что она вызывает себя. Метод B вызывает себя косвенно – через вызов A, который, в свою очередь, вы- зывает B. В листинге 9.3 приведён код, соответствующий этим функци- ям. Листинг 9.3. Взаимно-рекурсивные функции подсчёта популяции незрелых и зрелых пар кроликов спустя n месяцев 1 23456789101112def adults(n): if n == 1: return 0 else: return adults(n – 1) + babies(n – 1) def babies(n): if n == 1: return 1 else: return adults(n – 1) Эти функции можно выразить исключительно через самих себя, как показано в (3.38) и (3.39). Наконец, общее количество пар кроликов – это просто сумма A(n) + B(n), которая оказывается n-м числом Фибонач- чи (см. упражнение 9.2)1. 9.3.2. Родовое дерево кроликов Совершенно иной взгляд на эту задачу – рассмотреть родовое (генеа- логическое) древо кроликов. На рис. 9.3 показано такое дерево спустя 1 Нелишне напомнить, что автором этой задачи был сам Леонардо Пизанский по прозвищу Фи-боначчи. – Прим. перев.если если если если .\n--- Страница 275 ---\n274  Глава 9. Взаимная рекурсия 7 месяцев, где метки рядом с кроликами указывают на их возраст (в ме- сяцах). Первая пара кроликов – начальная, отправившаяся пастись в 1-й месяц. Заметьте, что у неё есть 5 пар потомков, первая из которых появилась в начале 3-го месяца (поэтому её возраст – 5), а последняя – в начале 7-го месяца (значит, в конце 7-го месяца этим кроликам 1 ме-сяц). В следующих подразделах разбираются решения, основанные на множественной и взаимной рекурсиях. Рис. 9.3. Родовое дерево кроликов спустя 7 месяцев 9.3.2.1. Решение с множественной рекурсией Первая приходящая на ум в связи с этой задачей декомпозиция – раз- бить задачу так, как показано на рис. 9.4. В этом конкретном примере задача размера 7 разбита на пять мень- ших задач размером от 1 до 5. Заметим, что начальная пара кроликов с третьего месяца создаёт новую пару потомков, каждая из которых уже имеет своих потомков. Каждая пара потомков вместе со своими потом-ками образует меньшую задачу, подобную исходной. Таким образом, в рекурсивном условии искомая функция f(n) – это пара, прожившая n месяцев плюс общее количество её потомков. Формально декомпози-ция приводит к следующему определению: 1 i11, 1 2, ()1 ( ), 2,nnn fnfi n− ===  =+>∑ (9.3)если или если1 1 1 11 2 2 23 34 57\n--- Страница 276 ---\n9.3. Размножение кроликов  275 где используется множественная рекурсия, подобная (1.7). Более того, схема декомпозиции задачи на рис. 9.4 пригодна для любого n (напом- ним, что f(n) = F(n), где F – функция Фибоначчи). Рис. 9.4. Конкретный пример разбиения задачи о росте популяции кроликов на подобные ей подзадачи 9.3.2.2. Решение со взаимной рекурсией Рекурсивное выражение (9.3) можно вычислить в цикле (см. лис - тинг 1.4). Решение, к которому мы хотим прийти, заменяет суммирова-ние рекурсивной функцией (это важно, если язык программирования не поддерживает циклы). Во-первых, взаимная рекурсия возникает только тогда, когда в ис - ходной задаче можно выделить несколько разных задач. В данном слу - чае, помимо функции f(n), решающей исходную задачу, мы рассмотрим ещё и решение похожей, но иной задачи. А именно пусть g(n) – коли- чество пар детей в возрасте от 1 до n месяцев вместе с их потомками от начальной пары. С помощью этой вспомогательной функции просто определить f(n), а именно: для заданного n она подсчитывает всю семью начальной пары кроликов плюс g(n – 2), поскольку начальная пара всег - да на 2 месяца старше самых старших своих детей. Таким образом, f(n) можно выразить так:f(1) f(2) f(3) f(4) f(5) f(7)\n--- Страница 277 ---\n276  Глава 9. Взаимная рекурсия 1, 1 2,()1 ( 2), 2,nnfngn n== =+− > (9.4) что соответствует декомпозиции на рис. 9.5(a) при n = 7. Рис. 9.5. Декомпозиция задачи о размножении кроликов, приводящая к двум взаимно-рекурсивным функциям (a) (b)f(5)f(7)g(5) g(5)g(4)если или если\n--- Страница 278 ---\n9.4. Задача о станциях водоочистки  277 Для функции g размер задачи – n. Тривиальное начальное условие с результатом 1 выполняется при n = 1. Но можно также использовать начальное условие g(0) = 0. Вывод рекурсивного условия основан на де- композиции, уменьшающей размер задачи на 1 (см. рис. 9.5(b)). Заме- тим, что общее количество пар кроликов – это сумма количества пар для некоторой начальной пары спустя n месяцев f(n) и количества детей в возрасте не старше n – 1 месяцев вместе с их потомками g(n – 1). Сле- довательно, g(n) можно записать так: 0, 0,()( ) ( 1), 0.ngnf n gn n= =+− >  (9.5) В результате мы получили пару взаимно-рекурсивных функций, ко- торые вызывают друг друга. Кроме того, отметим, что g(n) просто равна 1()n ifi =∑ . Таким образом, (9.4) и (9.5) равносильны (9.3). В итоге можно без труда закодировать эти функции, как показано в листинге 9.4. Листинг 9.4. Альтернативные взаимно-рекурсивные функции подсчёта популяции кроликов спустя n месяцев 1 2345678910111213def population_rabbits(n): if n <= 2: return 1 else: return 1 + children_descendants(n – 2) def children_descendants(n): if n == 0: return 0 else: return (population_rabbits(n) + children_descendants(n – 1)) 9.4. Задача о станциях водоочистки В задаче «Станции водоочистки» есть n городов со станциями водо- очистки, расположенных по одну сторону реки, как показано на рис. 9.6. Допустим, что города упорядочены слева направо. Каждый город – источник грязной воды, которую необходимо очистить на станции (не если если\n--- Страница 279 ---\n278  Глава 9. Взаимная рекурсия обязательно своей) и сбросить в реку по трубам, соединяющим сосед- ние города. Работающая станция забирает сточные воды своего и сосед-них городов и после очистки сбрасывает их в реку. Но станция может не работать, и тогда сточная вода её города плюс вода любого соседнего с ней города направляется в другой город. Учитывая, что вода по трубе, соединяющей города, может течь лишь в одном из направлений, задача состоит в вычислении количества способов сброса очищенной воды в реку для n городов. Кроме того, мы должны быть уверены в том, что хотя бы одна из станций работает, то есть способна очистить и сбросить очищенную воду в реку. Рис. 9.6. Задача о станциях водоочистки Мы рассмотрим два рекурсивных решения этой задачи подсчёта. Первое моделирует переток воды между городами и использует мно-жественную рекурсию. Второе рассматривает сброс воды в реку по каж - дому городу и опирается на три взаимно-рекурсивные функции. 9.4.1. Переток воды между городами Вода по каждой из соединяющих соседние города n – 1 труб может пе- ретекать в трёх направлениях: 'N' – перетока нет, 'R' – направо и 'L' – на - лево. Следовательно, сброс воды в реку можно смоделировать строкой длины n – 1, состоящей только из этих символов. Единственное ограни- чение, касающееся перетока воды, состоит в том, что город не имеет права направить свою воду обоим своим соседям. Таким образом, цель задачи в том, чтобы найти все строки, в которых нет подстроки \"LR\". Очевидно, что размер задачи – n. Пусть f(n) представляет решение задачи. Если есть только один город, то его водоочистная станция мо-жет сбросить в реку лишь свою воду, то есть f(1) = 1. Для двух городов существует 3 варианта строки размера 1 с одним из трех символов, то есть f(2) = 3. Заметим, что если обе станции работают, они сбросят в реку только воду своих городов, а если какая-то из них не работает, она направит свою воду на соседнюю станцию. Город 1 Город 2 Город n – 1 Город n Станция 1 Станция 2 Станция n – 1 Станция n Река\n--- Страница 280 ---\n9.4. Задача о станциях водоочистки  279 На рис. 9.7 представлена декомпозиция задачи, приводящая к алго- ритму с множественной рекурсией. Рис. 9.7. Декомпозиция задачи о станциях водоочистки, моделирующая переток воды между городами Сначала общее количество возможных строк длины n – 1 втрое боль- ше количества правильных строк длины n – 2, так как к каждой из них можно добавить один из трёх символов, что даёт слагаемое 3f(n – 1). Однако к строке с окончанием 'L' нельзя добавить 'R', поскольку тогда станция n – 1 направляла бы воду в обоих направлениях, что недопу - стимо. Поэтому все возможные строки длины n – 1 с окончанием \"LR\" необходимо исключить, а их количество равно f(n – 2). Таким образом, рекурсивное правило – f(n) = 3 f(n – 1) – f(n – 2). Вместе с начальными условиями функцию можно определить как 1, 1, ( ) 3, 2, 3 ( 1) ( 2), 2,n fn n fn fn n=  == −− − >  (9.6)если если еслиf(n) f(n – 1) f(n – 1) f(n – 1) f(n – 2)n – 2 n – 2 n – 2n – 2 n – 1 1 2 1 2 1 2 1 2 1 2'L''N' 'R' 'R' 'L'\n--- Страница 281 ---\n280  Глава 9. Взаимная рекурсия и можно легко реализовать, как показано в листинге 9.5. Наконец, f(n) = F(2n), где F – функция Фибоначчи (см. упражнение 9.4). Листинг 9.5. Функция с множественной рекурсией для решения задачи о станциях водоочистки 1 234567def water_multiple(n): if n == 1: return 1 elif n == 2: return 3 else: return 3 * water_multiple(n – 1) – water_multiple(n – 2) 9.4.2. Сброс воды в каждом городе Другой подход к решению задачи заключается в моделировании на- правлений передачи воды станциями. Существует 3 направления пере- дачи воды, которые мы обозначим следующими символами: '∨' – сброс в реку, '>' – переток вправо, '<' – переток влево. В этом случае мы должны подсчитать все строки длины n, которые не начинаются с '<', не закан- чиваются на '>' и не содержат подстрок \"><\". Для создания алгоритма со взаимной рекурсией будем использовать три похожие, но разные задачи. Рассмотрим правильные строки из трёх символов, начинающихся (слева направо) с непустой подстроки и за-канчивающихся подстрокой из n символов. В зависимости от началь- ного символа, предшествующего подстроке длины n (подстрока слева от символа неуместна), существует 3 сценария (подзадачи), которые представлены схемами на рис. 9.8 и заключаются в определении ко-личества правильных подстрок в каждом из трёх случаев. Их решения обозначены функциями f ∨(n), f>(n) и f<(n), где нижний индекс указывает на символ, предшествующий подстроке длины n. Рис. 9.8. Три сценария взаимно-рекурсивного решения задачи о станциях водоочистки Очевидно, что размер задач – n, а их начальные условия выполняются при n = 1. В частности, f∨(1) = f<(1) = 2, так как существует всего два вари- f∨(n) f>(n) f<(n) n n n\n--- Страница 282 ---\n9.4. Задача о станциях водоочистки  281 анта ('∨' и '<') для самого последнего символа. Наоборот, f>(1) = 1, так как последняя станция очистки, получившая воду от своего соседа, должна сбросить её в реку. На рис. 9.9 приведены декомпозиции задач. Для f∨(n) и f<(n) первый символ подстроки длины n может быть любым. Поэтому общее коли- чество правильных строк длины n равно количеству правильных строк длины n – 1 для каждого из трёх первых символов. Рис. 9.9. Декомпозиции трех под- задач для взаимно-рекурсивного решения задачи о станциях водо- очистки f<(n)n – 1 f∨(n – 1) + f>(n – 1) + f>(n – 1) f>(n)f∨(n) n – 1 n – 1 f∨(n – 1) + f>(n – 1) + f>(n – 1)f∨(n – 1) + f>(n – 1) …   … …   … …   … …   … …   … …   … …   ……   …        \n--- Страница 283 ---\n282  Глава 9. Взаимная рекурсия Таким образом, в правой части рекурсивного правила для обеих функций будет формула f∨(n – 1) + f>(n – 1) + f<(n – 1). Кроме того, по- скольку их начальные условия тоже одинаковы, одинаковыми будут и сами функции. В результате мы имеем: 2, 1,() ()( 1) ( 1) ( 1), 1.nfn fnfn fn fn n∨< ∨><= == −+ −+ − >  (9.7) Наоборот, для f>(n) символ '<' не может быть первым в строке длины n. Поэтому в правой части её рекурсивного правила будет f∨(n – 1) + f>(n – 1). А сама функция вместе с ее начальным условием будет такой: 1, 1,()( 1) ( 1), 1.nfnfn fn n> ∨>= =−+ − >  (9.8) Итак, решение f(n) исходной задачи можно выразить двояко: f(n) = f∨(n – 1) + f>(n – 1) = f>(n). Первое равенство говорит о том, что первым символом строки может быть или '∨', или '<', и в этом случае мы должны сложить число правиль-ных строк длины n – 1, начинающихся с этого символа. Второе равен- ство следует из рекурсивного правила для f >(n). Наконец, можно пока- зать, что f∨(n) = f<(n) = F(2n + 1), а f>(n) = F(2n), где F – функция Фибоначчи (см. упражнение 9.5). 9.5. Циклические ханойские башни Следующая задача является разновидностью классической задачи «Ха-нойская башня» (см. раздел 7.2) и известна как «циклические» ханойс - кие башни. Несмотря на то что вводимое в ней ограничение усложняет задачу, принцип её решения и само решение (то есть перемещение от - дельных дисков или стопок из нескольких дисков) аналогичны. Таким образом, она представляет собой превосходное дополнение к ориги-нальной задаче, которое поможет читателю лучше понять её решение. Кроме того, она подтверждает важность рекурсии для решения задач вообще, так как (насколько известно автору) единственный из итераци-онных алгоритмов решения этой задачи просто моделирует её рекур-сивное решение, используя стек (см. раздел 10.3). Правила циклических ханойских башен идентичны правилам ориги- нальной задачи с той лишь разницей, что перемещать отдельные диски если если если если\n--- Страница 284 ---\n9.5. Циклические ханойские башни  283 можно только циклически (по кругу). Например, если A, B и C обознача- ют три стержня, то диск можно перемещать только с A на B, с B на C или с C на A. Задача становится наглядней, если стержни расположить в виде треугольника и разрешить перемещения дисков только по кругу в опре- деленном направлении, скажем по часовой стрелке, как на рис. 9.10. Рис. 9.10. Циклические ханойские башни Задача заключается в том, чтобы переместить всю стопку из n дис - ков с исходного (начального) стержня, скажем A, на другой заданный (конечный) стержень, используя третий вспомогательный (промежу - точный) стержень. Обратите внимание, что условие задачи не огова-ривает, какой именно стержень, B или C, должен быть конечным. Не- смотря на то что мы условились перемещать диски по часовой стрелке, важно понимать, что на самом деле можно написать разные процедуры для перемещения всей стопки из n дисков как по часовой стрелке, так и против часовой стрелки. Иными словами, задача о циклических ха-нойских башнях состоит из двух разных задач: перемещение n дисков по часовой стрелке или против часовой стрелки, но при этом каждый отдельный диск должен перемещаться по кругу только в одном направ-лении. Обе задачи изображены на рис. 9.11, где O, D и A обозначают соответственно начальный, конечный и вспомогательный стержни. За-метьте, что конечный и вспомогательный стержни меняются местами в зависимости от варианта задачи. Понятно, что размер обеих задач – n. Первое начальное условие име- ет место при n = 1. Это тривиальное решение предполагает одно пере- мещение единственного диска по часовой стрелке или два перемеще-ния того же диска против часовой стрелки. Второе начальное условие, подобно функции towers_of_Hanoi_alt в листинге 7.3, предупреждает какие-либо действия при n = 0.Стержень A Стержень BСтержень C\n--- Страница 285 ---\n284  Глава 9. Взаимная рекурсия Рис. 9.11. Две разновидности задачи о циклических ханойских башнях Для вывода рекурсивных условий можно применить декомпозицию задачи с уменьшением её размера на 1, что приведёт к трём действиям, лежащим в основе рекурсивных методов её решения (см. рис. 9.12). Во-первых, согласно правилам задачи, отдельный диск можно перемес - тить по часовой стрелке. Во-вторых, согласно индукции, стопку из n – 1 дисков можно перемест ить либо по часовой стрелке, либо против неё. На рис. 9.13 показаны шаги решения задачи по перемещению стопки из n дисков по часовой стрелке с начального стержня на конечный. Сна- чала нужно переместить n – 1 дисков на вспомогательный стержень, так как иначе невозможно переместить наибольший диск. Добиться этого можно перемещением стопки из n – 1 дисков против часовой стрелки с начального стержня на вспомогательный при посредстве конечного стержня (шаг 1). На следующем, основном шаге 2 на конечный стер-жень переносится наибольший диск. А затем n – 1 дисков переносятся со вспомогательного стержня на конечный, что также осуществляется их перемещением против часовой стрелки (шаг 3). Процедура clockwise в листинге 9.6 реализует этот метод. Ход рас - суждений при решении данной задачи очень похож на тот, что приме-нялся при решении оригинальной задачи о ханойских башнях. Таким образом, алгоритм почти совпадает с кодом листинга 7.3, за исключе-нием того, что рекурсивные вызовы обращаются ко второму методу. Заметим, что при программировании алгоритма в целом мы предпола-Переместить n дисков по часовой стрелке Переместить n дисков против часовой стрелкиAO D AO D AO D AO D\n--- Страница 286 ---\n9.5. Циклические ханойские башни  285 гаем, что перемещения против часовой стрелки работают правильно, даже если мы не написали для них ни одной строчки кода. Рис. 9.12. Три действия рекурсивных методов, решающих задачу о циклических ханойских башнях Листинг 9.6. Взаимно-рекурсивные процедуры задачи о циклических ханойских башнях 1 234567891011121314def clockwise(n, o, d, a): if n > 0: counterclockwise(n – 1, o, a, d) print('Move disk', n, 'from rod', o, 'to rod', d) counterclockwise(n – 1, a, d, o) def counterclockwise(n, o, d, a): if n > 0: counterclockwise(n – 1, o, d, a) print('Move disk', n, 'from rod', o, 'to rod', d) clockwise(n – 1, d, o, a) print('Move disk', n, 'from rod', a, 'to rod', d) counterclockwise(n – 1, o, d, a)AO DAO D AO D Переместить n – 1 дисков по часовой стрелкеПереместить n – 1 дисков против часовой стрелкиПереместить один диск Основное действие Решение подзадачn – 1\n--- Страница 287 ---\n286  Глава 9. Взаимная рекурсия Рис. 9.13. Действия по перемещению n дисков по часовой стрелке Наконец, на рис. 9.14 показаны действия по перемещению стоп- ки из n дисков против часовой стрелки, осуществляемые процедурой counterclockwise из листинга 9.6. В этом случае требуется больше работы, так как для воспроизведения единственного перемещения наибольшего диска по часовой стрелке здесь необходимо два его перемещения против часовой стрелки. Пер-вый шаг с рекурсивным вызовом – это n – 1 перемещений против ча- совой стрелки, обеспечивающих выполнение основного действия по переносу наибольшего диска на вспомогательный стержень (шаг 2). На шаге 3 стопка из n – 1 дисков возвращается по часовой стрелке на начальный стержень (вызывая уже реализованный метод clockwise ), чтобы тем самым подготовить второе основное действие на шаге 4 – перемещение наибольшего диска на конечный стержень. После этого выполняется заключительное действие – перемещение против часовой стрелки стопки из n – 1 дисков на конечный стержень.AO D Шаг 1n – 1 Исходное положение дисковn AO D AO D AO D Шаг 2 Шаг 3\n--- Страница 288 ---\n9.5. Циклические ханойские башни  287 Рис. 9.14. Действия по перемещению n дисков против часовой стрелкиAO D AO D AO D AO D AO D AO DШаг 1n – 1 Исходное положение дисковn Шаг 2 Шаг 3 Шаг 4 Шаг 5\n--- Страница 289 ---\n288  Глава 9. Взаимная рекурсия 9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска В информатике формальная грамматика – это набор порождающих пра- вил (production rules) или продукций, определяющих синтаксис фор- мального языка. Иными словами, она описывает, как соединять символы алфавита формального языка и составлять из них цепочки (слова, сим-волы, числа, знаки препинания и т. д.), называемые лексемами. В этом разделе мы рассмотрим более сложный пример, касающийся понятий, с которыми обычно знакомятся в расширенных курсах по компилято-рам и языковым процессорам. В частности, мы реализуем калькулятор, который получает на входе строку, представляющую собой математи-ческое выражение, и выдаёт на выходе её значение. Калькулятор дол-жен уметь складывать, вычитать, умножать и делить числа. Для прос - тоты числа будут целыми (хотя результат может быть вещественным числом). Кроме того, калькулятор должен уметь обрабатывать круглые скобки и унарную (одноместную) операцию минус, которой предшест - вует левая круглая скобка. Построение калькулятора состоит из двух этапов. На первом исход- ная строка s, представляющая собой математическое выражение, раз- бивается на последовательность лексем. На втором, согласно правилам формальной грамматики, выполняется разбор последовательности лексем методом рекурсивного спуска с целью вычисления исходного вы- ражения. На практике при решении таких задач применяются мощные инструментальные средства и библиотеки. Однако мы ограничимся низкоуровневыми алгоритмами, чтобы рассмотреть как можно больше примеров взаимной рекурсии. Естественно, полный обзор упомянутых тем и понятий выходит далеко за пределы настоящей книги. 9.6.1. Лексический анализ входной строки Цель этого этапа заключается в преобразовании входной строки, представляющей собой математическое выражение, в последователь-ность (список) лексем, которыми могут быть: • положительные или отрицательные целые числа: последователь-ность цифр, которой может предшествовать символ '–'; • операции: '+', '–', '*', '/'; • круглые скобки: '(' и ')'.\n--- Страница 290 ---\n9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска  289 Например, для входной строки \"–(–6 / 3) – (–(4)) + (18–2)\" алгоритм на первом этапе должен создать такой список: ['–', '(', '–6', '/', '3', ')', '–', ')', '–', '(', '4', ')', ')', '+', '(', '18', '–', '2', ')']. Прежде всего алгоритм игнорирует символы пробела и табуляции (пропуски). Кроме того, отметим, что знак минус может выполнять разные роли: помимо обозначения отрицательного числа, он может быть также либо одноместной, либо двуместной (бинарной) операци-ей. Например, алгоритм должен считать –6 единым числом и потому не должен создавать две отдельные лексемы для (унарного) минуса и числа 6. Пример также показывает, что унарный минус может по-явиться в начале входной последовательности или между двумя ле- выми скобками. Взаимно-рекурсивные функции, которые мы вскоре рассмотрим, возникают из-за необходимости обработки унарных ми- нусов в математических выражениях. Наконец, отметим, что лексе-мой может быть число, состоящее из нескольких цифр, возможно, со знаком минус. Для решения этой задачи воспользуемся двумя похожими методами tokenize_unary и tokenize из листинга 9.7, которые получают на входе строку s длины n и возвращают список лексем. Разница между ними лишь в том, что первый предполагает, что первым непустым симво-лом s может быть унарный минус. Оба метода посредством функции is_number из листинга 9.8 проверяют также, является ли строка целым числом. Размер задач – длина входной строки (n). Существует несколько на- чальных условий. Если строка пуста или содержит лишь пропуски, ме-тоды должны вернуть пустой список. Кроме того, если строка состоит из единственного непустого символа (предыдущее условие уже «отсекло» все пропуски), то начальное условие должно вернуть список, содержа-щий этот символ. Оба этих условия гарантируют, что в рекурсивных ус - ловиях входная строка будет содержать не менее двух символов. Следо-вательно, мы можем спокойно обращаться ко второму элементу строки, не опасаясь выхода её индекса за границы строки. Рекурсивные условия этой задачи гораздо сложнее всех других, так как есть несколько моментов, которые следует принять во внимание. Во-первых, если первый элемент входной строки – пропуск, то им нуж - но пренебречь. В этом случае оба метода, вызвав самих себя, должны вернуть лишь остаток входной строки (s 1…n–1).\n--- Страница 291 ---\n290  Глава 9. Взаимная рекурсия Листинг 9.7. Взаимно-рекурсивные функции лексического анализа математического выражения 1 23456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def tokenize_unary(s): if not s or s == ' ' or s == '\\t': return [] elif len(s) == 1: return [s] elif s[0] == ' ' or s[0] == '\\t': return tokenize_unary(s[1:]) elif s[0].isdigit() or s[0] == '–': if s[0].isdigit() and (s[1] == ' ' or s[1] == '\\t'): return [s[0]] + tokenize(s[2:]) else: t = tokenize(s[1:]) if t == []: return [s[0]] else: if is_number(t[0]): t[0] = s[0] + t[0] return t else: return [s[0]] + t else: if s[0] == '(': t = tokenize_unary(s[1:]) else: t = tokenize(s[1:]) return [s[0]] + t def tokenize(s): if not s or s == ' ' or s == '\\t': return [] elif len(s) == 1: return [s] elif s[0] == ' ' or s[0] == '\\t': return tokenize(s[1:]) elif s[0].isdigit(): if s[1] == ' ' or s[1] == '\\t': return [s[0]] + tokenize(s[2:]) else: t = tokenize(s[1:]) if t == []: return [s[0]] else: if is_number(t[0]): t[0] = s[0] + t[0] return t else: return [s[0]] + t else: if s[0] == '(': t = tokenize_unary(s[1:]) else: t = tokenize(s[1:]) return [s[0]] + t\n--- Страница 292 ---\n9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска  291 Листинг 9.8. Представляет ли собой строка число? 1 23456def is_number(s): try: float(s) return True exept ValueError: return False 9.6.1.1. Функция tokenize() До рассмотрения прочих рекурсивных условий мы остановимся сна- чала на более простом лексическом анализе. Следующее рекурсивное условие выполняется, если первый символ входной строки (s 0) являет - ся цифрой (строка 36), которая, естественно, относится к некоторому числу. В этом случае алгоритм должен выполнить разные действия в зависимости от следующего символа (s 1) или первой лексемы остальной части строки (s1…n–1). Во-первых, если s1 – пропуск, то s0 – лексема. Значит, метод должен вернуть список, первый элемент которого – s0, плюс список лексем остатка строки s2…n–1. Это можно представить следующей схемой: В противном случае метод посредством рекурсивного вызова ищет лексемы в s1…n –1 и сохраняет их в списке t (строка 40). Если этот спи- сок пуст, то метод просто вернёт лексему, соответствующую s0 (стро- ка 42). Иначе последующее действие будет зависеть от того, является или нет первая лексема s 1 n–1 числом. Рассмотрим следующую част - ную схему:объединить с ['5']Входы Результаты \"+ 3∗2\"\"5 + 3 ∗2\" ['5', '+', '3', '∗', '2'] ['+', '3', '∗', '2']\n--- Страница 293 ---\n292  Глава 9. Взаимная рекурсия Поскольку первая лексема t ('+') не является числом, алгоритм должен присоединить список, содержащий s0, к списку t (строка 48). Иначе, если первая лексема t – число, метод должен добавить сим- вол s0 к первой лексеме (строки 45 и 46). Следующая схема иллюстри- рует это: Заметьте, что таким образом алгоритм собирает из отдельных цифр числовую лексему. Наконец, есть еще два рекурсивных условия, когда первый элемент строки не является цифрой. Поскольку функция уже проверила, что символ не является пропуском (строка 34), он может быть только лексе-мой – операцией или круглой скобкой. Таким образом, метод добавит эту лексему к результату решения задачи для s 1…n–1. Однако если сим- вол s0 является левой круглой скобкой, то первой лексемой оставшейся подстроки может быть унарный минус, и в этом случае метод должен вызвать функцию tokenize_unary (строка 51). В любом другом случае унарный минус не может быть первой лексемой, и метод может вызвать просто сам себя (строка 53). 9.6.1.2. Функция tokenize_unary() Функция tokenize_unary очень похожа на tokenize . Но есть два важных отличия. Во-первых, если в первой позиции строки появляет - ся символ пропуска, то функция вызывает саму себя (строка 7), так как вслед за первой лексемой строки может оказаться унарный минус.объединить с ['5']Входы Результаты \"+ 3∗2\"\"5 + 3 ∗2\" ['5', '+', '3', '∗', '2'] ['+', '3', '∗', '2'] Входы Результаты \"87 + 3 ∗2\"\"587 + 3 ∗2\" ['587', '+', '3', '∗', '2'] ['87', '+', '3', '∗', '2']добавить '5' до '87'\n--- Страница 294 ---\n9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска  293 Во-вторых, если первый символ – знак минус, то он может быть толь- ко унарной операцией. А если он предшествует числу, то он становится частью этого числа, как будто бы это была цифра. Рассмотрим следую-щую схему: Отметим, что '–' добавляется к '5', чтобы получить лексему '–5'. По- этому в строке 8 проверяется, что s0 – знак минус, а строки 12–20 иден- тичны строкам 40–48. Наконец, между строками 9 и 37 тоже есть тонкое различие. Если вслед за цифрой идёт символ пропуска, то эта цифра становится лексе-мой (строки 9, 10). Если же после унарного минуса идут пропуски, то это вовсе не значит, что он будет лексемой. Например, для строки \"–6\" алго-ритм должен вернуть именно лексему '–6', а не две лексемы для каждого непустого символа. Таким образом, первое условие в строке 9 до пере-хода к строке 10, где создаётся лексема, проверяет, что символ – имен-но цифра. Наконец, при обработке строк, подобных \"–6\", рекурсивный вызов в строке 12, игнорируя пропуски, возвращает лексему '6'. Таким образом, код в строке 17 продолжает работу и правильно применяет унарный минус к 6, как будто бы он является цифрой. 9.6.2. Синтаксический анализатор на основе рекурсивного спуска Создав список лексем, мы готовы обработать его, чтобы вычислить исходное математическое выражение. Конечно, лексемы не могут по-являться в случайном порядке (например, в списке лексем не может быть двух подряд операций или чисел, незакрытых скобок и т. д.). Они должны подчиняться порождающим правилам формальной грамма-тики, описывающим правильный порядок следования лексем. Грубо говоря, порождающие правила нужны для того, чтобы сгруппировать лексемы или разложить список лексем на фрагменты, соответствующие определённым грамматическим категориям, и выстроить их иерархию. Входы Результаты \"5 + 3 ∗2\"\"–5 + 3 ∗2\" ['–5', '+', '3', '∗', '2'] ['5', '+', '3', '∗', '2']добавить '–' до '5'\n--- Страница 295 ---\n294  Глава 9. Взаимная рекурсия Для нашего калькулятора такими категориями будут «Выражение» (Expression), «Слагаемое» (Term), «Множитель» (Factor) и несколько дру - гих, которые мы вкратце опишем. Чтобы понять эту идею, рассмотрим следующее математическое выражение: –(2 + 3) + 2 ∗ 8 / 4 – 3 ∗ (4 + 2) / 6 + 7 – (–(2 + 8) ∗ 3). На рис. 9.15 показано, что оно состоит из пяти слагаемых, связанных бинарными операциями плюс или минус. Затем эти слагаемые могут быть разбиты на множители, связанные операциями '∗' или '/'. На ри-сунке показано только разбиение слагаемого 3 ∗ (4 + 2) / 6 на три мно- жителя. Важно отметить, что второй множитель не является слагаемым исходного выражения, так как он заключён в круглые скобки. Кроме того, первый минус в выражении – унарный и, конечно же, не разде-ляет слагаемые. Унарный минус может также оказаться между двумя левыми круглыми скобками, как в последнем слагаемом. Из рисунка видно, что множитель может быть выражением, заклю- чённым в круглые скобки («скобочным выражением»). Это значит, что определения выражения, слагаемого и множителя взаимно-рекурсив-ны. Обратите внимание, что выражение – это последовательность сла-гаемых, слагаемое – это ряд множителей, а множителем может быть или число, или другое скобочное выражение. Понятно, что и выражение, и слагаемое, и множитель могут быть просто числами. Рассмотрим определение выражения с рекурсивной точки зрения. Его «размером» можно считать количество его слагаемых. Его начальное условие выполняется, когда оно состоит из единственного слагаемого. Но если в нём более одного слагаемого, то размер такого рекурсивно-го объекта можно уменьшить на 1 и определить его как подвыражение плюс/минус слагаемое. Такое рекурсивное определение в точности со-ответствует порождающим правилам формальной грамматики. Если E обозначает выражение, а T – слагаемое, то порождающие правила для выражения могут быть записаны с использованием следующей нота-ции: E → T | E + T | E – T, (9.9) где знаки плюс и минус – это лексемы (бинарные операции) входного списка лексем, а вертикальная черта | (читается как «или») используется для краткости записи, чтобы одной строкой можно было определить несколько порождающих правил. Иными словами, (9.9) определяет три порождающих правила: E → T, E → E + T и E → E – T .\n--- Страница 296 ---\n9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска  295 Рис. 9.15. Декомпозиция математической формулы на категории «Выражение», «Слагаемое», «Множитель» или «Число»Выражение ВыражениеСлагаемое Слагаемое Слагаемое Слагаемое Слагаемое Слагаемое СлагаемоеМножитель Множитель Множитель Множитель Множитель Число Число–(2 + 3) 2 ∗ 8 / 4 3 ∗ (4 + 2) / 6 7 (–(2 + 8) ∗ 3) 3 6 (4 + 2) 4 4 42 2 24 + 2\n--- Страница 297 ---\n296  Глава 9. Взаимная рекурсия Однако для калькулятора, который мы хотим реализовать, не доста- точно лишь одного определения выражения (9.9). В частности, есть ещё одно начальное условие для слагаемого, которое начинается с унарно-го минуса, продолжается скобочным выражением и заканчивается не-сколькими множителями. Пусть I – это то же самое слагаемое, но с про- тивоположным (после применения унарной операции) знаком. Тогда порождающие правила для E будут такими: E → T | E + T | E – T | – I. (9.10) Таким же образом можно построить рекурсивные (или нерекурсив- ные) определения и для других элементов языка. Пусть F – множитель, P – скобочное выражение, а Number – числовая лексема, тогда полное описание грамматики, которую мы будем использовать: E → T | E + T | E – T | – I T → F | T ∗ F | T / F I → P | P ∗ T | P / T F → P | Number P → ( E ) где '+', '–', '∗', '/', '(' и ')' – возможные входные лексемы. Возможны и дру - гие формальные грамматики, но их разработка выходит далеко за рам-ки этой книги. Синтаксический анализатор на основе рекурсивного спуска – это программа проверки списка лексем на соответствие порождающим правилам грамматики, реализованным методами, которые обыч-но взаимно-рекурсивны. Обычно в таких анализаторах один метод соответст вует одному символу 2 в левой части порождающих правил, который предполагает, что входной список лексем имеет тип, опреде-лённый этим символом. Для нашего калькулятора мы построим син-таксический анализатор на основе рекурсивного спуска с пятью взаим-но-рекурсивными функциями для каждого из символов E, T, I, F и P (на рис. 9.16 приводятся взаимные вызовы методов). Например, соответ - ствующая E функция обрабатывает выражения в предположении, что входной список лексем – именно выражение. В следующих подразделах приводятся возможные реализации этих функций. 9.6.2.1. Функция expression() В листинге 9.9 приведена функция, обрабатывающая выражение (E). 2 Синтаксической переменной. – Прим. перев.\n--- Страница 298 ---\n9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска  297 Рис. 9.16. Взаимно-рекурсивные вызовы функций синтаксического анализатора на основе рекурсивного спуска Листинг 9.9. Синтаксический анализ математического выражения, состоящего из слагаемых 1 2 34 5 6 7 8 9 10 11 12 13 14 15 1617 18 19 20 21 22 23 24 2527 27def expression(tokens): if tokens == []: raise SyntaxError('Syntax error') else: par_counter = 0 i = len(tokens) – 1 while i > 0 and ((tokens[i] != '+' and tokens[i] != '–') or par_counter > 0): if tokens[i] == ')': par_counter = par_counter + 1 if tokens[i] == '(': par_counter = par_counter – 1 i = i – 1 if i == 0: if tokens[0] == '–': return – inverted_term(tokens[1:]) else: return term(tokens) else: e = expression(tokens[0:i]) t = term(tokens[i + 1:]) if tokens[i] == '+': return e + t else: return e – tE T P FI\n--- Страница 299 ---\n298  Глава 9. Взаимная рекурсия Сначала все функции синтаксического анализатора на основе рекур- сивного спуска проверяют список лексем на пустоту, сообщая при этом о синтаксической ошибке. В противном случае метод выбирает подхо-дящее порождающее правило в предположении, что входной список лексем представляет собой выражение. Варианты выбора приведены на рис. 9.17. Рис. 9.17. Возможные декомпозиции выражения С одной стороны, выражение может быть простым (T) или «перевёр- нутым» (I) слагаемым (варианты (a) и (b) на рисунке). С другой стороны, если выражение содержит более одного слагаемого, то оно разбивает - ся на меньшее подвыражение (E) плюс/минус слагаемое (T), как в слу - чае (c). Для распознавания этих вариантов функция использует цикл while (строки 7–14), который, начиная с конца списка (то есть справа налево), ищет первую бинарную операцию плюс или минус, находящуюся вне любых круглых скобок. Метод подсчитывает левые и правые круглые скобки в переменной-сумматоре par_counter . После выхода из цикла переменная i (i на рис. 9.17(c)) будет содержать либо индекс найден- ной лексемы '+' или '–', либо 0, если её нет (то есть выражение состоит Входное выражение (E ) Входное выражение (E ) Входное выражение (E )Слагаемое (T ) Перевёрнутое слагаемое (I ) Слагаемое (T ) Выражение (E )(a) (b) (c)3 ∗ +/–05 6 I or T/ 4 (2 2 ) +∗ 3( ) +/– +/– +/– T iT0\n--- Страница 300 ---\n9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска  299 из одного слагаемого). В этом случае может быть два варианта. Если первой лексемой входного списка является '–', то это – «перевёрнутое» слагаемое (I), и в этом случае функция должна вернуть результат мето-да inverted_term(tokens[1:]) с входным списком лексем без первой лексемы '–' (строка 18). В противном случае это будет обычное слагае-мое (T), и функция может вызвать term(tokens) в строке 20. Если же i больше 0, то tokens[i] будет бинарной операцией ('+' или '–'). В этом случае функция вычисляет выражение слева от этой лексемы, сохраняя результат в e, и слагаемое справа от неё, сохраняя результат в t. После чего метод в зависимости от операции token[i] возвращает сумму или разность e и t, которые, очевидно, вычисляются взаимно-рекурсивны- ми вызовами функций. 9.6.2.2. Функция term() В листинге 9.10 приведён код метода, который анализирует слага- емое, состоящее из множителей. Он очень похож на код листинга 9.9 тем, что в нём операции '∗ ' и '/' играют ту же роль, что операции '+' и '–' в функции expression() . Цикл while ищет индекс лексемы-операции над множителями вне круглых скобок. Если этот индекс i = 0 , слагае- мое не содержит лексемы-операции. Следовательно, оно может быть простым множителем (F ), и функция должна вызвать метод factor со всем входным списком лексем (строка 17). В противном случае алго-ритм выполнит бинарную операцию token[i] ('∗' или '/') над значени- ями её левого и правого операндов – слагаемого ( t) и множителя ( f) соответственно. 9.6.2.3. Функция inverted_term() В листинге 9.11 приведён код, анализирующий «перевёрнутое» сла- гаемое. Поскольку оно всегда начинается с открывающей круглой скоб-ки '(', то в случае её отсутствия функция выдаст сообщение о синтакси-ческой ошибке. В противном случае функция в цикле ищет индекс ( i) операции, которая следует непосредственно за закрывающей скобкой, соответствующей открывающей. Если i оказалась равной длине вход- ного списка лексем, то всё слагаемое целиком – это выражение в скоб-ках. Следовательно, функция должна вернуть результат вызова метода parenthesized_expression со всем входным списком (строка 17). Ина- че функция вычисляет выражение в первых круглых скобках (строка 19) и слагаемое из множителей до и после лексемы-операции с индексом i (строка 20), а затем применяет к ним эту операцию.\n--- Страница 301 ---\n300  Глава 9. Взаимная рекурсия 9.6.2.4. Функция factor() В листинге 9.12 приведён код, анализирующий множитель. Если входной список состоит из одной лексемы, то она может быть только числом, и функция возвращает её значение (строка 6). Если же лексема не является числом, то исходное выражение ошибочно. Наконец, если длина входного списка лексем больше 1, множитель может быть только выражением в скобках, и метод должен вызвать соответствующую ему функцию со всем входным списком (строка 10). Листинг 9.10. Синтаксический анализ слагаемого, состоящего из множителей 1 2345 6 7891011121314 15 1617181920212223 24def term(tokens): if tokens == []: raise SyntaxError('Syntax error') else: par_counter = 0 i = len(tokens) – 1 while i > 0 and ((tokens[i] != '*' and tokens[i] != '/') or par_counter > 0): if tokens[i] == ')': par_counter = par_counter + 1 if tokens[i] == '(': par_counter = par_counter – 1 i = i – 1 if i == 0: return factor(tokens) else: t = term(tokens[0:i]) f = factor(tokens[i + 1:]) if tokens[i] == '*': return t * f else: return t / f\n--- Страница 302 ---\n9.6. Грамматики и синтаксический анализатор на основе рекурсивного спуска  301 Листинг 9.11. Синтаксический анализ слагаемого, состоящего из множителей, первый из которых – скобочное выражение 1 23 4 5 6 7 8 9 10 1112 1314 1516 17 18 19 20 21 2223 24def inverted_term(tokens): if tokens == [] or tokens[0] != '(': raise SyntaxError('Syntax error') else: par_counter = 1 n = len(tokens) i = 1 while i < n and par_counter > 0: if tokens[i] == '(': par_counter = par_counter + 1 if tokens[i] == ')': par_counter = par_counter – 1 i = i + 1 if i == n: return parenthesized_expression(tokens) else: p = parenthesized_expression(tokens[0:i]) t = term(tokens[i + 1:]) if tokens[i] == '*': return p * t else: return p / t Листинг 9.12. Синтаксический анализ множителя 1 2 3 45 6 78 9 10def factor(tokens): if tokens == []: raise SyntaxError('Syntax error') elif len(tokens) == 1: if is_number(tokens[0]): return float(tokens[0]) else: raise SyntaxError('Syntax error') else: return parenthesized_expression(tokens)\n--- Страница 303 ---\n302  Глава 9. Взаимная рекурсия 9.6.2.5. Функция parenthesized_expression() Листинг 9.13 анализирует выражение, заключенное в скобки. Помимо проверки входного списка на пустоту, метод проверяет также наличие открывающей и закрывающей круглых скобок соответственно в начале и в конце выражения. Если ошибок нет, метод продолжает вычисление выражения в круглых скобках (строка 5) и возвращает результат. Таким образом, вызовом функции expression этот метод замыкает всю цепь взаимно-рекурсивных функций. Листинг 9.13. Синтаксический анализ скобочного выражения 1 2 3 45def parenthesized_expression(tokens): if tokens == [] or tokens[0] != '(' or tokens[–1] != ')': raise SyntaxError('Syntax error') else: return expression(tokens[1:–1]) И наконец, в листинге 9.14 приводится сам калькулятор в целом. Листинг 9.14. Основной код программы-калькулятора 12s = input('> ')print(expression(tokenize_unary(s))) 9.7. Упражнения Упражнение 9.1. Мэри и Джон решили сыграть в игру с n камешка- ми. Каждый игрок может удалить один, три или четыре камешка за раз. Выигрывает тот, кто забирает последние камешки. Каждый из игроков может победить, если при его ходе остаётся один, три или четыре ка-мешка. Если же осталось два камешка, то это приводит к проигрышу, так как можно забрать только один из двух камешков. Если камешков больше четырёх, Мэри решила, что будет забирать всякий раз по четыре камешка, если это возможно, тогда как Джон решил забирать по одному камешку. Реализуйте две взаимно-рекурсивные функции, моделирую-щие игру соперников и возвращающие 1 в случае победы Джона и 0 в случае победы Мэри. Чья стратегия лучше, если 1 ≤ n ≤ 100? Считайте, что начать игру может любой игрок.\n--- Страница 304 ---\n9.7. Упражнения  303 Упражнение 9.2. Рассмотрите функции A(n) и B(n), определённые в (3.38) и (3.39). Не решая рекуррентных соотношений, покажите, что A(n) + B(n) соответствует n-му числу Фибоначчи. Иными словами, не ис - пользуйте (3.40) или (3.41). Упражнение 9.3. Определите асимптотический порядок роста вре- мени выполнения A(n) и B(n) в формулах (3.38) и (3.39). Иными словами, выведите (3.40) и (3.41). Упражнение 9.4. Покажите, что f(n), описанная в (9.6), равна F(2n), где F – функция Фибоначчи. Докажите равносильность: (1) математи- ческой индукции и (2) решения рекуррентного соотношения в (9.6), по-лучив формулу, подобную (3.37). Упражнение 9.5. Выразите функции (9.7) и (9.8) через самих себя (без взаимной рекурсии). Упражнение 9.6. Пусть A(n) и B(n) обозначают количество переме- щений дисков, выполненных процедурами из листинга 9.6, соответст - венно по часовой стрелке и против часовой стрелки для циклической ханойской башни. Приведите рекурсивные формулы для A(n) и B(n) и выразите каждую из них через саму себя без взаимной рекурсии. Затем решите рекуррентные соотношения и укажите порядок их роста. Упражнение 9.7. Вспомните вариант задачи о «поперечных» ханой- ских башнях из упражнения 7.4. Разработайте взаимно-рекурсивные процедуры перемещения стопки из n дисков: 1) с левого/правого стержня на средний; 2) со среднего стержня на левый/правый. Опишите функции, определяющие количество перемещений отдель- ных дисков при перемещении стопки из n дисков. Упражнение 9.8. Следующая задача – один из вариантов известной головоломки Spin-out ®, изображённой на рис. 9.18. Изначально у нас есть n фигур (на рисунке их семь), «сидящих» ряд- ком на стержне внутри контейнера с узкой горловиной справа. Фигу - ры могут находиться в двух положениях: вертикальном – вершиной вверх (a) или горизонтальном – вершиной влево (b). Цель задачи – по-воротами фигур привести «запертую» исходную конфигурацию (a) к «незапертой» (b), чтобы извлечь стержень с фигурами через узкую гор-ловину контейнера. Заметьте, что в вертикальном положении фигура не проходит через горловину, не позволяя вынуть и стержень. За один\n--- Страница 305 ---\n304  Глава 9. Взаимная рекурсия ход можно повернуть только одну из фигур – из вертикального в гори- зонтальное положение или наоборот. Более того, их можно поворачи-вать только в «поворотном круге» (затемнённый круг левее горловины контейнера). На рис. 9.18(c) горизонтально можно повернуть лишь 4-ю фигуру. Кроме того, заметьте, что стенки контейнера не позволяют вы-двинуть стержень дальше вправо, так как фигура правее поворотного круга находится в вертикальном положении. Более того, если первую фигуру можно повернуть всегда, остальные можно повернуть только тогда, когда фигура правее неё находится в вертикальном положении, как в конфигурации (c). Таким образом, в конфигурации (d) 4-ю фигуру повернуть уже нельзя. Рис. 9.18. Правила головоломки Spin-out® Реализуйте две взаимно-рекурсивные процедуры, определяющие последовательность поворотов для n фигур для «отпирания» стержня, начиная с конфигурации (a) и заканчивая конфигурацией (b). (a) (b) (c) (d)3 3 3 31 1 1 12 2 2 24 5 6 74 5 6 74 5 6 7 4 5 6 7\n--- Страница 306 ---\n9.7. Упражнения  305 Подсказка: задавшись противоположной целью достичь из (b) кон- фигурации (a), используйте одну процедуру для «отпирания» первых n фигур на стержне, а вторую – для их «запирания». Затем определите функцию, определяющую количество поворотов для отпирания стерж - ня с n фигурами.",
      "debug": {
        "start_page": 269,
        "end_page": 306
      }
    },
    {
      "name": "Глава 10. Выполнение программы 306",
      "content": "--- Страница 307 --- (продолжение)\nГлава 10 Выполнение программы На самом деле вы не понимаете того, что понимае- те односторонне. – Марвин Минский В предыдущих главах на большом количестве примеров разнообразных вычислительных задач и основных типов рекурсии было показано, как нужно мыслить, чтобы создавать рекурсивные программы. Все алго-ритмы придерживались высокоуровневой декларативной парадигмы программирования, когда нужно было сосредоточиться на том, что вычисляет программа. Эта глава, напротив, представляет низкоуров-невые аспекты рекурсивных программ и раскрывает, как они работа- ют, вплоть до последовательности выполнения команд (то есть потока управления). В этой главе процесс выполнения рекурсивных программ рассматри- вается с разных точек зрения, некоторые из которых являются чисто «умозрительными». В ней вводится понятие дерева рекурсии – рас - пространённое графическое представление последовательности вызо-вов рекурсивных программ. Среди его достоинств – удобство отладки, помощь в вычислении функций, наглядность оценки вычислительной (временнóй и пространственной) сложности рекурсивных программ, а также покрытие всех рассмотренных ранее разновидностей рекурсии. Кроме этого, в главе описывается тесное взаимодействие рекурсивных программ со стеком – структурой данных, используемой ими при вызо-вах подпрограмм (методов). Заканчивается глава кратким введением в мемоизацию – стратегию, которая сокращает временнýю сложность рекурсивных методов путём\nГлава 10 Выполнение программы На самом деле вы не понимаете того, что понимае- те односторонне. – Марвин Минский В предыдущих главах на большом количестве примеров разнообразных вычислительных задач и основных типов рекурсии было показано, как нужно мыслить, чтобы создавать рекурсивные программы. Все алго-ритмы придерживались высокоуровневой декларативной парадигмы программирования, когда нужно было сосредоточиться на том, что вычисляет программа. Эта глава, напротив, представляет низкоуров-невые аспекты рекурсивных программ и раскрывает, как они работа- ют, вплоть до последовательности выполнения команд (то есть потока управления). В этой главе процесс выполнения рекурсивных программ рассматри- вается с разных точек зрения, некоторые из которых являются чисто «умозрительными». В ней вводится понятие дерева рекурсии – рас - пространённое графическое представление последовательности вызо-вов рекурсивных программ. Среди его достоинств – удобство отладки, помощь в вычислении функций, наглядность оценки вычислительной (временнóй и пространственной) сложности рекурсивных программ, а также покрытие всех рассмотренных ранее разновидностей рекурсии. Кроме этого, в главе описывается тесное взаимодействие рекурсивных программ со стеком – структурой данных, используемой ими при вызо-вах подпрограмм (методов). Заканчивается глава кратким введением в мемоизацию – стратегию, которая сокращает временнýю сложность рекурсивных методов путём\n--- Страница 308 ---\nВыполнение программы  307 сохранения результатов потенциально затратных вызовов. Мемоиза- ция тесно связана с таким важным методом проектирования алгорит - мов, как динамическое программирование. Независимо от того, рекурсивны или нет выполняемые програм- мой методы, важно понимать правила их вызова. Рассмотрим код из листинга 10.1 для вычисления косинуса угла между двумя n-мерными векторами согласно определениям (3.14), (3.15) и (3.16). Листинг 10.1. Методы для вычисления косинуса угла между двумя n-мерными векторами 1 2 3 45 6 78 9 1011 12 1314 15 1617 18 1920 21 22import math def dot_product(u, v): s = 0 for i in range(0, len(u)): s = s + u[i] * v[i] return s def norm_Euclidean(v): return math.sqrt(dot_product(v, v)) def cosine(u, v): return dot_product(u, v) / norm_Euclidean(u) / norm_Euclidean(v) # Example a = [2, 1, 1] b = [1, 0, 1] print(cosine(a, b)) На рис. 10.1 приводится цепочка (нерекурсивных) вызовов подпро- грамм (тёмные стрелки) и возвратов из них (светлые стрелки) при вы- полнении этого кода. Блоки в правых верхних углах функций содержат конкретные параметры, приводящие к конечному результату √3 /2. Чис - ла в кружочках обозначают последовательность выполнения действий. Очевидно, но крайне важно то, что полное завершение подпрограммы невозможно до полного завершения всех вызвавших её методов.\n--- Страница 309 ---\n308  Глава 10. Выполнение программы Рис. 10.1. Цепочка вызовов-возвратов методов из листинга 10.1 То же самое – для рекурсивного кода. На рис. 10.2 приведена цепочка рекурсивных вызовов функции sum_first_naturals из листинга 1.1 для начального значения n = 4. При выполнении рекурсивного условия ме- тод вызывает сам себя (уменьшая исходное значение на 1) и снова пере- ходит к первой своей инструкции. Крайне важно понимать, что процесс a = [2, 1, 1]b = [1, 0, 1] print ( cosine(a, b) √3/2) def cosine(u, v): return dot_product(u, v) norm_Euclidean(u) norm_Euclidean(v) u = [2, 1, 1] v = [1, 0, 1] u = [2, 1, 1] v = [1, 0, 1] def dot_product(u, v): s = 0 for i in range(0, len(u)): s = s + u[i] * v[i] return s def norm_Euclidean(v): return math.sqrt ( dot_product(v, v) ) )def norm_Euclidean(v): return math.sqrt ( dot_product(v, v)def dot_product(u, v): s = 0 for i in range(0, len(u)): s = s + u[i] * v[i] return s def dot_product(u, v): s = 0 for i in range(0, len(u)): s = s + u[i] * v[i] return su = [2, 1, 1] v = [2, 1, 1] u = [1, 0, 1] v = [1, 0, 1]v = [2, 1, 1] v = [1, 0, 1]12 1 2 3 3 4 5 6 6 8 9 2 107 11 √6 √2\n--- Страница 310 ---\n10.1. Поток управления между подпрограммами  309 не завершается с выполнением начального условия (n = 1). Ведь до это- го метод уже вызывал себя несколько раз, поэтому программа должна выполняться до полного завершения каждого из этих рекурсивных вы-зовов. Непонимание этой последней цепочки действий, известной под названием «пассивный поток» (passive flow), – одна из главных причин искажённого представления о рекурсии. Наконец, вся цепочка действий алгоритма может быть проверена построчно шаг за шагом методами отладчика. Такие инструментальные средства доступны в большинстве интегрированных сред разработки. 10.1. Поток управления между подпрограммами Код в листинге 10.2 включает две процедуры с входным парамет ром- строкой, которые не возвращают значений, а просто выводят символы на экран. Они очень похожи и отличаются лишь порядком следования двух своих команд в рекурсивном условии, которое выполняется при непустой входной строке. Первая из них сначала выводит символ, а за-тем вызывает саму себя, тогда как вторая сначала вызывает себя, а затем выводит символ. Загадочные имена этим методам присвоены для того, чтобы скрыть суть их действий. Читателю предлагается разобраться в этом самостоятельно, прежде чем продолжить чтение. Листинг 10.2. Похожие рекурсивные методы. Что они делают? 1 23 4 567 8 9101112 13 141516def mystery_method_1(s): if s: print(s[0], end='') mystery_method_1(s[1:]) def mystery_method_2(s): if s: mystery_method_2(s[1:]) print(s[0], end='') s = 'Word' mystery_method_1(s)print()mystery_method_2(s)\n--- Страница 311 ---\n310  Глава 10. Выполнение программы Рис. 10.2. Цепочка вызовов-возвратов для sum_first_naturals(4) Подобно примерам на рис. 10.1 и 10.2, разберём эти процедуры, про- следив цепочку выполняемых ими действий. На рис. 10.3 приведена це- почка действий mystery_method_1 для входной строки s = 'Word' , где в полях рядом со стрелками показывается состояние экрана при вызове и по завершении рекурсивной процедуры. print ( sum_first_naturals(4) ) def sum_first_naturals(n): if n == 1: return 1 else: sum_first_naturals(n – 1) sum_first_naturals(n – 1) sum_first_naturals(n – 1)def sum_first_naturals(n): if n == 1: return 1 else: def sum_first_naturals(n): if n == 1: return 1 else: def sum_first_naturals(n): if n == 1: return 1 else: return sum_first_naturals(n – 1) + nreturn return return+ n + n + n n = 11 2 33 456 68 10 7 1n = 2n = 3n = 4\n--- Страница 312 ---\n10.1. Поток управления между подпрограммами  311 Рис. 10.3. Цепочка вызовов-возвратов для рекурсивной процедуры mystery_method_1(\"Word\") При первом вызове метода экран пуст. Затем, поскольку s не пустая строка, выводится её первый символ ( 'W') и вызывается тот же метод mystery_method_1('Word') mystery_method_1(s[1:]) mystery_method_1(s[1:]) mystery_method_1(s[1:]) mystery_method_1(s[1:])def mystery_method_1(s): if s: print(s[0], end='') def mystery_method_1(s): if s: print(s[0], end='') def mystery_method_1(s): if s: print(s[0], end='') def mystery_method_1(s): if s: print(s[0], end='') def mystery_method_1(s): if s: print(s[0], end='') mystery_method_1(s[1:])s = 'Word' s = 'ord' s = 'rd' s = 'd' s = ''Word Word Word Word Word WordWorWoW\n--- Страница 313 ---\n312  Глава 10. Выполнение программы с остатком строки ( 'ord' ). Эти два шага повторяются, пока аргумент метода не станет пустой строкой. Достигнув этого начального условия, программа выведет на экран символ за символом всю исходную строку 'Word' . После чего метод завершается и возвращает управление преды- дущему вызову, который также завершается. Это повторяется, пока не завершится каждый из вызовов. В итоге данная процедура просто вы-водит на экран исходную строку. В заключение заметьте, что в методе реализована хвостовая рекурсия, так как рекурсивный вызов – это по-следняя операция в рекурсивном условии. Таким образом, алгоритм ре-шает задачу при выполнении начального условия. Отметьте, что экран не меняется по завершении рекурсивных вызовов. Напротив, метод mystery_method_2 тоже выводит на экран исходную строку, но в обратном порядке. На рис. 10.4 приведена цепочка вызовов метода. В данном случае метод – линейно-рекурсивный, что подразу - мевает выполнение действия (вывода первого символа исходной стро-ки) по завершении рекурсивного вызова. По достижении начального условия алгоритм ничего не выводит, так как ни одна из команд вывода на экран не выполняется. То есть началь-ное условие не выполняет никаких действий. Однако по завершении метода управление передаётся первой после рекурсивного вызова ин-струкции, которая является выводом на экран и, в конце концов, выво-дит один за другим символы исходной строки, но в обратном порядке. 10.2. Деревья рекурсии Наиболее простой и наглядный способ представления цепочки рекур-сивных вызовов – дерево рекурсии (recursion tree). Его узлы соответству - ют вызовам метода с определенными параметрами. Если какой-то ме-тод вызывает другие подпрограммы, то его узел становится родителем узлов-вызовов соответствующих подпрограмм. Таким образом, листья дерева соответствуют начальным условиям, а внутренние узлы – рекур-сивным условиям. Кроме того, дочерние узлы родителя следуют слева направо в том же порядке, в котором они вызываются. Таким образом, прямой (preorder) обход дерева рекурсии задаёт последовательность вызовов подпрограмм, тогда как обратный (postorder) обход – после-довательность возвратов из рекурсивных подпрограмм (см. раздел 7.3). Как правило, параметры вызова отображаются рядом с соответству - ющим узлом. На рис. 10.5(a) приведено дерево рекурсии для вызова sum_first_naturals(4) , где число в каждом узле – это значение n для данного рекурсивного вызова.\n--- Страница 314 ---\n10.2. Деревья рекурсии  313 Рис. 10.4. Цепочка вызовов-возвратов для процедуры mystery_method_2(\"Word\") Хотя дерево является неориентированным, важно помнить, что про- цесс вычисления sum_first_naturals(4) сначала спускается вниз по mystery_method_2('Word') mystery_method_2(s[1:]) mystery_method_2(s[1:]) mystery_method_2(s[1:]) mystery_method_2(s[1:])def mystery_method_2(s): if s: print(s[0], end='') def mystery_method_2(s): if s: mystery_method_2(s[1:]) print(s[0], end='')s = 'Word' s = 'ord' s = 'rd' s = 'd' s = ''drdroW ddef mystery_method_2(s): if s: print(s[0], end='') def mystery_method_2(s): if s: print(s[0], end='') def mystery_method_2(s): if s: print(s[0], end='')dro\n--- Страница 315 ---\n314  Глава 10. Выполнение программы дереву (рекурсивных вызовов) к начальному условию, а затем подни- мается к корню вверх по дереву (рекурсивных возвратов). Поэтому де-рево рекурсии можно снабдить стрелками, обозначающими вызовы и возвраты, как показано на рис. 10.5(b). Наконец, по рисунку видно, что sum_first_naturals(4) возвращает своё значение методу, вызвавшему её (то есть на экран). Рис. 10.5. Деревья рекурсии для sum_first_naturals(4) Деревья рекурсии можно дополнить значениями функций по завер- шении их вызовов. В частности, эти значения можно указать в узлах дерева активации (activation tree) вслед за параметрами метода, как показано на рис. 10.6 для вызова sum_first_naturals(4) . Деревья ак - тивации могут быть полезными для оценки и отладки методов, так как помогают отслеживать возвращаемые значения. Рис. 10.6. Дерево активации для sum_first_naturals(4) И линейно-рекурсивные методы, и методы с хвостовой рекурсией порождают деревья рекурсии линейной структуры, так как вызывают себя в рекурсивном условии лишь однажды. При этом если линейно-ре-курсивная функция при каждом вызове возвращает разные значения, (a) (b) Параметры Возвращаемое значение3 124 10 63 124 3 124 3 1\n--- Страница 316 ---\n10.2. Деревья рекурсии  315 то функция с хвостовой рекурсией всегда возвращает одно и то же значение. Рассмотрим функцию gcd1 из листинга для алгоритма Ев- клида (см. (5.6)). На рис. 10.7 приведено дерево активации для вызова gcd1(20,24) , из которого следует, что метод возвращает значение, по- лученное в начальном условии. Однако вычисление не заканчивается в начальном условии. Наоборот, каждый вызов обязан завершиться, причём с возвратом одного и того же значения (4). Аналогично, в при-ведённом выше примере (см. рис. 10.3) процедура с хвостовой рекур-сией mystery_method_1 приходит к своему результату по достижении начального условия. Рис. 10.7. Дерево активации для gcd1(20,24) Рассмотрим ещё одну функцию – функцию Фибоначчи из листин- га 1.3. На рис. 10.8(a) приведено её дерево рекурсии для вычисления 6-го числа Фибоначчи. Оно сложнее из-за множественной рекурсии. В частности, оно – двоичное, так как рекурсивное условие содержит два рекурсивных вызова. Дополнительно на рис. 10.8(b) приведено соответст вующее дерево активации. Результат метода – количество ли- стьев в этих деревьях, так как по определению метод возвращает 1 в начальном условии и сумму двух вызовов в рекурсивном условии. Та-ким образом, алгоритм просто подсчитывает, сколько раз он достигает начального условия.4 4 4 4 4 4 4 4 44 4 4 4 4 4 4 44 002020 2024 16 12 8\n--- Страница 317 ---\n316  Глава 10. Выполнение программы Рис. 10.8. Деревья рекурсии (a) и активации (b) для fibonacci(6) Наконец, если метод – это процедура, не возвращающая значения, то в дерево рекурсии рядом со стрелками, указывающими последователь- ность вызовов, можно включить дополнительную информацию о дейст - виях этой процедуры. Например, рис. 10.3 и 10.4 похожи на деревья рекурсии (где каждый узел включает ещё и исходный текст), но отобра-жают ещё и состояние экрана до и после вызова (см. упражнение 10.2). Деревья рекурсии можно генерировать и для других типов рекурсии. Во-первых, взаимно-рекурсивные методы тоже могут порождать де-ревь я рекурсии с линейной структурой. Самый простой пример – мето- ды из листинга 9.1, определяющие чётность неотрицательного целого числа. На рис. 10.9 приведено дерево активации для is_even(5) , чей ре- зультат – False. Обратите внимание, что методы относятся к хвостовой рекурсии. Таким образом, логическое значение, полученное в началь-ном условии, просто «всплывает» вверх по дереву в неизменном виде как результат вызовов функций.(a) (b)3 2 16 84 4 4 45 22 2 21 13 3 1 1 11 111 1 1 1 1 33 3 3 32 2 2 22 22 26 55\n--- Страница 318 ---\n10.2. Деревья рекурсии  317 Рис. 10.9. Дерево активации для взаимно-рекурсивных функций из листинга 9.1 Деревья рекурсии могут быть ещё сложнее, если алгоритм включает множественную рекурсию. На рис. 10.10 приводится пример дерева ре- курсии для взаимно-рекурсивных функций (1.17) и (1.18), где корневой узел соответствует A(6). Рис. 10.10. Дерево рекурсии для взаимно-рекурсивных функций (1.17) и (1.18) Создание дерева рекурсии для вложенных рекурсивных функций ещё сложнее, так как для определения параметров функции необхо-димо знать результаты всех рекурсивных вызовов. Таким образом, для вложенных рекурсивных функций больше подходят деревья активации, чем обычные деревья рекурсии. На рис. 10.11(a) приведено дерево ак - тивации вызова f(6, 0) функции (1.19), а на рис. 10.11(b) – детализация Чётное? Нечётное? 44 40false 3 125 false false false false falsen n n nA(n) ≡ B(n) ≡ 3 2 16 45 2 2 2 2 1 13 3 3 2 15 2 2 1 13 1 1 1 1 1 1 1\n--- Страница 319 ---\n318  Глава 10. Выполнение программы вложенных рекурсивных вызовов. Левое поддерево отвечает вызову f(4, 0), возвращающему некоторое значение x. Правое поддерево, отве- чающее вызову f(5, 0 + x), невозможно детализировать, пока не полу - чено конкретное значение x – результат вычисления f(4, 0) (левое под- дерево корневого узла). В данном случае f(4, 0) = x = 3, поэтому правое поддерево корневого узла соответствует вызову f(5, 3). Рис. 10.11. Дерево активации вложенной рекурсивной функции (1.19) 10.2.1. Анализ времени выполнения Число узлов (то есть рекурсивных вызовов) дерева рекурсии позволя- ет также оценить вычислительную сложность рекурсивного алгоритма. Если дерево линейно, то понятно, что время выполнения метода прямо пропорционально высоте дерева (стоимость узла умножается на высоту дерева). Но можно также определить количество узлов и для нелиней-ного дерева. Например, следующая функция определяет количество ре-курсивных вызовов в методе Фибоначчи:(a) (b)Начальное условие Рекурсивное условие8 44 1 11 1 1 1 1 1 11 33 3 3 3 22 2 222 2 26 5 58 013 30 26 70 0 00 0 0 08 8 8 1 + y ny 1 + y y y n – 1 n – 2 x + y xz z\n--- Страница 320 ---\n10.2. Деревья рекурсии  319 1, 1, ( ) 1, 2, 1 ( 1) ( 2), 3.n Qn n Qn Qn n=  == +− +− ≥ Она похожа на саму функцию Фибоначчи. Но, помимо подсчета листь- ев дерева рекурсии, она добавляет единицу для рекурсивного условия, чтобы учесть также и его внутренние рекурсивные вызовы. В этом слу - чае можно доказать, что Q(n) = 2 F(n) – 1, где F(n) – n-е число Фибоначчи. Согласно (3.37), количество (приблизительное) вызовов имеет значение порядка 1,618 n. Стоит заметить, что количество узлов полного двоич- ного дерева высоты n можно оценить как 2n. Двоичное дерево рекур- сии для чисел Фибоначчи содержит несколько меньше узлов, поскольку оно – неполное. Таким образом, вполне объяснимо, что основание со-ответствующей экспоненты (1,618…) меньше двух. Кроме того, деревья рекурсии могут использоваться для оценки вре- мени выполнения алгоритмов типа «разделяй и властвуй» с помощью подхода, называемого «метод дерева», который связан с методом рас - ширения и основной теоремой. Идея заключается в формировании другого дерева рекурсии, узлы которого включают стоимость операций, выполняемых в пределах вызова рекурсивного метода, за исключением предстоящих вызовов. На рис. 10.12 приводится такое дерево для ре-куррентного соотношения T(n) = 2T(n/2) + n 2. Рис. 10.12. Дерево рекурсии для рекуррентного соотношения T(n) = 2T(n/2) + n2 Первый вызов метода требует n2 операций плюс стоимость 2T(n/2) будущих вызовов. Таким образом, первый узел просто содержит n2. Узлы второго уровня дерева содержат количество операций, соответ - ствующих T(n/2), то есть (n/2)2 = n2/4. Поскольку на этом уровне – два узла, общая его стоимость – n2/2. То же рассуждение применимо и для если если если n2 (n/2)2(n/2)2 (n/4)2(n/4)2(n/4)2(n/4)2 (n/8)2(n/8)2(n/8)2(n/8)2(n/8)2(n/8)2(n/8)2(n/8)2n2 n2/2 n2/4 n2/8высота = log2n\n--- Страница 321 ---\n320  Глава 10. Выполнение программы каждого из последующих уровней, суммарная стоимость которых ука- зана на рисунке справа от соответствующего уровня, а их сумма даст в итоге стоимость алгоритма. Если предположить, что n – степень двух и начальное условие выполняется при n = 1, то высота дерева будет log 2n. В этом примере, предположив, что T(1) = 1 (последний уровень будет состоять из n слагаемых, равных 1) – окончательное нерекурсивное вы- ражение, рекуррентное соотношение можно будет выразить так: 2log 22 2 0( ) 1/2 (2 1/ ) 2n i iTn n n n n n == = −=−∑ . 10.3. Программный стек Рекурсия очень полезна и удобна, когда для реализации алгоритма тре-буется стек – линейная структура данных, моделирующая кучу объек - тов, которые могут добавляться или удаляться в строго определённом порядке. А именно: при добавлении элемент помещается на вершину стека, тогда как единственным элементом, который можно удалить из стека, является тот, что находится на вершине стека, как показано на рис. 10.13(a). Поэтому такая структура данных называется магазином или структурой, отвечающей правилу LIFO 1. Операции добавления и удаления элементов стека, в нашем случае растущего вниз, называются push (втолкнуть) и pop (вытолкнуть) соответственно. В отличие от сте- ка, родственная ему структура данных очередь (queue) отвечает прави- лу FIFO 2, моделируя очередь ожидания, как показано на рис. 10.13(b). Новый элемент добавляется в конец очереди, а удаляется из неё самый первый элемент. Эти операции обозначаются как enqueue (в очередь) и dequeue (из очереди) соответственно. На нижнем уровне исполнения кода вызовы подпрограмм и воз- враты из них реализуются в памяти посредством специального стека, именуемого программным стеком (program stack), управляющим стеком (control stack), стеком вызовов (call stack) или просто стеком. И хотя он скрыт в языках программирования высокого уровня, представлять его устройство чрезвычайно важно для понимания механизма рекурсии. 10.3.1. Стековые кадры Каждый вызов подпрограммы в первую очередь создает в стеке сте- ковый кадр (stack frame), или фрейм, – блок данных, размещаемый на 1 Last In, First Out – последним вошёл, первым вышел. – Прим. перев. 2 First In, First Out – первым вошёл, первым вышел. – Прим. перев.\n--- Страница 322 ---\n10.3. Программный стек  321 вершине программного стека. Помимо адреса возврата, он содержит, в частности, параметры и локальные переменные метода или ссылки на них, а также другую низкоуровневую информацию. Адрес возвра-та указывает на машинную команду, которой метод должен передать управление по завершении своих действий. По завершении метода его запись активации удаляется из программного стека, а освобождае-мая память может использоваться для вызовов других методов. Таким образом, в любой момент программный стек содержит информацию только об «активных» подпрограммах, то есть вызванных, но еще не за-вершённых (стековые кадры называют также активными кадрами, или записями активации). Рис. 10.13. Структуры данных стек и очередь На рис. 10.14 приведены состояния программного стека при выпол- нении кода из листинга 10.1, а по существу – последовательность вызо-вов-возвратов методов на рис. 10.1. После инициализации списков a и b в строках 16 и 17 вызов cosine(u,v) создаёт в программном стеке первый стековый кадр (тём- ный прямоугольник на рисунке), в котором сохраняются ссылки на два входных списка (шаг 1). После этого управление передаётся вызываемо-му методу, первая операция которого (строка 13) – вычисление скаляр-ного произведения его входных параметров dot_product(u,v) . Следо- вательно, вызов этого нового метода добавляет в стек новый стековый кадр (шаг 2) с выделением памяти для хранения двух ссылок на входные списки и двух локальных переменных s и i. По завершении этого мето- да весь его стековый кадр удаляется из программного стека (шаг 3). На следующем шаге в той же строке 13 вычисляется norm_Euclidean(u) . (a) (b)Первым вошёл, последним вышел (LIFO)Первым вошёл, первым вышел (FIFO) Стек Очередьвершина втолкнуть вытолкнутьиз очереди в очередьпервый последний\n--- Страница 323 ---\n322  Глава 10. Выполнение программы Вызов этой функции помещает в программный стек свой стековый кадр (шаг 4). Метод вычисляет евклидову норму вектора – своего вход-ного списка (в данном случае a), вызывая dot_product(v,v) , который, в свою очередь, создаёт новый стековый кадр (шаг 5). На рис. 10.15 показаны сохранённые в программном стеке параметры и локальные переменные для вычисления этого скалярного произведения, а также данные двух предшествующих вызовов из приведённого примера кода. Рис. 10.14. Выделение стековых кадров при выполнении кода из листинга 10.1, где cos, | · | и ‹·, ·› обозначают методы cosine , norm_Euclidean и dot_product соответственно Рис. 10.15. Программный стек и данные на шаге 5 из рис. 10.14 На двух следующих шагах 6 и 7 из стека последовательно удаляют - ся стековые кадры полностью завершённых функций dot_product и norm_Euclidean . Затем алгоритм вычисляет евклидову норму второго Данные программы Программный стек 1 2 3 4 5 6 7 8 9 10 11 12 a bu v 01 11cos 12cos cos cos cos cos cos cos cos cos cos cos‹·, ·› ‹·, ·›‹·, ·› ‹·, ·›| · | | · | | · | | · | | · | | · | | · | u v s iv\n--- Страница 324 ---\n10.3. Программный стек  323 вектора – входного списка b, поэтому шаги 8–11 аналогичны шагам 4–7. В итоге функция cosine завершается, возвращая свой результат и осво- бождая стек программы. Программный стек – это структура данных, наилучшим образом при- способленная для реализации последовательности вложенных вызовов подпрограмм, включая рекурсию. Рассмотрим рекурсивные вызовы функции sum_first_naturals на рис. 10.2. Глядя на него, может пока- заться, что при каждом вызове функции в памяти создаётся ещё одна копия кода, но это не так: в памяти находится только один экземпляр кода, а весь механизм каждого конкретного вызова и отслеживания цепочек вызовов сосредоточен исключительно в программном стеке. В данном случае каждый новый стековый кадр очередного вызова хра-нит значение входного параметра n для этого вызова. Таким образом, при выполнении кода конкретное значение n будет именно тем, что хранится в кадре, расположенном на вершине программного стека. На рис. 10.16 приведено состояние программного стека при выполнении вызова sum_first_naturals(4) , где каждый кадр, очевидно, связан с од- ним и тем же методом. Рис. 10.16. Выделение стековых кадров для sum_first_naturals(4)РезультатыВызовы подпрограммы4 4 4 4 4 4 43 3 3 3 32 2 21n n nn nn n n n n nn nn nn\n--- Страница 325 ---\n324  Глава 10. Выполнение программы Выделение стековых кадров отражает цепочку вызовов-возвратов, как в дереве рекурсии (см. рис. 10.5). Затемнённый прямоугольник представляет собой цепочку стековых кадров тех методов, которые могли быть вызваны до вызова sum_first_naturals(4) . 10.3.2. Трассировка стека Ещё одно полезное и важное для отладки понятие – трассировка стека (stack trace), или отчёт о состоянии программного стека на опре- делённый момент выполнения программы. Большинство языков про-граммирования обладает функционалом для отображения трассировки стека. Например, в языке Python трассировку стека можно выполнить с помощью модуля Traceback . Помимо этого, «трасса» стека печатается при выходе программы на ошибку времени выполнения. Давайте заменим операцию сложения в строке 6 из листинга 10.1 ошибочным вычитанием s = s – u[i]*v[i] (прочие функции тоже будут ошибочными, поскольку и они вызывают dot_product ). Тогда, напри- мер, вычисление евклидовой нормы (длины) отличного от нуля вектора привело бы к ошибке времени выполнения программы, поскольку она попыталась бы извлечь квадратный корень из отрицательного числа. При выполнении такого кода стандартный интерпретатор языка Python выдал бы такое сообщение: Оно говорит о том, что пакет math столкнулся с ошибкой (времени выполнения) в строке 10 при выполнении метода norm_Euclidean , ко- торый был вызван в строке 13 функцией cosine . В сообщении также указывается строка 18, в которой вызывается метод cosine (в некото- рых языках программирования в программный стек помещается сте-ковый кадр основной программы main ). В заключение отметим, что структура сообщения точно соответствует состоянию программного стека на шаге 5 из рис. 10.14.Traceback (most recent call last): File \"traceback_example.py\", line 18, in <module> print(cosine(a,b)) File \"traceback_example.py\", line 13, in cosine return dot_product(u, v) / norm_Euclidean(u) / norm_Euclidean(v) File \"traceback_example.py\", line 10, in norm_Euclidean return math.sqrt(dot_product(v, v)) ValueError: math domain error\n--- Страница 326 ---\n10.3. Программный стек  325 10.3.3. Пространственная сложность вычислений Требования к памяти рекурсивного алгоритма зависят от наиболь- шего числа, скажем, h стековых кадров, помещенных в программный стек в произвольный момент вычислений. Эту величину можно так - же понимать как высоту дерева рекурсии. Естественно, для линейных или хвостовых рекурсивных методов h – это просто число узлов дерева рекурсии, поскольку оно линейно. В предположении, что каждый вы-зов рекурсивного метода требует одинакового объёма памяти М (это не всегда так), полный объём необходимой алгоритму памяти был бы М · h, поскольку в какой-то момент в программном стеке окажется h стековых кадров некоторого метода. Например, каждый стековый кадр функции sum_first_naturals требует постоянного объёма памяти c (то есть пространства памяти порядка Θ(1)), поскольку он хранит входной параметр и фиксированное количество информации нижнего уровня. Кроме того, так как высота дерева рекурсии – n, то полный объём необ- ходимой памяти – c · n, и мы можем заключить, что алгоритм требует пространства памяти порядка Θ(n). Для алгоритмов с нелинейным деревом рекурсии важно понимать, что необходимая рекурсивному алгоритму память – это высота дерева рекурсии, а не количество его узлов. Рассмотрим дерево рекурсии для функции fibonacci на рис. 10.8(a). Количество его узлов – показательная функция от его высоты n, но его высота – просто n – 1, и именно она определяет потребность метода в памяти. Это видно из анализа различ-ных состояний программного стека при выполнении fibonacci(5) , как показано на рис. 10.17. Так как по завершении метода стековые кадры удаляются из стека, их максимальное количество равно 4 (шаги 4 и 6). В итоге, поскольку каждый вызов требует одинакового объёма памяти для своих данных, пространственная сложность вычислений для этого алгоритма линейна относительно n. Так как рекурсия реализуется посредством программного стека, она всегда требует, по крайней мере, h блоков памяти (то есть Ω(h)). В этом соотношении рекурсивные алгоритмы, вообще говоря, используют больше памяти, чем их итерационные версии. Например, основные итерационные алгоритмы вычисления суммы первых положительных целых чисел или чисел Фибоначчи используют постоянный объём па-мяти, тогда как рекурсивные версии обязательно требуют порядка n блоков памяти. Кроме этого, к дополнительным вычислительным рас - ходам приводят стековые операции вталкивания и выталкивания. Та-ким образом, среди алгоритмов с одинаковой временнóй сложностью\n--- Страница 327 ---\n326  Глава 10. Выполнение программы итерационные, вообще говоря, будут (несколько) эффективнее, чем ре- курсивные (см. раздел 11.1). Рис. 10.17. Выделение стековых кадров для fibonacci(5) 10.3.4. Ошибки предельной глубины рекурсии и переполнения стека При выполнении программ существует предел на объем доступной им памяти, зависящий от ряда факторов, включая язык программи-рования, машинную архитектуру или многопоточность. В частности, сущест вует ограничение на объём данных или количество стековых ка- дров, сохраняемых в программном стеке. Например, в некоторых реа-лизациях языка Python в программном стеке по умолчанию допускается до 1000 кадров (то есть вложенных рекурсивных вызовов). Конкретную величину, скажем, М можно задать вызовом sys.getrecursionlimit() так, чтобы максимальная высота дерева рекурсии была М. Превысив- шая этот лимит программа «рушится» с сообщением «RecursionError: превышена предельная глубина рекурсии». 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 184 1 13 22 25 5 345 345 345 345 345 45 45 45 5 5 35 35 35 35 5\n--- Страница 328 ---\n10.3. Программный стек  327 Такой тип ошибки при выполнении программы называют также «пе- реполнением стека». В других языках вместо ограничения числа рекур- сивных вызовов ограничивают объём доступной памяти программного стека и «кучи» (области для динамического выделения памяти под дан-ные). Поскольку динамическая память и программный стек разраста-ются, программа может исчерпать доступную память, что приведёт к ошибке времени выполнения программы. Таким образом, если дина-мическая память велика, переполнение стека может произойти даже при небольшом количестве рекурсивных вызовов. В связи с этим про-граммисты должны стремиться уменьшить размер каждого стекового кадра, избегая параметров и локальных переменных большого объёма (например, размещая в динамически распределяемой памяти вместо самых данных указатели (ссылки) на них, как на рис. 10.15). Наиболее частая причина ошибки переполнения стека – бесконеч- ная рекурсия, возникающая в рекурсивном коде, который не дости-гает должным образом начального условия, как, например, метод factorial_no_base_case из листинга 2.1. Однако даже для правильно закодированных алгоритмов ограничение на количество стековых кад-ров может иметь серьёзные последствия при использовании рекурсии, особенно для линейных деревьев рекурсии. Например, большинство линейно-рекурсивных методов, использующих списки, не будет рабо-тать, если их размер превышает предельную глубину рекурсии (M). От - метим, что при декомпозиции задачи размера n путём его уменьшения на 1 она обычно генерирует n рекурсивных вызовов, пока не достигнет начального условия (будем считать, что это происходит при n = 1 или n = 0). В таких случаях, если n > М, выполнение программы прервётся из-за переполнения стека. В этом – одна из основных проблем исполь-зования линейных или хвостовых рекурсивных алгоритмов. В тех слу - чаях, когда размер задачи большой, лучше применять итерационные методы. 10.3.5. Рекурсия как альтернатива стеку Рекурсия – очевидная альтернатива итерации, когда программисту приходится явно отвечать за управление стеком или подобной ему структурой данных. Рассмотрим задачу поиска файла в файловой си-стеме, которая состоит в том, чтобы по заданным именам файла f и на - чальной папки F напечатать все пути к файлам с именем f , находящим- ся в F или в любой из вложенных в неё папках. Например, рассмотрим файлы и папки на рис. 10.18.\n--- Страница 329 ---\n328  Глава 10. Выполнение программы Рис. 10.18. Пример дерева файловой системы Допустим, что файл file_paths.py содержит метод решения этой за- дачи. Тогда он, будучи вызванным с параметрами 'file01.txt' и началь- ной папкой '.' (на рисунке обозначена как 'initial_folder'), в которой на-ходится file_paths.py , должен вывести что-то вроде: Поскольку файловая система имеет древовидную структуру, итераци- онному алгоритму придётся использовать структуру данных типа стек или очередь для поиска файла f в глубину или в ширину. В листинге 10.3 приведена возможная реализация поиска в глубину с использованием стека. Сначала он подключает модуль os, чтобы воспользоваться ме- тодом os.scandir , который позволяет получить описание содержимо- го конкретной папки. В частности, он возвращает (неупорядоченное) множество объектов, находящихся в данной папке. Оно используется в цикле для проверки (по атрибуту name ) имён файлов и папок в указан- ном пути, а также их свойств такими, например, методами, как is_file (является ли объект файлом) или is_dir (является ли объект папкой). Наконец, атрибут path используется для печати пути к найденному в файловой системе файлу. Определённый нами метод прежде всего объявляет пустой список, который будет представлять собой стековую структуру данных и содер-жать объекты-папки. После этого он используется в цикле для проверки всех файлов и папок в каталоге, заданном параметром folder . Для каж - дого объекта множества os.scandir алгоритм проверяет, является ли он файлом, и печатает его путь при совпадении его имени со значением initial_folder folder01 folder03 file01.txt file02.txt folder02 file01.txtfile_paths.py .\\file01.txt .\\folder01\\folder03\\file01.txt\n--- Страница 330 ---\n10.3. Программный стек  329 параметра file_name . В противном случае процедура посредством ме- тода is_dir определяет, является ли объект папкой. Если это так, то он помещает объект в стек (метод append ). После чего алгоритм выполняет те же действия над объектами, находящимися в стеке. Этот процесс по- вторяется, пока стек не опустеет. Листинг 10.3. Итерационный алгоритм поиска файла в файловой системе 1 23 4 567 8 9101112 13 141516 17 18192021import os def print_path_file_iterative(file_name, folder): stack = [] for entry in os.scandir(folder): if entry.is_file() and file_name == entry.name: print(entry.path) elif entry.is_dir(): stack.append(entry) while len(stack) > 0: entry = stack.pop() for entry in os.scandir(entry.path): if entry.is_file() and file_name == entry.name: print(entry.path) elif entry.is_dir(): stack.append(entry) print_path_file_iterative('file01.txt', '.'): На рис. 10.19 приводится несколько состояний стека при выполнении кода из листинга 10.3 для файлов и папок на рис. 10.18. Сначала стек пуст (шаг 0). Затем в первом цикле алгоритма в стек помещаются два каталога, находящихся непосредственно в начальной папке (шаги 1 и 2), и печатается путь .\\file01.txt . Потом метод перехо- дит ко второму циклу (строки 11–17). Сначала он выталкивает каталог folder02 (шаг 3) и проверяет его. Так как он пуст, метод не печатает новых путей и добавляет новые подпапки в стек. На втором шаге цик - ла while процедура выталкивает folder01 (шаг 4). Эта папка содержит файл, но он не file01.txt . Однако, кроме него, она содержит подпапку, которая помещается на вершину стека (шаг 5). На следующем шаге цик - ла метод выталкивает folder03 (шаг 6), находит файл под названием file01.txt и печатает его полный путь. При этом он не добавляет новые\n--- Страница 331 ---\n330  Глава 10. Выполнение программы объекты в стек, так как folder03 не содержит подкаталоги. Таким об- разом, стек становится пустым, и метод завершается. Читатель может проверить алгоритм на больших файловых системах, чтобы убедиться, что метод действительно выполняет поиск в глубину. В этом неболь-шом примере алгоритм начинает поиск файла с папки folder02 . Если бы в ней были подпапки, то метод продолжил бы поиск в них, прежде чем искать в folder01 . Рис. 10.19. Состояние стека при выполнении итерационного кода из листинга 10.3 для файлов и папок на рис. 10.18 В листинге 10.4 приведёно иное, более простое и естественное, рекур- сивное решение задачи. Вся его суть заключается в проверке наличия файла в некоторой папке (без учёта вложенных папок) и во всех вло-женных в неё папках. Обратите внимание, что поиск в этих подпап-ках – это просто меньший экземпляр исходной задачи. Метод тоже ис - пользует цикл для проверки каждого объекта данной папки (и потому использует множественную рекурсию). Однако при обнаружении папки он вызывает сам себя для поиска заданного файла в этой папке или в любой из вложенных в неё подпапок. На рис. 10.20 показано состояние программного стека при выполне- нии кода из листинга 10.4 для файлов и папок на рис. 10.18. Имя в стековом кадре – это имя папки при вызове метода (имя фай- ла – одно и то же для каждого вызова), где первый вызов метода исполь-зует начальный каталог. Как только метод обнаруживает папку F, он снова вызывает сам себя, чтобы напечатать все пути к файлу file_name в этой папке и ко всем вложенным в неё папкам. Таким образом, в ал-горитме реализован тот же поиск файла в файловой системе в глубину, 0 1 2 3 4 5 6folder01 folder03folder01 folder01 folder02\n--- Страница 332 ---\n10.3. Программный стек  331 но при этом нет явного управления стеком. Наоборот, все действия с программным стеком скрыты от программиста. Листинг 10.4. Рекурсивный алгоритм поиска файла в файловой системе 1 2 3 45 6 78 9 1011 12import os def print_path_file_recursive(file_name, folder): for entry in os.scandir(folder): if entry.is_file() and file_name == entry.name: print(entry.path) elif entry.is_dir(): print_path_file_recursive(file_name, entry.path) print_path_file_recursive('file01.txt', '.'): Рис. 10.20. Выделение стековых кадров при выполнении кода из листинга 10.4 для файлов и папок на рис. 10.18 На этом примере мы показали, что для определённых задач рекур- сивное решение может быть короче, проще (поскольку не использует стек) и легче для понимания, так как отвечает естественному ходу рас - суждений при решении задачи. Кроме того, в этом примере итераци-онный алгоритм лишь немного эффективнее рекурсивного. Читатели могут оценить время выполнения обоих алгоритмов на своих компью-терах. Наконец, благодаря удобочитаемости и простоте рекурсивные 1 2 3 4 5 6 7 8folder01 folder03folder01 folder01 folder02\n--- Страница 333 ---\n332  Глава 10. Выполнение программы алгоритмы легче поддерживать и отлаживать. Для определённых задач эти качества могут оказаться весомее временнóй и пространственной эффективности. Наконец, любая рекурсивная программа может быть преобразована в итерационную (и наоборот). Суть этого преобразования – в явном ис - пользовании стека для моделирования действий с программным сте-ком. Например, он мог бы содержать параметры, передаваемые рекур-сивным функциям. Существуют стандартные методы преобразования рекурсивного кода в итерационный, но эта тема выходит далеко за рам-ки данной книги. 10.4. Мемоизация и динамическое программирование В этом разделе рассматривается методика, известная как мемоиза- ция (memoization), которая используется для существенного ускорения некоторых рекурсивных алгоритмов. Подход связан с динамическим программированием, которое является важным и передовым мето-дом проектирования алгоритмов. 10.4.1. Мемоизация Некоторые рекурсивные алгоритмы несколько раз выполняют одни и те же рекурсивные вызовы (см. раздел 7.4). Другими словами, им приходится неоднократно решать одинаковые перекрывающиеся под- задачи. Мемоизация – это подход, позволяющий избежать повторных вычислений при решении таких подзадач и тем самым существенно ускорить алгоритмы. Суть подхода заключается в сохранении резуль-татов рекурсивных вызовов в поисковых таблицах. В частности, до рекурсивного вызова метод проверяет, был ли такой вызов ранее и сохранён ли его результат в таблице. Если это так, то алгоритм вместо повторного рекурсивного вызова просто возвращает его ранее вычис - ленный и сохранённый в таблице результат. Если же результат не был вычислен, алгоритм продолжает работу, как обычно, вызывая рекур-сивный метод. Одна из самых простых иллюстраций подхода – алгоритм вычисле- ния функции Фибоначчи F(n) = F(n – 1) + F(n – 2). На рис. 10.21 – его дерево рекурсии для F(6).\n--- Страница 334 ---\n10.4. Мемоизация и динамическое программирование  333 Рис. 10.21. Перекрывающиеся подзадачи при вычислении чисел Фибоначчи по формуле F(n) = F(n – 1) + F(n – 2)(a) (b) (c) (d)4 1 13 22 256 34 13 22 4 1 13 22 256 34 13 22 4 1 13 22 256 34 13 22 4 1 13 22 256 34 13 22\n--- Страница 335 ---\n334  Глава 10. Выполнение программы На рис. 10.21(a) мы имеем два одинаковых поддерева fibonacci(4) (корневой узел соответствует n = 4), то есть две перекрывающиеся под- задачи, которые выполняют одно и то же вычисление и возвращают один и тот же результат. Таким образом, по завершении первого вызо- ва fibonacci(4) алгоритм может сохранить его результат в поисковой таблице и воспользоваться им впоследствии, чтобы не вызывать метод снова и не выполнять лишних вычислений. Эта стратегия позволяет нам исключить все вызовы, связанные с правым поддеревом дерева рекур- сии, как показано на рис. 10.21(b). Более того, усечение дерева рекурсии можно продолжить, если обратить внимание и на другие перекрываю-щиеся подзадачи. Как видно по рис. 10.21(b), в оставшемся дереве есть ещё два одинаковых поддерева для n = 3 (отметим, что всего таких под- деревьев было три). Поэтому можно сохранить результат самого пер- вого вычисления fibonacci(3) и при необходимости использовать его значение. Применение такого подхода ко всему исходному дереву рекурсии приводит к алгоритму с рекурсивным деревом (рис. 10.21(d)), содержа- щим всего n узлов. Таким образом, за счет увеличения объёма памяти для хранения n промежуточных результатов F(i), где i = 1, …, n, новому алгоритму требуется для выполнения линейное время. Увеличение ско-рости просто поражает, если вспомнить, что первоначальный алгоритм выполнялся за показательное время. В листинге 10.5 приведён один из способов реализации нового под- хода для функции Фибоначчи. Помимо параметра n, метод получает за- полненный нулями список (таблицу) поиска a. Его длина – n + 1, так как индексы в языке Python начинаются с 0. Метод начинается с проверки начального условия. Поскольку оно всегда возвращает только констан- ту 1, проще проверить начальное условие и вернуть его значение, чем искать его в списке. Таким образом, эта версия алгоритма не сохраняет значения начальных условий в списке поиска. В случае рекурсивного условия, если a n > 0, значение F(n) уже сохранено в an (то есть an = F(n)). Если результат проверки рекурсивного условия – True, метод просто возвращает a n, не выполняя рекурсивного вызова. В противном случае алгоритм работает, как функция fibonacci , но прежде чем вернуть ре- зультат, он сохраняет его в an. В итоге метод позволяет вычислить чис - ла Фибоначчи за линейное время, но требует дополнительного списка размера n. Однако это не влияет на пространственную сложность вы- числений, поскольку функция fibonacci тоже требует порядка n блоков памяти в программном стеке, как описано в разделе 1.7.\n--- Страница 336 ---\n10.4. Мемоизация и динамическое программирование  335 Листинг 10.5. Рекурсивный алгоритм вычисления чисел Фибоначчи за линейное время с применением мемоизации 1 234 5 6789 10 111213def fib_memoization(n, a): if n == 1 or n == 2: return 1 elif a[n] > 0: return a[n] else: a[n] = fib_memoization(n – 1, a) + fib_memoization(n – 2, a) return a[n] n = 100 print(fib_memoization(n, [0] * (n + 1))) В разделе 7.4 описаны два рекурсивных алгоритма решения задачи о самой длинной подстроке-палиндроме, время выполнения которой – показательная функция от длины исходной строки. Рассмотрим теперь основанное на мемоизации решение, выполняющееся за квадратичное время. В листинге 10.6 приведена версия листинга 7.7, но с мемоизацией. Помимо начальной строки s длины n, метод имеет три дополнительных параметра. Во-первых, он использует нижний (i) и верхний (j) индексы, задающие подстроку поиска самой длинной подстроки-палиндрома. Кроме того, он использует матрицу L размерности n×n для хранения самых длинных подстрок-палиндромов, найденных методом (конечно, можно реализовать более эффективную версию, которая вмес то мат - рицы сохраняет в любой момент времени только самую длинную под- строку-палиндром, найденную методом). В частности, элемент L i,j бу- дет самой длинной подстрокой-палиндромом, найденной в подстроке s i j, где i ≤ j. Первоначально метод вызывается со строкой s, мат рицей L с пустыми элементами, а также верхним и нижним индексами 0 и n – 1 соответственно. Сначала метод проверяет, решалась ли ранее такая задача. В этом слу - чае элемент Li,j будет содержать непустую строку, которую метод может сразу возвратить (строки 2 и 3). Затем проверяется условие i > j, возвра- щающее в случае True пустую строку. В строках 6–8 алгоритм проверя-ет, состоит ли заданная своими индексами подстрока из единственно-го символа. В этом случае он сохраняется в таблице L и возвращается в качест ве результата. Остальная часть кода относится к рекурсивным ус - ловиям. В строках 10–14 метод ищет самую длинную подстроку-палин-\n--- Страница 337 ---\n336  Глава 10. Выполнение программы дром в si+1 j–1, но вызывает рекурсивный метод, только если решение еще не было вычислено и сохранено в L. Затем, если подстрока si+1 j–1 являет - ся палиндромом ( len(s_aux_1) == j – i – 1 ), метод проверяет усло- вие si = sj (строка 16). Если оно выполняется, то si j будет самым длинным палиндромом, и метод сохранит и вернёт его (строки 17 и 18). Если же si j не является палиндромом, метод выполнит два рекурсивных вызова, аналогичных вызовам в строках 10 и 11 из листинга 7.7, и сохранит их результаты, но только если соответствующие подзадачи не были решены ранее (строки 20–30). В заключение метод возвращает самую длинную из двух строк-палиндромов, соответствующих этим двум подзадачам. Алгоритм имеет квадратичную сложность вычисления, так как, по сути дела, создаёт двумерную матрицу L и решает подзадачу не более одного раза. Поэтому он гораздо эффективнее метода из листинга 7.7, требующего экспоненциального времени. 10.4.2. Граф зависимости и динамическое программирование Динамическое программирование – парадигма проектирования алгоритмов, применяемая для решения задач оптимизации, которые можно разбить рекурсивно на меньшие подзадачи так, что разбиение приводит к перекрывающимся подзадачам. Метод может быть нисхо-дящим (сверху вниз) с применением рекурсии и мемоизации. Но более общий подход заключается в применении восходящей (снизу вверх) стратегии. Суть её в том, чтобы реализовать восходящий итерационный алгоритм, который заполняет поисковую таблицу (такую же, как в ре-курсивном алгоритме с мемоизацией) снизу вверх, начиная с простей-ших экземпляров задачи, и последовательно сохраняет получаемые ре-зультаты, которые позволят нам решить исходную задачу. Даже при том, что восходящий подход является итерационным, ре- курсивное решение даёт представление о том, как следует заполнять поисковую таблицу. В частности, аналитики могут построить граф за- висимости (dependency graph), называемый также «графом подзадач», указывающий на зависимости между различными подзадачами (то есть вызовами методов), которые необходимо решить с помощью рекурсив-ного алгоритма. Безусловно, этот граф – ориентированный, где каждый узел представляет собой конкретную подзадачу, а рёбра – зависимости между ними. Будем считать, что если подзадача A требует решения (за- висима от) подзадачи B, то соединяющее их реб ро будет направлено от A к B. На рис. 10.22 приведён граф зависимос ти для рекурсивного\n--- Страница 338 ---\n10.4. Мемоизация и динамическое программирование  337 алгоритма на базе рекуррентного соотношения F(n) = F(n – 1) + F(n – 2) для F(6) и начальных условий F(2) и F(1). Листинг 10.6. Версия листинга 7.7 с мемоизацией 1 234 5 6789101112 13 14 15 1617181920212223 24 252627282930313233 34 3536373839def lps_memoization(s, L, i, j): if len(L[i][j]) > 0: return L[i][j] elif i > j: return '' elif i == j: L[i][j] = s[i] return s[i] else: if len(L[i + 1][j – 1]) > 0: s_aux_1 = L[i + 1][j – 1] else: s_aux_1 = lps_memoization(s, L, i + 1, j – 1) L[i + 1][j – 1] = s_aux_1 if len(s_aux_1) == j – i – 1 and s[i] == s[j]: L[i][j] = s[i:j + 1] return s[i:j + 1] else: if len(L[i + 1][j]) > 0: s_aux_2 = L[i + 1][j] else: s_aux_2 = lps_memoization(s, L, i + 1, j) L[i + 1][j] = s_aux_2 if len(L[i][j – 1]) > 0: s_aux_3 = L[i][j – 1] else: s_aux_3 = lps_memoization(s, L, i, j – 1) L[i][j – 1] = s_aux_3 if len(s_aux_2) > len(s_aux_3): return s_aux_2 else: return s_aux_3 s = 'bcaac' L = [['' for i in range(len(s))] for j in range(len(s))]print(lps_memoization(s, L, 0, len(s) – 1))\n--- Страница 339 ---\n338  Глава 10. Выполнение программы Рис. 10.22. Граф зависимости для F(n) = F(n – 1) + F(n – 2) Обратите внимание на зависимость узлов n от узлов n – 1 и n – 2. Теперь для реализации решающего задачу итерационного алгоритма граф зависимости нужно проанализировать. Очевидно, что для чисел Фибоначчи алгоритм может получить результат за n шагов при нали- чии сохранённых решений подзадач F(1), F(2), , F(n – 1). Более того, из графа зависимости видно, что нет необходимости в списке длины n для хранения всех промежуточных результатов, поскольку на каждом шаге i нам нужны только два значения – F(i – 1) и F(i – 2), которые можно хранить в двух переменных. Что касается задачи о самой длинной подстроке-палиндроме, то на рис. 10.23 приводится граф зависимости, относящийся к листингу 10.6, для исходной входной строки из пяти символов. Рис. 10.23. Граф зависимости для листинга 10.6, решающего задачу о самой длинной подстроке-палиндроме В его узлах указаны только нижний и верхний индексы i и j (если i > j, то результатом является пустая строка, а сам узел помечен как ''). За-метьте, что узел (i, j) зависит лишь от решений для пар (i + 1, j), ( i, j – 1) и (i + 1, j – 1), что следует из декомпозиции задачи. Каждый узел (i, j) свя-4 1 3 2 5 6 0,0 0,1 0,2 0,3 0,4 1,1 1,2 1,3 1,4 '' 2,2 2,3 2,4 '' 3,3 3,4'' 4,4 ''\n--- Страница 340 ---\n10.4. Мемоизация и динамическое программирование  339 зан с разными подзадачами, поэтому решение исходной задачи может быть получено только по завершении вызова, связанного с (затемнён-ным) узлом (0, n – 1). Если промежуточные результаты сохраняются в некоторой матрице L, то из графа зависимости на рис. 10.23 следует, что L i, j, связанный с уз- лом (i , j), может быть получен после вычисления и сохранения Li+1, j, Li, j–1 и Li+1, j–1. Таким образом, граф зависимости задаёт порядок или направ- ление (к верхнему правому углу), в котором нужно решать подзадачи и сохранять их решения. В частности, можно разработать алгоритм, кото-рый начинается с решения подзадач, расположенных на главной диа-гонали, с узлами (i , i) для i = 0, …, n – 1. Затем на следующей диагонали с узлами (i , i + 1) для i = 0, …, n – 2 и т. д. до достижения узла (0, n – 1). В лис - тинге 10.7 приведена возможная итерационная реализация алгоритма. Листинг 10.7. Поиск самой длинной подстроки-палиндрома в строке s с использованием динамического программирования 1 234 5 67891011121314 15 16171819202122 23 24 25def lps_dynamic_programming(s): n = len(s) L = [['' for i in range(n)] for j in range(n)] for i in range(n): L[i][j] = s[i] k = 1 while k < n: i = 0 j = k while j < n: if (len(L[i + 1][j – 1]) == j – i – 1 and s[i] == s[j]): L[i][j] = s[i:j + 1] elif len(L[i][j – 1]) >= len(L[i + 1][j]): L[i][j] = L[i][j – 1] else: L[i][j] = L[i + 1][j] i = i + 1 j = j + 1 k = k + 1 return L[0][n – 1]\n--- Страница 341 ---\n340  Глава 10. Выполнение программы Заметьте, что он решает подзадачи снизу вверх, начиная с меньших экземпляров, пока не вернёт решение всей исходной задачи. В част - ности, сначала он заполняет матрицу L пустыми строками (строка 3), а также сохраняет si в Li, i для i = 0, …, n – 1 (строки 5 и 6). Два следую- щих цикла последовательно, диагональ за диагональю, заполняют мат - рицу L, пока не достигнут верхнего правого узла графа зависимости. Строки 13–15 проверяют, что подстрока si j является палиндромом, и, если это так, сохраняют ее. В противном случае следующие четыре стро- ки сохраняют в Li, j самую длинную из подстрок Li+1, j и Li, j–1. На рис. 10.24 приведено состояние матрицы L по завершении метода со всеми ре- шениями подзадач для исходной входной строки s = 'bcaac'. Алгоритм работает за время Θ(n2), так как создаёт квадратную матрицу L, каждый элемент которой требует времени Θ(1) (можно разработать более эф- фективные алгоритмы, не использующие матрицу). Рис. 10.24. Матрица L по завершении метода из листинга 10.7 для s = 'bcaac' 10.5. Упражнения Упражнение 10.1. Догадайтесь, что вычисляет каждая из следующих функций f, подставляя в них различные (неотрицательные целые) зна- чения входных параметров. Кроме того, убедитесь, что найденная вами функция, скажем g, верна, разработав для неё рекурсивный алгоритм с применением декомпозиции к соответствующему описанию f. Рекур- сивное определение g должно быть идентично f. 1. True, 0,() ( 1), 0.nfnfn n= =¬− > 2. 3, 0,() ( 1), 0.nfnn fn n= =⋅− >'b' 'b' 'b' 'c' 'c' 'c''a' 'a' 'a''aa''aa''aa' 'aa''caac''caac' ' ' ' ' ' ' ' '· · ·· · · 0 1 2 3 40 1 2 3 4i j если если если если\n--- Страница 342 ---\n10.5. Упражнения  341 3. 0, 0,()( 1) 2 1, 0.nfnfn n n= =−+ − >  4. 0, 0 0,( ,)( 1, 1) 1 nmf mnfm n m n== =− −+ +−  Упражнение 10.2. Нарисуйте дерево рекурсии, как на рис. 10.5(b), для загадочных методов из листинга 10.2, вызываемых с параметром-стро- кой 'Word'. Рядом с каждой из стрелок укажите состояние экрана. Упражнение 10.3. Рассмотрим список кортежей вида (ключ, элемент). Методы, использующие процедуру insert_binary_tree из листин- га 5.10, сохраняют их в двоичном дереве поиска в виде четырехкомпо-нентного списка, как описано в разделе 5.3. Реализуйте различные ме-тоды, создающие двоичные деревья поиска, приведённые на рис. 5.2 и 10.25, для исходного списка a = [('John', '2006/05/08'), ('Luke', '1976/07/31'), ('Lara', '1987/08/23'), ('Sara', '1995/03/14'), ('Paul', '2000/01/13'), (' Anna', '1999/12/03'), ('Emma', '2002/08/23')]. Рис. 10.25. Альтернативное двоичное дерево поиска, хранящее информацию о днях рождения Упражнение 10.4. Нарисуйте дерево рекурсии для towers_of_ Hanoi(3, 'O', 'D', 'A') из листинга 7.3. Укажите в узлах все парамет - ры и перемещения дисков. Упражнение 10.5. Нарисуйте дерево активации вычисления 27 для каждого из листингов 4.1, 4.3 и 4.4. Упражнение 10.6. Рассмотрите функцию синтаксического анализа методом рекурсивного спуска для калькулятора из раздела 9.6.2. Нари-суйте дерево активации для вычисления выражения (5 – 3) ∗ 2 + (–(–7)). если или иначе.если если John Luke EmmaAnna PaulSara Lara2006/05/08 1976/07/31 1987/08/23 1995/03/14 2000/01/132002/08/231999/12/03\n--- Страница 343 ---\n342  Глава 10. Выполнение программы Укажите в нём наименования методов (E, T, I, F, P) и выразите список лексем в виде математических выражений. Упражнение 10.7. В листинге 10.8 приведены две функции – сложе- ния и подсчёта цифр неотрицательного целого числа n. Одна из них – неправильная. Объясните, в чём ошибка и какое проектное решение привело к ней. Листинг 10.8. Методы, якобы складывающие и подсчитывающие цифры неотрицательного целого числа. Верны ли они? 1 2 3 45 6 78 9 1011 12def add_digits(n): if n == 0: return 0 else: return add_digits(n // 10) + (n % 10) def count_digits(n): if n == 0: return 0 else: return count_digits(n // 10) + 1 Упражнение 10.8. Функция в листинге 10.9 подсчитывает коли чество двойных символов (Например, 'ее', 'оо'. – Прим. перев.) в списке длины n ≥ 1. Но в ней есть ошибка. Найдите и устраните её. Листинг 10.9. Ошибочный код для вычисления количества двойных символов в списке 1 2 3 45def count_consecutive_pairs(a): if len(a)==2: return int(a[0]==a[1]) else: return int(a[0]==a[1]) + count_consecutive_pairs(a[1:]) Упражнение 10.9. Код в листинге 10.10 вычисляет наименьший прос - той множитель числа n, не меньший m. Предусловия: n ≥ m, n ≥ 2 и m ≥ 2. Если он возвращает n при m = 2, то n – простое число. С какой проблемой мы столкнёмся, пытаясь вычислить первые 200 простых чисел?\n--- Страница 344 ---\n10.5. Упражнения  343 Листинг 10.10. Вычисление наименьшего простого множителя числа n, не меньшего m 1 23 4 56# Preconditions: n >= m, n >= 2, m >= 2def smallest_prime_factor(n, m): if n % m == 0: return m else: return smallest_prime_factor(n, m + 1) Упражнение 10.10. Код в листинге 10.11 предположительно вычис - ляет нижнюю границу логарифма: ⌊logbx⌋, где x ≥ 1 – вещественное чис - ло, а b ≥ 2 – целое число. Суть его состоит в подсчете количества возмож - ных делений числа x на b. Однако этот код содержит ошибки. Найдите и устраните их, изменив код. Листинг 10.11. Ошибочный код для вычисления нижней границы логарифма 12 3 45def floor_log(x, b): if r == 1: return 0 else: return 1 + floor_log(x / b, b) Упражнение 10.11. Рассмотрим список a из n чисел. Будем считать, что он содержит «наибольший» элемент, если один из его элементов больше суммы всех остальных. А именно ai – наибольший элемент, если ai > 1, 1nn j ji j ji ja aa =≠ ==−∑∑ , что равносильно 12n ij jaa =>∑ , где в правой части соотношения – сумма элементов списка. В листин-ге 10.12 приведено возможное решение, но оно неверно. Найдите ошиб-ку и исправьте функцию.\n--- Страница 345 ---\n344  Глава 10. Выполнение программы Листинг 10.12. Ошибочный код, проверяющий наличие в списке элемента, большего суммы всех остальных 1 234 5 6def contains_greatest_element(a): if a == []: return False else: return (2 * a[0] > sum(a) or contains_greatest_element(a[1:])) Упражнение 10.12. Рассмотрим непустой список a из n чисел, кото- рые увеличиваются до определенного индекса i (0 ≤ i ≤ n – 1), а затем уменьшаются до конца списка. Таким образом, элемент ai (назовём его «пиковым» и будем считать единственным) будет наибольшим в списке. Код в листинге 10.13 пытается найти этот индекс, но содержит ошибку. Найдите ошибку и исправьте функцию. Листинг 10.13. Ошибочный код для поиска позиции «пикового» элемента 1 23 4 567 8 910def peak_element(a, lower, upper): if lower == upper: return lower else: half = (lower + upper) // 2 if a[half] > a[half + 1]: return peak_element(a, 0, half) else: return peak_element(a, half, upper) Упражнение 10.13. Рассмотрим вариант кривой Коха, когда линей- ный отрезок заменяется пятью меньшими отрезками длиной в одну треть исходного, как показано на рис. 10.26. Рис. 10.26. Вариант разбиения линейного отрезка кривой Коха на пять меньших отрезков В листинге 10.14 приведена функция, создающая фрактал Коха, ос - нованный на том же преобразовании, что и снежинка Коха (см. раз-2p + q/3 p p qy qx p + 2q/3\n--- Страница 346 ---\n10.5. Упражнения  345 дел 7.5.1), и начинающийся с четырех линейных отрезков, образующих квадрат. Метод должен создать изображение на рис. 10.27 для n = 4 и квадрата с вершинами (0, 0), (1, 0), (1, 1) и (0, 1). Однако он этого не де-лает. Найдите ошибку и исправьте код. Листинг 10.14. Создание фрактала Коха с помощью преобразования на рис. 10.26 1 23 4 567 8 9101112 13 141516 17 18192021 22 232425 26 27282930 31 323334 35 3637import numpy as npimport matplotlib.pyplot as plt def koch_curve(p, q, n): if n == 0: # The base case is just a line segment plt.plot([p[0, 0], q[0, 0], p[0, 0], p[1, 0], q[1, 0], 'k–') else: v = q – p koch_curve(p, p + v / 3, n – 1) R_90 = np.matrix([[0, –1], [1, 0]]) x = p + v / 3 + R_90 * v / 3 koch_curve(p + v / 3, x, n – 1) y = x + v / 3 koch_curve(x, y, n – 1) koch_curve(y, p + 2 * v / 3, n – 1) koch_curve(p + 2 * v / 3, q, n – 1) def koch_square(n): p = np.array([0], [0]]) q = np.array([1], [0]]) r = np.array([1], [1]]) s = np.array([0], [1]]) koch_curve(p, q, n) koch_curve(q, r, n) koch_curve(r, s, n) koch_curve(s, p, n) fig = plt.figure() fig.patch.set_facecolor('white')koch_square(4) plt.axis('equal')plt.axis('off') plt.show()\n--- Страница 347 ---\n346  Глава 10. Выполнение программы Рис. 10.27. Вариант «квадрата Коха» для n = 4 Упражнение 10.14. Реализуйте эффективную версию функции (3.2) для вычисления биномиального коэффициента с мемоизацией, а также нарисуйте соответствующий граф зависимости, скажем, для n ≤ 4. Упражнение 10.15. В листинге 10.15 приведена функция, вычис - ляющая длину самой длинной подпоследовательности-палиндрома в спис ке a. Напомним, что в отличие от подстроки, где символы исходной строки должны идти подряд, подпоследовательность не обязательно состоит из подряд идущих элементов списка. Реализуйте эффективную версию алгоритма с мемоизацией, как в листинге 10.6. Листинг 10.15. Вычисление длины самой длинной подпоследовательности-палиндрома в списке 1 23 4 567 8 9101112def length_longest_palindrome_subseq(a): n = len(a) if n <= 1: return n else: if a[0] == a[n – 1]: return 2 + length_longest_palindrome_subseq( a[1:n – 1]) else: l1 = length_longest_palindrome_subseq(a[1:n]) l2 = length_longest_palindrome_subseq(a[0:n – 1]) return max(l1, l2)",
      "debug": {
        "start_page": 307,
        "end_page": 347
      }
    },
    {
      "name": "Глава 11. Вложенная рекурсия и снова хвостовая 347",
      "content": "--- Страница 348 --- (продолжение)\nГлава 11 Вложенная рекурсия и снова хвостовая Шерлок Холмс: «Всегда есть второе решение задачи, и надо его иск ать». – Артур Конан Дойл Особенность хвостовой рекурсии – её тесная связь с итерацией. Прежде всего её довольно просто преобразовать в аналогичные итерацион-ные версии – более эффективные и не подверженные ошибкам пере-полнения стека. По этой причине некоторые программисты склонны считать хвостовую рекурсию порочной практикой. Более того, неред-ко встречаются хвостовые рекурсивные алгоритмы, разработанные с использованием императивного подхода, который ближе к итерации, чем к рекурсии с её декомпозицией и индукцией. В этих случаях ите-рационные версии явно превосходят рекурсивные. Эта глава исследу - ет взаимо связь между хвостовой рекурсией и итерацией. Кроме того, она коротко знакомит со вложенной рекурсией (см. (1.19)) и стратеги-ей разработки простых хвостовых рекурсивных алгоритмов, зачастую подобных итерационным, но с использованием декларативного под-хода. 11.1. Хвостовая рекурсия и итерация Итерационные программы могут быть преобразованы в рекурсивные, и наоборот. Более того, связь между итерацией и хвостовой рекурсией особенно очевидна. Этот раздел исследует эту связь и объясняет, поче-му хвостовой рекурсии обычно предпочитают итерацию.\nГлава 11 Вложенная рекурсия и снова хвостовая Шерлок Холмс: «Всегда есть второе решение задачи, и надо его иск ать». – Артур Конан Дойл Особенность хвостовой рекурсии – её тесная связь с итерацией. Прежде всего её довольно просто преобразовать в аналогичные итерацион-ные версии – более эффективные и не подверженные ошибкам пере-полнения стека. По этой причине некоторые программисты склонны считать хвостовую рекурсию порочной практикой. Более того, неред-ко встречаются хвостовые рекурсивные алгоритмы, разработанные с использованием императивного подхода, который ближе к итерации, чем к рекурсии с её декомпозицией и индукцией. В этих случаях ите-рационные версии явно превосходят рекурсивные. Эта глава исследу - ет взаимо связь между хвостовой рекурсией и итерацией. Кроме того, она коротко знакомит со вложенной рекурсией (см. (1.19)) и стратеги-ей разработки простых хвостовых рекурсивных алгоритмов, зачастую подобных итерационным, но с использованием декларативного под-хода. 11.1. Хвостовая рекурсия и итерация Итерационные программы могут быть преобразованы в рекурсивные, и наоборот. Более того, связь между итерацией и хвостовой рекурсией особенно очевидна. Этот раздел исследует эту связь и объясняет, поче-му хвостовой рекурсии обычно предпочитают итерацию.\n--- Страница 349 ---\n348  Глава 11. Вложенная рекурсия и снова хвостовая Вообще говоря, любые рекурсивные алгоритмы могут быть преобра- зованы в равносильные итерационные версии с использованием стеко- вой структуры данных, исполняющей роль программного стека. Однако для хвостовых рекурсивных методов это преобразование гораздо про-ще, поскольку оно не нуждается в стеке. Всё дело в том, что хвостовые рекурсивные алгоритмы, в сущности, не обязаны хранить информацию в программном стеке, так как они не нуждаются в стеке при возврате из подпрограммы (метода). Рассмотрим ещё раз линейно-рекурсивную функцию sum_first_ naturals из листинга 1.1. Она требует сохранения в программном стеке значений аргументов (см. рис. 10.16), которые для получения конечного результата используются и обрабатываются затем вместе с результата-ми рекурсивных вызовов. Например, sum_first_naturals(4) вытал- кивает из стека аргумент 4 и добавляет его к результату sum_first_ naturals(4) , открывая тем самым аргумент sum_first_naturals(3) . Напротив, функция gcd1 в листинге 5.18 получает свой конечный ре- зультат после обработки начального условия, так как здесь имеет место хвостовая рекурсия. В частности, на рис. 11.1 приводится программный стек при вызове gcd1(20,24) на момент проверки начального условия. Рис. 11.1. Состояние программного стека при вызове gcd1(20,24) на момент проверки начального условия Этот рисунок похож на дерево активации на рис. 10.7 или на (5.6), где результат метода (4) достигается в начальном условии и без измене-Излишние данные Начальное условие Конечный результатn n n n n n n n nm m m m m m m m m4 4 4 4 4 44 4 420 20 2024 16 12 8 0 0\n--- Страница 350 ---\n11.1. Хвостовая рекурсия и итерация  349 ний возвращается каждым рекурсивным вызовом. Это значит, что все хранящиеся в программном стеке данные никогда не используются и потому не нужны. Действительно, получив результат в начальном ус - ловии, программа просто передаёт его без изменений самому первому рекурсивному вызову, последовательно удаляя каждый стековый кадр по завершении каждого рекурсивного вызова. Этот пример показывает, что можно создать равносильный итераци- онный алгоритм вычисления наибольшего общего делителя без исполь-зования стека. В частности, функция gcd1 нуждается в единственном цикле, в котором нужно изменять значения параметров n и m, когда она вызывает саму себя. Другими словами, цикл должен смоделировать изменение параметров при переходе от очередного стекового кадра к следующему, как на рис. 11.1. Следовательно, на каждом шаге цикла, в сущности, должны выполняться те же самые обновления параметров, что выполняются при вызове хвостовой рекурсивной функции (отме-тим, что рекурсивное условие хвостового рекурсивного метода задаёт лишь изменение параметров от одного вызова до следующего). Нако-нец, условие выхода из цикла должно быть таким же, как для началь-ного условия. В листинге 11.1 приведён этот альтернативный итерационный вари- ант. Начальное условие в gcd1 достигается при m = 0. Листинг 11.1. Итерационная версия алгоритма Евклида (gcd1) 1 2 3 45 6 78 9 10def gcd1_iterative(m, n): while m > 0: if m > n: aux = n n = m m = aux else: n = n – m return n Таким образом, рекурсивные условия выполняются при m > 0. По- этому мы можем использовать цикл, который выполняется, пока m > 0, и который моделирует все выполняемые gcd1 рекурсивные вызовы вплоть до достижения начального условия. Рекурсивных условий здесь два. Если m > n, то рекурсивный вызов просто меняет параметры места- ми (строки 4–6) с использованием вспомогательной переменной. При\n--- Страница 351 ---\n350  Глава 11. Вложенная рекурсия и снова хвостовая выполнении второго рекурсивного условия m ≤ n значение n просто ме- няется на n – m (строка 8). Наконец, когда m = 0, метод просто возвраща- ет значение n, согласно начальному условию gcd1 . Итерационные аналоги хвостовых рекурсивных алгоритмов облада- ют двумя преимуществами. С одной стороны, они более эффективны, так как не нуждаются в программном стеке и могут вернуть результат, как только он вычислен. Отметим, что итерационный алгоритм воз-вращает результат только один раз, тогда как хвостовой рекурсивный возвращает одно и то же значение многократно. С другой стороны, они не приводят к переполнению стека даже для больших значений вход-ных параметров. Если количество рекурсивных вызовов ограничено, то количество итераций цикла (который, в сущности, выполняет те же вы-числения, что и рекурсивные вызовы) не ограничено. Для большинст ва приложений потеря эффективности от применения хвостовых рекур-сивных методов не имеет значения. Однако ограничение на количество рекурсивных вызовов – важный фактор масштабируемости (универ-сальности) рекурсивных алгоритмов, представляющий гораздо более серьезную проблему. Однако если рекурсивный алгоритм делит размер задачи на два (или на другую константу), ограничение на количество рекурсивных вызо-вов обычно не представляет проблемы. Для таких алгоритмов высота дерева рекурсии является логарифмической функцией размера задачи. Таким образом, для решения задачи вряд ли потребуется большое ко-личество вложенных рекурсивных вызовов (например, 1000). Если же эффективность алгоритма тоже не важна, то хвостовой рекурсивный ал-горитм – вполне приемлемое решение. Рассмотрим, например, хвосто-вую рекурсивную функцию bisection из листинга 5.15, относящуюся к методу деления пополам. Если она используется для вычисления квад-ратного корня, то количество выполняемых ею рекурсивных вызовов относительно мало. Например, вызов bisection(0, 4, f, 10**(-10)) требует всего 36 рекурсивных вызовов, чтобы приблизиться к значению √4 = 2 с точностью до девяти десятичных цифр после запятой. Более того, при таком небольшом количестве рекурсивных вызовов разница во времени выполнения, по сравнению с аналогичным итерационным алгоритмом из листинга 11.2, будет совсем незначительной. Для моделирования рекурсивных вызовов метод также использует цикл while , в условии которого – инвертированное начальное условие рекурсивной функции. Условный оператор if различает два сценария, соответствующих двум рекурсивным условиям. В обоих случаях обнов-ляется только один параметр. Наконец, в каждой итерации значение\n--- Страница 352 ---\n11.2. Итерационный подход к хвостовой рекурсии  351 переменной z обновляется для сохранения окончательного результата. Поскольку оба алгоритма практически одинаковы, предпочтение можно отдать тому, который проще читается. В данном случае оба алгоритма просты в понимании той задачи, которую они решают. Однако хвосто-вые рекурсивные методы больше опираются на декомпозицию задачи. Листинг 11.2. Итерационная версия метода деления пополам 1 2 3 45 6 78 9 1011 12def bisection_iterative(a, b, f, epsilon): z = (a + b) / 2 while f(z) != 0 and b – a > 2 * epsilon: if (f(a) > 0 and f(z) < 0) or (f(a) < 0 and f(z) > 0): b = z else: a = z z = (a + b) / 2 return z Наконец, для повышения эффективности многие современные ком- пиляторы в состоянии обнаружить хвостовые рекурсивные методы и автоматически преобразовать их в итерационные версии. К сожале-нию, в языке Python нет такой возможности, которую часто называют «устранением хвостовой рекурсии» (tail-recursion elimination). Один из аргументов автора языка Python Гуидо ван Россума состоит в том, что это усложняет отладку. Поэтому он рекомендует использовать вместо хвостовой рекурсии итерацию. По мнению автора книги, если эффек - тивность и ограничение на размер программного стека актуальны, то, очевидно, нужно пользоваться итерационными методами вместо хвостовых рекурсивных. Если же они не актуальны, то программистам следует предпочесть реализацию, которая больше соответствует их по-ниманию решения задачи. Короче говоря, предпочтение отдаётся той версии, которую проще понять и легче сопровождать. 11.2. Итерационный подход к хвостовой рекурсии Очевидно, что хвостовые рекурсивные алгоритмы – это, как показано в главе 5, результат применения рекурсивного подхода. Но их можно\n--- Страница 353 ---\n352  Глава 11. Вложенная рекурсия и снова хвостовая разрабатывать и с применением итерационного подхода. Этот подход рассматривается в данном разделе на примере задач вычисления фак - ториала и преобразования системы счисления. 11.2.1. Факториал Рассмотрим итерационную версию функции вычисления факториала из листинга 11.3. Метод вычисляет искомое значение, последовательно повторяя одни и те же действия в цикле while . В этом алгоритме на- чальный параметр n задаёт количество итераций цикла, тогда как пе- ременную p можно считать накопителем промежуточных результатов, которая по завершении цикла будет содержать искомый факториал. Листинг 11.3. Итерационная функция вычисления факториала 1 2 3 45 6 7def factorial_iterative(n): p = 1 while n > 0: p = p * n n = n – 1 return p В табл. 11.1 приведены значения переменных и параметров метода или состояние памяти программы для каждой итерации цикла при вы- числении 4! (иными словами, каждый вход таблицы отображает значе-ния n и p при проверке программой условия в строке 3). Таблица 11.1. Состояния программы при вычислении факториала 4! итерационной функцией n p 4 1 3 4 2 12 1 24 0 24 Для вычисления факториала можно написать равнозначную хвосто- вую рекурсивную функцию, которая выполняет те же действия, что ите-рационный алгоритм. А именно: метод (скажем, f) требует обоих пара-\n--- Страница 354 ---\n11.2. Итерационный подход к хвостовой рекурсии  353 метров n и p и должен вызывать функцию со значениями параметров из табл. 11.1. Другими словами, хвостовой рекурсивный метод должен генерировать следующие рекурсивные вызовы: f(4, 1) → f(3, 4) → f(2, 12) → f(1, 24) → f(0, 24) = 24. Фактически они задают соответствие между рекурсивным хвостовым вызовом и шагом итерационного алгоритма. В частности, очевидно ре-курсивное правило f(n, p) = f(n – 1, p · n), выполняющее, в сущности, все те действия по обновлению переменных, которые производятся в теле цикла итерационной версии. Отметим, что n задаёт количество вызовов функции, а p хранит промежуточные результаты, включая окончатель- ный. Последний вызов соответствует начальному условию (при n = 0), когда метод возвращает свой второй параметр. Наконец, факториал n вычисляется при вызове f(n, 1), где параметры n и p достигают началь- ных (до входа в цикл) значений одноимённых переменных итерацион-ной версии. В листинге 11.4 приведена возможная реализация хвосто-вой рекурсии, где функция-оболочка вызывает рекурсивный метод со вторым аргументом, равным единице. Листинг 11.4. Хвостовая рекурсивная функция вычисления факториала и функция-оболочка 1 2 3 45 6 78 9def factorial_tail(n, p): if n == 0: return p else: return factorial_tail(n – 1, p * n) def factorial_tail_recursive_wrapper(n): return factorial_tail(n, 1) Итерационные и хвостовые рекурсивные функции очень похожи. Ри- сунок 11.2 показывает сходство обоих методов (рекурсивное условие проверяется до начального, чтобы использовать условие n > 0 в рекур- сивном методе). 11.2.2. Приведение десятичного числа к другому основанию Итерационный подход может быть применён для создания рекур- сивных хвостовых алгоритмов для многих задач. Рассмотрим более\n--- Страница 355 ---\n354  Глава 11. Вложенная рекурсия и снова хвостовая сложную задачу преобразования системы счисления из раздела 4.2.2. Представим себе итерационный алгоритм, выполняющий шаги по приведению десятичного числа 142 к основанию 5 (1032 5) согласно табл. 11.2. Таблица 11.2. Состояния итерационной программы приведения числа 142 к основанию 5 (1032 5) из листинга 11.5 n b p s 142 5 1 0 28 5 10 2 5 5 100 32 1 5 1000 32 0 5 10 000 1032 Рис. 11.2. Сходство между итерационным и хвостовым рекурсивным кодами, вычисляющими факториал Помимо параметров, методу необходима переменная s, в которой бу - дет храниться промежуточный результат, а в итоге – результат. Кроме того, дополнительная переменная p содержит степень 10, необходимую для обновления значения s. На каждом шаге n изменяется путём цело- численного деления на основание b (n // b), p умножается на 10, а пере-def factorial_iterative(n): p =1 n>0while p = n =n–1p*n return pdef factorial_tail_recursive_wrapper(n): def factorial_tail(n, p):return factorial_tail(n, return factorial_tail( return pn–1p*n1 n>0if else::) ),\n--- Страница 356 ---\n11.2. Итерационный подход к хвостовой рекурсии  355 менная-накопитель s увеличивается на (n % b) · p. Этот итерационный алгоритм приведён в листинге 11.5, где изначально p = 1 и s = 0. Нако- нец, когда n достигает значения 0, метод может возвратить результат, находящийся в s. Листинг 11.5. Итерационный алгоритм приведения неотрицательного целого десятичного числа n к основанию b 1 2 3 45 6 78def decimal_to_base_iterative(n, b): s = 0 p = 1 while n > 0: s = s + (n % b) * p p = p * 10 n = n // b return s Аналогичная хвостовая рекурсивная функция должна моделировать итерации цикла вызовами самой себя. Переменные (и параметры) ите- рационной версии должны стать параметрами рекурсивных вызовов, а сама рекурсивная функция должна воспроизвести их обновления в теле итерационного цикла (строки 5–7). Наконец, начальное условие выпол-няется при n = 0, когда метод может вернуть значение переменной s, так как она будет содержать окончательный результат. В листинге 11.6 при-ведена хвостовая рекурсивная функция вместе с методом-оболочкой, который инициализирует p единицей, а s – нулём. Обратите внимание на то, как аргументы рекурсивного вызова отражают изменение пере-менных итерационного алгоритма в теле цикла. Листинг 11.6. Хвостовая рекурсивная функция приведения числа к основанию b и метод-оболочка 1 2 3 45 6 78 9 10def decimal_to_base_tail(n, b, p, s): if n == 0: return s else: return decimal_to_base_tail(n // b, b, p * 10, s + (n % b) * p) def decimal_to_base_tail_wrapper(n, b): return decimal_to_base_tail(n, b, 1, 0)\n--- Страница 357 ---\n356  Глава 11. Вложенная рекурсия и снова хвостовая Хотя хвостовые рекурсивные функции в листингах 11.4 и 11.6, вне всяких сомнений, рекурсивны, такой способ их разработки соответ - ствует парадигме императивного программирования, когда всё вни- мание сосредоточено на переменных и параметрах, определяющих состояние программы. Обратите внимание, что при разработке рекур-сивного метода данный подход не опирается на декомпозицию задачи или индукцию. Вместо этого рекурсивные алгоритмы просто воспроиз-водят итерационные версии. По этой причине получаемые алгоритмы могут сбить с толку тех программистов, которые попытаются понять код с точки зрения декомпозиции задачи. Кроме того, из-за упомя-нутых в разделе 1.1 недостатков такой способ разработки, безуслов-но, следует избегать. (Для листингов 11.4 и 11.6 ошибки переполнения стека довольно редки, так как исходное значение факториала обычно небольшое, а высота дерева рекурсии для алгоритма преобразования к другому основанию является логарифмической функцией от n.) Таким образом, если к решению задачи применяется итерационный подход, то целесообразнее разрабатывать итерационный алгоритм. 11.3. Вложенная рекурсия Вложенная рекурсия – довольно редкий тип рекурсии, когда рекурсив-ная функция вызывается в аргументе рекурсивного метода. Подобно хвостовым рекурсивным функциям во многих функциях с вложенной рекурсией (в частности, во всех, представленных в этой книге), рекур-сивный вызов – это последнее действие, выполняемое алгоритмом. Тем не менее методы с вложенной рекурсией обязательно должны вызы-вать себя несколько раз хотя бы в одном из рекурсивных условий. Сле-довательно, их нельзя отнести к хвостовой рекурсии. В этом разделе описываются две известные функции с вложенной рекурсией и одна задача, которая решается таким же образом. В разделе 11.4 приводятся дополнительные примеры. 11.3.1. Функция Аккермана Один из самых популярных примеров вложенной рекурсии – функ - ция Аккермана, определяемая следующим образом: 1, 0 , ( , ) ( 1,1), 0 0, ( 1, ( , 1)), 0 0,nm Amn Am m n Am Amn m n+= =− >=  − − >>  (11.1)если если и если и\n--- Страница 358 ---\n11.3. Вложенная рекурсия  357 где второй аргумент в последнем рекурсивном условии – рекурсивный вызов. Функция растёт чрезвычайно быстро даже при малых значени-ях аргументов и используется для проверки способности компиляторов оптимизировать рекурсию. В листинге 11.7 приводится код функции, который совсем нетрудно реализовать. Листинг 11.7. Функция Аккермана 1 2 3 45 6 7def ack(m, n): if n == 0: return n + 1 elif n == 0: return ack(m – 1, 1) else: return ack(m – 1, ack(m , n – 1)) 11.3.2. Функция-91 Маккарти Ещё одна известная функция с вложенной рекурсией – «загадочная» функция-91 Маккарти, определяемая следующим образом: 10, 100,()( ( 11)), 100,nnfnffn n−>=+≤  где n – положительное целое число. Загадочность её в том, что совсем не просто представить её поведение при n ≤ 100. На рис. 11.3 приводится график этой функции для первых 110 положительных целых чисел. По- этому функцию можно переопределить как 10, 100,()91, 100.nnfnn−>=≤  11.3.3. Цифровой корень Цифровой корень неотрицательного целого числа n, обозначаемый здесь как d(n), вычисляется следующим образом. Сначала вычисляется сумма цифр исходного числа n, затем – сумма цифр полученной суммы и так далее до тех пор, пока очередная сумма не станет однозначным числом. Например, d(79868) = (7 + 9 + 8 + 6 + 8) = 38 → d(38) = (3 + 8) = 11 → d(11) = (1 + 1) = 2 → d(2) = 2. Размер задачи зависит от количества цифр n, а к начальному условию задачи мы, очевидно, приходим, когда n состоит из одной цифры.если если если если\n--- Страница 359 ---\n358  Глава 11. Вложенная рекурсия и снова хвостовая Рис. 11.3. Функция-91 Маккарти Для рекурсивного условия можно предложить два варианта. Во-пер- вых, по условию задачи n заменяется суммой своих цифр, что приводит к следующему определению цифрового корня: , 10,()( ( )), 10,nndndsn n< =≥  где s(n) – функция суммирования цифр неотрицательного целого числа (см. листинг 2.2). Заметьте, что это – хвостовая рекурсивная функция. Второй вариант подразумевает уменьшение размера задачи путём отбрасывания одной из цифр n. Рассмотрим следующую конкретную рекурсивную схему: Рекурсивное условие требует добавления последней цифры n к ре- зультату подзадачи и повторного применения того же метода. Таким образом, функцию можно определить исключительно через саму себя: , 10,()( ( //10) %10), 10,nndnddn n n< =+≥  что является примером вложенной рекурсии. Такую функцию легко за-кодировать (см. листинг 11.8). Наконец, функция d обладает многими свойствами, которые включают в себя вложенную рекурсию. Например, d(n + m) = d(d(n) + d(m)) или d(n · m) = d(d(n) · d(m)).если если если если+ 8, повторно применить dВходы Результаты n = 79868 2 3 n//10 = 7986n0 20 40 60 80 100100 95 90 8580f(n)\n--- Страница 360 ---\n11.4. К хвостовой и вложенной рекурсии через обобщённую функцию  359 Листинг 11.8. Метод с вложенной рекурсией для вычисления цифрового корня неотрицательного целого числа 1 23 4 5def digital_root(n): if n < 10: return n else: return digital_root(digital_root(n // 10) + n % 10) 11.4. К хвостовой и вложенной рекурсии через обобщённую функцию Мы видели, что хвостовые рекурсивные функции можно вывести, опи- раясь на итерационный подход или на готовую итерационную версию. В этом разделе мы увидим, что для некоторых простых вычислительных задач, содержащих формулы, можно создать те же хвостовые рекурсив-ные функции, но с использованием чисто декларативного подхода. Эта стратегия связана с формальными методами разработки программно-го обеспечения, которые выходят за рамки данной книги. Но суть её в том, что некоторые хвостовые рекурсивные функции реализуются с помощью обобщённых (расширенных) функций, решающих ту же за-дачу. Например, метод factorial_tail(n,p) из листинга 11.4 – обоб- щение функции факториала. Очевидно, при p = 1 метод вычисляет фак - ториал n, но при других значениях p он вычислит нечто иное. В данном случае нетрудно видеть, что метод вычисляет p · n!. Стратегия разра- ботки алгоритма, описанная в этом разделе, заключается в разработке таких обобщённых хвостовых рекурсивных функций с использованием рекурсивных понятий и элементарной алгебры. Кроме того, подобная методология может привести к неэффективным, но правильным вло-женным рекурсивным алгоритмам. 11.4.1. Факториал Естественное рекурсивное определение факториала n! = f(n) = n · f(n – 1) приводит к линейно-рекурсивной функции. Для создания хвостовой рекурсивной функции ей нужны дополнительные параметры, которые будут содержать информацию, необходимую для того, чтобы вернуть конечный результат в начальном условии. Например, можно ввести новую функцию g(n, p), которая включает новый параметр p и будет определяться своей формулой, зависящей от параметра p, но при этом\n--- Страница 361 ---\n360  Глава 11. Вложенная рекурсия и снова хвостовая позволит нам вычислить n!. Несколько вариантов обобщения функции факториала: g(n, p) = p · n!, (11.2) g(n, p) = p + n!, (11.3) g(n, p) = (n!)p. (11.4) Очевидно, что из каждой формулы легко получить факториал f(n), за- дав p = 1 в (11.2) и (11.4) или p = 0 в (11.3). 11.4.1.1. Приемлемые обобщения Первый шаг состоит в выборе конкретного обобщения, с которым мы будем работать. Из нескольких вариантов обобщения функции факто- риала сначала разберём g(n, p) = p · n!, так как он приводит к простому хвостовому рекурсивному алгоритму. Этот выбор объясняется ещё и тем, что другие обобщения обычно приводят к неэффективным и слож - ным вложенным рекурсивным функциям. Для построения рекурсивного алгоритма для g(n, p) можно действо- вать так же, как в предыдущих главах. Размер задачи – n. Поэтому на-чальное условие выполняется при n = 0, когда функция просто возвра- щает p (то есть g(0, p) = p). Для рекурсивного условия можно попытаться уменьшить n на 1, что привело бы к следующей рекурсивной схеме: Однако такая декомпозиция приводит не к хвостовому рекурсив- ному алгоритму, а к линейному, поскольку результат подзадачи здесь должен умножаться на n. В этом случае предыдущая схема бесполезна, потому что она не учитывает тот факт, что цель состоит в разработке хвостового рекурсивного метода, когда результат подзадачи должен со-впадать с результатом исходной задачи. Поскольку g(n, p) ≠ g(n – 1, p), то прежде всего должен быть изменён способ декомпозиции. Если мы хотим уменьшить размер задачи на 1, то должны использовать другое выражение для второго параметра. Например, g(n, p) = g(n – 1, q), где q – фиктивная переменная, представляющая собой выражение от вход-× nВходы Результаты (n, p) p · (n – 1)! (n – 1, p)p · n!g g\n--- Страница 362 ---\n11.4. К хвостовой и вложенной рекурсии через обобщённую функцию  361 ных параметров n и p. Теперь наша цель – определить q, которую можно найти, построив другую, но похожую схему: Во-первых, следует обратить внимание, что все элементы схемы рав- ны: g(n, p) = p · n! – определение обобщённой функции, тогда как g(n, p) = g(n – 1, q) должно быть хвостовым рекурсивным правилом. Применение определения g(n – 1, q) естественно приводит к g(n – 1, q) = q · (n – 1)!. Наконец, формулы в правой части схемы тоже должны быть равными и могут использоваться для получения q. В данном случае мы имеем: p · n! = q · (n – 1)!, откуда следует, что q = p · n. В итоге функция определяется следующим образом: , 0,(,)( 1, ), 0,png npgn pn n= =−⋅ >  что соответствует методу factorial_tail(n, p) в листинге 11.4 (а f(n) = g(n, 1) становится функцией-оболочкой). В этом случае параметр p – это результат использования обобщённой функции, а не переменная-нако-питель, как в итерационном алгоритме. 11.4.1.2. Неприемлемые обобщения Вообще говоря, если определение функции содержит произведение, то обобщение тоже должно включать произведение, умноженное на новый параметр. Точно так же, если функция содержит сумму, то обоб-щение должно добавлять дополнительный параметр. Это облегчает нахождение дополнительного параметра (в предыдущем примере – q) в подзадаче. Но не все обобщения приводят к хвостовым рекурсивным алгорит - мам. Например, рассмотрим g(n, p) = p + n!, использующую вместо про- изведения сумму. Во-первых, начальное условие было бы g(0, p) = p + 0! = p + 1. Для рекурсивного условия мы можем сформировать следующую диаграмму:если еслиРекурсивное условие Формулы g(n, p) = g · (n – 1)! g(n – 1, q) =p · n! q = p · n!⇒= =\n--- Страница 363 ---\n362  Глава 11. Вложенная рекурсия и снова хвостовая В этом случае определить q сложнее. Начав с q + ( n – 1)! = p + n!, мы получим: q = p + n! – ( n – 1)! = p + (n – 1) · (n – 1)! = p + (n – 1) · g(n – 1, 0), где последнее равенство следует из определения обобщения. Таким об- разом, функцию можно определить как 1, 0,(,)( 1, ( 1) ( 1, 0)), 0,png npgn p n gn n+==− + −⋅ − >  (11.5) что является примером вложенной рекурсии. Хотя алгоритм – правиль- ный, он не только более сложный, но ещё и менее эффективный. Его дерево рекурсии является полным двоичным деревом, из чего следует, что его временнáя сложность порядка Θ(2 n). Вариант g(n, p) = ( n!)p еще более затруднителен. Чтобы решить урав- нение ((n – 1)!)q = ( n!)p, нужно сначала прологарифмировать (осно- вание логарифма не имеет значения) обе его части. Это приводит к q log((n – 1)!) = p log(n!). Таким образом, мы имеем: q = p log(n!) / log((n – 1)!) = p (log(n) + log((n – 1)!)) / log((n – 1)!) = = p (log(n) / log((n – 1)!) + 1) = p (log(n) / log(g(n – 1, 1)) + 1). Это выражение верно только для n > 2 (обратите внимание, что невоз- можно получить q для (1!) q = (2!)p). Таким образом, для вывода правиль- ной функции нам потребуется несколько начальных условий, а саму функцию можно определить следующим образом: 1, 1, ( , ) 2 , 2, ( 1, (log( )/log( ( 1, 1)) 1), n g np p n gn p n gn≤ == −⋅ − + 2.n  >  Как видим, она тоже содержит вложенную рекурсию. Как и (11.5), она выполняется за экспоненциальное от n время. Кроме того, присутствие логарифмов означает, что она работает с вещественными числами если если если если еслиРекурсивное условие Формулы g(n, p) g + ( n – 1)! g(n – 1, q)p + n! q = ? == ⇒= =\n--- Страница 364 ---\n11.4. К хвостовой и вложенной рекурсии через обобщённую функцию  363 вмес то целых, и поэтому её результат должен округляться до ближай- шего целого числа. 11.4.2. Приведение десятичного числа к другому основанию Нам уже известны два способа создания алгоритма по преобразова- нию числа из одной системы счисления в другую. Листинги 4.10 и 11.6 содержат линейное и хвостовое рекурсивные решения соответственно. Теперь мы разработаем тот же хвостовой рекурсивный алгоритм, но с использованием обобщённой функции. Решение будет более сложным, поскольку нам потребуется два дополнительных параметра. Кроме того, гораздо сложнее будет и сама функция преобразования системы счисления, которую можно записать, например, следующим образом: 1 0( , ) 10m i i if nb d− ==⋅∑, где n – приводимое к основанию b десятичное число. Кроме того, m – количество цифр по основанию b в новом представлении n, а di (i = 0, …, m – 1) – цифры этого представления. К счастью, более точного опреде- ления этих цифр не требуется. Поскольку формула представляет собой сумму, мы можем начать с добавления к ней нового параметра s, что приводит к следующей обоб- щённой функции: 1 0( , , ) 10m i i ig nbs s d− ==+ ⋅∑ . Для уменьшения размера задачи на 1 в декомпозиции используется целочисленное деление n на b, что приводит к следующей схеме: Из неё следует, что: 11 1 0010 10mm ii ii iisd qd−− − ==+⋅ = +⋅∑∑ .Рекурсивное условие g(n, b, s) q = ? g(n//b, b, q)1 0( , , ) 10m i i ig nbs s d− ==+ ⋅∑ 11 1 0010 10mm ii ii iisd qd−− − ==+⋅ = +⋅∑∑Формулы == ⇒= =\n--- Страница 365 ---\n364  Глава 11. Вложенная рекурсия и снова хвостовая При попытке найти q сразу видно, что решение получается сложным: 1 1 0 0(10 10 ).m ii i iq sd d− − ==+ + ⋅ − ∑ (11.6) Но нетрудно заметить, что, умножив сумму подзадачи на 10, можно избавиться от суммы в формуле (11.6) и тем самым значительно упро- стить её. С этой целью можно добавить ещё один параметр – множитель суммы, – чтобы получить более общую функцию 1 0( , , , ) 10 .m i i ihnbps s p d− ==+⋅ ⋅ ∑ (11.7) Для этой новой функции можно создать следующую схему: В этом случае мы имеем: 11 1 0010 10 ,mm ii ii iis p d qr d−− − ==+⋅ ⋅ =+ ⋅ ⋅∑∑ где есть две фиктивные переменные r и q. Если задать r = 10 p, то выра- жение сокращается до 11 0010 10 ,mm ii ii iis pd q pd−− ==+⋅ ⋅ =+⋅ ⋅∑∑ откуда теперь можно легко найти q. А именно: q = s + p · d0 = s + p · ( n % b). Наконец, с учётом того, что начальное условие выполняется при n < b, где f(n, b) = n, начальным условием для h(n, b, p, s) должно быть s + p · n (это следует из (11.7) при m = 1 и d0 = n). Таким образом, функцию h мож - но определить так: , ,(,,,)( // , , 10 , ( % )), ,s pn n bhnbpshn b b p s p n b n b+⋅ < =+⋅ ≥ если еслиh(n, b, p, s) q = ?, r = ? h(n//b, b, r, q)1 0( , , , ) 10 .m i i ihnbps s p d− ==+⋅ ⋅ ∑ 11 1 0010 10 ,mm ii ii iis p d qr d−− − ==+⋅ ⋅ =+ ⋅ ⋅∑∑Рекурсивное условие Формулы == ⇒= =\n--- Страница 366 ---\n11.5. Упражнения  365 где f(n, b) = h(n, b, 1, 0). Второе начальное условие выполняется при n = 0, что приводит к функции из листинга 11.6. 11.5. Упражнения Упражнение 11.1. Отталкиваясь от итерационного решения, реализуй- те хвостовой рекурсивный алгоритм, вычисляющий сумму первых n (n ≥ 0) положительных целых чисел. В частности, рассмотрите, как ите-рационный алгоритм решил бы задачу с использованием перемен-ной-накопителя промежуточных сумм и окончательного результата. Наконец, выведите хвостовой рекурсивный алгоритм с использовани-ем обобщённой функции. Упражнение 11.2. Реализуйте хвостовую рекурсивную версию функ - ции из листинга 5.16 и напишите аналогичную итерационную функ - цию. Упражнение 11.3. Рассмотрите задачу сложения элементов списка a из n чисел. Создайте хвостовую рекурсивную функцию, применив обобщения. После чего преобразуйте её в итерационную. Упражнение 11.4. Применив обобщение, создайте хвостовую рекур- сивную функцию, вычисляющую степень b n, где b – вещественное чис - ло, а n – неотрицательное целое число. После этого преобразуйте её в итерационную. Упражнение 11.5. Создайте хвостовую рекурсивную функцию, вы- числяющую n-е число Фибоначчи (для n > 0), применив обобщение. В частности, используйте обобщённую функцию f(n, a, b) = G(n), которая задаёт последовательность, отвечающую рекурсивному правилу G(n) = G(n – 1) + G(n – 2), где G(1) = a и G(2) = b. После этого преобразуйте код в итерационную версию. Упражнение 11.6. Создайте функцию, вычисляющую n-е число Фи- боначчи F(n) (для n > 0), используя обобщённую функцию f(n, s) = s + F(n). Декомпозиция задачи должна уменьшать её размер на единицу. Упражнение 11.7. Для функции Аккермана (11.1) нарисуйте её дере- во активации на примере вызова A(2, 1).",
      "debug": {
        "start_page": 348,
        "end_page": 366
      }
    },
    {
      "name": "Глава 12. Множественная рекурсия III: перебор с возвратами 366",
      "content": "--- Страница 367 --- (продолжение)\nГлава 12 Множественная рекурсия III: перебор с возвратами Кто хочет найти жемчуг, должен нырнуть глубже. – Джон Драйден Перебор с возвратами (backtracking) – одна из самых важных парадигм разработки алгоритмов. Её можно считать «интеллектуальной» страте-гией грубой силы (решением «в лоб»), выполняющей исчерпывающий поиск решений задач с заданными ограничениями и задач дискретной оптимизации. Подход может использоваться для решения огромного числа головоломок и задач, включая задачи о восьми ферзях, поиска пути в лабиринте, судоку, оптимизации рюкзака 0–1 и многие другие. В самом общем случае методы перебора с возвратами сочетают в себе рекурсию и итерацию, имеют несколько параметров и обычно разраба-тываются без строгого следования парадигмам декомпозиции и индук - ции. Поэтому тем, кто изучает материал впервые, они могут показаться сложными. К счастью, все алгоритмы перебора с возвратами зачастую имеют схожую структуру, что позволяет облегчить их разработку. Эта структура зафиксирована в так называемых «шаблонах перебора с воз-вратами», которые зависят только от языка и стиля программирования. В этой книге все методы обладают вполне определённой структурой с большим множеством параметров, что придаёт им достаточно боль-шую степень свободы и лишь изредка требует дополнительных методов. При этом читатель должен отдавать себе отчёт в том, что существуют и другие варианты их реализации. Но в любом случае студенты могут от - носительно легко освоить перебор с возвратами, изучив приведённые ниже примеры и применив подобные алгоритмы к другим задачам.\nГлава 12 Множественная рекурсия III: перебор с возвратами Кто хочет найти жемчуг, должен нырнуть глубже. – Джон Драйден Перебор с возвратами (backtracking) – одна из самых важных парадигм разработки алгоритмов. Её можно считать «интеллектуальной» страте-гией грубой силы (решением «в лоб»), выполняющей исчерпывающий поиск решений задач с заданными ограничениями и задач дискретной оптимизации. Подход может использоваться для решения огромного числа головоломок и задач, включая задачи о восьми ферзях, поиска пути в лабиринте, судоку, оптимизации рюкзака 0–1 и многие другие. В самом общем случае методы перебора с возвратами сочетают в себе рекурсию и итерацию, имеют несколько параметров и обычно разраба-тываются без строгого следования парадигмам декомпозиции и индук - ции. Поэтому тем, кто изучает материал впервые, они могут показаться сложными. К счастью, все алгоритмы перебора с возвратами зачастую имеют схожую структуру, что позволяет облегчить их разработку. Эта структура зафиксирована в так называемых «шаблонах перебора с воз-вратами», которые зависят только от языка и стиля программирования. В этой книге все методы обладают вполне определённой структурой с большим множеством параметров, что придаёт им достаточно боль-шую степень свободы и лишь изредка требует дополнительных методов. При этом читатель должен отдавать себе отчёт в том, что существуют и другие варианты их реализации. Но в любом случае студенты могут от - носительно легко освоить перебор с возвратами, изучив приведённые ниже примеры и применив подобные алгоритмы к другим задачам.\n--- Страница 368 ---\n12.1. Введение  367 12.1. Введение В этом разделе излагаются основы метода перебора с возвратами и при- водится его краткий обзор на примере простой задачи о четырёх ферзях. Её цель – разместить четыре ферзя на шахматной доске размером 4×4 так, чтобы они не угрожали друг другу. Поскольку ферзи могут ходить по горизонтали, вертикали и диагонали, на любой из них не может нахо-диться более одного ферзя. На рис. 12.1 приведено одно из двух возмож - ных решений задачи. Естественно, задачу можно обобщить до размеще-ния n ферзей на шахматной доске размером n ×n (см. раздел 12.3). Рис. 12.1. Одно из решений задачи четырёх ферзей 12.1.1. Частичные и полные решения Перебор с возвратами – это общая стратегия решения вычисли- тельных задач, состоящая в выборе одного из конечного дискретного множества вариантов (элементов). Таким образом, формально говоря, перебор с возвратами – это стратегия поиска решения в «дискретном (конечном) пространстве состояний». Кроме того, это – метод решения «в лоб» в том смысле, что поиск является исчерпывающим. Другими словами, если решение существует, то алгоритм перебора с возвратами обязательно его найдёт. Метод ведёт поиск решения с созданием и обновлением частичного решения (partial solution), которое в итоге может стать правильным пол - ным решением (complete solution) задачи. Частичные решения создают - ся путём пошагового наращивания количества элементов-кандидатов (candidate) в последовательных рекурсивных вызовах. Таким образом, неявно подразумевается некий порядок следования кандидатов в ре-шении. В этом смысле частичное решение можно считать «префиксом» полного решения. Если полное решение задачи – список, то частичное решение – это просто его подсписок из нескольких первых элементов (светлая область на рис. 12.2(a)). Если же полное решение представляет\n--- Страница 369 ---\n368  Глава 12. Множественная рекурсия III: перебор с возвратами собой двумерную матрицу, то её элементы необходимо линейно упо- рядочить каким-то образом. Два самых естественных способа – упоря-дочить элементы матрицы по строкам или по столбцам, как показано на рис. 12.2(b) и рис. 12.2(c) соответственно. В этом случае частичное решение будет представлять собой множество из нескольких первых элементов матрицы, согласно выбранному линейному порядку. Рис. 12.2. Частичные решения внутри полных решений для списка или матрицы Ключевой момент перебора с возвратами – эффективная проверка частичного решения на соответствие заданным ограничениям задачи. Если она успешна, то появляется возможность довести частичное реше-ние до полного правильного решения. Если же правильное частичное решение после добавления к нему нового элемента оказывается недо-пустимым, алгоритм должен вернуться («откатиться») к другому, пре-дыдущему, правильному частичному решению и продолжить перебор других, ещё не рассмотренных вариантов. Таким образом, алгоритмы перебора с возвратами выполняют исчерпывающий перебор вариан-тов, но для некоторых задач могут оказаться довольно эффективными за счёт сокращения тех частичных решений, которые определённо не могут привести к правильным полным решениям. Первый вопрос при решении задач методом перебора с возврата- ми – выбор конкретной формы или структуры данных для решений. Как правило, они реализуются в виде списка или матрицы. В частности, для задачи размещения n ферзей первое, что приходит в голову, – это представить решения задачи в виде логической матрицы n×n, в которой n истинных значений соответствуют тем клеткам шахматной доски, где расположены ферзи. Частичные решения будут иметь ту же структуру, но включать меньше, чем n ферзей (разместив n-го ферзя, мы получим либо неправильное, либо полное решение задачи). Однако, несмотря на естественность и простоту матричного представления, такой выбор структуры данных нельзя признать удачным, поскольку он приводит к неэффективному алгоритму. Так как методы перебора с возвратами (a) (b) (c)00 0 1 11 22 2 3 4 5 6 34 5 63 4 5 6 798 107 9 8 10 11 12 13 14 15 1112 13 14 15\n--- Страница 370 ---\n12.1. Введение  369 выполняют исчерпывающий перебор, алгоритму для размещения оче- редного ферзя в одной из клеток шахматной доски придётся просмат - ривать всю матрицу по строкам или столбцам. Это займёт слишком много времени, ведь размещать ферзя, скажем, в столбце, где уже стоит ферзь, алгоритму нет необходимости. Вместо этого алгоритм должен просто перейти к следующему столбцу. Поэтому более подходящая структура данных для представления ре- шений этой задачи – простой список длины n. В этом случае индексы списка могут представлять номера вертикалей шахматной доски, а зна-чения элементов списка – номера горизонталей, где стоят ферзи. Дру - гими словами, если x – список, представляющий решение, и ферзь стоит в столбце (вертикали) i и строке (горизонтали) j, то x i = j. Например, если столбцы пронумерованы слева направо, а строки – сверху вниз, начиная с нуля, то решение на рис. 12.1 соответствует списку [1, 3, 0, 2]. Использу - ющий такой список алгоритм, (правильно) разместив ферзя в строке для определённого столбца (i ), может попытаться разместить ферзя в следу - ющем столбце (i + 1). Кроме того, он может отслеживать строки, где уже стоит ферзь, чтобы не размещать в них следующих ферзей. 12.1.2. Рекурсивная структура Чтобы понять принцип работы алгоритма перебора с возвратами, рассмотрим его дерево рекурсии. На рис. 12.3 приведено дерево рекур-сии для метода перебора с возвратами, который находит одно решение задачи четырёх ферзей. Рис. 12.3. Дерево рекурсии алгоритма перебора с возвратами, который находит одно из решений задачи четырёх ферзей0 1 2301 23 0 1 23 2 21\n--- Страница 371 ---\n370  Глава 12. Множественная рекурсия III: перебор с возвратами Корневой узел дерева представляет собой первый вызов метода, где частичное решение в виде квадратной доски размером 4×4 (но пред- ставленное списком) пусто. Все последующие вызовы метода выпол-няются в порядке прямого (preorder) обхода дерева рекурсии. Первый рекурсивный вызов, связанный с левым потомком корня, размещает ферзя (затенённая клетка доски) в первой строке первого столбца. Мет - ка «0» над ветвью дерева обозначает номер строки, на которую постав-лен ферзь. Поскольку это частичное решение удовлетворяет ограниче-ниям задачи, метод может продолжить размещение ферзей во втором столбце. В частности, он начинается с исключения попытки размеще-ния ферзя в первой строке, поскольку он там уже есть. Затем алгоритм проверяет, можно ли разместить ферзя во второй строке. Очевидно, что этого сделать нельзя, потому что два ферзя оказались бы на одной диагонали. Значит, такое частичное решение неверно, и алгоритм не должен рассматривать его дальше. Другими словами, он не выполняет последующих рекурсивных вызовов с таким (недопустимым) частич-ным решением. Такие ветви обозначены на рисунке пунктиром. Дальше метод ставит ферзя в третью строку, что приводит к пра- вильному частичному решению. Следовательно, алгоритм может по-пытаться разместить ферзя в третьем столбце. Очередная свободная строка – вторая, но эта попытка приводит к недопустимому частичному решению. Размещение ферзя в четвёртой строке также нарушает усло-вия задачи. Поскольку других вариантов нет, алгоритм «откатывается» к узлу с одним ферзём в первом столбце первой строки. Затем метод рассматривает все возможные частичные решения, которые возникают после размещения ферзя в 4-й строке 2-го столбца. Поскольку и в этом случае ни одного правильного решения нет, алгоритм вынужден будет вернуться к начальному узлу. Отметим, что на данном этапе метод вы-полняет полный перебор решений, когда ферзь стоит в первой строке первого столбца. На следующем этапе алгоритм продолжает перебор вариантов, начав с размещения ферзя на второй строке первого столб-ца. Та же самая процедура повторяется до тех пор, пока в конце концов метод не сможет разместить четырёх ферзей, которые не угрожают друг другу. В этом случае он может либо прекратить поиск, если требовалось найти только одно решение, либо продолжить его, чтобы найти все ре-шения. Дерево рекурсии демонстрирует также несколько особенностей алго- ритма. Во-первых, узлы соответствуют рекурсивным вызовам метода, для которых частичное решение (входной параметр метода) правильно. Маленькие темные узлы, «висящие» на пунктирных ветвях, обознача-\n--- Страница 372 ---\n12.2. Генерация комбинаторных объектов  371 ют возможные вызовы метода в тех случаях, когда соответствующие им частичные решения оказываются правильными. Кроме того, обратите внимание, что для каждого такого неосуществлённого рекурсивного вызова указан новый элемент, добавляемый к частичному решению. Другими словами, частичные решения из k элементов связаны с узла- ми глубины k. Следовательно, полные решения достигаются в листовых узлах глубины n. Таким образом, путь от корня до узла определяет час - тичное решение или, если узлом является лист, полное решение. На-пример, найденное алгоритмом решение [1, 3, 0, 2] – это список меток тех ветвей, по которым пролегает путь от корня до листа-решения. Кро-ме того, поскольку значения в списке всегда представляют только раз-личные строки, решение задачи четырёх ферзей – это фактически одна из перестановок номеров строк, то есть первых n неотрицательных це- лых чисел. Поэтому полное дерево перебора всех вариантов имело бы n! лис тьев, а это довольно большая величина даже для малых значений n. Однако на рис. 12.3 видно, что дерево рекурсии можно существенно со- кратить за счёт исключения из рассмотрения недопустимых частичных решений, что является ключевым моментом в построении эффектив-ных алгоритмов перебора. Подобные моменты будут выявляться и в других задачах и приме- рах этой главы. В частности, в задаче о размещении n ферзей, кото- рая вместе с кодом алгоритма её решения подробно разбирается в разделе 12.3. Или, например, дерево на рис. 8.18 может соответство-вать дереву рекурсии алгоритма поиска размещения с повторениями из четырёх элементов по два. Списки рядом с узлами можно считать частичными или полными решениями, а метки над ветвями – новы- ми элементами, добавляемыми к частичному решению. На практике сокращение деревьев рекурсии ради повышения эффективности алго-ритмов перебора с возвратами достигается за счёт отбрасывания не-допустимых решений. 12.2. Генерация комбинаторных объектов Мы только что узнали, что задача об n ферзях сводится к задаче о пере- становке первых n неотрицательных целых чисел, которая будет возни- кать во многих задачах. Кроме этого, большое число других задач сво-дится к нахождению различных подмножеств множества из n элементов. Поэтому важно знать, как генерировать перестановки и подмножества множества из n различных элементов. В этом разделе приводятся алго- ритмы, генерирующие такие комбинаторные объекты. Польза их в том,\n--- Страница 373 ---\n372  Глава 12. Множественная рекурсия III: перебор с возвратами что они могут послужить отправными точками при разработке алго- ритмов перебора с возвратами для многих других задач. Отметим, что эти алгоритмы не будут создавать списков или иных структур данных для хранения всех подмножеств или перестано-вок. Это было бы непрактично из-за большого количества вариантов (для множества из n различных элементов существует n! перестановок и 2 n подмножеств). Вместо этого методы будут использовать простой список, который содержит только одно частичное или полное решение (подмножество или перестановку) и обновляется в процессе выполне-ния алгоритма. Таким образом, методы будут выдавать все решения, не сохраняя их в единой структуре данных, а просто печатая их или под-считывая их количество во время выполнения. 12.2.1. Подмножества В этом разделе представлены две стратегии генерации всех подмно- жеств множества из n (различных) элементов, которое будет задаваться входным списком. В обоих методах дерево рекурсии будет двоичным, а решения (подмножества) будут представляться его листьями. В одном методе частичные решения имеют фиксированную длину n, тогда как в другом их длина меняется при выполнении рекурсивного вызова. 12.2.1.1. Частичные решения фиксированной длины На рис. 12.4 приведено двоичное дерево рекурсии алгоритма, генери- рующего восемь подмножеств, которые можно создать на множестве из трёх различных элементов. Рис. 12.4. Дерево рекурсии алгоритма генерации всех подмножеств множества из трёх элементов[-,-,-] [0,-,-] [1,-,-] [1,1,-] [1,0,-] [0,0,0] [0,0,1] [0,1,0] [0,1,1] [1,0,0] [1,0,1] [1,1,0] [ 1,1,1][0,0,-] [0,1,-] 1 00 00 1 1 0 1 01 1 0 1\n--- Страница 374 ---\n12.2. Генерация комбинаторных объектов  373 Каждое подмножество задаётся двоичным списком из n нулей или единиц (конечно, допускаются и логические значения). Например, для исходного списка элементов [a, b, c] список [1, 0, 1] будет обозначать подмножество {a, c}. Этот двоичный список – частичное решение, ко- торое становится полным по достижении методом листа дерева рекур-сии, а сами двоичные цифры – это элементы-кандидаты в процессе его формирования. При выполнении рекурсивного вызова метод просто добавляет нового кандидата (двоичная цифра над ветвью дерева) к час - тичному решению (указано рядом с узлом дерева), передаваемому ме-тоду в качестве аргумента. Исходная длина списка – n, но его элементы не определены. По достижении начального условия метод генерирует одно из 2 n возможных подмножеств в одном из листьев дерева рекур- сии. В этом случае список содержит n уже определённых элементов и представляет собой полное решение. В листинге 12.1 приведён алгоритм, соответствующий дереву ре- курсии на рис. 12.4 и печатающий каждое подмножество с помощью метода print_subset_binary . Кроме исходного множества (списка) из n элементов, процедура метода получает также список sol (частич- ное решение) из n элементов со значениями None, присвоенными ему в методе-оболочке generate_subsets_wrapper . Обратите внима- ние, что на каждом уровне метод, спускаясь вниз по дереву рекурсии, включает в частичное решение нового кандидата. По этой причине он использует третий параметр i – индекс элемента списка (частичного решения), куда будет помещена новая цифра 0 или 1. Кроме того, i также соответствует уровню узла рекурсивного вызова, отвечающего за добавление нового элемента в частичное решение. Поскольку ре- курсивный метод перебора с возвратами generate_subsets добавляет новую цифру 0 или 1, начиная с индекса 0 списка частичного реше- ния, в generate_subsets_wrapper индексу i присваивается начальное значение 0. Метод generate_subsets в строке 3 проверяет, является ли частичное решение sol полным, то есть совпадает ли значение i с n. Эта проверка отвечает начальному условию, когда метод должен просто напечатать решение (строка 5). В рекурсивном условии процедура должна дважды выполнить рекурсивный вызов, чтобы включить новых кандидатов в частичное решение. Это достигается простым циклом, в котором пере-менная k принимает значения 0 или 1 (строка 8), а элемент частичного решения sol[i] получает значение k (строка 11). Все алгоритмы пере- бора с возвратами в этой книге также будут использовать цикл для пе-\n--- Страница 375 ---\n374  Глава 12. Множественная рекурсия III: перебор с возвратами ребора всех возможных кандидатов, которых можно добавить к частич- ному решению. После этого процедура вызывает саму себя (строка 14) с изменённым частичным решением и увеличенным на 1 индексом i, чтобы добавить нового кандидата (если частичное решение ещё не ста-ло полным). Листинг 12.1. Печать всех подмножеств множества, заданного списком 1 23 4 567 8 9101112 13 141516 17 18192021 22 232425 26 27282930 31 323334 35def generate_subsets(i, sol, elements): # Base case if i == len(elements): # Print complete solution print_subset_binary(sol, elements) else: # Generate candidate elements for k in range(0, 2): # Include candidate in partial solution sol[i] = k # Expand partial solution at position i+1 generate_subsets(i + 1, sol, elements) # Remove candidate from partial solution sol[i] = None # optional def generate_subsets_wrapper(elements): sol = [None] * (len(elements)) generate_subsets(0, sol, elements) def print_subset_binary(sol, elements): no_elements = True print('{', end='') for i in range(0, len(sol)): if sol[i] == 1: if no_elements: print(elements[i], sep='', end='') no_elements = False else: print(', ', elements[i], sep='', end='') print('{')\n--- Страница 376 ---\n12.2. Генерация комбинаторных объектов  375 Строка 17 не обязательна, поскольку метод и без неё работает пра- вильно. Она включена в процедуру на тот случай, если такое действие понадобится в других алгоритмах перебора с возвратами. Обратите внимание, что когда определённый рекурсивный вызов в узле дерева завершается, управление передаётся его родителю, для которого по-зиция i частичного решения уже не имеет значения, и строка 17 явно отражает этот факт. Однако метод работает и без неё, потому что по достижении начального условия (когда частичное решение становит - ся полным) он всего лишь печатает подмножество, а присваивание в строке 11 просто обнуляет этот элемент при k = 1. Чтобы проследить изменения частичного решения, читателю рекомендуется выполнить программу шаг за шагом с помощью отладчика (со строкой 17 или без неё). Например, вызов generate_subsets_wrapper(['a','b','c']) даёт следующий результат: 12.2.1.2. Частичные решения переменной длины В предыдущем алгоритме частичные решения имели фиксирован- ную длину n. Такая процедура может работать со списками или мас - сивами, размер которых не меняется. В этом случае для указания ин-декса добавляемого к частичному решению элемента был необходим параметр i. Если же вместо частичных решений фиксированной длины использовать частичные решения переменного размера, то необходи-мость в параметре i отпадает. На рис. 12.5 приведено другое рекурсив- ное дерево с той же, как на рис. 12.4, структурой, однако метки (частич-ные решения) рядом с узлами (вызовами рекурсивного метода) теперь не содержат неопределённостей.{} {c} {b} {b, c}{a} {a, c} {a, b}{a, b, c}\n--- Страница 377 ---\n376  Глава 12. Множественная рекурсия III: перебор с возвратами Рис. 12.5. Двоичное дерево рекурсии альтернативного алгоритма генерации всех подмножеств множества из трёх элементов В листинге 12.2 приведён соответствующий этому подходу метод, ко- торый очень похож на код листинга 12.1. Листинг 12.2. Альтернативная печать всех подмножеств множества, заданного списком 1 23 4 567 8 9101112 13 141516 17 18192021 22def generate_subsets_alt(sol, a): # Base case if len(sol) == len(a): # Print complete solution print_subset_binary(sol, a) else: # Generate candidate elements for k in range(0, 2): # Include candidate in partial solution sol = sol + [k] # Expand partial solution at position i+1 generate_subsets_alt(sol, a) # Remove candidate from partial solution del sol[–1] def generate_subsets_alt_wrapper(elements): sol = [] generate_subsets_alt(sol, elements)[ ] [0] [1] [1,1] [1,0] [0,0,0] [0,0,1] [0,1,0] [0,1,1] [1,0,0] [1,0,1] [1,1,0] [ 1,1,1][0,0] [0,1] 1 00 00 1 1 0 1 01 1 0 1\n--- Страница 378 ---\n12.2. Генерация комбинаторных объектов  377 В начальном условии он просто печатает решение, если оно содержит n элементов. В рекурсивном условии он использует тот же цикл, в кото- ром в конец частичного решения он добавляет 0 или 1, а затем вызыва-ет сам себя. В этом случае код в строке 17 становится необходимым, так как метод должен «отменить» все изменения в частичном решении до рекурсивного вызова самого себя. Если в листинге 12.1 алгоритм обну - ляет единицу в частичном решении, то в данном случае метод должен сначала удалить 0 из списка, чтобы затем правильно добавить в него 1. Таким образом, вызов рекурсивного метода подразумевает добавление нового элемента к частичному решению (строка 14) и поэтому должен удалить старый элемент (строка 17) по возвращении из рекурсивного вызова. Строка 17 из листинга 12.1 имеет тот же смысл, но в ней нет необходимости. Что касается эффективности, то динамическое добав-ление элементов в структуру данных и их удаление из неё может за-нимать значительное время. Таким образом, зачастую лучше выделить для частичного решения фиксированный объём памяти и обновлять его, не меняя его размера. В этом отношении код в листинге 12.1 вы-полняется быстрее, чем метод generate_subsets_alt . Наконец, для этого альтернативного алгоритма метод-оболочка должен инициали-зировать частичное решение пустым списком. 12.2.2. Перестановки В этом разделе рассматриваются два схожих алгоритма, которые пе- чатают все возможные перестановки n различных элементов заданно- го списка (множества). В первом частичное решение (перестановка) представлено списком индексов от 0 до n – 1, указывающих на позиции элементов в исходном списке. Например, для исходного списка [a, b, c] частичное решение [1, 2, 0] означает перестановку [b, c, a]. Во всех после- дующих алгоритмах частичное решение (перестановка) будет состоять просто из элементов исходного списка (и пустых значений None ). На рис. 12.6 показана структура дерева рекурсии для такого алгоритма на примере списка [a, b, c]. Заметьте, что список с частичным решением имеет длину n, но толь- ко первые его элементы значимы. При первом вызове метода частич-ное решение пусто, то есть все его элементы установлены в None . Кро- ме того, процедуры получают (первоначально установленный в ноль) параметр i, который задаёт количество уже включённых в частичное решение элементов-кандидатов. Таким образом, он указывает место нового кандидата в частичном решении и уровень узла в дереве рекур-сии или глубину рекурсивного вызова.\n--- Страница 379 ---\n378  Глава 12. Множественная рекурсия III: перебор с возвратами Рис. 12.6. Дерево рекурсии алгоритма генерации всех перестановок множества из трёх элементов Метод начинается с добавления одного из n элементов-кандидатов исходного списка в первую позицию частичного решения. Поскольку вариантов всего n, корневой узел имеет n дочерних узлов. На следую- щем уровне дерева методы вызывают себя (n – 1) раз, так как элемент, помещённый в первую позицию, уже не может снова появиться в пе-рестановке. Точно так же на следующем уровне частичные решения содержат по два элемента, а методы вызывают себя (n – 2) раза. И так повторяется до тех пор, пока метод не достигает начального условия в листе дерева рекурсии, где частичные решения становятся полными перестановками. В следующих двух подразделах описываются способы проверки пра- вильности частичного решения в каждом из двух методов, в чём и за-ключается их основное различие. 12.2.2.1. Проверка правильности частичных решений без использования дополнительных структур данных В листинге 12.3 приводится первый метод, соответствующий дереву рекурсии на рис. 12.6. Поскольку i – это число элементов в частичном решении sol, первый условный оператор if выполняет проверку на- чального условия. Если результат – True , процедура просто печатает перестановку, сохранённую в sol. Иначе алгоритм в цикле начинает добавлять в частичное решение новых кандидатов из исходного спис - ка. Для каждого значения от 0 до n – 1 счётчика цикла k в роли индекса [-,-,-] [a,-,-] [c,-,-] [a,b,c] [a,c,b] [b,a,c] [b,c,a] [c,a,b] [c,b,a][a,b,-] b cb ca c a bc a c a b b a[b,-,-] [a,c,-] [b,a,-] [b,c,-] [c,a,-] [c,b,-]\n--- Страница 380 ---\n12.2. Генерация комбинаторных объектов  379 элемента списка алгоритм выполняет проверку на отсутствие канди- дата в частичном решении (строка 10). Стоит отметить, что, несмотря на лаконичность записи условия в строке 10, оно может потребовать в самом худшем случае i проверок значений кандидатов. Если канди- дата ещё нет в частичном решении, метод добавляет его (строка 13) и выполняет рекурсивный вызов с увеличением i на единицу (строка 16). Следующая за рекурсивным вызовом строка 19 с «отклонением» канди-дата не обязательна, так как метод всё равно перезаписывает значение sol[i] . Иными словами, нет нужды присваивать sol[i] значение None . Тем не менее эта строка включена в код, чтобы он точно соответствовал дереву рекурсии на рис. 12.6. Листинг 12.3. Печать всех перестановок элементов множества из списка 1 23 4 567 8 9101112 13 141516 17 18192021 22 232425 26 27282930def generate_permutations(i, sol, elements): # Base case if i == len(elements): print_permutations(sol) # complete solution else: # Generate candidate elements for k in range(0, len(elements)): # Check candidate validity if not elements[k] in sol[0:i]: # Include candidate in partial solution sol[i] = elements[k] # Expand partial solution at position i+1 generate_permutations(i + 1, sol, elements) # Remove candidate from partial solution sol[i] = None # not necessary def generate_permutations_wrapper(elements): sol = [None] * (len(elements)) generate_permutations(0, sol, elements) def print_permutations(sol): for i in range(0, len(sol)): print(sol[i], ' ', end='') print()\n--- Страница 381 ---\n380  Глава 12. Множественная рекурсия III: перебор с возвратами Метод generate_permutations_wrapper – это процедура-оболочка, необходимая для инициализации частичного решения n значениями None и вызова рекурсивного метода generate_permutations с нулевым значением i. В заключение код содержит процедуру печати через про- бел элементов списка (перестановки) sol. Итак, подобно остальным алгоритмам этой главы, метод использует цикл для подбора возможных кандидатов на включение в частичное решение. Без учёта проверок ограничений во внутренних узлах дерева данный алгоритм может привести к полному n-арному дереву рекур- сии (у каждого внутреннего узла дерева n дочерних узлов) с n n лис ть- ями. Конечно, можно проверять правильность частичных решений в каждом из этих nn листьев. Но гораздо лучше проверять допустимость кандидата во внутреннем узле и отказываться от ненужных рекурсив-ных вызовов, если алгоритм обнаруживает совершенно недопустимое частичное решение. Условие в строке 6 обеспечивает такую проверку и резко ускоряет алгоритм, сокращая дерево рекурсии, как показано на рис. 12.7. Более светлые узлы и ветви дерева – это те вызовы мето-да полного троичного дерева, которые не выполняются (сокращаются) благодаря условию в строке 6. Получающееся дерево рекурсии (изо-браженное более тёмными узлами и ветвями) становится идентичным изображённому на рис. 12.6 и содержит n! листьев. Хотя эта величина тоже внушительна даже для относительно малых значений n, она всё же значительно меньше n n. Рис. 12.7. Сокращение дерева рекурсии за счёт исключения недопустимых частичных решений 12.2.2.2. Проверка правильности частичных решений с использованием дополнительных структур данных Вместо проверки правильности частичного решения путём перебора его первых i значений (они должны отличаться от elements[k] ) код в [a,b,c] [a,c,b] [b,a,c] [b,c,a] [c,a,b] [c,b,a]b ca c c ac ab b abcba\n--- Страница 382 ---\n12.3. Задача n ферзей  381 листинге 12.4 использует дополнительный параметр – логический спи- сок available размера n, в котором хранятся признаки доступности эле- ментов исходного множества для включения их в частичное решение. Поэтому в методе-оболочке всем его n элементам изначально присваи- вается значение True . В этом случае условие в строке 10 становится го- раздо проще и может быть оценено по времени как Θ(1). Таким образом, если элемент k действительно доступен, процедура сначала включает его в частичное решение (строка 13) и делает его недоступным (строка 16), а затем уже вызывает саму себя с увеличением параметра i (строки 19 и 20). По завершении вызова выбранный кандидат снова должен стать доступным для включения в частичное решение (строка 23). Обратите внимание, что по завершении рекурсивного вызова метод может выпол-нить несколько больше итераций цикла, чтобы вставить другие элемен-ты в позицию i частичного решения, но перед этим список available должен быть приведён к своему начальному состоянию. В частности, available[k] должен быть установлен в True , так как алгоритму ещё придётся включать elements[k] в следующие позиции частичного ре- шения. В итоге, несмотря на дополнительный входной параметр, этот алгоритм эффективнее алгоритма из листинга 12.3. 12.3. Задача n ферзей Задача n ферзей была представлена ранее в разделе 12.1. Напомним, что это задача удовлетворения ограничений (constraint satisfaction) или соблюдения заданных условий, решение которой сводится к пере-становкам строк, в которых расположены ферзи. Поэтому для решения данной задачи методом перебора с возвратами можно использовать в качестве отправной точки код из листинга 12.4, генерирующий переста-новки. Хотя конечный алгоритм потребует некоторых модификаций, его структура будет очень похожа на метод генерации перестановок. Рассмотрим метод generate_permutations_alt и его входные па- раметры. Он переставляет элементы списка, которые могут содержать произвольные числа, символы или другие типы данных. В данном слу - чае перестановке подлежат горизонтали (строки) шахматной доски. Поскольку их номера – это просто целые числа от 0 до n – 1, можно на- писать код без применения списка. Но мы всё же будем использовать для частичного решения список sol номеров строк размера n, пара- метр i для номера столбца, в котором размещается очередной ферзь, а также логический список размера n available , в котором помечены свободные строки – кандидаты для включения в частичные решения.\n--- Страница 383 ---\n382  Глава 12. Множественная рекурсия III: перебор с возвратами Мы поменяем имя этого списка на free_rows , так как даже в отсут - ствие ферзя в строке она может быть недоступной для включения в частичное решение из-за дополнительного ограничения, связанного с диагональю. Листинг 12.4. Альтернативная печать всех перестановок элементов множества в списке 1 234 5 6789101112 13 14 15 1617181920212223 24 2526272829def generate_permutations_alt(i, available, sol, elements): # Base case if i == len(elements): print_permutations(sol) # complete solution else: # Generate candidate elements for k in range(0, len(elements)): # Check candidate validity if available[k]: # Include candidate in partial solution sol[i] = elements[k] # k-th candidate no longer available available[k] = False # Expand partial solution at position i+1 generate_permutations_alt(i + 1, available, sol, elements) # k-th candidate available again available[k] = True def generate_permutations_alt_wrapper(elements): available = [True] * (len(elements)) sol = [None] * (len(elements)) generate_permutations_alt(0, available, sol, elements) В дополнение к этим параметрам мы будем использовать ещё два логических списка для указания присутствия ферзя на диагоналях шахматной доски. Есть два вида диагоналей: a) основные, параллель-ные главной диагонали от верхнего левого угла до нижнего правого угла шахматной доски, и b) побочные, перпендикулярные основным.\n--- Страница 384 ---\n12.3. Задача n ферзей  383 Их ровно 2n – 1 каждого вида, как показано на рис. 12.8 для n = 4. Та - ким образом, мы будем использовать логические списки free_pdiags и free_sdiags – оба длиной 2n – 1, которые будут содержать True , если нет ферзей на основных и побочных диагоналях соответственно. На рисунке также показан способ нумерации диагоналей, где пара чисел внутри клетки задаёт номера её строки и столбца на доске. Заметим, что, с одной стороны, сумма номера столбца и номера строки клетки в каждой побочной диагонали постоянна. Она меняется в диапазоне от 0 до 2n – 2 и может служить индексом в free_sdiags . С другой сторо- ны, для каждой основной диагонали разность номера строки и номера столбца постоянна и меняется в диапазоне от –(n – 1) до n – 1. Поскольку индексы должны быть неотрицательными, можно просто увеличить эту разность на n – 1 и получить правильный индекс для основной диагона- ли, который после этого будет находиться в диапазоне от 0 до 2n – 2. Эти простые операции позволят нам по номеру строки и столбца быстро определить диагональ, на которой расположена клетка. Рис. 12.8. Индексированные основные и побочные диагонали матрицы или шахматной доски 12.3.1. Поиск всех решений В листинге 12.5 приведён рекурсивный алгоритм перебора с возвра- тами, который находит все решения задачи n ферзей. Для n = 8 возмож - но 92 решения, хотя только 12 из них действительно различны в том смысле, что не могут быть получены путём поворотов и отражений дру - гих решений. Основные диагонали Побочные диагонали столбец + строка + n –1 строка + столбец0,0 0,1 0,2 0,3 1,0 1,1 1,2 1,3 2,0 2,1 2,2 2,3 3,0 3,1 3,2 3,30,0 0,1 0,2 0,3 1,0 1,1 1,2 1,3 2,0 2,1 2,2 2,3 3,0 3,1 3,2 3,3 0 1 2 3 3 4 5 641 250 6\n--- Страница 385 ---\n384  Глава 12. Множественная рекурсия III: перебор с возвратами В начальном условии метод обрабатывает правильную перестановку, если она является полным решением (строки 6 и 7). Например, он мог бы печатать это решение (см. метод print_chessboard в листинге 12.6) или изображение шахматной доски с расположенными на ней ферзями. Цикл в строке 12 служит для перебора всех кандидатов на включение в частичное решение, а переменная цикла k представляет номера строк шахматной доски. Условный оператор в строках 16 и 17 проверяет, яв-ляется ли строка k правильным кандидатом для столбца i. В частности, он проверяет, что строка и соответствующие диагонали свободны (то есть не содержат ферзя). Если результат проверки – True , алгоритм мо- жет включить строку k в частичное решение (строка 20). Поскольку это подразумевает размещение нового ферзя на шахматной доске, необхо-димо обновить логические структуры данных, чтобы отразить тот факт, что строка и две диагонали теперь уже не свободны (строки 24–26). Пос ле этого метод может вызвать себя (строки 30 и 31) с изменёнными списками, чтобы продолжить размещение ферзей в следующем столбце (i + 1). Наконец, после рекурсивного вызова метод должен на следую щем шаге подготовить цикл для проверки возможности размещения ферзя в следующей строке. Для этого ему необходимо вернуть логичес кие спис - ки в то состояние, в котором они находились до включения строки k в частичное решение, то есть изменить значения в списках так, чтобы и сама строка k, и обе диагонали клетки в столбце i и строке k стали сво- бодными от ферзей (строки 37–39). 12.3.2. Поиск одного решения Во многих случаях представляет интерес найти только одно решение задачи, тем более что некоторые из них часто имеют единственное ре-шение (например, задача судоку). Поэтому имеет смысл разработать методы перебора с возвратами, которые прекращают поиск решений, как только одно из них найдено. В языке Python есть возможность применить оператор return (возврат) сразу после обнаружения ре- шения. Например, мы можем включать его сразу после вызова print_ chessboard(sol) в методе nqueens_all_sol из листинга 12.5. Однако во многих языках программирования этого делать нельзя. Существует множество способов реализовать программу поиска и обработки одного решения. В листинге 12.6 приводится один из та-ких способов, где рекурсивный метод представляет собой логическую функцию, возвращающую True , если решение найдено.\n--- Страница 386 ---\n12.3. Задача n ферзей  385 Листинг 12.5. Поиск всех решений задачи n ферзей 1 2 3 4 5 67 8 910 11 1213 14 1516 17 1819 20 2122 23 2425 26 2728 29 3031 32 3334 35 3637 38 3940 41 4243 44 4546 47def nqueens_all_sol(i, free_rows, free_pdiags, free_sdiags, sol): n = len(sol) # Test if the partial solution is a complete solution if i == n: print_chessboard(sol) # process the solution else: # Generate all possible candidate that could # be introduced in the partial solution for k in range(0, n): # Check if the partial solution with the # k-th candidate would be valid if (free_rows[k] and free_pdiags[i – k + n – 1] and free_sdiags[i + k]): # Introduce candidate k in the partial solution sol[i] = k # Update data structures, indicating that # candidate k in the partial solution free_rows[k] = False free_pdiags[i – k + n – 1] = False free_sdiags[i + k] = False # Perform a recursive call in order to include # more candidates in the partial solution nqueens_all_sol(i + 1, free_rows, free_pdiags, free_sdiags, sol) # Eliminate candidate k from the partial # solution, and restore the data structures, # indicating that candidate k is no longer # in the partial solution free_rows[k] = True free_pdiags[i – k + n – 1] = True free_sdiags[i + k] = True def nqueens_wrapper(n): free_rows = [True] * n free_pdiags = [True] * (2 * n – 1) free_sdiags = [True] * (2 * n – 1) sol = [None] * n nqueens_all_sol(0, free_rows, free_pdiags, free_sdiags, sol)\n--- Страница 387 ---\n386  Глава 12. Множественная рекурсия III: перебор с возвратами Листинг 12.6. Поиск одного решения задачи n ферзей 1 2 3 4 5 67 8 910 11 1213 14 1516 17 1819 20 2122 23 2425 26 2728 29 3031 32 3334 35 3637 38 3940 41 4243 44 4546 47def nqueens_one_sol(i, free_rows, free_pdiags, free_sdiags, sol): n = len(sol) sol_found = False if i == n: return True else: k = 0 while not sol_found and k < n: if (free_rows[k] and free_pdiags[i – k + n – 1] and free_sdiags[i + k]): sol[i] = k free_rows[k] = False free_pdiags[i – k + n – 1] = False free_sdiags[i + k] = False sol_found = nqueens_one_sol(i + 1, free_rows, free_pdiags, free_sdiags, sol) free_rows[k] = True free_pdiags[i – k + n – 1] = True free_sdiags[i + k] = True k = k + 1 return sol_found def nqueens_one_sol_wrapper(n): free_rows = [True] * n free_pdiags = [True] * (2 * n – 1) free_sdiags = [True] * (2 * n – 1) sol = [None] * n if nqueens_one_sol(0, free_rows, free_pdiags, free_sdiags, sol): print_chessboard(sol) def print_chessboard(sol): for i in range(0, len(sol)): print(sol[i], ' ', end='') print()\n--- Страница 388 ---\n12.4. Задача о сумме элементов подмножества  387 Он очень похож на код для поиска всех решений. С одной стороны, метод-оболочка nqueens_one_sol_wrapper вызывает в условном опе- раторе if рекурсивную функцию перебора с возвратами и выдаёт ре- шение, как только она смогла его найти. Отметим, что список sol ме- няется (его можно считать параметром, который передается по ссылке) и по завершении вызова метода будет содержать решение задачи, если оно существует. Другой вариант – выдать решение в начальном усло-вии рекурсивной функции перед возвратом из неё. С другой стороны, функция nqueens_one_sol сначала определяет логическую перемен- ную sol_found с начальным значением False – признак того, что ре- шение найдено. Цикл for заменён циклом while , чтобы завершить цикл, как только решение найдено. Тело цикла – то же, что в процедуре nqueens_all_sol , только результат рекурсивного вызова присваивает - ся переменной sol_found , значение которой возвращается по заверше- нии цикла while . 12.4. Задача о сумме элементов подмножества Цель этой задачи – в том, чтобы для заданного множества S из n по- ложительных целых чисел и заданного целого числа x найти в S такое подмножество, сумма элементов которого равна x. Формально, если si – i-е целое число множества S, то задача состоит в том, чтобы найти такое подмножество T ⊆ S, что: ii sTsx ∈=∑ . (12.1) В данном случае мы создадим алгоритм перебора с возвратами, печа- тающий все такие подмножества. Например, если S = {1, 2, 3, 5, 6, 7, 9} и x = 13, то метод должен вывести на экран следующие пять подмножеств: {6, 7}, {2, 5, 6}, {1, 5, 7}, {1, 3, 9} и {1, 2, 3, 7}. Простейшее решение задачи «в лоб» – это генерация всех возмож - ных подмножеств множества S с проверкой истинности требования (12.1). Такой полный перебор можно осуществить процедурой, подоб-ной generate_subsets из листинга 12.1. Множество S было бы входным списком элементов, а метод имел бы дополнительный параметр, в ко-тором хранится значение x. Кроме этого, процедура в начальном ус - ловии перед выводом подмножества на экран должна будет проверить ограничение (12.1). Иными словами, она должна проверять ограниче-ние (12.1) в каждом листе дерева рекурсии.\n--- Страница 389 ---\n388  Глава 12. Множественная рекурсия III: перебор с возвратами Однако даже при использовании перебора с возвратами существу - ет возможность ускорить поиск. В листинге 12.7 приводится одна из реа лизаций, где частичное решение ( sol) представляет собой подмно- жество T. Листинг 12.7. Решение задачи о сумме подмножества перебором с возвратами 1 234 5 6789101112 13 14 15 1617181920212223 24 252627282930def print_subset_sum(i, sol, psum, elements, x): # Base case if psum == x: print_subset_binary(sol, elements) elif i < len(elements)): # Generate candidates for k in range(0, 2): # Check if recursion tree can be pruned if psum + k * elements[i] <= x: # Expand partial solution sol[i] = k # Update sum related to partial solution psum = psum + k * elements[i] # Try to expand partial solution print_subset_sum(i + 1, sol, psum, elements, x) # not necessary: # psum = psum + k * elements[i] # Make sure a 0 indicates the absence of an element sol[i] = 0 def print_subset_sum_wrapper(elements, x): sol = [0] * (len(elements)) print_subset_sum(0, sol, 0, elements, x) Чтобы избежать вычисления суммы элементов частичного решения в каждом рекурсивном вызове, используется дополнительный пара- метр – переменная-накопитель суммы psum , которой, очевидно, в ме- тоде-оболочке нужно присвоить начальное значение 0. Ключевая идея алгоритма состоит в том, что дерево рекурсии можно сократить, если сумма элементов частичного решения равна x, когда выполнено тре-\n--- Страница 390 ---\n12.4. Задача о сумме элементов подмножества  389 бование (12.1), или больше x, когда добавление нового положительного целого числа из множества S к частичному решению только увеличи- вает его сумму (12.1). Прежде всего метод проверяет начальное условие (строки 3 и 4), когда на экран выводится подмножество (частичное решение), удов-летворяющее ограничению (12.1). Это позволяет сокращать дерево рекурсии в его внутренних узлах глубины i. В начальном условии в T могут входить только первые i элементов S. Другими словами, значи- мыми являются лишь первые i элементов частичного решения. Если n – i последних элементов могут принимать произвольные значения, то методу печати следовало бы передать значение i и указать «истин- ный» размер час тичного решения. Но вместо этого алгоритм вызывает метод print_subset_binary из листинга 12.1, который требует, чтобы эти последние значения были всегда равны нулю, указывая на то, что они не относятся к частичному решению T. Это требование обеспечи- вается в методе-обо лочке print_subset_sum_wrapper инициализаци- ей частичного решения n нулями, что равносильно пустому множеству, и обновлением частичного решения таким образом, чтобы последние его n – i элементов всегда оставались нулевыми при достижении на- чального условия (это реализуется присваиванием в строке 25). Если частичное решение из n элементов не отвечает требованию (12.1), метод просто завершается, не выполняя никаких действий. В против-ном случае при выполнении условия i < n (строка 5) он продолжает по- полнять частичное решение. В этом случае он использует цикл, где про-веряет два варианта – не включать ( k=0) или включать ( k=1) элемент si в частичное решение. Так как k – число, его можно использовать для вы- числения суммы psum + k*elements[i] частичного решения. Обратите внимание, что при k=0 она не меняется, тогда как при k=1 она увеличи- вается на si. Поэтому перед включением элемента в частичное решение и очередным рекурсивным вызовом в строке 10 проверяется, не превы-сила ли новая сумма значения x. Если это так, то в частичное решение включается новый кандидат (строка 13), psum обновляется (строка 16) и выполняется рекурсивный вызов (строка 19). После всех этих действий нет необходимости восстанавливать значение psum (в строке 22), так как в первой итерации цикла при k=0 значение psum не меняется. В заверше- ние алгоритм обнуляет значение позиции i частичного решения, чтобы правильно вывести на экран частичное решение в начальном условии (последние его n – i элементов всегда должны быть нулями). На рис. 12.9 приведено дерево рекурсии метода print_subset_sum для множества S = {2, 6, 3, 5} и x = 8. Частичные решения создаются на каж -\n--- Страница 391 ---\n390  Глава 12. Множественная рекурсия III: перебор с возвратами дом уровне, как в методах из раздела 12.2.1. Спускаясь по левой ветви дерева, алгоритм не включает элемент si в T, но включает его, спускаясь по правой ветви. Здесь числа рядом с узлами обозначают сумму вклю-ченных в частичные решения элементов ( psum ) при вызове метода. Об- ратите внимание, что дерево сокращается, как только найдено решение, удовлетворяющее условию (12.1), или сумма элементов в T превысила x. Рис. 12.9. Дерево рекурсии процедуры, решающей задачу суммы подмножества для множества S = {2, 6, 3, 5} и x = 8 В итоге вызов print_subset_sum_wrapper([2,6,3,5],8) приводит к правильному результату: В заключение отметим, что без обнуления в строке 25 частичное ре- шение {2, 6} попадёт в начальное условие с единицей в своей третьей позиции, и метод выведет на экран {2, 6, 3}. 12.5. Путь в лабиринте В этом разделе описывается алгоритм перебора с возвратами для поис - ка пути в лабиринте (рис. 12.10(a)), который представляет собой прямо-угольный массив клеток – пустых и непустых. Пустые клетки – это про-ходы по лабиринту, непустые – это его стены или перегородки. Мы же представим его в виде списка списков M (состоящего из символов), где первый список в списке – это верхний ряд (слева направо) клеток лаби-ринта, второй список – следующий под ним ряд и т. д. Чтобы задать ла-биринт, пользователю нужно записать каждый ряд клеток в виде строки {3,5}{2,6}6 20 00 2 3 6 5 0 5 390+2 ? +6 ?+3 ? +5 ?2 6 11 2 7 5 10 {3, 5} {2, 6}\n--- Страница 392 ---\n12.5. Путь в лабиринте  391 разделённых пробелом символов (см. рис. 12.10(b)), где 'E' обозначает пус - тую клетку, по которой можно пройти, a 'W' – стену. Поскольку большие лабиринты вводить вручную трудно, можно хранить массив символов в файле, который можно загрузить автоматически при выполнении про-граммы (что также удобно для отладки). Кроме самого лабиринта, методу нужны параметры, задающие клетки входа в лабиринт и выхода из него. На рисунке это верхняя левая и нижняя правая клетки соответственно. Таким образом, в данном примере начальная клетка – это M[0][0]. Алгоритм перебора с возвратами выполняет полный перебор путей, начинающихся в начальной клетке и заканчивающихся в конечной клетке. Достигнув на каком-то промежуточном шаге некоторой клетки, алгоритм должен рассмотреть каждое из четырёх возможных направ-лений продолжения пути к соседней клетке – вверх, вниз, вправо или влево. Поскольку конечная клетка находится в нижнем правом углу ла-биринта, алгоритм может начать поиск пути с попытки пойти сначала вниз, затем вправо, потом вверх и, наконец, влево. При таком порядке поиска пути метод выполнит шаги, показанные на рис. 12.10(c). Отме-тим, что, достигнув пустой клетки, метод сначала пытается продолжить путь вниз. Если это невозможно, он пытается сделать шаг вправо, затем вверх и, наконец, влево. Если это невозможно ни в одном из этих четы-рёх направлений, он должен «откатиться» назад к предыдущей клетке и попытаться найти другой путь. В нашем примере начальная клетка находится в позиции (0, 0) и соответствует строке 0 и столбцу 0. Метод помечает эту клетку как часть текущего пути, присваивая M[0][0] значе-ние 'P'. Первый шаг возможен только в клетку (1, 0), которая тоже поме-чается символом 'P'. Из неё метод пытается продвинуться вниз, но на-тыкается на стену в клетке (2, 0). Поскольку дальше пути нет, алгоритм делает попытку шагнуть вправо, которая возможна, так как клетка (1, 1) пуста. Достигнув в какой-то момент клетки (6, 0), метод продолжит по-иск пути с попытки пойти вниз. Этот путь приведёт его к тупиковой клетке (9, 0): снизу и справа – стены, слева – граница лабиринта, за пре-делы которого выходить нельзя, а сверху – клетка, заведшая метод в этот тупик. Поскольку алгоритм не может продвинуться ни в одном из направлений, он «откатывается» к клетке (8, 0), где он еще не пытался двигаться вправо, вверх или влево. Однако эти варианты тоже оказы-ваются недопустимыми. То же самое происходит и после «отката» к клетке (7, 0). И только после возврата к клетке (6, 0) и исчерпывающе-го анализа всех возможных путей вниз от неё появляется возможность исследовать новые пути, ведущие от неё вправо. Этот процесс повторя-ется до тех пор, пока алгоритм не найдёт конечную клетку выхода из\n--- Страница 393 ---\n392  Глава 12. Множественная рекурсия III: перебор с возвратами лабиринта. Решение приведено на рис. 12.10(d), где все исследованные в процессе поиска выхода клетки затенены. Рис. 12.10. Задача поиска пути в лабиринте и её решение перебором с возвратами при определённом порядке поиска(a) (b) (c) (d)Вход Вход ВходВыход Выход ВыходПустая клетка Процесс поиска Исследованные клеткиПуть клетки в лабиринтеСтена Порядок поиска: ↓, →, ↑, ← Порядок поиска: ↓, →, ↑, ←\n--- Страница 394 ---\n12.5. Путь в лабиринте  393 Алгоритм перебора с возвратами может либо прекратить поиск ре- шений, когда найдено одно из них, либо продолжить поиск других воз- можных решений. Мы рассмотрим алгоритм, который останавливает - ся, как только находит путь в лабиринте. В связи с этим нужно иметь в виду, что порядок рассмотрения возможных направлений движения может приводить к различным решениям, как показано на рис. 12.11. Обратите внимание, что множества исследуемых в каждом случае кле-ток различны. Рис. 12.11. Различные пути в лабиринте в зависимости от порядка поиска Очевидно, что решение этой задачи не сводится к перестановкам клеток. Это видно хотя бы из того, что длина пути (то есть решение) непостоянна. Более того, хотя путь состоит из подмножества множест - ва клеток лабиринта, эти подмножества являются упорядоченными. Значит, свести решение к генерации подмножеств множества тоже не удастся. По этим причинам мы представляем решение в виде символь-ной матрицы, в которой клетки определённого пути помечаются сим-волом 'P'. Таким образом, частичное решение будет представлять собой исходный лабиринт, включающий путь от начальной клетки до некото-рой пустой клетки, по достижении которой метод должен выбрать одну из четырёх клеток-кандидатов на включение её в частичное решение. Следовательно, мы приходим к рекурсивной декомпозиции задачи, по-казанной на рис. 12.12, где r и c обозначают конкретные строку и стол- бец соответственно. Каждый узел дерева рекурсии будет иметь четыре дочерних узла, соответствующих четырём возможным направлениям движения. При этом алгоритм, прежде чем выполнить рекурсивный Вход Вход Выход ВыходПорядок поиска: → , ↑, ←, ↓ Порядок поиска: ← , ↑, →, ↓\n--- Страница 395 ---\n394  Глава 12. Множественная рекурсия III: перебор с возвратами вызов с расширенным частичным решением, должен убедиться, что новая клетка пуста. Рис. 12.12. Декомпозиция задачи поиска пути в лабиринте В листинге 12.8 приводится одна из реализаций алгоритма решения задачи методом перебора с возвратами. Параметры метода-оболочки – исходный лабиринт и четыре целых числа, которые задают координа-ты начальной ( enter_row , enter_col ) и конечной ( exit_row , exit_col ) клеток лабиринта. Кроме того, в нём объявляется список incr , опреде- ляющий направления движения при поиске пути, а также порядок вы-бора этих направлений. Каждая пара (x, y) в списке задаёт приращение номера столбца c и номера строки r клетки для перемещения из неё в новую соседнюю клетку с координатами (c + x, r + y). Порядок следова- ния пар в списке определяет последовательность выбора направления поиска в этом алгоритме: вниз, вправо, вверх и влево. Заметьте, что до-бавление единицы к номеру строки означает движение вниз (поскольку первая строка расположена наверху лабиринта), тогда как добавление единицы к столбцу – движение вправо. В заключение метод-оболочка включает пустую начальную клетку в искомый путь в качестве первого шага к цели и возвращает (логическое) значение результата вызова ре-курсивного метода перебора с возвратами. Первый параметр M рекурсивного метода find_path_maze – это од - новременно и исходный лабиринт, и частичное решение. Следующие два параметра – координаты последней клетки частичного пути в M, из которой алгоритм попытается расширить частичный путь переме-щением в одну из соседних клеток последней клетки. Последние три параметра метода – это incr и координаты конечной клетки выхода из лабиринта.Задача Подзадача Подзадача Подзадача Подзадача(c, r) (c, r + 1) (c, r – 1) (c + 1, r) (c – 1, r)\n--- Страница 396 ---\n12.5. Путь в лабиринте  395 Листинг 12.8. Перебор с возвратами для поиска пути в лабиринте 1 23 4 5 6 7 8 9 10 1112 1314 1516 17 18 19 20 21 2223 24 25 26 27 28 2930 3132 3334 35 36 37 38 39 4041 42 43 44def find_path_maze(M, row, col, incr, exit_row, exit_col): # Base case: check if path found if row == exit_row and col == exit_col: return True # Solution found else: sol_found = False # Generate candidates k = 0 while not sol_found and k < 4: # New candidate cell new_col = col + incr[k][0] new_row = row + incr[k][1] # Test candidate validity if (new_row >= 0 and new_row < len(M) and new_col >= 0 and new_col < len(M[0]) and M[new_row][new_col] == 'E'): # Add to path (partial solution) M[new_row][new_col] = 'P' # Try to expand path starting at new cell sol_found = find_path_maze( M, new_row, new_col, incr, exit_row, exit_col) # Mark as empty if new cell not in solution if not sol_found: M[new_row][new_col] = 'E' k = k + 1 return sol_found def find_path_maze_wrapper(M, enter_row, enter_col, exit_row, exit_col): # search directions incr = [(0, 1), (1, 0), (0, –1), (–1, 0)] M[enter_row][enter_col] = 'P' return find_path_maze(M, enter_row, enter_col, incr, exit_row, exit_col)\n--- Страница 397 ---\n396  Глава 12. Множественная рекурсия III: перебор с возвратами Рекурсивная функция find_path_maze возвращает True , как только находит путь в лабиринте M. Она объявляет переменную sol_found с начальным значением False , которое меняется на True в начальном условии, когда алгоритм находит полное решение. В противном случае (случае рекурсивного условия) для генерации четырёх клеток-кандида-тов она использует условный цикл while , который заканчивается, как только решение найдено. Переменные new_col и new_row определяют нового кандидата (строки 12 и 13), который сразу проверяется на пра-вильность. В частности, он не должен выходить за пределы лабиринта (строки 16 и 17) и должен быть пустым (строка 18) 1. Если клетка не на- рушает ограничений задачи, метод присоединяет её к пути (строка 21) и в строках 24–26 вызывает сам себя, сохраняя результат вызова в sol_ found . Если решение не найдено, метод возвращает ей прежнее пустое значение 'E', исключая её таким образом из пути (строка 30). Это дей-ствие необходимо, так как в полном решении пометку 'P' могут иметь только клетки, образующие путь через лабиринт. Без этого действия все исследуемые клетки содержали бы символ 'P'. По завершении цикла ме-тод просто возвращает значение sol_found (строка 34). Листинг 12.9 служит необходимым дополнением к основному листин- гу 12.8. В нём приведён вспомогательный код, запускающий и выпол-няющий основной код, а также заполняющий и рисующий лабиринт. Метод read_maze_from_file считывает текстовый файл с определением лабиринта и возвращает соответствующий ему список списков. Бóль-шую часть кода занимает итерационная процедура draw_maze , которая рисует лабиринт, используя пакет Matplotlib . В последних строках кода лабиринт считывается из файла и рисуется, если путь от его на-чальной (верхней левой) до конечной (нижней правой) клетки найден. 12.6. Судоку Головоломка судоку – из разряда так называемых задач удовлетворения ограничений. Её цель состоит в том, чтобы заполнить сетку 9×9 цифра-ми от 1 до 9 (или любыми другими девятью различными символами, так как их числовые значения не важны). Каждая из цифр может появиться только однажды в каждой строке, каждом столбце и каждой из девяти неперекрывающихся подсеток размером 3×3, называемых также бло-ками, которые покрывают сетку 9×9. На рис. 12.13 показан экземпляр задачи с частично заполненной исходными цифрами сеткой. Правиль- 1 Если лабиринт по всему его периметру, за исключением входа и выхода, охватить стеной из непустых клеток, то строки 16 и 17 станут ненужными. – Прим. перев.\n--- Страница 398 ---\n12.6. Судоку  397 но поставленная задача должна иметь только одно решение (начальная сетка должна содержать не меньше 17 цифр). Листинг 12.9. Вспомогательный код для поиска пути в лабиринте методом перебора с возвратами 1 234567891011 12 13 141516 17 18 192021 22 23 242526 27 28 293031 32 33 343536 37 38 394041 42 43 444546 47 48 495051 52import matplotlib.pyplot as plt from matplotlib.patches import Rectangle def read_maze_from_file(filename): file = open(filename, 'r') M = [] for line in file.readlines(): M.append([x[0] for x in line.split(' ')]) file.close() return M gray = (0.75, 0.75, 0.75) black = (0, 0, 0)red = (0.75, 0, 0)green = (0, 0.75, 0) def draw_maze(M, enter_row, enter_col, exit_row, exit_col): nrows = len(M) ncols = len(M[0]) fig = plt.figure() fig.patch.set_facecolor('white') ax = plt.gca() if enter_row is not None and enter_col is not None: ax.add_patch(Rectangle((enter_col, nrows – enter_row), 1, –1, linewidth=0, facecolor=green, fill=True)) if exit_row is not None and exit_col is not None: ax.add_patch(Rectangle((exit_col, nrows – exit_row), 1, –1, linewidth=0, facecolor=red, fill=True)) for row in range(0, nrows): for col in range(0, ncols): if M[row][col] == 'W': ax.add_patch(Rectangle((col, nrows – row), 1, –1, linewidth=0, facecolor=gray)) elif M[row][col] == 'P': circ = plt.Circle((col + 0.5, nrows – row – 0.5), radius=0.15, color=black, fill=True) ax.add_patch(circ) ax.add_patch(Rectangle((0, 0), ncols, nrows, edgecolor=black, fill=False)) plt.axis('equal') plt.axis('off') plt.show() M = read_maze_from_file('maze_01.txt') # some file # Enter at top-left, exit bottom-rightif find_path_maze_wrapper(M, 0, 0, len(M) – 1, len(M[0]) – 1): draw_maze(M, 0, 0, len(M) – 1, len(M[0]) – 1)\n--- Страница 399 ---\n398  Глава 12. Множественная рекурсия III: перебор с возвратами Рис. 12.13. Задача судоку и ее решение Для представления сетки судоку мы будем использовать список спис ков цифр, где цифра 0 будет обозначать пустую клетку. Частичные решения будут частично заполненными сетками, а алгоритм должен неким образом пронумеровать все клетки сетки, чтобы можно было расширять частичные решения новыми цифрами. Приводимый ниже алгоритм будет расширять частичные решения в порядке следования строк, начав добавлять цифры-кандидаты с верхнего ряда сетки слева направо и так далее для каждой последующей строки. Таким образом, алгоритм найдёт решение, если сумеет поместить правильную цифру в последнюю клетку последней строки. В рекурсивном условии метод генерирует девять возможных кан- дидатов для заполнения пустой клетки. Таким образом, каждый узел дерева рекурсии мог бы иметь до девяти дочерних узлов, как показа-но на рис. 12.14(a). Однако у этой задачи есть особенность, которая не встречалась ни в одной из предыдущих задач: присутствие в частичном решении (сетке) заранее заданных фиксированных элементов (клеток с цифрой). Это значит, что при обработке клетки с цифрой алгоритм должен просто пропустить её (без расширения частичного решения) и выполнить рекурсивный вызов, обрабатывающий следующую клетку. Это требует включения второго рекурсивного условия, которое приве-дено на рис. 12.14(b). В листингах 12.10 и 12.11 приводится решающая задачу процедура перебора с возвратами и несколько вспомогательных функций. Ре-курсивная процедура solve_sudoku_all_solutions допускает в том числе и неправильную постановку задачи, когда она может иметь несколько решений или даже ни одного. Таким образом, процедура выдаёт все правильные решения задачи для заданной сетки судоку. Задача судоку Решение1 28 9 1 2 891 28 76 34 5 7 6 345 76 6 45 76 3 4 51 28 9 1 2 891 28 76 34 5 7 6 345 76 6 45 76 4 51 2 89 128 9 12 87 63 457 6 34 5 7 66 4 57 4 5 1289 12 89 1 283 5 7 349 93 39\n--- Страница 400 ---\n12.6. Судоку  399 Например, если верхний ряд судоку на рис. 12.13 заменить пустой строкой, то существует 10 различных способов заполнения цифрами сетки судоку. (a) (b)Заданная начальная цифра 12 89 … Рис. 12.14. Рекурсивные условия при решении судоку Параметры рекурсивной процедуры – пара координат ( row и col) клетки, куда она пытается внести цифру для расширения частичного решения, а также само частичное решение S, представленное списком списков цифр. Так как процедура расширяет частичное решение по-строчно, начиная с клетки (0, 0), правильное решение достигается при row = 9. При выполнении начального условия она просто выводит сетку судоку (строка 4). В противном случае метод проверяет, не заполнена ли текущая клетка, то есть не содержит ли она одну из заранее заданных фиксированных цифр. Если да, то такая клетка пропускается и проце-дура вызывает себя (строка 14) с координатами (вычисленными в стро-ке 11) следующей по порядку клетки. Во втором рекурсивном условии процедура использует цикл для ге- нерации девяти возможных кандидатов на включение в пустую клет - ку. Затем в строке 20 она проверяет, можно ли включить кандидата k в клетку ( row, col) частичного решения S. Если можно, то процедура включает кандидата в частичное решение (строка 23) и продолжает ра-боту, выполняя рекурсивный вызов со следующей клеткой (строка 29). По завершении цикла процедура должна отменить произведённые в клетке изменения, сделав её пустой (строка 32). Это необходимо для по-следующего анализа решений. Отметим, что клетка должна быть пус - той, чтобы алгоритм мог снова обработать её после отката к одной из предыдущих клеток. Вспомогательные функции: a) функция, возвращающая пару коор- динат следующей по порядку клетки (см. листинг 12.10); b) функция, определяющая, нарушает ли размещённая в некоторой строке и столб-це цифра ограничения задачи, где переменные box_row и box_col за- дают верхнюю левую клетку блока 3×3; c) функция, считывающая сетку судоку из текстового файла, каждая строка которого содержит девять\n--- Страница 401 ---\n400  Глава 12. Множественная рекурсия III: перебор с возвратами строк цифр исходного судоку, разделённых символом пробела; d) метод для вывода сетки; e) код, считывающий и решающий судоку. Листинг 12.10. Решение задачи судоку 1 23 4 567 8 9101112 13 141516 17 18192021 22 232425 26 27282930 31 323334 35 36373839 40def solve_sudoku_all_sols(row, col, S): # Check if sudoku is complete if row == 9: print_sudoku(S) # print the completed sudoku print() else: # Check if digit S[row][col] is an initial fixed symbol if S[row][col] != 0: # Advance to a new cell in row-major order (new_row, new_col) = advance(row, col) # Try to expand the partial solution solve_sudoku_all_sols(new_row, new_col, S) else: # Generate candidate digits for k in range(1, 10): # Check if digit k is a valid candidate if is_valid_candidate(row, col, k, S): # Include digit in cell (row, col) S[row][col] = k # Advance to a new cell in row-major order (new_row, new_col) = advance(row, col) # Try to expand the partial solution solve_sudoku_all_sols(new_row, new_col, S) # Empty cell (i, j) S[row][col] = 0 # Compute the next cell in row-major order def advance(row, col): if col == 8: return (row + 1, 0) else: return (row, col + 1)\n--- Страница 402 ---\n12.6. Судоку  401 Листинг 12.11. Вспомогательные функции для решения задачи судоку 1 23 4 5 6 7 8 9 10 1112 1314 1516 17 18 19 20 21 2223 24 25 26 27 28 2930 3132 3334 35 36 37 38 39 4041 42 43 44import math # Check if the digit at cell (row, col) is valid def is_valid_candidate(row, col, digit, S): # Check conflict in column for k in range(0, 9): if k != col and digit == S[row][k]: return False # Check conflict in row for k in range(0, 9): if k != row and digit == S[k][col]: return False # Check conflict in box box_row = math.floor(row / 3) box_col = math.floor(col / 3) for k in range(0, 3): for n in range(0, 3): if (row != 3 * box_row + k and col != 3 * box_col + m): if digit == S[3 * box_row + k][3 * box_col + m]: return False return True# Read a sudoku grid from a text file def read_sudoku(filename): file = open(filename, 'r') S = [[None] * 9] * 9 i = 0 for line in file.readlines(): S[i] = [int(x) for x in line.split(' ')] i = i + 1 file.close() return S # Print a sudoku grid on the console def print_sudoku(S): for s in S: print (*s) S = read_sudoku('sudoku01_input.txt') # Some file solve_sudoku_all_sols(0, 0, S)\n--- Страница 403 ---\n402  Глава 12. Множественная рекурсия III: перебор с возвратами 12.7. Задача о рюкзаке 0–1 Алгоритмы перебора с возвратами применяются также для решения задач оптимизации. В задаче о рюкзаке 0–1 у нас есть множество из n предметов со стоимостями vi и весами wi, где i = 0, …, n – 1. Цель зада- чи – найти такое подмножество предметов, чтобы их суммарный вес не превышал грузоподъёмности C рюкзака, а суммарная стоимость была максимальной. Формально задачу оптимизации можно записать так: максимизировать 1 0n ii ixv− =∑ при условии, что 1 0n ii ixw− =∑ ≤ C, где xi ∈ {0, 1} для i = 0, …, n – 1. Вектор или список x = [ x1, …, xn] – переменная величина задачи (её частичное решение), компоненты которой могут принимать значения 0 или 1. В частности, xi = 1 означает, что предмет под номером i помещён в рюкзак. Таким образом, x играет ту же роль, что и двоичный список в задаче генерации подмножеств или в задаче о сумме подмножества. Сумма 1 0n ii ixv− =∑ называется целевой функцией и просто суммирует сто- имости находящихся в рюкзаке предметов, а ограничение 1 0n ii ixw− =∑ ≤ C означает, что сумма их весов не может превышать грузоподъёмности C рюкзака. В следующих подразделах описываются два подхода, выполняющих полный перебор для поиска оптимального решения. Первым является стандартный алгоритм перебора с возвратами, который сокращает де- рево рекурсии, когда частичное решение не удовлетворяет ограничени-ям задачи (то есть сумма весов превышает грузоподъёмность рюкзака). Второй подход использует широко известный метод ветвей и границ, тесно связанный с методом перебора с возвратами. Метод также улуч-шает поиск за счёт сокращения дерева рекурсии, но только тогда, когда обнаруживает, что не в состоянии улучшить путём расширения некото-рого частичного решения лучшее решение, найденное на предыдущих шагах. 12.7.1. Стандартный алгоритм перебора с возвратами Поскольку решением задачи является подмножество множества из n предметов, можно разработать алгоритм, дерево рекурсии которого подобно двоичным деревьям рекурсии алгоритмов генерации подмно-жеств или сумм подмножеств. На рис. 12.15 приводится дерево рекурсии\n--- Страница 404 ---\n12.7. Задача о рюкзаке 0–1  403 для весов w = [3, 6, 9, 5], стоимостей v = [7, 2, 10, 4] и грузоподъёмности рюкзака C = 15, которые будут входными параметрами рекурсивного метода. (a) (b)x = остаточная вместимость y = частичное значение 0: не включать объект i 1: включить объект i Оптимальное решение: [1,0,1,0]w = [3, 6, 9, 5] v = [7, 2, 10, 4] C = 15x yx – wi y + vi 15 0 15 0 15 0 15 012 7 12 7 12 7 12 715 09 2 92 9269 69 696 10 6 100 12 0 123 17 3 17–3 19 10 41 1446 7 111 13–5 16–2 211 10 0 Рис. 12.15. Дерево рекурсии алгоритма перебора с возвратами для задачи о рюкзаке 0–1 Узлы дерева – это вызовы метода с конкретным частичным решени- ем в качестве параметра, а числа в узлах – это весовой остаток рюк -\n--- Страница 405 ---\n404  Глава 12. Множественная рекурсия III: перебор с возвратами зака и суммарная стоимость уже помещённых в него предметов (см. рис.12.15(a)). Для каждого индекса i в частичном решении алгоритм либо не помещает (левый потомок узла), либо помещает (правый пото-мок узла) предмет в рюкзак. Если предмет не помещён в рюкзак, то обе величины в дочернем узле не меняются. Если же предмет помещён в рюкзак, то весовой остаток рюкзака уменьшается на w i, а его суммарная стоимость увеличивается на vi. Поскольку алгоритм решает задачу оптимизации, он должен хранить найденное на предыдущих шагах лучшее решение, чтобы обновлять его при обнаружении ещё лучшего решения. Полное дерево рекурсии приведено на рис. 12.15(b), где затемнённые узлы обозначают вызовы метода, которые обновляют это лучшее реше-ние. Если оптимальной суммарной стоимости рюкзака сразу присвоить отрицательное начальное значение, то метод обновит оптимальное ре-шение уже в первом листе дерева. В этом случае частичное решение бу - дет пустым множеством, а суммарная стоимость – нулевой. Продолжив обход дерева, метод обновит лучшее решение после добавления в рюк - зак самого последнего предмета (w 3 = 5 и v3 = 4) так, что весовой остаток рюкзака в листовом узле будет равен 10, а общая стоимость частично-го решения – 4. В процессе решения задачи лучшее решение будет об- новлено ещё трижды для суммарных стоимостей 10, 14 и 17. Последнее обновление, естественно, даст оптимальное решение задачи. В данном случае это подмножество, состоящее из первого и третьего предметов, а максимальная сумма стоимостей – 17. В заключение важно отметить, что метод сокращает двоичное дерево рекурсии в тех случаях, когда весовой остаток рюкзака для частичного решения (и узла) – отрица-тельный. В листинге 12.12 приведена возможная реализация алгоритма пере- бора с возвратами. Во-первых, подобно другим методам, его входные параметры включают частичное решение sol и индекс i предмета, ко- торый можно поместить в рюкзак. Метод получает ещё списки весов w и стоимостей v, а также грузо- подъёмность рюкзака C. По этим параметрам можно на любом шаге вычислить и весовой остаток, и суммарную стоимость предметов в рюкзаке. Но гораздо эффективнее ввести для хранения этих вели-чин два дополнительных параметра w_left – для весового остатка и current_v – для суммарной стоимости предметов. Их преимущество в том, что они легко и быстро обновляются, не требуя дополнительных вычислений.\n--- Страница 406 ---\n12.7. Задача о рюкзаке 0–1  405 Листинг 12.12. Алгоритм решения задачи о рюкзаке 0–1 методом перебора с возвратами 1 2 3 456 7 8910 11 12131415 16 171819 20 21222324 25 262728 29 30313233 34 353637 38def knapsack_0_1(i, w_left, current_v, sol, opt_sol, opt_v, w, v, C): # Check base case if i == len(sol): # Check if better solution has been found if current_v > opt_v: # Update optimal value and solution opt_v = current_v for k in range(0, len(sol)): opt_sol[k] = sol[k] else: # Generate candidates for k in range(0, 2): # Check if recursion tree can be pruned if k * w[i] <= w_left: # Expand partial solution sol[i] = k # Update remaining capacity and partial value new_w_left = w_left – k * w[i] new_current_v = current_v + k * v[i] # Try to expand partial solution opt_v = knapsack_0_1(i + 1, new_w_left, new_current_v, sol, opt_sol, opt_v, w, v, C): # return value of optimal solution found so far return opt_v def knapsack_0_1_wrapper(w, v, C): sol = [0] * (len(w)) opt_sol = [0] * (len(w)) total_v = knapsack_0_1(0, C, 0, sol, opt_sol, –1, w, v, C) print_knapsack_solution(opt_sol, w, v, C, total_v) Кроме того, метод во время выполнения сохраняет лучшее из най- денных решений. Оно хранится в параметре opt_sol , который являет -\n--- Страница 407 ---\n406  Глава 12. Множественная рекурсия III: перебор с возвратами ся копией того частичного решения, которое получено по достижении листа дерева рекурсии. Наконец, opt_v содержит оптимальную суммар- ную стоимость opt_sol . Этот параметр тоже избыточен в том смысле, что его значение можно вычислить по opt_sol , но ради дополнитель- ной эффективности его значение лучше передавать как параметр. Как обычно, рекурсивная функция начинается с проверки начально- го условия. Если метод достиг полного решения (строка 4), он в строке 6 сравнивает стоимости текущего sol и лучшего opt_sol решений, по- лученных на предыдущих шагах. Если стоимость sol превышает стои- мость opt_sol , метод обновляет opt_v и opt_sol . Позже, в строке 31, метод вернёт в качестве своего результата opt_v . Значения списка opt_ sol тоже будут доступны по завершении метода, поскольку этот список передаётся в метод по ссылке и, следовательно, меняется в процессе поиска решения. В рекурсивном условии метод в строке 13 генерирует кандидатов (со значениями 0 или 1) для включения в двоичный список частичного ре-шения. Затем, с целью сократить дерево рекурсии, он проверяет усло-вие k*w[i] <= w_left . Если k = 0, предмет не добавляется в рюкзак, и условие всегда истинно, так как w_left – неотрицательная величина. Если же k = 1, алгоритм добавляет предмет в рюкзак, если это возможно, то есть если wi не превосходит весового остатка рюкзака. После чего он, предварительно обновив частичное решение, весовой остаток и сум-марную стоимость предметов рюкзака, выполняет рекурсивный вызов с этими новыми параметрами и, сохранив результат в opt_v , заверша- ется в строке 31 возвратом этого результата. Фнкция-оболочка knapsack_0_1_wrapper инициализирует i значе- нием 0, w_left – грузоподъёмностью рюкзака C и current_v – значени- ем 0, поскольку рюкзак изначально пуст. Максимальное значение opt_v может быть нулём или некоторым отрицательным числом. На рис. 12.15 мы посчитали его отрицательным с расчётом на то, что метод всё равно обновит его даже при пустом оптимальном решении (в крайнем левом листе). В заключение в листинге 12.13 приведён простой итерационный код, который может использоваться для печати решения задачи. Стоимость решения можно вычислить по частичному решению и списку стоимостей предметов. Однако метод получает это значение в качестве параметра, так как оно возвращается функцией knapsack_0_1 и, следовательно, доступно в knapsack_0_1_wrapper . В последних стро- ках листинга алгоритму ставится конкретная задача, и он находит её решение.\n--- Страница 408 ---\n12.7. Задача о рюкзаке 0–1  407 Листинг 12.13. Вспомогательный код для задачи о рюкзаке 0–1 1 2 3 456 7 8910 11 12131415 16 171819 20 21222324 25def print_knapsack_solution(sol, w, v, C, opt_value): n = len(sol) k = 0 while k < n and sol[k] == 0: k = k + 1 total_weight = 0 if k < n: print('(', w[k], ', ', v[k], ')', sep='', end='') total_weight = total_weight + w[k] for i in range(k + 1, n): if sol[i] == 1: total_weight = total_weight + w[i] print(' + ', sep='', end='') print('(', w[i], ', ', v[i], ')', sep='', end='') print(' => ', '(', total_weight, ', ', opt_value, ')', sep='') w = [3, 6, 9, 5] # List of object weights v = [7, 2, 10, 4] # List of object valuesC = 15 # Weight capacity of the knapsack knapsack_0_1_wrapper(w, v, C) 12.7.2. Алгоритм ветвей и границ Алгоритм ветвей и границ можно считать разновидностью алгорит - ма перебора с возвратами, который выполняет такой же полный, но более эффективный перебор вариантов решения дискретных и комби-наторных задач оптимизации. Его идея заключается в использовании границ для сокращения дерева рекурсии не только тогда, когда частич-ное решение не удовлетворяет ограничениям задачи, но и когда ясно, что расширение частичного решения не улучшит решения, найденного на предыдущих шагах. Суть метода ветвей и границ, который мы применим к задаче о рюк - заке 0–1, – в использовании дополнительного параметра для хранения максимальной суммарной стоимости, которая получается при расши-рении частичного решения. Если при вызове некоторого метода это значение хуже лучшего, найденного на предыдущих шагах, то алгоритм\n--- Страница 409 ---\n408  Глава 12. Множественная рекурсия III: перебор с возвратами не будет расширять частичное решение, поскольку не сможет улучшить его. Это позволяет сократить ещё больше узлов дерева рекурсии, что может привести к значительно более эффективному поиску. На рис. 12.16 приведено дерево рекурсии для тех же весов, стоимос - тей и грузоподъёмности рюкзака, что на рис. 12.15. –vi (не включать объект i) +vi (включить объект i) (a) (b)x = частичное значение y = привязка к максимально возможному значению Оптимальное решение: [1,0,1,0]w = [3, 6, 9, 5] v = [7, 2, 10, 4] C = 15x y – vix + viy 0 23 0 16 0 14 0 07 23 7 21 7 11042 16 269 23 9 131014 10101216 12121721 17171923 44 1414 1616 2121+7 –7 +2 –2 +2 –2 +10 –10 +10 –10 +10 –10 +10 –10 +4–4 +4–4 +4–4 +4–46<14 11<14 13<17 12<14 Рис.12.16. Дерево рекурсии алгоритма ветвей и границ для решения задачи о рюкзаке 0–1 Но в этом случае числа в узлах указывают частичную стоимость и гра- ницу максимально возможной стоимости, которую мы могли бы полу -\n--- Страница 410 ---\n12.7. Задача о рюкзаке 0–1  409 чить, расширив связанное с ней частичное решение, как показано на рис. 12.16(a). Первоначально частичная стоимость равна 0, а граница, как показано на рис. 12.16(b), равна сумме всех стоимостей предметов (то есть 23 = 7 + 2 + 10 + 4), так как сначала мы должны рассмотреть слу - чай, когда все предметы помещаются в рюкзаке. Каждый внутренний узел глубины i может иметь два дочерних узла. Спуск по левой ветви означает, что предмет i не добавляется в рюкзак. Поэтому частичная стоимость не меняется, но граница при этом умень-шается на v i, поскольку стоимость этого предмета уже не может входить в суммарную стоимость полного решения. И наоборот, спуск по правой ветви означает, что предмет добавляется в рюкзак и его стоимость v i добавляется к частичной стоимости, но граница при этом остаётся не-изменной. Подобно примеру на рис. 12.15, метод обновляет лучшее решение, найденное ранее (затемнённые листья дерева). Кроме того, обведён-ные крупным пунктиром узлы обозначают вызовы метода, которые не выполняются, так как сумма весов предметов превышает грузоподъ-ёмность рюкзака. Помимо этого, на рисунке есть обведённые мелким пунк тиром узлы, которые алгоритм также не вызывает, поскольку гра- ница их стоимости меньше лучшей из встречавшихся ранее. Например, лучшая стоимость по достижении четвёртого листа – 14. После этого нужно рассмотреть узел с частичной стоимостью 2 и границей 16. От - казавшись от третьего предмета, алгоритм должен уменьшить границу на 10, а это означает, что максимально возможная суммарная стои-мость, которую можно получить при расширении частичного решения, равна 16 – 10 = 6. Поскольку 6 < 14 (это отношение изображено под уз-лом), алгоритм не вызывает метода, сокращая тем самым дерево рекур-сии. Обратите внимание, что дерево рекурсии этого алгоритма имеет ту же структуру, что на рис. 12.15, но содержит меньше узлов, так как сокращает дерево в большем количестве случаев. На практике такое усовершенствование может оказать существенное влияние на эффек - тивность. В листинге 12.14 приведён код решения задачи методом ветвей и гра- ниц, который во многом схож с кодом листинга 12.12. Основное разли-чие между ними – новый (четвёртый) параметр max_v , в котором сохра- няется граница. Отметим, что он инициализируется в методе-оболочке суммарной стоимостью всех предметов. В рекурсивном условии ме-тод, проверив правильность частичного решения с новым кандидатом (строка 17), вычисляет новое значение границы new_max_v (строка 20). Обратите внимание, что при k = 0 новая граница уменьшается на vi, тог -\n--- Страница 411 ---\n410  Глава 12. Множественная рекурсия III: перебор с возвратами да как при k = 1 она остаётся неизменной. После этого метод проверя- ет, можно ли сократить дерево с новой границей и вычисленной ранее оптимальной стоимостью решения (строка 24). Остальная часть кода аналогична алгоритму перебора с возвратами. Листинг 12.14. Алгоритм ветвей и границ для решения задачи рюкзака 0–1 1 2 3 4 5 6 7 89 10 11 12 13 14 15 16 17 18 1920 2122 2324 25 2627 28 29 30 31 32 33 34 35 36 37 38 3940 41 42def knapsack_0_1_bnb(i, w_left, current_v, max_v, sol, opt_sol, opt_v, w, v, C): # Check base case if i == len(sol): # Check if better solution has been found if current_v > opt_v: # Update optimal value and solution opt_v = current_v for k in range(0, len(sol)): opt_sol[k] = sol[k] else: # Generate candidates for k in range(0, 2): # Check if recursion tree can be pruned # according to (capacity) constraint if k * w[i] <= w_left: # Update maximum possible value new_max_v = max_v – (1 – k) * v[i] # Check if recursion tree can be pruned # according to optimal value if new_max_v > opt_v: # Expand partial solution sol[i] = k # Update remaining capacity # and partial value new_w_left = w_left – k * w[i] new_current_v = current_v + k * v[i] # Try to expand partial solution opt_v = knapsack_0_1_bnb(i + 1, new_w_left, new_current_v, new_max_v, sol, opt_sol, opt_v, w, v, C): # return value of optimal solution found so far return opt_v\n--- Страница 412 ---\n12.8. Упражнения  411 Наконец, в листинге 12.15 приводится метод-оболочка, решающий задачу для конкретных значений w, v и C. Листинг 12.15. Метод-оболочка алгоритма ветвей и границ для решения конкретной задачи рюкзака 0–1 1 2 3 45 6 78 9 1011 12def knapsack_0_1_branch_and_bound_wrapper(w, v, C): sol = [0] * (len(w)) opt_sol = [0] * (len(w)) total_v = knapsack_0_1_bnb(0, C, 0, sum(v) sol, opt_sol, –1, w, v, C) print_knapsack_solution(opt_sol, w, v, C, total_v) w = [3, 6, 9, 5] # List of object weights v = [7, 2, 10, 4] # List of object valuesC = 15 # Weight capacity of the knapsack knapsack_0_1_branch_and_bound_wrapper(w, v, C) 12.8. Упражнения Упражнение 12.1. Есть разные способы построения алгоритмов гене- рации всех подмножеств множества. Описанные в разделе 12.2.1 мето- ды опирались на двоичные деревья рекурсии. Цель этого упражнения состоит в том, чтобы реализовать альтернативные процедуры, которые также выводят все подмножества множества из n элементов, представ- ленного списком. Однако они должны генерировать подмножество в каждом узле дерева рекурсии, приведённого на рис. 12.17. Отметим, что дерево имеет ровно 2 n узлов, а метки 0, 1 и 2 представ- ляют собой индексы элементов исходного списка [a, b, c]. В связи с этим для указания вхождения элементов в подмножество частичное реше-ние должно быть не двоичным списком, а списком индексов, входя-щих в подмножество элементов. Например, подмножество {a, c} должно представляться списком [0, 2]. В этом случае каждое частичное решение будет ещё и полным. Упражнение 12.2. Реализуйте алгоритм перебора с возвратами, который выводит все решения задачи n ладей. Он похож на задачу n ферзей, но вместо ферзей используются ладьи. Поскольку ладьи могут ходить только по вертикали и горизонтали, в каждой строке и каждом столбце может находиться только одна ладья. При этом на одной диа-\n--- Страница 413 ---\n412  Глава 12. Множественная рекурсия III: перебор с возвратами гонали может стоять несколько ладей. На рис. 12.18 приведено одно из решений задачи. {a,b,c}{ } 0 112 2 22 {a,c}{b,c}{a,b}{a} {b} {c} Рис. 12.17. Дерево рекурсии альтернативного алгоритма генерации всех подмножеств множества из трёх элементов Рис. 12.18. Одно из решений задачи четырёх ладей Упражнение 12.3. Реализуйте функцию перебора с возвратами, под- считывающую количество правильных решений неточно поставленной задачи судоку (то есть задачи с одним и более решениями или вовсе без них). Упражнение 12.4. Магический квадрат – это сетка размером n×n, за - полненная первыми n 2 положительными целыми числами так, что сум- мы чисел в каждой строке, столбце и диагонали одинаковы. Эта сумма называется «магической константой» и равна n(n 2 + 1)/2 для любого n. На рис. 12.19 приведён пример магического квадрата размера 3×3 с ма-гической константой 15.\n--- Страница 414 ---\n12.8. Упражнения  413 Рис. 12.19. Магический квадрат 3×3 Разработайте алгоритм перебора с возвратами, который выводит все возможные магические квадраты размера 3×3. Примечание: разраба- тывать алгоритм решения этой задачи для любого n не нужно. С какой проблемой можно столкнуться при решении этой задачи для бóльших значений n? Упражнение 12.5. Шахматный конь ходит с одного поля на другое буквой Г, как показано на рис. 12.20(a). На рис. 12.20(b) приведены 4 по-следовательных хода коня, начиная с левой верхней клетки. Рис. 12.20. Ходы шахматного коня Задача «обхода конём» заключается в определении маршрута шах - матного коня из заданного поля по всем остальным полям шахматной доски размера n×n с однократным их посещением. Реализуйте алгоритм перебора с возвратами, осуществляющий такой обход, и проверьте его для n = 5 и n = 6. Кроме n, метод должен получить координаты началь- ного поля. Маршрут не обязательно должен быть «замкнутым», то есть заканчивающимся в начальном поле.(a) (b)15 15 15 15 15 15 15 15\n--- Страница 415 ---\n414  Глава 12. Множественная рекурсия III: перебор с возвратами Упражнение 12.6. «Задача коммивояжёра» – это классическая дис - кретная задача оптимизации. Её цель – найти кратчайший замкнутый маршрут по n городам из заданного отправного пункта с однократным посещением каждого города. На рис. 12.21 показан кратчайший путь для 10 городов. Рис. 12.21. Пример задачи коммивояжёра и её решение Реализуйте алгоритм перебора с возвратами для решения этой зада- чи. Будем считать, что местоположения городов задаются в текстовом файле, каждая строка которого содержит координаты x и y города на плоской карте. Этот файл можно прочитать методом loadtxt из пакета NumPy . Отправным пунктом будем считать первый город в файле. Кроме того, будем считать, что коммивояжёр перемещается от города к городу строго по прямой линии. В этом случае можно (используя, например, метод pdist из пакета SciPy ) заранее вычислить матрицу расстояний между городами, которая будет передаваться в рекурсивный метод пе-ребора с возвратами, делая ненужными местоположения городов. В за-ключение проверьте полученный код для n ≤ 10. Упражнение 12.7. Следующая оптимизационная задача разбиения множества чисел известна под названием «перетягивание каната». В ней непустое множество из n чисел, где n – чётное, нужно разбить на два подмножества по n/2 элементов так, чтобы разность между сумма- ми чисел в каждом из подмножеств была минимальной. Например, для множества {3, 5, 9, 14, 20, 24} оптимальное разделение приводит к двум подмножествам {5, 9, 24} и {3, 14, 20}, суммы элементов которых, соот - ветственно, – 38 и 37, а разность между этими суммами – 1. Для решения данной задачи реализуйте алгоритм перебора с воз- вратами, основанный на генерации подмножеств. Исходное множество представлено списком из n чисел, а решение – двоичным списком дли- ны n с n/2 нулями и n/2 единицами. Позиции нулей/единиц в списке со-\n--- Страница 416 ---\n12.8. Упражнения  415 ответствуют позициям элементов подмножества в исходном множест - ве. Для приведённого выше примера решением будет список [0, 1, 1, 0, 0, 1], представляющий подмножество {5, 9, 24}, или равносильный ему список [1, 0, 0, 1, 1, 0]), представляющий подмножество {3, 14, 20}. Дополнительно реализуйте более эффективную стратегию, где реше- ние представляется списком s длины n/2, значения элементов которого располагаются в возрастающем порядке и являются позициями эле-ментов подмножества в исходном множестве (списке). Например, под-множеству {5, 9, 24} будет соответствовать список [1, 2, 5]. На рис. 12.22 приведены оба способа представления решения. Рис. 12.22. Два способа представления решения задачи «перетягивание каната» Упражнение 12.8. В рассмотренной в разделе 12.4 задаче нужно было для заданного множества S из n положительных целых чисел вы- вести все подмножества T, сумма элементов которых равна некото- рому целому значению x. Разработайте альтернативную рекурсивную функцию, которая вместо этого выводит (правильное) подмножество T с наименьшей мощностью (количеством элементов). В частности, она должна сохранить в списке оптимальное подмножество и вернуть оп-тимальное количество элементов. Например, для S = {1, 2, 3, 5, 6, 7, 9} и x = 13 функция должна сохранить в списке подмножество {6, 7} и вернуть значение 2. Отметим, что в этой оптимизационной задаче оптимальное подмножество может быть не единственным, причём с оптимальным количеством элементов. Например, для S = {2, 6, 3, 5} и x = 8 оптималь- ными будут два подмножества – {2, 6} и {3, 5}. Частичное (и оптималь-ное) решение представьте двоичным списком, как в методе из листин-га 12.7. Кроме того, реализуйте сокращение дерева рекурсии, исключив недопустимые подмножества, а также подмножества с мощностью, превышающей оптимальную. После этого напишите метод-оболочку, который находит оптимальное подмножество и выводит его, если оно найдено (не исключено, что искомого подмножества T в S вообще нет).(a) (b)множество решениемножество решение142024 3 0 0059 11 1142024 359 125\n--- Страница 417 ---\nЧто ещё почитать Монографии о рекурсии Наша книга охватывает довольно широкий круг вопросов, связанных с рекурсивным программированием, включая вопросы разработки ре- курсивных алгоритмов. Однако читатель может найти дополнительные аспекты, примеры и детали реализации в других источниках. В частно-сти, в [14] содержатся многочисленные примеры рекурсивных алгорит - мов на Паскале, работающих со структурами данных (связанные списки, деревья, графы), реализованными посредством указателей. В нашей книге мы, напротив, обошлись без них, поскольку в языке Python их явное использование не предусмотрено. Предлагаемая книга включает алгоритмы перебора с возвратами для генерации таких новых комби-наторных объектов, как сочетания, композиции и разбиения. А заклю-чительная её глава посвящена низкоуровневым проблемам преобразо-вания рекурсивных программ в эквивалентные итерационные. Книги [13] с примерами на Паскале и [14] с примерами на Java также целиком посвящены рекурсии. Обе они содержат главы о рекурсивных типах данных и о низкоуровневой реализации рекурсии. Java-программисты могут найти много интересного в книге [11] с примерами связанных списков, связанных деревьев и графических за-дач. Разработка и анализ алгоритмов Настоящая книга включает задачи, которые могут быть решены ме- тодами «разделяй и властвуй» и перебора с возвратами. Но существует множество превосходных книг, рассматривающих более сложные зада-чи и иные алгоритмы их решения – «жадный», динамическое програм-мирование или опирающиеся на более сложные структуры данных. Книги [3], [5], [6], [19] – это лишь малая часть обширной литературы по методам разработки и анализа алгоритмов. Любители сложных задач могут обратиться к книгам, посвящённым соревнованиям по программированию (например, Международный университетский чемпионат ACM по программированию или Между - народная олимпиада по информатике). Наиболее известные источни-ки – [21], [22].\n--- Страница 418 ---\nЧто ещё почитать  417 Учебники [9], [20] посвящены исключительно анализу алгоритмов. Второй из них гораздо полнее и доступен в массовом открытом сетевом ресурсе coursera.org . Превосходные курсы по алгоритмам предлагают и другие сетевые учебные платформы. Функциональное программирование Всё функциональное программирование основано на рекурсии. По- этому для освоения этой парадигмы программирования программистам нужно основательно проштудировать нашу книгу. Популярные книги по этой теме – [1], [2], [10]. Последнюю из них (см. сайт coursera.org ) можно ре- комендовать в качестве лучшего обучающего курса по этой дисциплине. Язык Python Настоящая книга предполагает, что её читатель уже имеет некото- рый опыт программирования. Популярные книги [7], [12], [24] будут полезны тем, кто хочет познакомиться со всеми возможностями языка Python, включая детали его реализации и разработку альтернативных и/или более эффективных рекурсивных решений задач, проходящих через всю нашу книгу. Исследования в обучении и изучении рекурсии Настоящая книга содержит несколько идей, возникших в процессе обучения и изучения рекурсии. В частности, она делает упор не на вы-числительную (например, пошаговую мысленную) модель или на ите-рационный/императивный подход, а на абстрактную декларативную декомпозицию задачи и индукцию. Этому способствовали такие, на-пример, источники, как [4], [23]. Используемые в главе 2 методика и схемы (они подобны приведён- ным в статье [23]) были введены для того, чтобы сделать упор именно на декларативном мышлении. Да и само построение книги преследует ту же цель. Такие понятия, как трассировка, деревья рекурсии, программ-ный стек или связь итерации с хвостовой рекурсией, не вводятся вплоть до глав 10 и 11. Книга включает также примеры из моих статей [17] и [18], посвя- щённых обучению взаимной, хвостовой (и вложенной) рекурсии через обобщённые функции. Наконец, есть множество источников по исследованию обучения и изучения рекурсии. Недавние обзоры [8], [16] содержат сотни источни-ков по данной теме.\n--- Страница 419 ---\nДополнительная литература 1. Abelson Harold and Sussman Gerald J. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, MA, USA, 2nd edition, 1996. 2. Bird Richard. Introduction to Functional Programming Using Haskell. Prentice Hall Europe, April 1998. 3. Cormen Thomas H., Leiserson Charles E., Rivest Ronald L., and Stein Clif - ford. Introduction to Algorithms. The MIT Press, 3rd edition, 2009. 4. Ginat D. and Shifroni E. Teaching recursion in a procedural environ-ment – how much should we emphasize the computing model? SIGCSE Bull., 31(1):127–131, 1999. 5. Goodrich Michael T., Tamassia Roberto, and Goldwasser Michael H. Data Structures and Algorithms in Python. Wiley Publishing, 1st edition, 2013. 6. Levitin Anany V. Introduction to the Design and Analysis of Algorithms. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 3rd edition, 2012. 7. Lutz Mark. Learning Python. O’Reilly, 5th edition, 2013. 8. McCauley Renée, Grissom Scott, Fitzgerald Sue, and Murphy Laurie. Teaching and learning recursive programming: a review of the research literature. Computer Science Education, 25(1):37–66, 2015. 9. McConnell Jeffrey J. Analysis of Algorithms: An Active Learning Approach. Jones and Bartlett Publishers, Inc., USA, 1st edition, 2001. 10. Odersky Martin, Spoon Lex, and Venners Bill. Programming in Scala: A Comprehensive Step-by-Step Guide. Artima Incorporation, USA, 1st edition, 2008. 11. Pevac Irena. Practicing Recursion in Java. CreateSpace Independent Publishing Platform, 1st edition, April 2016. 12. Pilgrim Mark. Dive Into Python 3. Apress, Berkely, CA, USA, 2009. 13. Roberts Eric S. Thinking Recursively. Wiley, 1st edition, January 1986. 14. Roberts Eric S. Thinking Recursively with Java. Wiley, 1st edition, February 2006. 15. Rohl Jeffrey Soden. Recursion Via Pascal. Cambridge Computer Science Texts. Cambridge University Press, 1st edition, August 1984.\n--- Страница 420 ---\nДополнительная литература  419 16. Rinderknecht Christian. A survey on teaching and learning recursive programming. Informatics in Education, 13(1):87-119, 2014. 17. Rubio-Sánchez M., J. Urquiza-Fuentes, and Pareja-Flores C. A gentle introduction to mutual recursion. SIGCSE Bull., 40(3):235–239, 2008. 18. Rubio-Sánchez Manuel. Tail recursive programming by applying generalization. In Proceedings of the Fifteenth Annual Conference on Innovation and Technology in Computer Science Education, ITiCSE ‘10, pages 98–102. ACM, 2010. 19. Sedgewick Robert and Wayne Kevin. Algorithms. Addison-Wesley Professional, 4th edition, 2011. 20. Sedgewick Robert and Flajolet Philippe. An Introduction to the Analysis of Algorithms. Addison-Wesley Professional, 2nd edition, 2013. 21. Skiena Steven S. and Revilla Miguel. Programming Challenges: The Programming Contest Training Manual. Springer-Verlag New York, Inc., Secaucus, NJ, USA, 2003. 22. Skiena Steven S. The Algorithm Design Manual. Springer Publishing Company, Incorporated, 2nd edition, 2008. 23. Sooriamurthi R. Problems in comprehending recursion and suggested solutions. SIGCSE Bull., 33(3):25–28, 2001. 24. Summerfield Mark. Programming in Python 3: A Complete Introduction to the Python Language. Addison-Wesley Professional, 2nd edition, 2009.\n--- Страница 421 ---\nСписок рисунков 1.1 Примеры рекурсивных объектов. 1.2 Рекурсивная декомпозиция списков и деревьев. 1.3 Генеалогическое древо потомков человека – его детей и потомков их де- тей. 1.4 Рекурсивное решение задачи. 1.5 Декомпозиции суммы первых положительных целых чисел. 1.6 Декомпозиции суммы элементов списка a из n = 9 чисел. 1.7 Функции вычисления суммы первых n натуральных чисел в разных язы- ках программирования. 1.8 Списочные структуры данных с параметрами, необходимыми для опре-деления подсписков. 1.9 Задача на устный счёт в классе. Учитель просит учеников сложить пер-вые 100 положительных целых чисел. S(n) – сумма первых n положи- тельных целых чисел. 2.1 Общий шаблон проектирования рекурсивных алгоритмов. 2.2 Дополнительные диаграммы, которые иллюстрируют декомпозицию суммы первых позитивных целых чисел, когда размер проблемы умень-шен модулем. 2.3 При рекурсивном подходе обычно нет нужды представлять декомпози-цию задачи всеми её экземплярами меньшего размера. 2.4 Декомпозиции функции Фибоначчи. 2.5 Общая схема обдумывания рекурсивных условий (когда декомпозиция задачи приводит к единственной, подобной ей подзадаче). 2.6 Схема декомпозиции задачи о сумме первых n положительных целых чисел S(n), использующая две подзадачи в половину размера исходной. 2.7 Схема декомпозиции задачи вывода на экран цифр неотрицательного целого числа – вертикально и в обратном порядке: (a) – частный случай (n = 2743), (b) – общий случай числа из m цифр (n = d m–1 … d1 d0). 2.8 Общая схема осмысления рекурсивных условий, когда задача разбива-ется на несколько (N) себе подобных подзадач. 2.9 Альтернативная схема декомпозиции методом «разделяй и власт вуй» и процесс осмысления задачи поиска наибольшего значения в списке. 2.10 Схема декомпозиции суммы первых n положительных целых чисел S(n) на две подзадачи (примерно) в половину размера исходной для нечёт - ных значений n.\n--- Страница 422 ---\nСписок рисунков  421 3.1 Графический способ вывода формулы для суммы S(n) первых n положи- тельных целых чисел. 3.2 Прямоугольный треугольник как иллюстрация тригонометрических определений. 3.3 Геометрическая интерпретация сложения и вычитания векторов. 3.4 Матрица поворота (против часовой стрелки). 3.5 Порядок роста функции определяется её старшим членом. Для T(n) = 0,5n2 + 2000n + 50 000 порядок роста – квадратичный, посколь- ку для больших значений n её старший член 0,5n2, очевидно, доминиру - ет над младшими (даже взятыми вместе). 3.6 Типичные порядки роста вычислительной сложности. 3.7 Графическая иллюстрация асимптотических обозначений вычисли-тельной сложности. 3.8 Последовательность действий, выполняемых функцией из лис тинга 1.1 при начальном условии. 3.9 Последовательность действий, выполняемых функцией из листинга 1.1 при рекурсивном условии. 3.10 Метод расширения (краткая справка). 3.11 Количество проверенных (затенённых) битов для чисел от 1 до 2 n–1, где n = 4. 4.1 Приведение десятичного числа 142 к основанию 5 (1032). 4.2 Треугольник Паскаля. 4.3 Декомпозиция и восстановление строки треугольника Паскаля. 4.4 Задача о резистивной цепи. 4.5 Эквивалентность резисторных соединений. 4.6 Декомпозиция задачи о резистивной цепи и вывод рекурсивного усло-вия методом индукции. 4.7 Произведение двух неотрицательных целых чисел n и m как площадь прямоугольника размером n×m. 4.8 Шаг алгоритма сортировки вставкой. 5.1 Декомпозиция для алгоритмов двоичного поиска. 5.2 Двоичное дерево поиска с информацией о днях рождения. 5.3 Двоичное дерево поиска (см. рис. 5.2 и 5.1), где каждый узел – это список из четырёх элементов: имени (строка), дня рождения (строка), левого поддерева (список) и правого поддерева (список). 5.4 Декомпозиция для некоторых алгоритмов поиска в двоичном дереве. 5.5 Разделение списка, используемого в алгоритмах quicksort и quickselect. 5.6 Пример метода разбиения Хоара.\n--- Страница 423 ---\n422  Список рисунков 5.7 Декомпозиция задачи о разбиении Хоара. 5.8 Начальное условие и декомпозиция задачи, используемые алгоритмом quickselect. 5.9 Несколько шагов алгоритма двоичного поиска корня. 5.10 Начальное условие алгоритма двоичного поиска (b – a ≤ 2ϵ). 5.11 Пример задачи лесоруба. 5.12 Декомпозиция задачи лесоруба. 5.13 Шаги алгоритма двоичного поиска на примере задачи лесоруба для w = 10. 5.14 Шаги алгоритма сортировки подсчётом. 5.15 Основная идея метода Ньютона. 6.1 Алгоритм сортировки слиянием. 6.2 Декомпозиция алгоритма quicksort. 6.3 Типы тримино без вращений и симметрии. 6.4 Задача укладки тримино. 6.5 Декомпозиция задачи укладки тримино. 6.6 Вращения L-тримино. 6.7 Задача очертания. 6.8 Начальное условие задачи очертания для одного здания. 6.9 Рекурсивное условие задачи очертания. 6.10 Случаи объединения контуров, когда их высота меняется в одной и той же точке x. 6.11 Возможные варианты слияния контуров при x 1 < x2. 7.1 Задача о пути по болоту. 7.2 Декомпозиция задачи о пути по болоту. 7.3 Головоломка «Ханойская башня». 7.4 Решение головоломки «Ханойская башня» с количеством дисков n = 2. 7.5 Решение головоломки «Ханойская башня» с количеством дисков n = 4. 7.6 Декомпозиция задачи «Ханойская башня». 7.7 Результат процедуры из листинга 7.3 при решении задачи «Ханойская башня» с количеством дисков n = 4. 7.8 Пример декомпозиции задачи внутреннего обхода дерева. 7.9 Декомпозиция задачи поиска в строке самого длинного палиндрома. 7.10 Фрактальная кривая Коха. 7.11 Фрактальная снежинка Коха. 7.12 Декомпозиция кривой Коха. 7.13 Новые концевые точки на очередном шаге построения кривой Коха. 7.14 Ковёр Серпиньского после 0-го, 1-го, 2-го и 3-го шагов.\n--- Страница 424 ---\nСписок рисунков  423 7.15 Декомпозиция ковра Серпиньского. 7.16 Деления английской дюймовой линейки. 7.17 Дополнительное условие «узкой» задачи «Ханойская башня». 7.18 Треугольный ковёр Серпиньского. 7.19 Первые шесть шагов построения кривой Гильберта. 8.1 Возможные перестановки (списки) первых четырёх положительных це- лых чисел. 8.2 Декомпозиция задачи подсчёта возможных перестановок f(n) для n раз- личных элементов. 8.3 Декомпозиция возможных перестановок первых четырех положитель-ных целых чисел. 8.4 Пример размещения с повторениями по k элементам из n элементов множества. 8.5 Декомпозиция задачи подсчёта размещений с повторениями n элемен- тов множества в k позициях. 8.6 Декомпозиция задачи подсчёта сочетаний из n элементов по k. 8.7 Один из способов подняться по лестнице с шагом в 1 или 2 ступеньки. 8.8 Декомпозиция задачи подсчёта всех способов подняться по лестнице с шагом в 1 или 2 ступеньки. 8.9 Задача о пути по Манхэттену. 8.10 Декомпозиция задачи о пути по Манхэттену. 8.11 Две возможные триангуляции одного выпуклого 7-угольника. 8.12 Шесть (n – 2) треугольников на базе нижней стороны восьмиугольника (n = 8). 8.13 Декомпозиция задачи триангуляции выпуклого многоугольника для конкретного треугольника. 8.14 Общее количество триангуляций в восьмиугольнике. 8.15 Правильные и неправильные пирамиды из кругов. 8.16 Пирамиды, сгруппированные по количеству кругов непосредст венно над нижним рядом из n = 4 кругов. 8.17 Декомпозиция задачи о пирамиде из кругов на подзадачи конечного размера. 8.18 Размещения с повторениями из четырех элементов множества {a, b, c, d} по два элемента. 8.19 Выкладывание прямоугольника размером 2×10 из костей домино раз-мером 1×2 или 2×1. 8.20 Пять различных двоичных деревьев из трёх узлов. 8.21 Пирамиды на базе n = 4 круга нижнего ряда, сгруппированные по их высоте.\n--- Страница 425 ---\n424  Список рисунков 9.1 Вызовы взаимно-рекурсивных методов. 9.2 Правила размножения кроликов. 9.3 Родовое дерево кроликов спустя 7 месяцев. 9.4 Конкретный пример разбиения задачи о росте популяции кроликов на подобные ей подзадачи. 9.5 Декомпозиция задачи о размножении кроликов, приводящая к двум взаимно-рекурсивным функциям. 9.6 Задача о станциях водоочистки. 9.7 Декомпозиция задачи о станциях водоочистки, моделирующая переток воды между городами. 9.8 Три сценария взаимно-рекурсивного решения задачи о станциях водо-очистки. 9.9 Декомпозиции трёх подзадач для взаимно-рекурсивного решения зада-чи о станциях водоочистки. 9.10 Циклические ханойские башни. 9.11 Две разновидности задачи о циклических ханойских башнях. 9.12 Три действия рекурсивных методов, решающих задачу о циклических ханойских башнях. 9.13 Действия по перемещению n дисков по часовой стрелке. 9.14 Действия по перемещению n дисков против часовой стрелки. 9.15 Декомпозиция математической формулы на категории «Выражение», «Слагаемое», «Множитель» или «Число». 9.16 Взаимно-рекурсивные вызовы функций синтаксического анализатора на основе рекурсивного спуска. 9.17 Возможные декомпозиции выражения. 9.18 Правила головоломки Spin-out ®. 10.1 Цепочка вызовов-возвратов методов из листинга 10.1. 10.2 Цепочка вызовов-возвратов для sum_first_naturals(4) . 10.3 Цепочка вызовов-возвратов для рекурсивной процедуры mystery_ method_1(\"Word\") . 10.4 Цепочка вызовов-возвратов для процедуры mystery_method_2(\"Word\") . 10.5 Деревья рекурсии для sum_first_naturals(4) . 10.6 Дерево активации для sum_first_naturals(4). 10.7 Дерево активации для gcd1(20,24) . 10.8 Деревья рекурсии (a) и активации (b) для fibonacci(6) . 10.9 Дерево активации для взаимно-рекурсивных функций из листинга 9.1. 10.10 Дерево рекурсии для взаимно-рекурсивных функций (1.17) и (1.18). 10.11 Дерево активации вложенной рекурсивной функции (1.19). 10.12 Дерево рекурсии для рекуррентного отношения T(n) = 2T(n/2) + n2.\n--- Страница 426 ---\nСписок рисунков  425 10.13 Структуры данных стек и очередь. 10.14 Выделение стековых кадров при выполнении кода из листинга 10.1, где cos, | · | и ‹ · , · › обозначают методы cosine , norm_Euclidean и dot_product соответственно. 10.15 Программный стек и данные на шаге 5 из рис. 10.14. 10.16 Выделение стековых кадров для sum_first_naturals(4) . 10.17 Выделение стековых кадров для f ibonacci(5) . 10.18 Пример дерева файловой системы. 10.19 Состояние стека при выполнении итерационного кода из листинга 10.3 для файлов и папок на рис. 10.18. 10.20 Выделение стековых кадров при выполнении кода из листинга 10.4 для файлов и папок на рис. 10.18. 10.21 Перекрывающиеся подзадачи при вычислении чисел Фибоначчи по формуле F(n) = F(n – 1) + F(n – 2). 10.22 Граф зависимости для F(n) = F(n – 1) + F(n – 2). 10.23 Граф зависимости для листинга 10.6, решающего задачу о самой длин-ной подстроке-палиндроме. 10.24 Матрица L по завершении метода из листинга 10.7 для s = 'bcaac'. 10.25 Альтернативное двоичное дерево поиска, хранящее информацию о днях рождения. 10.26 Вариант разбиения линейного отрезка кривой Коха на пять меньших отрезков. 10.27 Вариант «квадрата Коха» для n = 4. 11.1 Состояние программного стека при вызове gcd1(20,24) на момент про- верки начального условия. 11.2 Сходство между итерационным и хвостовым рекурсивным кодами, вы-числяющими факториал. 11.3 Функция-91 Маккарти. 12.1 Одно из решений задачи четырёх ферзей. 12.2 Частичные решения внутри полных решений для списка или матрицы. 12.3 Дерево рекурсии алгоритма перебора с возвратами, который находит одно из решений задачи четырёх ферзей. 12.4 Дерево рекурсии алгоритма генерации всех подмножеств множества из трёх элементов. 12.5 Двоичное дерево рекурсии альтернативного алгоритма генерации всех подмножеств множества из трёх элементов. 12.6 Дерево рекурсии алгоритма генерации всех перестановок множества из трёх элементов.\n--- Страница 427 ---\n426  Список таблиц 12.7 Сокращение дерева рекурсии за счёт исключения недопустимых час - тичных решений. 12.8 Индексированные основные и побочные диагонали матрицы или шах - матной доски. 12.9 Дерево рекурсии процедуры, решающей задачу суммы подмножества для множества S = {2, 6, 3, 5} и x = 8. 12.10 Задача поиска пути в лабиринте и её решение перебором с возвратами при определённом порядке поиска. 12.11 Различные пути в лабиринте в зависимости от порядка поиска. 12.12 Декомпозиция задачи поиска пути в лабиринте. 12.13 Задача судоку и ее решение. 12.14 Рекурсивные условия при решении судоку. 12.15 Дерево рекурсии алгоритма перебора с возвратами для задачи о рюкза- ке 0-1. 12.16 Дерево рекурсии алгоритма ветвей и границ для решения задачи о рюк - заке 0-1. 12.17 Дерево рекурсии альтернативного алгоритма генерации всех подмно- жеств множества из трёх элементов. 12.18 Одно из решений задачи четырёх ладей. 12.19 Магический квадрат 3×3. 12.20 Ходы шахматного коня. 12.21 Пример задачи коммивояжёра и её решение. 12.22 Два способа представления решения задачи «перетягивание каната». Список таблиц 3.1 Фактические значения типичных функций оценки вычислительной сложности. 11.1 Состояния итерационной программы при вычислении факториала 4!. 11.2 Состояния итерационной программы приведения числа 142 к основа-нию 5 (1032 5) из листинга 11.5. Список листингов 1.1 Суммирование первых n натуральных чисел. 1.2 Другой вариант суммирования первых n натуральных чисел. 1.3 Вычисление n-го числа Фибоначчи.\n--- Страница 428 ---\nСписок листингов  427 1.4 Другой вариант вычисления n-го числа Фибоначчи. 1.5 Рекурсивные функции суммирования элементов списка с единствен- ным параметром – списком a. 1.6 Другой вариант рекурсивных функций суммирования элементов под-списков списка a. Границы подсписков задаются двумя входными пара- метрами lower и upper – соответственно нижним и верхним индекса- ми в списке a. 2.1 Неправильные представления начальных условий для функции вычис - ления факториала. 2.2 Вычисление суммы цифр неотрицательного целого числа. 2.3 Вывод на экран цифр неотрицательного целого числа – вертикально и в обратном порядке. 2.4 Вычисление максимального значения в списке методом «разделяй и властвуй». 2.5 Неправильный код для определения чётности неотрицательного целого числа n. 2.6 Правильный код для определения чётности неотрицательного целого числа n. 2.7 Ошибочное суммирование первых n положительных целых чисел, по- рождающее бесконечную рекурсию для большинства значений n. 2.8 Неполный код при сложении первых n положительных чисел. 2.9 Сумма первых n положительных чисел с двумя подзадачами размером (примерно) в половину исходной. 3.1 Вычисление времени выполнения кода с помощью модуля time . 3.2 Решение системы линейных уравнений Ax = b. 4.1 Степенная функция для неотрицательных степеней с линейным време-нем выполнения. 4.2 Степенная функция с линейным временем выполнения. 4.3 Степенная функция для неотрицательных степеней с логарифмическим временем выполнения. 4.4 Неэффективная реализация степенной функции с линейным временем выполнения. 4.5 Медленное сложение двух неотрицательных целых чисел. 4.6 Ускоренное медленное сложение двух неотрицательных целых чисел. 4.7 Ещё одно ускоренное медленное сложение двух неотрицательных це-лых чисел. 4.8 Рекурсивные функции вычисления двойной суммы (4.3). 4.9 Двоичное представление неотрицательного целого числа. 4.10 Приведение неотрицательного целого числа n к основанию b. 4.11 Обращение строки s.\n--- Страница 429 ---\n428  Список листингов 4.12 Функция проверки строки на палиндром. 4.13 Рекурсивный алгоритм сортировки выбором. 4.14 Другой рекурсивный алгоритм сортировки выбором. 4.15 Вычисление полинома по схеме Горнера. 4.16 Функция, генерирующая n-ю строку треугольника Паскаля. 4.17 Функция, решающая задачу о резистивной цепи. 5.1 Линейно-рекурсивная логическая функция, определяющая наличие в неотрицательном целом числе n заданной цифры d. 5.2 Хвостовая рекурсивная логическая функция, определяющая, содержит ли неотрицательное целое число n цифру d. 5.3 Линейно-рекурсивная функция, сопоставляющая две строки. 5.4 Функция с хвостовой рекурсией, сопоставляющая две строки. 5.5 Хвостовая рекурсия при линейном поиске элемента в списке. 5.6 Линейно-рекурсивный линейный поиск элемента в списке. 5.7 Альтернативный хвостовой рекурсивный линейный поиск элемента в списке. 5.8 Двоичный поиск элемента в списке. 5.9 Алгоритм поиска элемента с заданным ключом в двоичном дереве. 5.10 Процедура вставки элемента с заданным ключом в двоичное дерево. 5.11 Вспомогательные методы для разбиения списка. 5.12 Итерационный алгоритм разбиения Хоара. 5.13 Альтернативная рекурсивная версия схемы разбиения Хоара. 5.14 Хвостовой рекурсивный алгоритм quickselect. 5.15 Алгоритм двоичного поиска корня функции. 5.16 Функция, вычисляющая количество древесины, если деревья срезаются на высоте h. 5.17 Алгоритм двоичного поиска для задачи лесоруба. 5.18 Алгоритм Евклида для вычисления НОД двух неотрицательных целых чисел. 6.1 Функция, определяющая, отсортирован ли список по возрастанию. 6.2 Метод сортировки слиянием. 6.3 Метод для слияния двух сортированных списков. 6.4 Вариант алгоритма quicksort. 6.5 Алгоритм внутренней сортировки quicksort. 6.6 Подсчёт количества элементов в списке. 6.7 Решение задачи о мажоритарном элементе. 6.8 Быстрый алгоритм Карацубы умножения двух неотрицательных целых чисел. 6.9 Умножение матриц по принципу «разделяй и властвуй». 6.10 Альтернативное умножение матриц по принципу «разделяй и власт - вуй».\n--- Страница 430 ---\nСписок листингов  429 6.11 Вспомогательные функции для рисования тримино. 6.12 Рекурсивный метод рисования тримино. 6.13 Вызов метода тримино. 6.14 Основной рекурсивный метод вычисления очертания. 6.15 Рекурсивный метод объединения контуров. 7.1 Функция поиска пути через болото. 7.2 Альтернативная функция поиска пути через болото. 7.3 Процедура решения задачи «Ханойская башня». 7.4 Внутренний обход двоичного дерева. 7.5 Прямой и обратный обходы двоичного дерева. 7.6 Поиск самого длинного палиндрома в строке. 7.7 Альтернативный метод поиска самого длинного палиндрома в строке. 7.8 Генерация кривых и снежинки Коха. 7.9 Генерация ковра Серпиньского. 9.1 Взаимно-рекурсивные функции для определения чётности неотрица- тельного целого числа n. 9.2 Взаимно-рекурсивные процедуры, реализующие игровые стратегии Элис и Боба. 9.3 Взаимно-рекурсивные функции подсчёта популяции незрелых и зре-лых пар кроликов спустя n месяцев. 9.4 Альтернативные взаимно-рекурсивные функции подсчёта популяции кроликов спустя n месяцев. 9.5 Функция с множественной рекурсией для решения задачи о станциях водоочистки. 9.6 Взаимно-рекурсивные процедуры задачи о циклических ханойс ких башнях. 9.7 Взаимно-рекурсивные функции лексического анализа математическо-го выражения. 9.8 Представляет ли собой строка число? 9.9 Синтаксический анализ математического выражения, состоящего из слагаемых. 9.10 Синтаксический анализ слагаемого, состоящего из множителей. 9.11 Синтаксический анализ слагаемого, состоящего из множителей, первый из которых – скобочное выражение. 9.12 Синтаксический анализ множителя. 9.13 Синтаксический анализ скобочного выражения. 9.14 Основной код программы-калькулятора. 10.1 Методы для вычисления косинуса угла между двумя n-мерными векто- рами. 10.2 Похожие рекурсивные методы. Что они делают?\n--- Страница 431 ---\n430  Список листингов 10.3 Итерационный алгоритм поиска файла в файловой системе. 10.4 Рекурсивный алгоритм поиска файла в файловой системе. 10.5 Рекурсивный алгоритм вычисления чисел Фибоначчи за линейное вре- мя с применением мемоизации. 10.6 Версия листинга 7.7 с мемоизацией. 10.7 Поиск самой длинной подстроки-палиндрома в строке s с использова- нием динамического программирования. 10.8 Методы, якобы складывающие и подсчитывающие цифры неотрица-тельного целого числа. Верны ли они? 10.9 Ошибочный код для вычисления количества двойных символов в спис ке. 10.10 Вычисление наименьшего простого множителя числа n, не меньшего m. 10.11 Ошибочный код для вычисления нижней границы логарифма. 10.12 Ошибочный код, проверяющий наличие в списке элемента, большего суммы всех остальных. 10.13 Ошибочный код для поиска позиции «пикового» элемента. 10.14 Создание фрактала Коха с помощью преобразования на рис. 10.26. 10.15 Вычисление длины самой длинной подпоследовательности-палиндро-ма в списке. 11.1 Итерационная версия алгоритма Евклида (gcd1). 11.2 Итерационная версия метода деления пополам. 11.3 Итерационная функция вычисления факториала. 11.4 Хвостовая рекурсивная функция вычисления факториала и функция-обо лочка. 11.5 Итерационный алгоритм приведения неотрицательного целого деся- тичного числа n к основанию b. 11.6 Хвостовая рекурсивная функция приведения числа к основанию b и ме - тод-оболочка. 11.7 Функция Аккермана. 11.8 Метод с вложенной рекурсией для вычисления цифрового корня не-отрицательного целого числа. 12.1 Печать всех подмножеств множества, заданного списком. 12.2 Альтернативная печать всех подмножеств множества, заданного спис - ком. 12.3 Печать всех перестановок элементов множества из списка. 12.4 Альтернативная печать всех перестановок элементов множества в списке. 12.5 Поиск всех решений задачи n ферзей. 12.6 Поиск одного решения задачи n ферзей. 12.7 Решение задачи о сумме подмножества перебором с возвратами. 12.8 Перебор с возвратами для поиска пути в лабиринте. 12.9 Вспомогательный код для поиска пути в лабиринте методом перебора с возвратами.\n--- Страница 432 ---\nСписок листингов  431 12.10 Решение задачи судоку. 12.11 Вспомогательные функции для решения задачи судоку. 12.12 Алгоритм решения задачи о рюкзаке 0–1 методом перебора с возврата- ми. 12.13 Вспомогательный код для задачи о рюкзаке 0–1. 12.14 Алгоритм ветвей и границ для решения задачи о рюкзаке 0–1. 12.15 Метод-оболочка алгоритма ветвей и границ для решения конкретной задачи рюкзака 0–1.\n--- Страница 433 ---\nПредметный указатель А Адрес возврата 321 Алгоритм 26 ветвей и границ 402, 407 Горнера 141 деления пополам 174, 350 Евклида 182, 349 Карацубы 200, 220 метода Ньютона 186 поиска quickselect 173, 196 в ширину 328 в глубину 230, 328 двоичный 159, 161, 174 линейный 157 разбиения Хоара 166, 173, 194 решения «в лоб» 366 сортировки 190 quicksort 194 внешней 196 внутренней 196 вставкой 150 выбором 131 подсчётом 178, 184 слиянием 191 Штрассена 203, 220 Алфавит 288 Асимптотические обозначения 92, 95 O 92, 95 Ω 93, 95 Θ 93, 95 Активная подпрограмма 321 Б Баскетбол 266 Биномиальный коэффициент 78, 143, 250, 256, 260 Биты 133, 149, 250, 266 Брокколи Romanesco 20 В Вектор 79, 87, 240 Вычислительная задача 44 Время выполнения 95 Выражение 294, 299, 302 скобочное 299, 301 Г Гласная (буква) 149 Глубина рекурсии 56, 326 Головоломка Spin-out® 303 Грамматика формальная 288, 293 Граница верхняя 85 нижняя 85 Граф зависимости 336 подзадач 336 Гуидо ван Россум (Guido van Rossum) 351 Д Декомпозиция задачи 25, 30, 57, 420 Дерево 24 двоичное (бинарное) 161, 162, 165 поиска 161 активации 314, 341, 348, 365 рекурсии 312, 341, 371, 376 высота 319, 325 Динамическая память 327 З Задача 25 N ферзей 381 N ладей 411\n--- Страница 434 ---\nПредметный указатель  433 коммивояжёра 414 лесоруба 177 подсчёта 250 оптимизации 234, 366, 402, 407, 414, 415 «Закорачивание» вычисления 153 И Игры со многими игроками 270, 302 Индукции 40, 61 гипотеза 40 доказательство 40 Исчерпывающий поиск 366, 367 Итерация 44, 347, 350 К Калькулятор 288 Кандидат 367, 374, 393, 398 Комбинаторика 250 Компилятор 288 Конечное пространство состояний 367 Л Лабиринт 390 Лексема 288, 289, 294 Ловушка 52, 55, 58 Логарифм 78, 95 Линейка 245 М Магический квадрат 412 Мажоритарный элемент списка 197 Масштабируемость 350 Матрица 87, 147 блочная 58 поворота 89, 240 симметричная 88 транспонированная 87, 220 Матрёшка 20 Мемоизация 236 Метод дерева 319 расширения (итерации, обратной подстановки) 99Методика, см. Шаблон проектирования рекурсивных алгоритмов Множитель 294, 296 Модуль Matplotlib 210, 222, 240, 396 NumPy 111, 147, 203, 240 Traceback 323 Н Наибольший общий делитель (НОД) 182 Начальное условие 22, 54 избыточное 32, 55, 109, 124, 150 недостаточное 72 неправильное представление 56 О Обход конём шахматной доски 413 Обход дерева 230 внутренний 231 обратный 233, 234, 312 прямой 233, 312, 370 Общность 55 Основная теорема 103, 203, 319 Отладка 16 Очертание 213 П Палиндром 137, 234, 247, 335, 346 Парадигмы программирования 43 Перебор с возвратами 366 шаблон 366 Перекрывающиеся подзадачи 235, 332, 336 Переполнение стека 45, 327, 350 Перестановка 251, 377, 381 «Перетягивание каната» 414 Пирамида 27, 63, 263, 267 Подзадача 23, 26, 57 Подмножество 387, 402, 415, 425 Подпоследовательность 30, 234, 247, 265 Подсписок 30, 247 Подстрока 234, 338 Подъём по лестнице 256\n--- Страница 435 ---\n434  Предметный указатель Поиск корня 174 Полином 184, 220 Порождающее правило 298 Порядок роста 90, 95 Поток пассивный 309 управления 309 Потомок 25 Предел 79 Предусловие 33 Программирование декларативное 43, 51 динамическое 234, 307, 332, 336 императивное 43, 356 функциональное 44, 417 Прогрессия арифметическая 81 геометрическая 83 Произведение 84 матриц 88 скалярное 87 Процедура 67 Путь через болото (трясину) 222 Путь по Манхэттену 259 Р «Разделяй и властвуй» 47, 71, 103, 151, 188 Размер задачи 23, 52, 123, 188 Размещение с повторениями 25, 253 принцип умножения 254 Размножение кроликов 271 Разностное уравнение 107 общий метод решения 107 Резистор 145 Рекуррентное соотношение 77, 95 неоднородное 112 однородное 108 Рекурсивная схема 51, 57, 61 убеждённость 40 Рекурсивное условие 22, 51, 55 Рекурсивный вызов 33спуск 288, 296 Рекурсия бесконечная 32, 55, 72, 73 Решение оптимальное 402, 406 полное 367 частичное 367 Рюкзак 402 С Система счисления 132 основание 132 преобразование 135, 354, 363 Слагаемое 294, 296, 299 Сложность вычисления 89 Сокращение дерева 371, 389, 407 Сочетание 255 Список 24, 36, 154, 189, 190, 197, 367 голова 49 хвост 49 Станция водоочистки 277 Степень 78, 123, 142, 255, 365 Стек программный (вызовов, управляющий) 320 трассировка 323 Стековый кадр 320 активации 321 активный 321 Строка 136, 137, 155, 288 Структура данных 24 FIFO 320 LIFO 320дерево 24 очередь 320, 328 список 24стек 320, 328, 348 Судоку 396, 412 Сумма 21, 28, 29, 31, 35, 59, 79, 131, 148, 378 частичная 82 Сумматор или накопитель (переменная, параметр) 352, 361, 388 Суммирование, см. Сумма\n--- Страница 436 ---\nПредметный указатель  435 Схемы разбиения 165, 172 Т Тест 71 Тип рекурсии 46 взаимная 47, 268 вложенная 48, 347 двойная (binary) 47 концевая (final) 152 косвенная 46, 273 линейная 46, 122, 152, 314 множественная 26, 47 хвостовая (tail) 46, 152 Транспонирование 87, 220 Треугольник Паскаля 143, 149 Триангуляция многоугольника 260 Тригонометрия 86 У Удовлетворение ограничений 381 Укладка домино 266 тримино 208 Управление стеком 327 Ф Файловая система 328 Факториал 22, 52, 253, 359 Фибоначчи (Fibonacci) функция 22, 29, 35, 46–48, 265, 280, 282, 303, 315, 332, 334 число 22, 222, 251, 303, 338 последовательность 22 Фрактал 222, 236, 242, 247 Гильберта (Hilbert) кривая 247 Коха (Koch) 344 квадрат 346 кривая 236 снежинка 236 Серпиньского (Sierpinski) ковёр 242треугольник 20, 247 Функция Аккермана 356, 365 -91 Маккарти 357 обобщённая 359 Х Ханойская башня 222 циклическая 282, 303 «узкая» 245 Характеристический полином 108 Худший случай 93 Ц Цифровой корень 357 Цифры 23, 65, 132, 149, 150, 152, 184, 220 Ч Частично заполненный массив 37 Чётность 269 Числа Каталана 263, 266 Ш Шаблон проектирования рекурсивных алгоритмов 51 Э Экземпляр задачи 26, 65 Эффект Дросте 20 Эффективность, см. Сложность вычисления Я Язык формальный 288\n--- Страница 437 ---\nМануэль Рубио-Санчес Введение в рекурсивное программирование Г лавный редактор Мо вчан Д. А. dmkpress@gmail.com Пе ревод с английского Бо рисов Е. А. К орректор Си няева Г. И. Ве рстка Па ранская Н. В. Ди зайн обложки Мо вчан А. Г. Формат 70×1001/16. Печать цифровая. Усл. печ. л. 35,43. Тираж 200 экз. Веб-сайт издательства: www.dmkpress.comКниги издательства «ДМК Пресс» можно заказать в торгово-издательском холдинге «Планета Альянс» наложенным платежом, выслав открытку или письмо по почтовому адресу: 115487, г. Москва, 2-й Нагатинский пр-д, д. 6А. При оформлении заказа следует указать адрес (полностью), по которому должны быть высланы книги; фамилию, имя и отчество получателя. Желательно также указать свой телефон и электронный адрес. Эти книги вы можете заказать и в интернет-магазине: www.a-planeta.ru. Оптовые закупки: тел. +7(499) 782-38-89. Электронный адрес: books@alians-kniga.ru.",
      "debug": {
        "start_page": 367,
        "end_page": 437
      }
    }
  ]
}